# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-15 11:13+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:5(title)
msgid "fuzzystrmatch"
msgstr "fuzzystrmatch"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:7(indexterm)
msgid "<primary>fuzzystrmatch</primary>"
msgstr "<primary>fuzzystrmatch</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:11(para)
msgid ""
"The <filename>fuzzystrmatch</filename> module provides several functions to "
"determine similarities and distance between strings."
msgstr ""
"Модуль <filename>fuzzystrmatch</filename> содержит несколько функций для "
"вычисления схожести и расстояния между строками."

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:17(para)
msgid ""
"At present, the <function>soundex</function>, <function>metaphone</"
"function>, <function>dmetaphone</function>, and <function>dmetaphone_alt</"
"function> functions do not work well with multibyte encodings (such as "
"UTF-8)."
msgstr ""
"В настоящее время функции <function>soundex</function>, <function>metaphone</"
"function>, <function>dmetaphone</function> и <function>dmetaphone_alt</"
"function> плохо работают с многобайтными кодировками (в частности, с UTF-8)."

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:25(title)
msgid "Soundex"
msgstr "Soundex"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:27(para)
msgid ""
"The Soundex system is a method of matching similar-sounding names by "
"converting them to the same code. It was initially used by the United States "
"Census in 1880, 1900, and 1910. Note that Soundex is not very useful for non-"
"English names."
msgstr ""
"Система Soundex позволяет вычислить похожие по звучанию имена, приводя их к "
"одинаковым кодам. Изначально она использовалась для обработки данных "
"переписи населения США в 1880, 1900 и 1910 г. Заметьте, что эта система не "
"очень полезна для неанглоязычных имён."

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:34(para)
msgid ""
"The <filename>fuzzystrmatch</filename> module provides two functions for "
"working with Soundex codes:"
msgstr ""
"Модуль <filename>fuzzystrmatch</filename> предоставляет две функции для "
"работы с кодами Soundex:"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:39(indexterm)
msgid "<primary>soundex</primary>"
msgstr "<primary>soundex</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:43(indexterm)
msgid "<primary>difference</primary>"
msgstr "<primary>difference</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:47(synopsis)
#, no-wrap
msgid ""
"soundex(text) returns text\n"
"difference(text, text) returns int"
msgstr ""
"soundex(text) returns text\n"
"difference(text, text) returns int"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:52(para)
msgid ""
"The <function>soundex</function> function converts a string to its Soundex "
"code. The <function>difference</function> function converts two strings to "
"their Soundex codes and then reports the number of matching code positions. "
"Since Soundex codes have four characters, the result ranges from zero to "
"four, with zero being no match and four being an exact match. (Thus, the "
"function is misnamed &mdash; <function>similarity</function> would have been "
"a better name.)"
msgstr ""
"Функция <function>soundex</function> преобразует строку в код Soundex. "
"Функция <function>difference</function> преобразует две строки в их коды "
"Soundex и затем сообщает количество совпадающих позиций в этих кодах. Так "
"как коды Soundex состоят из четырёх символов, результатом может быть число "
"от нуля до четырёх (0 обозначает полное несоответствие, а 4 — точное "
"совпадение). (Таким образом, имя этой функции не вполне корректное &mdash; "
"лучшим именем для неё было бы <function>similarity</function>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:62(para)
msgid "Here are some usage examples:"
msgstr "Несколько примеров использования:"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:66(programlisting)
#, no-wrap
msgid ""
"SELECT soundex('hello world!');\n"
"\n"
"SELECT soundex('Anne'), soundex('Ann'), difference('Anne', 'Ann');\n"
"SELECT soundex('Anne'), soundex('Andrew'), difference('Anne', 'Andrew');\n"
"SELECT soundex('Anne'), soundex('Margaret'), difference('Anne', 'Margaret');\n"
"\n"
"CREATE TABLE s (nm text);\n"
"\n"
"INSERT INTO s VALUES ('john');\n"
"INSERT INTO s VALUES ('joan');\n"
"INSERT INTO s VALUES ('wobbly');\n"
"INSERT INTO s VALUES ('jack');\n"
"\n"
"SELECT * FROM s WHERE soundex(nm) = soundex('john');\n"
"\n"
"SELECT * FROM s WHERE difference(s.nm, 'john') &gt; 2;"
msgstr ""
"SELECT soundex('hello world!');\n"
"\n"
"SELECT soundex('Anne'), soundex('Ann'), difference('Anne', 'Ann');\n"
"SELECT soundex('Anne'), soundex('Andrew'), difference('Anne', 'Andrew');\n"
"SELECT soundex('Anne'), soundex('Margaret'), difference('Anne', 'Margaret');\n"
"\n"
"CREATE TABLE s (nm text);\n"
"\n"
"INSERT INTO s VALUES ('john');\n"
"INSERT INTO s VALUES ('joan');\n"
"INSERT INTO s VALUES ('wobbly');\n"
"INSERT INTO s VALUES ('jack');\n"
"\n"
"SELECT * FROM s WHERE soundex(nm) = soundex('john');\n"
"\n"
"SELECT * FROM s WHERE difference(s.nm, 'john') &gt; 2;"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:87(title)
msgid "Levenshtein"
msgstr "Левенштейн"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:89(para)
msgid "This function calculates the Levenshtein distance between two strings:"
msgstr "Эта функция вычисляет расстояние Левенштейна между двумя строками:"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:93(indexterm)
msgid "<primary>levenshtein</primary>"
msgstr "<primary>levenshtein</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:97(indexterm)
msgid "<primary>levenshtein_less_equal</primary>"
msgstr "<primary>levenshtein_less_equal</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:101(synopsis)
#, no-wrap
msgid ""
"levenshtein(text source, text target, int ins_cost, int del_cost, int sub_cost) returns int\n"
"levenshtein(text source, text target) returns int\n"
"levenshtein_less_equal(text source, text target, int ins_cost, int del_cost, int sub_cost, int max_d) returns int\n"
"levenshtein_less_equal(text source, text target, int max_d) returns int"
msgstr ""
"levenshtein(text source, text target, int ins_cost, int del_cost, int sub_cost) returns int\n"
"levenshtein(text source, text target) returns int\n"
"levenshtein_less_equal(text source, text target, int ins_cost, int del_cost, int sub_cost, int max_d) returns int\n"
"levenshtein_less_equal(text source, text target, int max_d) returns int"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:108(para)
msgid ""
"Both <literal>source</literal> and <literal>target</literal> can be any non-"
"null string, with a maximum of 255 characters. The cost parameters specify "
"how much to charge for a character insertion, deletion, or substitution, "
"respectively. You can omit the cost parameters, as in the second version of "
"the function; in that case they all default to 1."
msgstr ""
"И в <literal>source</literal>, и в <literal>target</literal> может быть "
"передана любая строка, отличная от NULL, не длиннее 255 символов. Параметры "
"стоимости (ins_cost, del_cost, sub_cost) определяют цену добавления, "
"удаления или замены символов, соответственно. Эти параметры можно опустить, "
"как во второй версии функции; в этом случае все они по умолчанию равны 1."

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:116(para)
msgid ""
"<function>levenshtein_less_equal</function> is an accelerated version of the "
"Levenshtein function for use when only small distances are of interest. If "
"the actual distance is less than or equal to <literal>max_d</literal>, then "
"<function>levenshtein_less_equal</function> returns the correct distance; "
"otherwise it returns some value greater than <literal>max_d</literal>. If "
"<literal>max_d</literal> is negative then the behavior is the same as "
"<function>levenshtein</function>."
msgstr ""
"Функция <function>levenshtein_less_equal</function> является ускоренной "
"версией функции Левенштейна, предназначенной для использования, только когда "
"интерес представляют небольшие расстояния. Если фактическое расстояние "
"меньше или равно <literal>max_d</literal>, то "
"<function>levenshtein_less_equal</function> возвращает точное его значение; "
"в противном случае она возвращает значение, большее чем <literal>max_d</"
"literal>. Если значение <literal>max_d</literal> отрицательное, она работает "
"так же, как функция <function>levenshtein</function>."

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:126(para)
msgid "Examples:"
msgstr "Примеры:"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:130(screen)
#, no-wrap
msgid ""
"test=# SELECT levenshtein('GUMBO', 'GAMBOL');\n"
" levenshtein\n"
"-------------\n"
"           2\n"
"(1 row)\n"
"\n"
"test=# SELECT levenshtein('GUMBO', 'GAMBOL', 2,1,1);\n"
" levenshtein\n"
"-------------\n"
"           3\n"
"(1 row)\n"
"\n"
"test=# SELECT levenshtein_less_equal('extensive', 'exhaustive',2);\n"
" levenshtein_less_equal\n"
"------------------------\n"
"                      3\n"
"(1 row)\n"
"\n"
"test=# SELECT levenshtein_less_equal('extensive', 'exhaustive',4);\n"
" levenshtein_less_equal\n"
"------------------------\n"
"                      4\n"
"(1 row)"
msgstr ""
"test=# SELECT levenshtein('GUMBO', 'GAMBOL');\n"
" levenshtein\n"
"-------------\n"
"           2\n"
"(1 row)\n"
"\n"
"test=# SELECT levenshtein('GUMBO', 'GAMBOL', 2,1,1);\n"
" levenshtein\n"
"-------------\n"
"           3\n"
"(1 row)\n"
"\n"
"test=# SELECT levenshtein_less_equal('extensive', 'exhaustive',2);\n"
" levenshtein_less_equal\n"
"------------------------\n"
"                      3\n"
"(1 row)\n"
"\n"
"test=# SELECT levenshtein_less_equal('extensive', 'exhaustive',4);\n"
" levenshtein_less_equal\n"
"------------------------\n"
"                      4\n"
"(1 row)"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:158(title)
msgid "Metaphone"
msgstr "Metaphone"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:160(para)
msgid ""
"Metaphone, like Soundex, is based on the idea of constructing a "
"representative code for an input string. Two strings are then deemed similar "
"if they have the same codes."
msgstr ""
"Metaphone, как и Soundex, построен на идее составления кода, представляющего "
"входную строку. Две строки признаются похожими, если их коды совпадают."

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:166(para)
msgid "This function calculates the metaphone code of an input string:"
msgstr "Эта функция вычисляет код метафона входной строки:"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:170(indexterm)
msgid "<primary>metaphone</primary>"
msgstr "<primary>metaphone</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:174(synopsis)
#, no-wrap
msgid "metaphone(text source, int max_output_length) returns text"
msgstr "metaphone(text source, int max_output_length) returns text"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:178(para)
msgid ""
"<literal>source</literal> has to be a non-null string with a maximum of 255 "
"characters. <literal>max_output_length</literal> sets the maximum length of "
"the output metaphone code; if longer, the output is truncated to this length."
msgstr ""
"В качестве <literal>source</literal> должна передаваться строка, отличная от "
"NULL, не длиннее 255 символов. Параметр <literal>max_output_length</literal> "
"задаёт максимальную длину выходного кода метафона; если код оказывается "
"длиннее, он обрезается до этой длины."

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:185(para) fuzzystrmatch.xml:226(para)
msgid "Example:"
msgstr "Пример:"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:189(screen)
#, no-wrap
msgid ""
"test=# SELECT metaphone('GUMBO', 4);\n"
" metaphone\n"
"-----------\n"
" KM\n"
"(1 row)"
msgstr ""
"test=# SELECT metaphone('GUMBO', 4);\n"
" metaphone\n"
"-----------\n"
" KM\n"
"(1 row)"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:199(title)
msgid "Double Metaphone"
msgstr "Double Metaphone"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:201(para)
msgid ""
"The Double Metaphone system computes two <quote>sounds like</quote> strings "
"for a given input string &mdash; a <quote>primary</quote> and an "
"<quote>alternate</quote>. In most cases they are the same, but for non-"
"English names especially they can be a bit different, depending on "
"pronunciation. These functions compute the primary and alternate codes:"
msgstr ""
"Алгоритм Double Metaphone (Двойной метафон) вычисляет две строки "
"<quote>похожего звучания</quote> для заданной строки &mdash; "
"<quote>первичную</quote> и <quote>альтернативную</quote>. В большинстве "
"случаев они совпадают, но для неанглоязычных имён в особенности они могут "
"быть весьма различными, в зависимости от произношения. Эти функции вычисляют "
"первичный и альтернативный коды:"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:209(indexterm)
msgid "<primary>dmetaphone</primary>"
msgstr "<primary>dmetaphone</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:213(indexterm)
msgid "<primary>dmetaphone_alt</primary>"
msgstr "<primary>dmetaphone_alt</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:217(synopsis)
#, no-wrap
msgid ""
"dmetaphone(text source) returns text\n"
"dmetaphone_alt(text source) returns text"
msgstr ""
"dmetaphone(text source) returns text\n"
"dmetaphone_alt(text source) returns text"

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:222(para)
msgid "There is no length limit on the input strings."
msgstr "Длина входных строк может быть любой."

#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:230(screen)
#, no-wrap
msgid ""
"test=# select dmetaphone('gumbo');\n"
" dmetaphone\n"
"------------\n"
" KMP\n"
"(1 row)"
msgstr ""
"test=# select dmetaphone('gumbo');\n"
" dmetaphone\n"
"------------\n"
" KMP\n"
"(1 row)"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: fuzzystrmatch.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
