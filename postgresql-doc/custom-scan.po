# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-21 15:22+0300\n"
"PO-Revision-Date: 2017-09-22 16:03+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:5(title)
msgid "Writing A Custom Scan Provider"
msgstr "Написание провайдера нестандартного сканирования"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:7(indexterm)
msgid ""
"<primary>custom scan provider</primary> <secondary>handler for</secondary>"
msgstr ""
"<primary>провайдер нестандартного сканирования</primary> "
"<secondary>обработчик</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:12(para)
msgid ""
"<productname>PostgreSQL</productname> supports a set of experimental "
"facilities which are intended to allow extension modules to add new scan "
"types to the system. Unlike a <link linkend=\"fdwhandler\">foreign data "
"wrapper</link>, which is only responsible for knowing how to scan its own "
"foreign tables, a custom scan provider can provide an alternative method of "
"scanning any relation in the system. Typically, the motivation for writing a "
"custom scan provider will be to allow the use of some optimization not "
"supported by the core system, such as caching or some form of hardware "
"acceleration. This chapter outlines how to write a new custom scan provider."
msgstr ""
"<productname>PostgreSQL</productname> поддерживает набор экспериментальных "
"средств, предназначенных для того, чтобы модули расширения могли добавлять в "
"систему новые типы сканирования. В отличие от <link linkend=\"fdwhandler"
"\">обёртки сторонних данных</link>, которая должна знать, как сканировать "
"только собственные таблицы, провайдер сканирования может реализовать "
"нестандартный вариант сканирования любого отношения в системе. Обычно к "
"написанию провайдера нестандартного сканирования подталкивает желание "
"реализовать какую-то оптимизацию, не поддерживаемую основной системой, "
"например, кеширование или аппаратное ускорение некоторого рода. В этой главе "
"рассказывается, как написать свой провайдер нестандартного сканирования."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:24(para)
msgid ""
"Implementing a new type of custom scan is a three-step process. First, "
"during planning, it is necessary to generate access paths representing a "
"scan using the proposed strategy. Second, if one of those access paths is "
"selected by the planner as the optimal strategy for scanning a particular "
"relation, the access path must be converted to a plan. Finally, it must be "
"possible to execute the plan and generate the same results that would have "
"been generated for any other access path targeting the same relation."
msgstr ""
"Процесс реализации нестандартного сканирования нового типа состоит из трёх "
"этапов. Во-первых, во время планирования необходимо построить пути доступа, "
"представляющие сканирование с предлагаемой стратегией. Во-вторых, если один "
"из этих путей доступа выбирается планировщиком как оптимальная стратегия "
"сканирования определённого отношения, этот путь доступа должен быть "
"преобразован в план. Наконец, должно быть возможно выполнить этот план, "
"получив при этом те же результаты, что были бы получены с любым другим путём "
"доступа, выбранным для того же отношения."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:36(title)
msgid "Creating Custom Scan Paths"
msgstr "Создание нестандартных путей сканирования"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:43(programlisting)
#, no-wrap
msgid ""
"typedef void (*set_rel_pathlist_hook_type) (PlannerInfo *root,\n"
"                                            RelOptInfo *rel,\n"
"                                            Index rti,\n"
"                                            RangeTblEntry *rte);\n"
"extern PGDLLIMPORT set_rel_pathlist_hook_type set_rel_pathlist_hook;"
msgstr ""
"typedef void (*set_rel_pathlist_hook_type) (PlannerInfo *root,\n"
"                                            RelOptInfo *rel,\n"
"                                            Index rti,\n"
"                                            RangeTblEntry *rte);\n"
"extern PGDLLIMPORT set_rel_pathlist_hook_type set_rel_pathlist_hook;"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:38(para)
msgid ""
"A custom scan provider will typically add paths for a base relation by "
"setting the following hook, which is called after the core code has "
"generated what it believes to be the complete and correct set of access "
"paths for the relation. <placeholder-1/>"
msgstr ""
"Провайдер нестандартного сканирования обычно добавляет пути для базового "
"отношения, установив следующий обработчик, который вызывается после того, "
"как ядро системы построит, по её мнению, полный и корректный набор путей "
"доступа для отношения. <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:59(programlisting)
#, no-wrap
msgid ""
"typedef struct CustomPath\n"
"{\n"
"    Path      path;\n"
"    uint32    flags;\n"
"    List     *custom_paths;\n"
"    List     *custom_private;\n"
"    const CustomPathMethods *methods;\n"
"} CustomPath;"
msgstr ""
"typedef struct CustomPath\n"
"{\n"
"    Path      path;\n"
"    uint32    flags;\n"
"    List     *custom_paths;\n"
"    List     *custom_private;\n"
"    const CustomPathMethods *methods;\n"
"} CustomPath;"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:52(para)
msgid ""
"Although this hook function can be used to examine, modify, or remove paths "
"generated by the core system, a custom scan provider will typically confine "
"itself to generating <structname>CustomPath</structname> objects and adding "
"them to <literal>rel</literal> using <function>add_path</function>. The "
"custom scan provider is responsible for initializing the "
"<structname>CustomPath</structname> object, which is declared like this: "
"<placeholder-1/>"
msgstr ""
"Хотя эта функция-обработчик может изучать, изменять или удалять пути, "
"сформированные основной системой, провайдер нестандартного сканирования "
"обычно ограничивается созданием объектов <structname>CustomPath</structname> "
"и добавлением их в <literal>rel</literal> (с помощью <function>add_path</"
"function>). Провайдер нестандартного сканирования отвечает за инициализацию "
"объекта <structname>CustomPath</structname>, который описан так: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:71(para)
msgid ""
"<structfield>path</structfield> must be initialized as for any other path, "
"including the row-count estimate, start and total cost, and sort ordering "
"provided by this path. <structfield>flags</structfield> is a bit mask, which "
"should include <literal>CUSTOMPATH_SUPPORT_BACKWARD_SCAN</literal> if the "
"custom path can support a backward scan and "
"<literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal> if it can support mark "
"and restore. Both capabilities are optional. An optional "
"<structfield>custom_paths</structfield> is a list of <structname>Path</"
"structname> nodes used by this custom-path node; these will be transformed "
"into <structname>Plan</structname> nodes by planner. "
"<structfield>custom_private</structfield> can be used to store the custom "
"path's private data. Private data should be stored in a form that can be "
"handled by <literal>nodeToString</literal>, so that debugging routines that "
"attempt to print the custom path will work as designed. "
"<structfield>methods</structfield> must point to a (usually statically "
"allocated) object implementing the required custom path methods, of which "
"there is currently only one. The <structfield>LibraryName</structfield> and "
"<structfield>SymbolName</structfield> fields must also be initialized so "
"that the dynamic loader can resolve them to locate the method table."
msgstr ""
"Поле <structfield>path</structfield> должно инициализироваться как для "
"любого другого пути и включать оценку числа строк, стоимость запуска и "
"общую, а также порядок сортировки, устанавливаемый этим путём. Поле "
"<structfield>flags</structfield> задаёт битовую маску, которая должна "
"включать флаг <literal>CUSTOMPATH_SUPPORT_BACKWARD_SCAN</literal>, если "
"нестандартный путь поддерживает сканирование назад, и "
"<literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal>, если он поддерживает "
"пометку позиции и её восстановление. Обе эти возможности являются "
"факультативными. В необязательном поле <structfield>custom_paths</"
"structfield> задаётся список узлов <structname>Path</structname>, "
"используемых данным узлом; они будут преобразованы планировщиком в узлы "
"<structname>Plan</structname>. В поле <structfield>custom_private</"
"structfield> могут быть сохранены внутренние данные нестандартного пути. "
"Сохранять их нужно в форме, которую может принять <literal>nodeToString</"
"literal>, чтобы отладочные процедуры, пытающиеся вывести нестандартный путь, "
"работали ожидаемым образом. Поле <structfield>methods</structfield> должно "
"указывать на объект (обычно статически размещённый), реализующий требуемые "
"методы нестандартного пути (на данный момент это один метод). В этом объекте "
"также должны быть инициализированы поля <structfield>LibraryName</"
"structfield> и <structfield>SymbolName</structfield>, чтобы динамический "
"загрузчик мог разрешить их и загрузить таблицу методов."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:98(programlisting)
#, no-wrap
msgid ""
"typedef void (*set_join_pathlist_hook_type) (PlannerInfo *root,\n"
"                                             RelOptInfo *joinrel,\n"
"                                             RelOptInfo *outerrel,\n"
"                                             RelOptInfo *innerrel,\n"
"                                             JoinType jointype,\n"
"                                             JoinPathExtraData *extra);\n"
"extern PGDLLIMPORT set_join_pathlist_hook_type set_join_pathlist_hook;"
msgstr ""
"typedef void (*set_join_pathlist_hook_type) (PlannerInfo *root,\n"
"                                             RelOptInfo *joinrel,\n"
"                                             RelOptInfo *outerrel,\n"
"                                             RelOptInfo *innerrel,\n"
"                                             JoinType jointype,\n"
"                                             JoinPathExtraData *extra);\n"
"extern PGDLLIMPORT set_join_pathlist_hook_type set_join_pathlist_hook;"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:92(para)
msgid ""
"A custom scan provider can also provide join paths. Just as for base "
"relations, such a path must produce the same output as would normally be "
"produced by the join it replaces. To do this, the join provider should set "
"the following hook, and then within the hook function, create "
"<structname>CustomPath</structname> path(s) for the join relation. "
"<placeholder-1/> This hook will be invoked repeatedly for the same join "
"relation, with different combinations of inner and outer relations; it is "
"the responsibility of the hook to minimize duplicated work."
msgstr ""
"Провайдер нестандартного сканирования может также реализовать пути "
"соединений. Как и для базовых отношений, такой путь должен выдавать тот же "
"результат, какой был бы получен обычным соединением, которое он заменяет. "
"Для этого провайдер соединения должен установить следующий обработчик, а "
"затем внутри функции-обработчика создать пути <structname>CustomPath</"
"structname> для отношения соединения. <placeholder-1/> Этот обработчик будет "
"вызываться многократно для одного отношения соединения с разными сочетаниями "
"внутренних и внешних отношений; задача обработчика — минимизировать при этом "
"дублирующиеся операции."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:114(title)
msgid "Custom Scan Path Callbacks"
msgstr "Обработчики пути нестандартного сканирования"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:117(programlisting)
#, no-wrap
msgid ""
"Plan *(*PlanCustomPath) (PlannerInfo *root,\n"
"                         RelOptInfo *rel,\n"
"                         CustomPath *best_path,\n"
"                         List *tlist,\n"
"                         List *clauses,\n"
"                         List *custom_plans);"
msgstr ""
"Plan *(*PlanCustomPath) (PlannerInfo *root,\n"
"                         RelOptInfo *rel,\n"
"                         CustomPath *best_path,\n"
"                         List *tlist,\n"
"                         List *clauses,\n"
"                         List *custom_plans);"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:116(para)
msgid ""
"<placeholder-1/> Convert a custom path to a finished plan. The return value "
"will generally be a <literal>CustomScan</literal> object, which the callback "
"must allocate and initialize. See <xref linkend=\"custom-scan-plan\"/> for "
"more details."
msgstr ""
"<placeholder-1/> Преобразует нестандартный путь в законченный план. "
"Возвращаемым значением обычно будет объект <literal>CustomScan</literal>, "
"который этот обработчик должен разместить в памяти и инициализировать. За "
"подробностями обратитесь к <xref remap=\"3\" linkend=\"custom-scan-plan\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:133(title)
msgid "Creating Custom Scan Plans"
msgstr "Создание нестандартных планов сканирования"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:138(programlisting)
#, no-wrap
msgid ""
"typedef struct CustomScan\n"
"{\n"
"    Scan      scan;\n"
"    uint32    flags;\n"
"    List     *custom_plans;\n"
"    List     *custom_exprs;\n"
"    List     *custom_private;\n"
"    List     *custom_scan_tlist;\n"
"    Bitmapset *custom_relids;\n"
"    const CustomScanMethods *methods;\n"
"} CustomScan;"
msgstr ""
"typedef struct CustomScan\n"
"{\n"
"    Scan      scan;\n"
"    uint32    flags;\n"
"    List     *custom_plans;\n"
"    List     *custom_exprs;\n"
"    List     *custom_private;\n"
"    List     *custom_scan_tlist;\n"
"    Bitmapset *custom_relids;\n"
"    const CustomScanMethods *methods;\n"
"} CustomScan;"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:135(para)
msgid ""
"A custom scan is represented in a finished plan tree using the following "
"structure: <placeholder-1/>"
msgstr ""
"Нестандартное сканирование представляется в окончательном дереве плана в "
"виде следующей структуры: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:153(para)
msgid ""
"<structfield>scan</structfield> must be initialized as for any other scan, "
"including estimated costs, target lists, qualifications, and so on. "
"<structfield>flags</structfield> is a bit mask with the same meaning as in "
"<structname>CustomPath</structname>. <structfield>custom_plans</structfield> "
"can be used to store child <structname>Plan</structname> nodes. "
"<structfield>custom_exprs</structfield> should be used to store expression "
"trees that will need to be fixed up by <filename>setrefs.c</filename> and "
"<filename>subselect.c</filename>, while <structfield>custom_private</"
"structfield> should be used to store other private data that is only used by "
"the custom scan provider itself. <structfield>custom_scan_tlist</"
"structfield> can be NIL when scanning a base relation, indicating that the "
"custom scan returns scan tuples that match the base relation's row type. "
"Otherwise it is a target list describing the actual scan tuples. "
"<structfield>custom_scan_tlist</structfield> must be provided for joins, and "
"could be provided for scans if the custom scan provider can compute some non-"
"Var expressions. <structfield>custom_relids</structfield> is set by the core "
"code to the set of relations (range table indexes) that this scan node "
"handles; except when this scan is replacing a join, it will have only one "
"member. <structfield>methods</structfield> must point to a (usually "
"statically allocated) object implementing the required custom scan methods, "
"which are further detailed below."
msgstr ""
"Объект в поле <structfield>scan</structfield> должен быть инициализирован, "
"как и для любого другого сканирования, и включать оценки стоимости, целевые "
"списки, условия и т. д. Поле <structfield>flags</structfield> содержит "
"битовую маску с тем же значением, что и в <structname>CustomPath</"
"structname>. В поле <structfield>custom_plans</structfield> могут быть "
"сохранены дочерние узлы <structname>Plan</structname>. В "
"<structfield>custom_exprs</structfield> могут быть сохранены деревья "
"выражений, которые будут исправляться кодом в <filename>setrefs.c</filename> "
"и <filename>subselect.c</filename>, а в <structfield>custom_private</"
"structfield> следует сохранить другие внутренние данные, которые будут "
"использоваться только самим провайдером нестандартного сканирования. Поле "
"<structfield>custom_scan_tlist</structfield> может содержать NIL при "
"сканировании базового отношения, что будет показывать, что нестандартное "
"сканирование возвращает кортежи, соответствующие типу строк базового "
"отношения. В противном случае оно должно указывать на целевой список, "
"описывающий фактические кортежи. Список <structfield>custom_scan_tlist</"
"structfield> должен устанавливаться при соединениях и может задаваться при "
"сканировании, если провайдер сканирования может вычислять какие-либо "
"выражения без переменных. Поле <structfield>custom_relids</structfield> "
"заполняется ядром и задаёт набор отношений (индексов в списке отношений), "
"которые обрабатывает данный узел сканирования; когда имеет место "
"сканирование, а не соединение, в этом списке будет всего один элемент. Поле "
"<structfield>methods</structfield> должно указывать на объект (обычно "
"статически размещённый), реализующий требуемые методы нестандартного "
"сканирования, которые подробнее описываются ниже."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:179(para)
msgid ""
"When a <structname>CustomScan</structname> scans a single relation, "
"<structfield>scan.scanrelid</structfield> must be the range table index of "
"the table to be scanned. When it replaces a join, <structfield>scan."
"scanrelid</structfield> should be zero."
msgstr ""
"Когда <structname>CustomScan</structname> сканирует одно отношение, в "
"<structfield>scan.scanrelid</structfield> должен задаваться индекс "
"сканируемой таблицы в списке отношений. Когда он заменяет соединение, поле "
"<structfield>scan.scanrelid</structfield> должно быть нулевым."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:186(para)
msgid ""
"Plan trees must be able to be duplicated using <function>copyObject</"
"function>, so all the data stored within the <quote>custom</quote> fields "
"must consist of nodes that that function can handle. Furthermore, custom "
"scan providers cannot substitute a larger structure that embeds a "
"<structname>CustomScan</structname> for the structure itself, as would be "
"possible for a <structname>CustomPath</structname> or "
"<structname>CustomScanState</structname>."
msgstr ""
"Деревья планов должны поддерживать возможность копирования функцией "
"<function>copyObject</function>, так что все данные, сохранённые в "
"<quote>дополнительных</quote> полях, должны быть узлами, которые может "
"обработать эта функция. Более того, провайдеры нестандартного сканирования "
"не могут заменять структуру <structname>CustomScan</structname> расширенной "
"структурой, её содержащей, что возможно с <structname>CustomPath</"
"structname> или <structname>CustomScanState</structname>."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:196(title)
msgid "Custom Scan Plan Callbacks"
msgstr "Обработчики плана нестандартного сканирования"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:198(programlisting)
#, no-wrap
msgid "Node *(*CreateCustomScanState) (CustomScan *cscan);"
msgstr "Node *(*CreateCustomScanState) (CustomScan *cscan);"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:197(para)
msgid ""
"<placeholder-1/> Allocate a <structname>CustomScanState</structname> for "
"this <structname>CustomScan</structname>. The actual allocation will often "
"be larger than required for an ordinary <structname>CustomScanState</"
"structname>, because many providers will wish to embed that as the first "
"field of a larger structure. The value returned must have the node tag and "
"<structfield>methods</structfield> set appropriately, but other fields "
"should be left as zeroes at this stage; after <function>ExecInitCustomScan</"
"function> performs basic initialization, the <function>BeginCustomScan</"
"function> callback will be invoked to give the custom scan provider a chance "
"to do whatever else is needed."
msgstr ""
"<placeholder-1/> Выделяет структуру <structname>CustomScanState</structname> "
"для заданного объекта <structname>CustomScan</structname>. Фактически "
"выделенная область будет обычно больше, чем требуется для самой структуры "
"<structname>CustomScanState</structname>, так как многие провайдеры могут "
"включать её в расширенную структуру в качестве первого поля. В возвращаемом "
"значении должны быть подходящим образом заполнены тег узла и поле "
"<structfield>methods</structfield>, но другие поля на данном этапе должны "
"быть обнулены; после того как <function>ExecInitCustomScan</function> "
"произведёт базовую инициализацию, будет вызван обработчик "
"<function>BeginCustomScan</function>, в котором провайдер нестандартного "
"сканирования может выполнить все остальные требуемые действия."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:215(title)
msgid "Executing Custom Scans"
msgstr "Выполнение нестандартного сканирования"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:221(programlisting)
#, no-wrap
msgid ""
"typedef struct CustomScanState\n"
"{\n"
"    ScanState ss;\n"
"    uint32    flags;\n"
"    const CustomExecMethods *methods;\n"
"} CustomScanState;"
msgstr ""
"typedef struct CustomScanState\n"
"{\n"
"    ScanState ss;\n"
"    uint32    flags;\n"
"    const CustomExecMethods *methods;\n"
"} CustomScanState;"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:217(para)
msgid ""
"When a <structfield>CustomScan</structfield> is executed, its execution "
"state is represented by a <structfield>CustomScanState</structfield>, which "
"is declared as follows: <placeholder-1/>"
msgstr ""
"Когда выполняется узел <structfield>CustomScan</structfield>, его состояние "
"представляется структурой <structfield>CustomScanState</structfield>, "
"объявленной следующим образом: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:231(para)
msgid ""
"<structfield>ss</structfield> is initialized as for any other scan state, "
"except that if the scan is for a join rather than a base relation, "
"<literal>ss.ss_currentRelation</literal> is left NULL. <structfield>flags</"
"structfield> is a bit mask with the same meaning as in "
"<structname>CustomPath</structname> and <structname>CustomScan</structname>. "
"<structfield>methods</structfield> must point to a (usually statically "
"allocated) object implementing the required custom scan state methods, which "
"are further detailed below. Typically, a <structname>CustomScanState</"
"structname>, which need not support <function>copyObject</function>, will "
"actually be a larger structure embedding the above as its first member."
msgstr ""
"Поле <structfield>ss</structfield> инициализируется как и для состояния "
"любого другого сканирования, за исключением того, что когда это сканирование "
"для соединения, а не для базового отношения, в <literal>ss."
"ss_currentRelation</literal> остаётся NULL. Поле <structfield>flags</"
"structfield> содержит битовую маску с тем же значением, что и в "
"<structname>CustomPath</structname> и <structname>CustomScan</structname>. "
"Поле <structfield>methods</structfield> должно указывать на объект (обычно "
"статически размещённый), реализующий требуемые методы состояния "
"нестандартного сканирования, подробнее описанные ниже. Обычно структура "
"<structname>CustomScanState</structname>, которой не нужно поддерживать "
"<function>copyObject</function>, фактически включается в расширенную "
"структуру в качестве её первого члена."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:245(title)
msgid "Custom Scan Execution Callbacks"
msgstr "Обработчики выполнения нестандартного сканирования"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:248(programlisting)
#, no-wrap
msgid ""
"void (*BeginCustomScan) (CustomScanState *node,\n"
"                         EState *estate,\n"
"                         int eflags);"
msgstr ""
"void (*BeginCustomScan) (CustomScanState *node,\n"
"                         EState *estate,\n"
"                         int eflags);"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:247(para)
msgid ""
"<placeholder-1/> Complete initialization of the supplied "
"<structname>CustomScanState</structname>. Standard fields have been "
"initialized by <function>ExecInitCustomScan</function>, but any private "
"fields should be initialized here."
msgstr ""
"<placeholder-1/> Завершает инициализацию переданного объекта "
"<structname>CustomScanState</structname>. Стандартные поля инициализируются "
"в <function>ExecInitCustomScan</function>, но все внутренние поля должны "
"инициализироваться здесь."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:259(programlisting)
#, no-wrap
msgid "TupleTableSlot *(*ExecCustomScan) (CustomScanState *node);"
msgstr "TupleTableSlot *(*ExecCustomScan) (CustomScanState *node);"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:258(para)
msgid ""
"<placeholder-1/> Fetch the next scan tuple. If any tuples remain, it should "
"fill <literal>ps_ResultTupleSlot</literal> with the next tuple in the "
"current scan direction, and then return the tuple slot. If not, "
"<literal>NULL</literal> or an empty slot should be returned."
msgstr ""
"<placeholder-1/> Считывает следующий кортеж. В случае наличия кортежей эта "
"функция должна записать в <literal>ps_ResultTupleSlot</literal> следующий "
"кортеж в текущем направлении сканирования и вернуть слот с кортежем. Если же "
"кортежей больше нет, она должна вернуть <literal>NULL</literal> или пустой "
"слот."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:269(programlisting)
#, no-wrap
msgid "void (*EndCustomScan) (CustomScanState *node);"
msgstr "void (*EndCustomScan) (CustomScanState *node);"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:268(para)
msgid ""
"<placeholder-1/> Clean up any private data associated with the "
"<literal>CustomScanState</literal>. This method is required, but it does not "
"need to do anything if there is no associated data or it will be cleaned up "
"automatically."
msgstr ""
"<placeholder-1/> Очищает все внутренние данные, связанные с "
"<literal>CustomScanState</literal>. Этот метод является обязательным, но он "
"может ничего не делать, если такие данные отсутствуют или они будут очищены "
"автоматически."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:278(programlisting)
#, no-wrap
msgid "void (*ReScanCustomScan) (CustomScanState *node);"
msgstr "void (*ReScanCustomScan) (CustomScanState *node);"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:277(para)
msgid ""
"<placeholder-1/> Rewind the current scan to the beginning and prepare to "
"rescan the relation."
msgstr ""
"<placeholder-1/> Возвращает позицию текущего сканирования в начало и "
"подготавливает повторное сканирование отношения."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:286(programlisting)
#, no-wrap
msgid "void (*MarkPosCustomScan) (CustomScanState *node);"
msgstr "void (*MarkPosCustomScan) (CustomScanState *node);"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:285(para)
msgid ""
"<placeholder-1/> Save the current scan position so that it can subsequently "
"be restored by the <function>RestrPosCustomScan</function> callback. This "
"callback is optional, and need only be supplied if the "
"<literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal> flag is set."
msgstr ""
"<placeholder-1/> Сохраняет текущую позицию сканирования, чтобы к ней "
"впоследствии можно было вернуться, вызвав обработчик "
"<function>RestrPosCustomScan</function>. Данный обработчик является "
"необязательным и должен присутствовать, только если установлен флаг "
"<literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:296(programlisting)
#, no-wrap
msgid "void (*RestrPosCustomScan) (CustomScanState *node);"
msgstr "void (*RestrPosCustomScan) (CustomScanState *node);"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:295(para)
msgid ""
"<placeholder-1/> Restore the previous scan position as saved by the "
"<function>MarkPosCustomScan</function> callback. This callback is optional, "
"and need only be supplied if the <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</"
"literal> flag is set."
msgstr ""
"<placeholder-1/> Восстанавливает предыдущую позицию сканирования, "
"сохранённую обработчиком <function>MarkPosCustomScan</function>. Данный "
"обработчик является необязательным и должен присутствовать, только если "
"установлен флаг <literal>CUSTOMPATH_SUPPORT_MARK_RESTORE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:306(programlisting)
#, no-wrap
msgid ""
"Size (*EstimateDSMCustomScan) (CustomScanState *node,\n"
"                               ParallelContext *pcxt);"
msgstr ""
"Size (*EstimateDSMCustomScan) (CustomScanState *node,\n"
"                               ParallelContext *pcxt);"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:305(para)
msgid ""
"<placeholder-1/> Estimate the amount of dynamic shared memory that will be "
"required for parallel operation. This may be higher than the amount that "
"will actually be used, but it must not be lower. The return value is in "
"bytes. This callback is optional, and need only be supplied if this custom "
"scan provider supports parallel execution."
msgstr ""
"<placeholder-1/> Оценивает объём динамической разделяемой памяти, которая "
"потребуется для параллельной операции. Это значение может превышать объём, "
"который будет занят фактически, но не должно быть меньше. Возвращаемое "
"значение задаётся в байтах. Этот обработчик не является обязательным и "
"должен устанавливаться, только если провайдер нестандартного сканирования "
"поддерживает параллельное выполнение."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:318(programlisting)
#, no-wrap
msgid ""
"void (*InitializeDSMCustomScan) (CustomScanState *node,\n"
"                                 ParallelContext *pcxt,\n"
"                                 void *coordinate);"
msgstr ""
"void (*InitializeDSMCustomScan) (CustomScanState *node,\n"
"                                 ParallelContext *pcxt,\n"
"                                 void *coordinate);"

#. +> REL_10
#: custom-scan.xml:317(para)
msgid ""
"<placeholder-1/> Initialize the dynamic shared memory that will be required "
"for parallel operation. <literal>coordinate</literal> points to a shared "
"memory area of size equal to the return value of "
"<function>EstimateDSMCustomScan</function>. This callback is optional, and "
"need only be supplied if this custom scan provider supports parallel "
"execution."
msgstr ""
"<placeholder-1/> Инициализирует динамическую разделяемую память, которая "
"потребуется для параллельной операции; <literal>coordinate</literal> "
"указывает на область разделяемой памяти размера, равного возвращаемому "
"значению <function>EstimateDSMCustomScan</function>. Этот обработчик "
"является необязательным и должен устанавливаться, только если провайдер "
"нестандартного сканирования поддерживает параллельное выполнение."

#. +> REL9_6_3 REL9_6
#: custom-scan.xml:317(para)
msgid ""
"<placeholder-1/> Initialize the dynamic shared memory that will be required "
"for parallel operation; <literal>coordinate</literal> points to an amount of "
"allocated space equal to the return value of "
"<function>EstimateDSMCustomScan</function>. This callback is optional, and "
"need only be supplied if this custom scan provider supports parallel "
"execution."
msgstr ""
"<placeholder-1/> Инициализирует динамическую разделяемую память, которая "
"потребуется для параллельной операции; <literal>coordinate</literal> "
"указывает на выделяемый размер, равный возвращаемому значению "
"<function>EstimateDSMCustomScan</function>. Этот обработчик является "
"необязательным и должен устанавливаться, только если провайдер "
"нестандартного сканирования поддерживает параллельное выполнение."

#. +> REL_10
#: custom-scan.xml:331(programlisting)
#, no-wrap
msgid ""
"void (*ReInitializeDSMCustomScan) (CustomScanState *node,\n"
"                                   ParallelContext *pcxt,\n"
"                                   void *coordinate);"
msgstr ""
"void (*ReInitializeDSMCustomScan) (CustomScanState *node,\n"
"                                   ParallelContext *pcxt,\n"
"                                   void *coordinate);"

#. +> REL_10
#: custom-scan.xml:330(para)
msgid ""
"<placeholder-1/> Re-initialize the dynamic shared memory required for "
"parallel operation when the custom-scan plan node is about to be re-scanned. "
"This callback is optional, and need only be supplied if this custom scan "
"provider supports parallel execution. Recommended practice is that this "
"callback reset only shared state, while the <function>ReScanCustomScan</"
"function> callback resets only local state. Currently, this callback will be "
"called before <function>ReScanCustomScan</function>, but it's best not to "
"rely on that ordering."
msgstr ""
"<placeholder-1/> Заново инициализирует динамическую разделяемую память, "
"требуемую для параллельной операции, перед тем как будет повторно прочитан "
"узел нестандартного сканирования. Этот обработчик является необязательным и "
"должен устанавливаться, только если провайдер нестандартного сканирования "
"поддерживает параллельное выполнение. В этом обработчике рекомендуется "
"сбрасывать только общее состояние, а в обработчике "
"<function>ReScanCustomScan</function> сбрасывать только локальное. В "
"настоящее время этот обработчик будет вызываться перед "
"<function>ReScanCustomScan</function>, но лучше на этот порядок не "
"рассчитывать."

#. +> REL9_6_3 REL9_6
#: custom-scan.xml:330(para)
msgid ""
"<placeholder-1/> Initialize a parallel worker's custom state based on the "
"shared state set up in the leader by <literal>InitializeDSMCustomScan</"
"literal>. This callback is optional, and needs only be supplied if this "
"custom path supports parallel execution."
msgstr ""
"<placeholder-1/> Инициализирует собственное состояние параллельного "
"исполнителя на основе общего состояния, заданного ведущим исполнителем при "
"вызове <literal>InitializeDSMCustomScan</literal>. Этот обработчик является "
"необязательным и должен устанавливаться, только если провайдер "
"нестандартного сканирования поддерживает параллельное выполнение."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:348(programlisting)
#, no-wrap
msgid ""
"void (*InitializeWorkerCustomScan) (CustomScanState *node,\n"
"                                    shm_toc *toc,\n"
"                                    void *coordinate);"
msgstr ""
"void (*InitializeWorkerCustomScan) (CustomScanState *node,\n"
"                                    shm_toc *toc,\n"
"                                    void *coordinate);"

#. +> REL_10
#: custom-scan.xml:347(para)
msgid ""
"<placeholder-1/> Initialize a parallel worker's local state based on the "
"shared state set up by the leader during <function>InitializeDSMCustomScan</"
"function>. This callback is optional, and need only be supplied if this "
"custom scan provider supports parallel execution."
msgstr ""
"<placeholder-1/> Инициализирует локальное состояние параллельного "
"исполнителя на основе общего состояния, заданного ведущим исполнителем во "
"время <function>InitializeDSMCustomScan</function>. Этот обработчик является "
"необязательным и должен устанавливаться, только если провайдер "
"нестандартного сканирования поддерживает параллельное выполнение."

#. +> REL_10
#: custom-scan.xml:360(programlisting)
#, no-wrap
msgid "void (*ShutdownCustomScan) (CustomScanState *node);"
msgstr "void (*ShutdownCustomScan) (CustomScanState *node);"

#. +> REL_10
#: custom-scan.xml:359(para)
msgid ""
"<placeholder-1/> Release resources when it is anticipated the node will not "
"be executed to completion. This is not called in all cases; sometimes, "
"<literal>EndCustomScan</literal> may be called without this function having "
"been called first. Since the DSM segment used by parallel query is destroyed "
"just after this callback is invoked, custom scan providers that wish to take "
"some action before the DSM segment goes away should implement this method."
msgstr ""
"<placeholder-1/> Освобождает ресурсы, когда становится понятно, что этот "
"узел больше не будет выполняться. Этот обработчик вызывается не во всех "
"случаях; иногда может вызываться только <literal>EndCustomScan</literal>. "
"Так как сегмент DSM, используемый параллельным запросом, освобождается сразу "
"после вызова этого обработчика, провайдеры нестандартного сканирования, "
"которым нужно выполнять некоторые действия до ликвидации сегмента DSM, "
"должны реализовывать этот метод."

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:373(programlisting)
#, no-wrap
msgid ""
"void (*ExplainCustomScan) (CustomScanState *node,\n"
"                           List *ancestors,\n"
"                           ExplainState *es);"
msgstr ""
"void (*ExplainCustomScan) (CustomScanState *node,\n"
"                           List *ancestors,\n"
"                           ExplainState *es);"

#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:372(para)
msgid ""
"<placeholder-1/> Output additional information for <command>EXPLAIN</"
"command> of a custom-scan plan node. This callback is optional. Common data "
"stored in the <structname>ScanState</structname>, such as the target list "
"and scan relation, will be shown even without this callback, but the "
"callback allows the display of additional, private state."
msgstr ""
"<placeholder-1/> Выводит дополнительную информацию для <command>EXPLAIN</"
"command> об узле нестандартного сканирования. Этот обработчик является "
"необязательным. Общие данные, сохранённые в <structname>ScanState</"
"structname>, такие как целевой список и сканируемое отношение, будут "
"выводиться и без этого обработчика, но с помощью этого обработчика можно "
"выдать дополнительные, внутренние сведения."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: custom-scan.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
