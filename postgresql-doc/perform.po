# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016, 2017.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2017-09-21 15:23+0300\n"
"PO-Revision-Date: 2017-09-21 17:02+0300\n"
"Last-Translator: Alexander Lakhin <a.lakhin@postgrespro.ru>\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:5(title)
msgid "Performance Tips"
msgstr "Оптимизация производительности"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:7(indexterm)
msgid "<primary>performance</primary>"
msgstr "<primary>производительность</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:11(para)
msgid ""
"Query performance can be affected by many things. Some of these can be "
"controlled by the user, while others are fundamental to the underlying "
"design of the system. This chapter provides some hints about understanding "
"and tuning <productname>PostgreSQL</productname> performance."
msgstr ""
"Быстродействие запросов зависит от многих факторов. На некоторые из них "
"могут воздействовать пользователи, а другие являются фундаментальными "
"особенностями системы. В этой главе приводятся полезные советы, которые "
"помогут понять их и оптимизировать производительность "
"<productname>PostgreSQL</productname>."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:19(title)
msgid "Using <command>EXPLAIN</command>"
msgstr "Использование <command>EXPLAIN</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:21(indexterm)
msgid "<primary>EXPLAIN</primary>"
msgstr "<primary>EXPLAIN</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:25(indexterm)
msgid "<primary>query plan</primary>"
msgstr "<primary>план запроса</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:29(para)
msgid ""
"<productname>PostgreSQL</productname> devises a <firstterm>query plan</"
"firstterm> for each query it receives. Choosing the right plan to match the "
"query structure and the properties of the data is absolutely critical for "
"good performance, so the system includes a complex <firstterm>planner</"
"firstterm> that tries to choose good plans. You can use the <xref linkend="
"\"sql-explain\"/> command to see what query plan the planner creates for any "
"query. Plan-reading is an art that requires some experience to master, but "
"this section attempts to cover the basics."
msgstr ""
"Выполняя любой полученный запрос, <productname>PostgreSQL</productname> "
"разрабатывает для него <firstterm>план запроса</firstterm>. Выбор "
"правильного плана, соответствующего структуре запроса и характеристикам "
"данным, крайне важен для хорошей производительности, поэтому в системе "
"работает сложный <firstterm>планировщик</firstterm>, задача которого &mdash; "
"подобрать хороший план. Узнать, какой план был выбран для какого-либо "
"запроса, можно с помощью команды <xref linkend=\"sql-explain\"/>. Понимание "
"плана &mdash; это искусство, и чтобы овладеть им, нужен определённый опыт, "
"но этот раздел расскажет о самых простых вещах."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:41(para)
msgid ""
"Examples in this section are drawn from the regression test database after "
"doing a <command>VACUUM ANALYZE</command>, using 9.3 development sources. "
"You should be able to get similar results if you try the examples yourself, "
"but your estimated costs and row counts might vary slightly because "
"<command>ANALYZE</command>'s statistics are random samples rather than "
"exact, and because costs are inherently somewhat platform-dependent."
msgstr ""
"Приведённые ниже примеры показаны на тестовой базе данных, которая создаётся "
"для выявления регрессий в исходных кодах <productname>PostgreSQL</"
"productname> текущей версии. Для неё предварительно выполняется "
"<command>VACUUM ANALYZE</command>. Вы должны получить похожие результаты, "
"если возьмёте ту же базу данных и проделаете следующие действия, но "
"примерная стоимость и ожидаемое число строк у вас может немного отличаться "
"из-за того, что статистика команды <command>ANALYZE</command> рассчитывается "
"по случайной выборке, а оценки стоимости зависят от конкретной платформы."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:50(para)
msgid ""
"The examples use <command>EXPLAIN</command>'s default <quote>text</quote> "
"output format, which is compact and convenient for humans to read. If you "
"want to feed <command>EXPLAIN</command>'s output to a program for further "
"analysis, you should use one of its machine-readable output formats (XML, "
"JSON, or YAML) instead."
msgstr ""
"В этих примерах используется текстовый формат вывода <command>EXPLAIN</"
"command>, принятый по умолчанию, как более компактный и удобный для "
"восприятия человеком. Если вывод <command>EXPLAIN</command> нужно передать "
"какой-либо программе для дальнейшего анализа, лучше использовать один из "
"машинно-ориентированных форматов (XML, JSON или YAML)."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:59(title)
msgid "<command>EXPLAIN</command> Basics"
msgstr "Азы <command>EXPLAIN</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:61(para)
msgid ""
"The structure of a query plan is a tree of <firstterm>plan nodes</"
"firstterm>. Nodes at the bottom level of the tree are scan nodes: they "
"return raw rows from a table. There are different types of scan nodes for "
"different table access methods: sequential scans, index scans, and bitmap "
"index scans. There are also non-table row sources, such as <literal>VALUES</"
"literal> clauses and set-returning functions in <literal>FROM</literal>, "
"which have their own scan node types. If the query requires joining, "
"aggregation, sorting, or other operations on the raw rows, then there will "
"be additional nodes above the scan nodes to perform these operations. Again, "
"there is usually more than one possible way to do these operations, so "
"different node types can appear here too. The output of <command>EXPLAIN</"
"command> has one line for each node in the plan tree, showing the basic node "
"type plus the cost estimates that the planner made for the execution of that "
"plan node. Additional lines might appear, indented from the node's summary "
"line, to show additional properties of the node. The very first line (the "
"summary line for the topmost node) has the estimated total execution cost "
"for the plan; it is this number that the planner seeks to minimize."
msgstr ""
"Структура плана запроса представляет собой дерево <firstterm>узлов плана</"
"firstterm>. Узлы на нижнем уровне дерева &mdash; это узлы сканирования, "
"которые возвращают необработанные данные таблицы. Разным типам доступа к "
"таблице соответствуют разные узлы: последовательное сканирование, "
"сканирование индекса и сканирование битовой карты. Источниками строк могут "
"быть не только таблицы, но и например, предложения <literal>VALUES</literal> "
"и функции, возвращающие множества во <literal>FROM</literal>, и они "
"представляются отдельными типами узлов сканирования. Если запрос требует "
"объединения, агрегатных вычислений, сортировки или других операций с "
"исходными строками, над узлами сканирования появляются узлы, обозначающие "
"эти операции. И так как обычно операции могут выполняться разными способами, "
"на этом уровне тоже могут быть узлы разных типов. В выводе команды "
"<command>EXPLAIN</command> для каждого узла в дереве плана отводится одна "
"строка, где показывается базовый тип узла плюс оценка стоимости выполнения "
"данного узла, которую сделал для него планировщик. Если для узла выводятся "
"дополнительные свойства, в вывод могут добавляться дополнительные строки, с "
"отступом от основной информации узла. В самой первой строке (основной строке "
"самого верхнего узла) выводится общая стоимость выполнения для всего плана; "
"именно это значение планировщик старается минимизировать."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:84(para)
msgid ""
"Here is a trivial example, just to show what the output looks like: "
"<screen>\n"
"EXPLAIN SELECT * FROM tenk1;\n"
"\n"
"                         QUERY PLAN\n"
"-------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)\n"
"</screen>"
msgstr ""
"Взгляните на следующий простейший пример, просто иллюстрирующий формат "
"вывода: <screen>\n"
"EXPLAIN SELECT * FROM tenk1;\n"
"\n"
"                         QUERY PLAN\n"
"-------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:104(para)
msgid ""
"Estimated start-up cost. This is the time expended before the output phase "
"can begin, e.g., time to do the sorting in a sort node."
msgstr ""
"Приблизительная стоимость запуска. Это время, которое проходит, прежде чем "
"начнётся этап вывода данных, например для сортирующего узла это время "
"сортировки."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:111(para)
msgid ""
"Estimated total cost. This is stated on the assumption that the plan node is "
"run to completion, i.e., all available rows are retrieved. In practice a "
"node's parent node might stop short of reading all available rows (see the "
"<literal>LIMIT</literal> example below)."
msgstr ""
"Приблизительная общая стоимость. Она вычисляется в предположении, что узел "
"плана выполняется до конца, то есть возвращает все доступные строки. На "
"практике родительский узел может досрочно прекратить чтение строк дочернего "
"(см. приведённый ниже пример с <literal>LIMIT</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:120(para)
msgid ""
"Estimated number of rows output by this plan node. Again, the node is "
"assumed to be run to completion."
msgstr ""
"Ожидаемое число строк, которое должен вывести этот узел плана. При этом так "
"же предполагается, что узел выполняется до конца."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:127(para)
msgid "Estimated average width of rows output by this plan node (in bytes)."
msgstr "Ожидаемый средний размер строк, выводимых этим узлом плана (в байтах)."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:96(para)
msgid ""
"Since this query has no <literal>WHERE</literal> clause, it must scan all "
"the rows of the table, so the planner has chosen to use a simple sequential "
"scan plan. The numbers that are quoted in parentheses are (left to right): "
"<placeholder-1/>"
msgstr ""
"Этот запрос не содержит предложения <literal>WHERE</literal>, поэтому он "
"должен просканировать все строки таблицы, так что планировщик выбрал план "
"простого последовательного сканирования. Числа, перечисленные в скобках "
"(слева направо), имеют следующий смысл: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:134(para)
msgid ""
"The costs are measured in arbitrary units determined by the planner's cost "
"parameters (see <xref linkend=\"runtime-config-query-constants\"/>). "
"Traditional practice is to measure the costs in units of disk page fetches; "
"that is, <xref linkend=\"guc-seq-page-cost\"/> is conventionally set to "
"<literal>1.0</literal> and the other cost parameters are set relative to "
"that. The examples in this section are run with the default cost parameters."
msgstr ""
"Стоимость может измеряться в произвольных единицах, определяемых параметрами "
"планировщика (см. <xref remap=\"4\" linkend=\"runtime-config-query-constants"
"\"/>). Традиционно единицей стоимости считается операция чтения страницы с "
"диска; то есть <xref remap=\"4\" linkend=\"guc-seq-page-cost\"/> обычно "
"равен <literal>1.0</literal>, а другие параметры задаётся относительно него. "
"Примеры в этом разделе выполняются со стандартными параметрами стоимости."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:144(para)
msgid ""
"It's important to understand that the cost of an upper-level node includes "
"the cost of all its child nodes. It's also important to realize that the "
"cost only reflects things that the planner cares about. In particular, the "
"cost does not consider the time spent transmitting result rows to the "
"client, which could be an important factor in the real elapsed time; but the "
"planner ignores it because it cannot change it by altering the plan. (Every "
"correct plan will output the same row set, we trust.)"
msgstr ""
"Важно понимать, что стоимость узла верхнего уровня включает стоимость всех "
"его потомков. Также важно осознавать, что эта стоимость отражает только те "
"факторы, которые учитывает планировщик. В частности, она не зависит от "
"времени, необходимого для передачи результирующих строк клиенту, хотя оно "
"может составлять значительную часть общего времени выполнения запроса. Тем "
"не менее планировщик игнорирует эту величину, так как он всё равно не сможет "
"изменить её, выбрав другой план. (Мы верим в то, что любой правильный план "
"запроса выдаёт один и тот же набор строк.)"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:155(para)
msgid ""
"The <literal>rows</literal> value is a little tricky because it is not the "
"number of rows processed or scanned by the plan node, but rather the number "
"emitted by the node. This is often less than the number scanned, as a result "
"of filtering by any <literal>WHERE</literal>-clause conditions that are "
"being applied at the node. Ideally the top-level rows estimate will "
"approximate the number of rows actually returned, updated, or deleted by the "
"query."
msgstr ""
"Значение <literal>rows</literal> здесь имеет особенность &mdash; оно "
"выражает не число строк, обработанных или просканированных узлом плана, а "
"число строк, выданных этим узлом. Часто оно окажется меньше числа "
"просканированных строк в результате применённой к узлу фильтрации по "
"условиям <literal>WHERE</literal>. В идеале, на верхнем уровне это значение "
"будет приблизительно равно числу строк, которое фактически возвращает, "
"изменяет или удаляет запрос."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:165(para)
msgid ""
"Returning to our example: <screen>\n"
"EXPLAIN SELECT * FROM tenk1;\n"
"\n"
"                         QUERY PLAN\n"
"-------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)\n"
"</screen>"
msgstr ""
"Возвращаясь к нашему примеру: <screen>\n"
"EXPLAIN SELECT * FROM tenk1;\n"
"\n"
"                         QUERY PLAN\n"
"-------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:180(programlisting)
#, no-wrap
msgid "SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';"
msgstr "SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:177(para)
msgid ""
"These numbers are derived very straightforwardly. If you do: <placeholder-1/"
"> you will find that <classname>tenk1</classname> has 358 disk pages and "
"10000 rows. The estimated cost is computed as (disk pages read * <xref "
"linkend=\"guc-seq-page-cost\"/>) + (rows scanned * <xref linkend=\"guc-cpu-"
"tuple-cost\"/>). By default, <varname>seq_page_cost</varname> is 1.0 and "
"<varname>cpu_tuple_cost</varname> is 0.01, so the estimated cost is (358 * "
"1.0) + (10000 * 0.01) = 458."
msgstr ""
"Эти числа получаются очень просто. Выполните: <placeholder-1/> и вы увидите, "
"что <classname>tenk1</classname> содержит 358 страниц диска и 10000 строк. "
"Общая стоимость вычисляется как (число_чтений_диска * <xref linkend=\"guc-"
"seq-page-cost\"/>) + (число_просканированных_строк * <xref linkend=\"guc-cpu-"
"tuple-cost\"/>). По умолчанию, <varname>seq_page_cost</varname> равно 1.0, а "
"<varname>cpu_tuple_cost</varname> &mdash; 0.01, так что приблизительная "
"стоимость запроса равна (358 * 1.0) + (10000 * 0.01) = 458."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:192(para)
msgid ""
"Now let's modify the query to add a <literal>WHERE</literal> condition: "
"<screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 7000;\n"
"\n"
"                         QUERY PLAN\n"
"------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=7001 width=244)\n"
"   Filter: (unique1 &lt; 7000)\n"
"</screen> Notice that the <command>EXPLAIN</command> output shows the "
"<literal>WHERE</literal> clause being applied as a <quote>filter</quote> "
"condition attached to the Seq Scan plan node. This means that the plan node "
"checks the condition for each row it scans, and outputs only the ones that "
"pass the condition. The estimate of output rows has been reduced because of "
"the <literal>WHERE</literal> clause. However, the scan will still have to "
"visit all 10000 rows, so the cost hasn't decreased; in fact it has gone up a "
"bit (by 10000 * <xref linkend=\"guc-cpu-operator-cost\"/>, to be exact) to "
"reflect the extra CPU time spent checking the <literal>WHERE</literal> "
"condition."
msgstr ""
"Теперь давайте изменим запрос, добавив в него предложение <literal>WHERE</"
"literal>: <screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 7000;\n"
"\n"
"                             QUERY PLAN\n"
"------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=7001 width=244)\n"
"   Filter: (unique1 &lt; 7000)\n"
"</screen> Заметьте, что в выводе <command>EXPLAIN</command> показано, что "
"условие <literal>WHERE</literal> применено как <quote>фильтр</quote> к узлу "
"плана Seq Scan (Последовательное сканирование). Это означает, что узел плана "
"проверяет это условие для каждого просканированного им узла и выводит только "
"те строки, которые удовлетворяют ему. Предложение <literal>WHERE</literal> "
"повлияло на оценку числа выходных строк. Однако при сканировании потребуется "
"прочитать все 10000 строк, поэтому общая стоимость не уменьшилась. На деле "
"она даже немного увеличилась (на 10000 * <xref linkend=\"guc-cpu-operator-"
"cost\"/>, если быть точными), отражая дополнительное время, которое "
"потребуется процессору на проверку условия <literal>WHERE</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:217(para)
msgid ""
"The actual number of rows this query would select is 7000, but the "
"<literal>rows</literal> estimate is only approximate. If you try to "
"duplicate this experiment, you will probably get a slightly different "
"estimate; moreover, it can change after each <command>ANALYZE</command> "
"command, because the statistics produced by <command>ANALYZE</command> are "
"taken from a randomized sample of the table."
msgstr ""
"Фактическое число строк результата этого запроса будет равно 7000, но "
"значение <literal>rows</literal> даёт только приблизительное значение. Если "
"вы попытаетесь повторить этот эксперимент, вы можете получить немного другую "
"оценку; более того, она может меняться после каждой команды "
"<command>ANALYZE</command>, так как <command>ANALYZE</command> получает "
"статистику по случайной выборке таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:226(para)
msgid ""
"Now, let's make the condition more restrictive: <screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100;\n"
"\n"
"                                  QUERY PLAN\n"
"------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=5.07..229.20 rows=101 width=244)\n"
"   Recheck Cond: (unique1 &lt; 100)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 "
"width=0)\n"
"         Index Cond: (unique1 &lt; 100)\n"
"</screen> Here the planner has decided to use a two-step plan: the child "
"plan node visits an index to find the locations of rows matching the index "
"condition, and then the upper plan node actually fetches those rows from the "
"table itself. Fetching rows separately is much more expensive than reading "
"them sequentially, but because not all the pages of the table have to be "
"visited, this is still cheaper than a sequential scan. (The reason for using "
"two plan levels is that the upper plan node sorts the row locations "
"identified by the index into physical order before reading them, to minimize "
"the cost of separate fetches. The <quote>bitmap</quote> mentioned in the "
"node names is the mechanism that does the sorting.)"
msgstr ""
"Теперь давайте сделаем ограничение более избирательным: <screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100;\n"
"\n"
"                             QUERY PLAN\n"
"--------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=5.07..229.20 rows=101 width=244)\n"
"   Recheck Cond: (unique1 &lt; 100)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1\n"
"                                        (cost=0.00..5.01 rows=101 width=0)\n"
"         Index Cond: (unique1 &lt; 100)\n"
"</screen> В данном случае планировщик решил использовать план из двух "
"этапов: сначала дочерний узел плана просматривает индекс и находит в нём "
"адреса строк, соответствующих условию индекса, а затем верхний узел "
"собственно выбирает эти строки из таблицы. Выбирать строки по отдельности "
"гораздо дороже, чем просто читать их последовательно, но так как читать "
"придётся не все страницы таблицы, это всё равно будет дешевле, чем "
"сканировать всю таблицу. (Использование двух уровней плана объясняется тем, "
"что верхний узел сортирует адреса строк, выбранных из индекса, в физическом "
"порядке, прежде чем читать, чтобы снизить стоимость отдельных чтений. Слово "
"<quote>bitmap</quote> (битовая карта) в имени узла обозначает механизм, "
"выполняющий сортировку.)"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:253(para)
msgid ""
"Now let's add another condition to the <literal>WHERE</literal> clause: "
"<screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND stringu1 = 'xxx';\n"
"\n"
"                                  QUERY PLAN\n"
"------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=5.04..229.43 rows=1 width=244)\n"
"   Recheck Cond: (unique1 &lt; 100)\n"
"   Filter: (stringu1 = 'xxx'::name)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 "
"width=0)\n"
"         Index Cond: (unique1 &lt; 100)\n"
"</screen> The added condition <literal>stringu1 = 'xxx'</literal> reduces "
"the output row count estimate, but not the cost because we still have to "
"visit the same set of rows. Notice that the <literal>stringu1</literal> "
"clause cannot be applied as an index condition, since this index is only on "
"the <literal>unique1</literal> column. Instead it is applied as a filter on "
"the rows retrieved by the index. Thus the cost has actually gone up slightly "
"to reflect this extra checking."
msgstr ""
"Теперь давайте добавим ещё одно условие в предложение <literal>WHERE</"
"literal>: <screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND stringu1 = 'xxx';\n"
"\n"
"                             QUERY PLAN\n"
"--------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=5.01..229.40 rows=1 width=244)\n"
"   Recheck Cond: (unique1 &lt; 100)\n"
"   Filter: (stringu1 = 'xxx'::name)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1\n"
"                                        (cost=0.00..5.04 rows=101 width=0)\n"
"         Index Cond: (unique1 &lt; 100)\n"
"</screen> Добавленное условие <literal>stringu1 = 'xxx'</literal> уменьшает "
"оценку числа результирующих строк, но не стоимость запроса, так как "
"просматриваться будет тот же набор строк, что и раньше. Заметьте, что "
"условие на <literal>stringu1</literal> не добавляется в качестве условия "
"индекса, так как индекс построен только по столбцу <literal>unique1</"
"literal>. Вместо этого оно применяется как фильтр к строкам, полученным по "
"индексу. В результате стоимость даже немного увеличилась, отражая добавление "
"этой проверки."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:277(para)
msgid ""
"In some cases the planner will prefer a <quote>simple</quote> index scan "
"plan: <screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 = 42;\n"
"\n"
"                                 QUERY PLAN\n"
"-----------------------------------------------------------------------------\n"
" Index Scan using tenk1_unique1 on tenk1  (cost=0.29..8.30 rows=1 "
"width=244)\n"
"   Index Cond: (unique1 = 42)\n"
"</screen> In this type of plan the table rows are fetched in index order, "
"which makes them even more expensive to read, but there are so few that the "
"extra cost of sorting the row locations is not worth it. You'll most often "
"see this plan type for queries that fetch just a single row. It's also often "
"used for queries that have an <literal>ORDER BY</literal> condition that "
"matches the index order, because then no extra sorting step is needed to "
"satisfy the <literal>ORDER BY</literal>."
msgstr ""
"В некоторых случаях планировщик предпочтёт <quote>простой</quote> план "
"сканирования индекса: <screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 = 42;\n"
"\n"
"                             QUERY PLAN\n"
"---------------------------------------------------------------------------\n"
" Index Scan using tenk1_unique1 on tenk1 (cost=0.29..8.30 rows=1 width=244)\n"
"   Index Cond: (unique1 = 42)\n"
"</screen> В плане такого типа строки таблицы выбираются в порядке индекса, в "
"результате чего чтение их обходится дороже, но так как их немного, "
"дополнительно сортировать положения строк не стоит. Вы часто будете "
"встречать этот тип плана в запросах, которые выбирают всего одну строку. "
"Также он часто задействуется там, где условие <literal>ORDER BY</literal> "
"соответствует порядку индекса, так как в этих случаях для выполнения "
"<literal>ORDER BY</literal> не требуется дополнительный шаг сортировки."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:298(para)
msgid ""
"If there are separate indexes on several of the columns referenced in "
"<literal>WHERE</literal>, the planner might choose to use an AND or OR "
"combination of the indexes: <screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;\n"
"\n"
"                                     QUERY PLAN\n"
"-------------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244)\n"
"   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))\n"
"   -&gt;  BitmapAnd  (cost=25.08..25.08 rows=10 width=0)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 "
"rows=101 width=0)\n"
"               Index Cond: (unique1 &lt; 100)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 "
"rows=999 width=0)\n"
"               Index Cond: (unique2 &gt; 9000)\n"
"</screen> But this requires visiting both indexes, so it's not necessarily a "
"win compared to using just one index and treating the other condition as a "
"filter. If you vary the ranges involved you'll see the plan change "
"accordingly."
msgstr ""
"Если в таблице есть отдельные индексы по разным столбцам, фигурирующим в "
"<literal>WHERE</literal>, планировщик может выбрать сочетание этих индексов "
"(с AND и OR): <screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;\n"
"\n"
"                                     QUERY PLAN\n"
"-------------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244)\n"
"   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))\n"
"   -&gt;  BitmapAnd  (cost=25.08..25.08 rows=10 width=0)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 "
"rows=101 width=0)\n"
"               Index Cond: (unique1 &lt; 100)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 "
"rows=999 width=0)\n"
"               Index Cond: (unique2 &gt; 9000)\n"
"</screen> Но для этого потребуется обойти оба индекса, так что это не "
"обязательно будет выгоднее, чем просто просмотреть один индекс, а второе "
"условие обработать как фильтр. Измените диапазон и вы увидите, как это "
"повлияет на план."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:323(para)
msgid ""
"Here is an example showing the effects of <literal>LIMIT</literal>: "
"<screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000 "
"LIMIT 2;\n"
"\n"
"                                     QUERY PLAN\n"
"-------------------------------------------------------------------------------------\n"
" Limit  (cost=0.29..14.48 rows=2 width=244)\n"
"   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..71.27 rows=10 "
"width=244)\n"
"         Index Cond: (unique2 &gt; 9000)\n"
"         Filter: (unique1 &lt; 100)\n"
"</screen>"
msgstr ""
"Следующий пример иллюстрирует эффекты <literal>LIMIT</literal>: <screen>\n"
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000 "
"LIMIT 2;\n"
"\n"
"                                     QUERY PLAN\n"
"-------------------------------------------------------------------------------------\n"
" Limit  (cost=0.29..14.48 rows=2 width=244)\n"
"   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..71.27 rows=10 "
"width=244)\n"
"         Index Cond: (unique2 &gt; 9000)\n"
"         Filter: (unique1 &lt; 100)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:338(para)
msgid ""
"This is the same query as above, but we added a <literal>LIMIT</literal> so "
"that not all the rows need be retrieved, and the planner changed its mind "
"about what to do. Notice that the total cost and row count of the Index Scan "
"node are shown as if it were run to completion. However, the Limit node is "
"expected to stop after retrieving only a fifth of those rows, so its total "
"cost is only a fifth as much, and that's the actual estimated cost of the "
"query. This plan is preferred over adding a Limit node to the previous plan "
"because the Limit could not avoid paying the startup cost of the bitmap "
"scan, so the total cost would be something over 25 units with that approach."
msgstr ""
"Это тот же запрос, что и раньше, но добавили мы в него <literal>LIMIT</"
"literal>, чтобы возвращались не все строки, и планировщик решает выполнять "
"запрос по-другому. Заметьте, что общая стоимость и число строк для узла "
"Index Scan рассчитываются в предположении, что он будет выполняться "
"полностью. Однако узел Limit должен остановиться, получив только пятую часть "
"всех строк, так что его стоимость будет составлять одну пятую от вычисленной "
"ранее, и это и будет итоговой оценкой стоимости запроса. С другой стороны, "
"планировщик мог бы просто добавить в предыдущий план узел Limit, но это не "
"избавило бы от затрат на запуск сканирования битовой карты, а значит, общая "
"стоимость была бы выше 25 единиц."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:351(para)
msgid ""
"Let's try joining two tables, using the columns we have been discussing: "
"<screen>\n"
"EXPLAIN SELECT *\n"
"FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                      QUERY PLAN\n"
"--------------------------------------------------------------------------------------\n"
" Nested Loop  (cost=4.65..118.62 rows=10 width=488)\n"
"   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 "
"width=244)\n"
"         Recheck Cond: (unique1 &lt; 10)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 "
"width=0)\n"
"               Index Cond: (unique1 &lt; 10)\n"
"   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 "
"rows=1 width=244)\n"
"         Index Cond: (unique2 = t1.unique2)\n"
"</screen>"
msgstr ""
"Давайте попробуем соединить две таблицы по столбцам, которые мы уже "
"использовали: <screen>\n"
"EXPLAIN SELECT *\n"
"FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                      QUERY PLAN\n"
"--------------------------------------------------------------------------------------\n"
" Nested Loop  (cost=4.65..118.62 rows=10 width=488)\n"
"   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 "
"width=244)\n"
"         Recheck Cond: (unique1 &lt; 10)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 "
"width=0)\n"
"               Index Cond: (unique1 &lt; 10)\n"
"   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 "
"rows=1 width=244)\n"
"         Index Cond: (unique2 = t1.unique2)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:371(para)
msgid ""
"In this plan, we have a nested-loop join node with two table scans as "
"inputs, or children. The indentation of the node summary lines reflects the "
"plan tree structure. The join's first, or <quote>outer</quote>, child is a "
"bitmap scan similar to those we saw before. Its cost and row count are the "
"same as we'd get from <literal>SELECT ... WHERE unique1 &lt; 10</literal> "
"because we are applying the <literal>WHERE</literal> clause <literal>unique1 "
"&lt; 10</literal> at that node. The <literal>t1.unique2 = t2.unique2</"
"literal> clause is not relevant yet, so it doesn't affect the row count of "
"the outer scan. The nested-loop join node will run its second, or "
"<quote>inner</quote> child once for each row obtained from the outer child. "
"Column values from the current outer row can be plugged into the inner scan; "
"here, the <literal>t1.unique2</literal> value from the outer row is "
"available, so we get a plan and costs similar to what we saw above for a "
"simple <literal>SELECT ... WHERE t2.unique2 = <replaceable>constant</"
"replaceable></literal> case. (The estimated cost is actually a bit lower "
"than what was seen above, as a result of caching that's expected to occur "
"during the repeated index scans on <literal>t2</literal>.) The costs of the "
"loop node are then set on the basis of the cost of the outer scan, plus one "
"repetition of the inner scan for each outer row (10 * 7.87, here), plus a "
"little CPU time for join processing."
msgstr ""
"В этом плане появляется узел соединения с вложенным циклом, на вход которому "
"поступают данные от двух его потомков, узлов сканирования. Эту структуру "
"плана отражает отступ основных строк его узлов. Первый, или <quote>внешний</"
"quote>, потомок соединения &mdash; узел сканирования битовой карты, похожий "
"на те, что мы видели раньше. Его стоимость и число строк те же, что мы "
"получили бы для запроса <literal>SELECT ... WHERE unique1 &lt; 10</literal>, "
"так как к этому узлу добавлено предложение <literal>WHERE</literal> "
"<literal>unique1 &lt; 10</literal>. Условие <literal>t1.unique2 = t2."
"unique2</literal> ещё не учитывается, поэтому оно не влияет на число строк "
"узла внешнего сканирования. Узел соединения с вложенным циклом будет "
"выполнять узел <quote>внутреннего</quote> потомка для каждой строки, "
"полученной из внешнего потомка. Значения столбцов из текущей внешней строки "
"могут использоваться во внутреннем сканировании (в данном случае это "
"значение <literal>t1.unique2</literal>), поэтому мы получаем план и "
"стоимость примерно такие, как и раньше для простого запроса "
"<literal>SELECT ... WHERE t2.unique2 = <replaceable>константа</replaceable></"
"literal>. (На самом деле оценочная стоимость немного меньше, в "
"предположении, что при неоднократном сканировании индекса по <literal>t2</"
"literal> положительную роль сыграет кеширование.) В результате стоимость "
"узла цикла складывается из стоимости внешнего сканирования, цены внутреннего "
"сканирования, умноженной на число строк (здесь 10 * 7.87), и небольшой "
"наценки за обработку соединения."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:396(para)
msgid ""
"In this example the join's output row count is the same as the product of "
"the two scans' row counts, but that's not true in all cases because there "
"can be additional <literal>WHERE</literal> clauses that mention both tables "
"and so can only be applied at the join point, not to either input scan. "
"Here's an example: <screen>\n"
"EXPLAIN SELECT *\n"
"FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 10 AND t2.unique2 &lt; 10 AND t1.hundred &lt; t2."
"hundred;\n"
"\n"
"                                         QUERY PLAN\n"
"---------------------------------------------------------------------------------------------\n"
" Nested Loop  (cost=4.65..49.46 rows=33 width=488)\n"
"   Join Filter: (t1.hundred &lt; t2.hundred)\n"
"   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 "
"width=244)\n"
"         Recheck Cond: (unique1 &lt; 10)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 "
"width=0)\n"
"               Index Cond: (unique1 &lt; 10)\n"
"   -&gt;  Materialize  (cost=0.29..8.51 rows=10 width=244)\n"
"         -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..8.46 "
"rows=10 width=244)\n"
"               Index Cond: (unique2 &lt; 10)\n"
"</screen> The condition <literal>t1.hundred &lt; t2.hundred</literal> can't "
"be tested in the <literal>tenk2_unique2</literal> index, so it's applied at "
"the join node. This reduces the estimated output row count of the join node, "
"but does not change either input scan."
msgstr ""
"В этом примере число выходных строк соединения равно произведению чисел "
"строк двух узлов сканирования, но это не всегда будет так, потому что в "
"дополнительных условиях <literal>WHERE</literal> могут упоминаться обе "
"таблицы, так что применить их можно будет только в точке соединения, а не в "
"одном из узлов сканирования. Например: <screen>\n"
"EXPLAIN SELECT *\n"
"FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 10 AND t2.unique2 &lt; 10 AND t1.hundred &lt; t2."
"hundred;\n"
"\n"
"                                         QUERY PLAN\n"
"---------------------------------------------------------------------------------------------\n"
" Nested Loop  (cost=4.65..49.46 rows=33 width=488)\n"
"   Join Filter: (t1.hundred &lt; t2.hundred)\n"
"   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 "
"width=244)\n"
"         Recheck Cond: (unique1 &lt; 10)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 "
"width=0)\n"
"               Index Cond: (unique1 &lt; 10)\n"
"   -&gt;  Materialize  (cost=0.29..8.51 rows=10 width=244)\n"
"         -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..8.46 "
"rows=10 width=244)\n"
"               Index Cond: (unique2 &lt; 10)\n"
"</screen> Условие <literal>t1.hundred &lt; t2.hundred</literal> не может "
"быть проверено в индексе <literal>tenk2_unique2</literal>, поэтому оно "
"применяется в узле соединения. Это уменьшает оценку числа выходных строк, "
"тогда как число строк в узлах сканирования не меняется."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:427(para)
msgid ""
"Notice that here the planner has chosen to <quote>materialize</quote> the "
"inner relation of the join, by putting a Materialize plan node atop it. This "
"means that the <literal>t2</literal> index scan will be done just once, even "
"though the nested-loop join node needs to read that data ten times, once for "
"each row from the outer relation. The Materialize node saves the data in "
"memory as it's read, and then returns the data from memory on each "
"subsequent pass."
msgstr ""
"Заметьте, что здесь планировщик решил <quote>материализовать</quote> "
"внутреннее отношение соединения, поместив поверх него узел плана Materialize "
"(Материализовать). Это значит, что сканирование индекса <literal>t2</"
"literal> будет выполняться только единожды, при том, что узлу вложенного "
"цикла соединения потребуется прочитать данные десять раз, по числу строк во "
"внешнем соединении. Узел Materialize сохраняет считанные данные в памяти, "
"чтобы затем выдать их из памяти на следующих проходах."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:437(para)
msgid ""
"When dealing with outer joins, you might see join plan nodes with both "
"<quote>Join Filter</quote> and plain <quote>Filter</quote> conditions "
"attached. Join Filter conditions come from the outer join's <literal>ON</"
"literal> clause, so a row that fails the Join Filter condition could still "
"get emitted as a null-extended row. But a plain Filter condition is applied "
"after the outer-join rules and so acts to remove rows unconditionally. In an "
"inner join there is no semantic difference between these types of filters."
msgstr ""
"Выполняя внешние соединения, вы можете встретить узлы плана с "
"присоединёнными условиями, как обычными <quote>Filter</quote>, так и "
"<quote>Join Filter</quote> (Фильтр соединения). Условия Join Filter "
"формируются из предложения <literal>ON</literal> для внешнего соединения, "
"так что если строка не удовлетворяет условию Join Filter, она всё же "
"выдаётся как строка, дополненная значениями NULL. Обычное же условие Filter "
"применяется после правил внешнего соединения и поэтому полностью исключает "
"строки. Во внутреннем соединении оба этих фильтра работают одинаково."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:447(para)
msgid ""
"If we change the query's selectivity a bit, we might get a very different "
"join plan: <screen>\n"
"EXPLAIN SELECT *\n"
"FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                        QUERY PLAN\n"
"------------------------------------------------------------------------------------------\n"
" Hash Join  (cost=230.47..713.98 rows=101 width=488)\n"
"   Hash Cond: (t2.unique2 = t1.unique2)\n"
"   -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244)\n"
"   -&gt;  Hash  (cost=229.20..229.20 rows=101 width=244)\n"
"         -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.07..229.20 rows=101 "
"width=244)\n"
"               Recheck Cond: (unique1 &lt; 100)\n"
"               -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 "
"rows=101 width=0)\n"
"                     Index Cond: (unique1 &lt; 100)\n"
"</screen>"
msgstr ""
"Если немного изменить избирательность запроса, мы можем получить совсем "
"другой план соединения: <screen>\n"
"EXPLAIN SELECT *\n"
"FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                        QUERY PLAN\n"
"------------------------------------------------------------------------------------------\n"
" Hash Join  (cost=230.47..713.98 rows=101 width=488)\n"
"   Hash Cond: (t2.unique2 = t1.unique2)\n"
"   -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244)\n"
"   -&gt;  Hash  (cost=229.20..229.20 rows=101 width=244)\n"
"         -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.07..229.20 rows=101 "
"width=244)\n"
"               Recheck Cond: (unique1 &lt; 100)\n"
"               -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 "
"rows=101 width=0)\n"
"                     Index Cond: (unique1 &lt; 100)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:469(para)
msgid ""
"Here, the planner has chosen to use a hash join, in which rows of one table "
"are entered into an in-memory hash table, after which the other table is "
"scanned and the hash table is probed for matches to each row. Again note how "
"the indentation reflects the plan structure: the bitmap scan on "
"<literal>tenk1</literal> is the input to the Hash node, which constructs the "
"hash table. That's then returned to the Hash Join node, which reads rows "
"from its outer child plan and searches the hash table for each one."
msgstr ""
"Здесь планировщик выбирает соединение по хешу, при котором строки одной "
"таблицы записываются в хеш-таблицу в памяти, после чего сканируется другая "
"таблица и для каждой её строки проверяется соответствие по хеш-таблице. "
"Обратите внимание, что и здесь отступы отражают структуру плана: результат "
"сканирования битовой карты по <literal>tenk1</literal> подаётся на вход узлу "
"Hash, который конструирует хеш-таблицу. Затем она передаётся узлу Hash Join, "
"который читает строки из узла внешнего потомка и проверяет их по этой хеш-"
"таблице."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:479(para)
msgid ""
"Another possible type of join is a merge join, illustrated here: <screen>\n"
"EXPLAIN SELECT *\n"
"FROM tenk1 t1, onek t2\n"
"WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                        QUERY PLAN\n"
"------------------------------------------------------------------------------------------\n"
" Merge Join  (cost=198.11..268.19 rows=10 width=488)\n"
"   Merge Cond: (t1.unique2 = t2.unique2)\n"
"   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.29..656.28 "
"rows=101 width=244)\n"
"         Filter: (unique1 &lt; 100)\n"
"   -&gt;  Sort  (cost=197.83..200.33 rows=1000 width=244)\n"
"         Sort Key: t2.unique2\n"
"         -&gt;  Seq Scan on onek t2  (cost=0.00..148.00 rows=1000 "
"width=244)\n"
"</screen>"
msgstr ""
"Ещё один возможный тип соединения &mdash; соединение слиянием: <screen>\n"
"EXPLAIN SELECT *\n"
"FROM tenk1 t1, onek t2\n"
"WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                        QUERY PLAN\n"
"------------------------------------------------------------------------------------------\n"
" Merge Join  (cost=198.11..268.19 rows=10 width=488)\n"
"   Merge Cond: (t1.unique2 = t2.unique2)\n"
"   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.29..656.28 "
"rows=101 width=244)\n"
"         Filter: (unique1 &lt; 100)\n"
"   -&gt;  Sort  (cost=197.83..200.33 rows=1000 width=244)\n"
"         Sort Key: t2.unique2\n"
"         -&gt;  Seq Scan on onek t2  (cost=0.00..148.00 rows=1000 "
"width=244)\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:499(para)
msgid ""
"Merge join requires its input data to be sorted on the join keys. In this "
"plan the <literal>tenk1</literal> data is sorted by using an index scan to "
"visit the rows in the correct order, but a sequential scan and sort is "
"preferred for <literal>onek</literal>, because there are many more rows to "
"be visited in that table. (Sequential-scan-and-sort frequently beats an "
"index scan for sorting many rows, because of the nonsequential disk access "
"required by the index scan.)"
msgstr ""
"Соединение слиянием требует, чтобы входные данные для него были "
"отсортированы по ключам соединения. В этом плане данные <literal>tenk1</"
"literal> сортируются после сканирования индекса, при котором все строки "
"просматриваются в правильном порядке, но таблицу <literal>onek</literal> "
"выгоднее оказывается последовательно просканировать и отсортировать, так как "
"в этой таблице нужно обработать гораздо больше строк. (Последовательное "
"сканирование и сортировка часто бывает быстрее сканирования индекса, когда "
"нужно отсортировать много строк, так как при сканировании по индексу "
"обращения к диску не упорядочены.)"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:509(para)
msgid ""
"One way to look at variant plans is to force the planner to disregard "
"whatever strategy it thought was the cheapest, using the enable/disable "
"flags described in <xref linkend=\"runtime-config-query-enable\"/>. (This is "
"a crude tool, but useful. See also <xref linkend=\"explicit-joins\"/>.) For "
"example, if we're unconvinced that sequential-scan-and-sort is the best way "
"to deal with table <literal>onek</literal> in the previous example, we could "
"try <screen>\n"
"SET enable_sort = off;\n"
"\n"
"EXPLAIN SELECT *\n"
"FROM tenk1 t1, onek t2\n"
"WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                        QUERY PLAN\n"
"------------------------------------------------------------------------------------------\n"
" Merge Join  (cost=0.56..292.65 rows=10 width=488)\n"
"   Merge Cond: (t1.unique2 = t2.unique2)\n"
"   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.29..656.28 "
"rows=101 width=244)\n"
"         Filter: (unique1 &lt; 100)\n"
"   -&gt;  Index Scan using onek_unique2 on onek t2  (cost=0.28..224.79 "
"rows=1000 width=244)\n"
"</screen> which shows that the planner thinks that sorting <literal>onek</"
"literal> by index-scanning is about 12% more expensive than sequential-scan-"
"and-sort. Of course, the next question is whether it's right about that. We "
"can investigate that using <command>EXPLAIN ANALYZE</command>, as discussed "
"below."
msgstr ""
"Один из способов посмотреть различные планы &mdash; принудить планировщик не "
"считать выбранную им стратегию самой выгодной, используя флаги, описанные в "
"<xref remap=\"6\" linkend=\"runtime-config-query-enable\"/>. (Это полезный, "
"хотя и грубый инструмент. См. также <xref remap=\"4\" linkend=\"explicit-"
"joins\"/>.) Например, если мы убеждены, что последовательное сканирование и "
"сортировка &mdash; не лучший способ обработать таблицу <literal>onek</"
"literal> в предыдущем примере, мы можем попробовать <screen>\n"
"SET enable_sort = off;\n"
"\n"
"EXPLAIN SELECT *\n"
"FROM tenk1 t1, onek t2\n"
"WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                        QUERY PLAN\n"
"------------------------------------------------------------------------------------------\n"
" Merge Join  (cost=0.56..292.65 rows=10 width=488)\n"
"   Merge Cond: (t1.unique2 = t2.unique2)\n"
"   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.29..656.28 "
"rows=101 width=244)\n"
"         Filter: (unique1 &lt; 100)\n"
"   -&gt;  Index Scan using onek_unique2 on onek t2  (cost=0.28..224.79 "
"rows=1000 width=244)\n"
"</screen> Видно, что планировщик считает сортировку <literal>onek</literal> "
"со сканированием индекса примерно на 12% дороже, чем последовательное "
"сканирование и сортировку. Конечно, может возникнуть вопрос &mdash; а "
"правильно ли это? Мы можем ответить на него, используя описанную ниже "
"команду <command>EXPLAIN ANALYZE</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:544(command)
msgid "EXPLAIN ANALYZE"
msgstr "EXPLAIN ANALYZE"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:546(para)
msgid ""
"It is possible to check the accuracy of the planner's estimates by using "
"<command>EXPLAIN</command>'s <literal>ANALYZE</literal> option. With this "
"option, <command>EXPLAIN</command> actually executes the query, and then "
"displays the true row counts and true run time accumulated within each plan "
"node, along with the same estimates that a plain <command>EXPLAIN</command> "
"shows. For example, we might get a result like this: <screen>\n"
"EXPLAIN ANALYZE SELECT *\n"
"FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                                           QUERY PLAN\n"
"---------------------------------------------------------------------------------------------------------------------------------\n"
" Nested Loop  (cost=4.65..118.62 rows=10 width=488) (actual "
"time=0.128..0.377 rows=10 loops=1)\n"
"   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244) "
"(actual time=0.057..0.121 rows=10 loops=1)\n"
"         Recheck Cond: (unique1 &lt; 10)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 "
"width=0) (actual time=0.024..0.024 rows=10 loops=1)\n"
"               Index Cond: (unique1 &lt; 10)\n"
"   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 "
"rows=1 width=244) (actual time=0.021..0.022 rows=1 loops=10)\n"
"         Index Cond: (unique2 = t1.unique2)\n"
" Planning time: 0.181 ms\n"
" Execution time: 0.501 ms\n"
"</screen> Note that the <quote>actual time</quote> values are in "
"milliseconds of real time, whereas the <literal>cost</literal> estimates are "
"expressed in arbitrary units; so they are unlikely to match up. The thing "
"that's usually most important to look for is whether the estimated row "
"counts are reasonably close to reality. In this example the estimates were "
"all dead-on, but that's quite unusual in practice."
msgstr ""
"Точность оценок планировщика можно проверить, используя команду "
"<command>EXPLAIN</command> с параметром <literal>ANALYZE</literal>. С этим "
"параметром <command>EXPLAIN</command> на самом деле выполняет запрос, а "
"затем выводит фактическое число строк и время выполнения, накопленное в "
"каждом узле плана, вместе с теми же оценками, что выдаёт обычная команда "
"<command>EXPLAIN</command>. Например, мы можем получить примерно такой "
"результат: <screen>\n"
"EXPLAIN ANALYZE SELECT *\n"
"FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                                           QUERY PLAN\n"
"---------------------------------------------------------------------------------------------------------------------------------\n"
" Nested Loop  (cost=4.65..118.62 rows=10 width=488) (actual "
"time=0.128..0.377 rows=10 loops=1)\n"
"   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244) "
"(actual time=0.057..0.121 rows=10 loops=1)\n"
"         Recheck Cond: (unique1 &lt; 10)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 "
"width=0) (actual time=0.024..0.024 rows=10 loops=1)\n"
"               Index Cond: (unique1 &lt; 10)\n"
"   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.91 "
"rows=1 width=244) (actual time=0.021..0.022 rows=1 loops=10)\n"
"         Index Cond: (unique2 = t1.unique2)\n"
" Planning time: 0.181 ms\n"
" Execution time: 0.501 ms\n"
"</screen> Заметьте, что значения <quote>actual time</quote> (фактическое "
"время) приводятся в миллисекундах, тогда как оценки <literal>cost</literal> "
"(стоимость) выражаются в произвольных единицах, так что они вряд ли "
"совпадут. Обычно важнее определить, насколько приблизительная оценка числа "
"строк близка к действительности. В этом примере они в точности совпали, но "
"на практике так бывает редко."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:580(para)
msgid ""
"In some query plans, it is possible for a subplan node to be executed more "
"than once. For example, the inner index scan will be executed once per outer "
"row in the above nested-loop plan. In such cases, the <literal>loops</"
"literal> value reports the total number of executions of the node, and the "
"actual time and rows values shown are averages per-execution. This is done "
"to make the numbers comparable with the way that the cost estimates are "
"shown. Multiply by the <literal>loops</literal> value to get the total time "
"actually spent in the node. In the above example, we spent a total of 0.220 "
"milliseconds executing the index scans on <literal>tenk2</literal>."
msgstr ""
"В некоторых планах запросов некоторый внутренний узел может выполняться "
"неоднократно. Например, внутреннее сканирование индекса будет выполняться "
"для каждой внешней строки во вложенном цикле верхнего уровня. В таких "
"случаях значение <literal>loops</literal> (циклы) показывает, сколько всего "
"раз выполнялся этот узел, а фактическое время и число строк вычисляется как "
"среднее по всем итерациям. Это делается для того, чтобы полученные значения "
"можно было сравнить с выводимыми приблизительными оценками. Чтобы получить "
"общее время, затраченное на выполнение узла, время одной итерации нужно "
"умножить на значение <literal>loops</literal>. В показанном выше примере мы "
"потратили в общей сложности 0.220 мс на сканирование индекса в "
"<literal>tenk2</literal>."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:593(para)
msgid ""
"In some cases <command>EXPLAIN ANALYZE</command> shows additional execution "
"statistics beyond the plan node execution times and row counts. For example, "
"Sort and Hash nodes provide extra information: <screen>\n"
"EXPLAIN ANALYZE SELECT *\n"
"FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2 ORDER BY t1."
"fivethous;\n"
"\n"
"                                                                 QUERY PLAN\n"
"--------------------------------------------------------------------------------------------------------------------------------------------\n"
" Sort  (cost=717.34..717.59 rows=101 width=488) (actual time=7.761..7.774 "
"rows=100 loops=1)\n"
"   Sort Key: t1.fivethous\n"
"   Sort Method: quicksort  Memory: 77kB\n"
"   -&gt;  Hash Join  (cost=230.47..713.98 rows=101 width=488) (actual "
"time=0.711..7.427 rows=100 loops=1)\n"
"         Hash Cond: (t2.unique2 = t1.unique2)\n"
"         -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 "
"width=244) (actual time=0.007..2.583 rows=10000 loops=1)\n"
"         -&gt;  Hash  (cost=229.20..229.20 rows=101 width=244) (actual "
"time=0.659..0.659 rows=100 loops=1)\n"
"               Buckets: 1024  Batches: 1  Memory Usage: 28kB\n"
"               -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.07..229.20 "
"rows=101 width=244) (actual time=0.080..0.526 rows=100 loops=1)\n"
"                     Recheck Cond: (unique1 &lt; 100)\n"
"                     -&gt;  Bitmap Index Scan on tenk1_unique1  "
"(cost=0.00..5.04 rows=101 width=0) (actual time=0.049..0.049 rows=100 "
"loops=1)\n"
"                           Index Cond: (unique1 &lt; 100)\n"
" Planning time: 0.194 ms\n"
" Execution time: 8.008 ms\n"
"</screen> The Sort node shows the sort method used (in particular, whether "
"the sort was in-memory or on-disk) and the amount of memory or disk space "
"needed. The Hash node shows the number of hash buckets and batches as well "
"as the peak amount of memory used for the hash table. (If the number of "
"batches exceeds one, there will also be disk space usage involved, but that "
"is not shown.)"
msgstr ""
"В ряде случаев <command>EXPLAIN ANALYZE</command> выводит дополнительную "
"статистику по выполнению, включающую не только время выполнения узлов и "
"число строк. Для узлов Sort и Hash, например выводится следующая информация: "
"<screen>\n"
"EXPLAIN ANALYZE SELECT *\n"
"FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2 ORDER BY t1."
"fivethous;\n"
"\n"
"                                                                 QUERY PLAN\n"
"--------------------------------------------------------------------------------------------------------------------------------------------\n"
" Sort  (cost=717.34..717.59 rows=101 width=488) (actual time=7.761..7.774 "
"rows=100 loops=1)\n"
"   Sort Key: t1.fivethous\n"
"   Sort Method: quicksort  Memory: 77kB\n"
"   -&gt;  Hash Join  (cost=230.47..713.98 rows=101 width=488) (actual "
"time=0.711..7.427 rows=100 loops=1)\n"
"         Hash Cond: (t2.unique2 = t1.unique2)\n"
"         -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 "
"width=244) (actual time=0.007..2.583 rows=10000 loops=1)\n"
"         -&gt;  Hash  (cost=229.20..229.20 rows=101 width=244) (actual "
"time=0.659..0.659 rows=100 loops=1)\n"
"               Buckets: 1024  Batches: 1  Memory Usage: 28kB\n"
"               -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.07..229.20 "
"rows=101 width=244) (actual time=0.080..0.526 rows=100 loops=1)\n"
"                     Recheck Cond: (unique1 &lt; 100)\n"
"                     -&gt;  Bitmap Index Scan on tenk1_unique1  "
"(cost=0.00..5.04 rows=101 width=0) (actual time=0.049..0.049 rows=100 "
"loops=1)\n"
"                           Index Cond: (unique1 &lt; 100)\n"
" Planning time: 0.194 ms\n"
" Execution time: 8.008 ms\n"
"</screen> Для узла Sort показывается использованный метод и место сортировки "
"(в памяти или на диске), а также задействованный объём памяти. Для узла Hash "
"выводится число групп и пакетов хеша, а также максимальный объём, который "
"заняла в памяти хеш-таблица. (Если число пакетов больше одного, часть хеш-"
"таблицы будет выгружаться на диск и занимать какое-то пространство, но его "
"объём здесь не показывается.)"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:629(para)
msgid ""
"Another type of extra information is the number of rows removed by a filter "
"condition: <screen>\n"
"EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE ten &lt; 7;\n"
"\n"
"                                               QUERY PLAN\n"
"---------------------------------------------------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=7000 width=244) (actual "
"time=0.016..5.107 rows=7000 loops=1)\n"
"   Filter: (ten &lt; 7)\n"
"   Rows Removed by Filter: 3000\n"
" Planning time: 0.083 ms\n"
" Execution time: 5.905 ms\n"
"</screen> These counts can be particularly valuable for filter conditions "
"applied at join nodes. The <quote>Rows Removed</quote> line only appears "
"when at least one scanned row, or potential join pair in the case of a join "
"node, is rejected by the filter condition."
msgstr ""
"Другая полезная дополнительная информация &mdash; число строк, удалённых "
"условием фильтра: <screen>\n"
"EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE ten &lt; 7;\n"
"\n"
"                                               QUERY PLAN\n"
"---------------------------------------------------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=7000 width=244) (actual "
"time=0.016..5.107 rows=7000 loops=1)\n"
"   Filter: (ten &lt; 7)\n"
"   Rows Removed by Filter: 3000\n"
" Planning time: 0.083 ms\n"
" Execution time: 5.905 ms\n"
"</screen> Эти значения могут быть особенно ценны для условий фильтра, "
"применённых к узлам соединения. Строка <quote>Rows Removed</quote> "
"выводится, только когда условие фильтра отбрасывает минимум одну "
"просканированную строку или потенциальную пару соединения, если это узел "
"соединения."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:651(para)
msgid ""
"A case similar to filter conditions occurs with <quote>lossy</quote> index "
"scans. For example, consider this search for polygons containing a specific "
"point: <screen>\n"
"EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon "
"'(0.5,2.0)';\n"
"\n"
"                                              QUERY PLAN\n"
"------------------------------------------------------------------------------------------------------\n"
" Seq Scan on polygon_tbl  (cost=0.00..1.05 rows=1 width=32) (actual "
"time=0.044..0.044 rows=0 loops=1)\n"
"   Filter: (f1 @&gt; '((0.5,2))'::polygon)\n"
"   Rows Removed by Filter: 4\n"
" Planning time: 0.040 ms\n"
" Execution time: 0.083 ms\n"
"</screen> The planner thinks (quite correctly) that this sample table is too "
"small to bother with an index scan, so we have a plain sequential scan in "
"which all the rows got rejected by the filter condition. But if we force an "
"index scan to be used, we see: <screen>\n"
"SET enable_seqscan TO off;\n"
"\n"
"EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon "
"'(0.5,2.0)';\n"
"\n"
"                                                        QUERY PLAN\n"
"--------------------------------------------------------------------------------------------------------------------------\n"
" Index Scan using gpolygonind on polygon_tbl  (cost=0.13..8.15 rows=1 "
"width=32) (actual time=0.062..0.062 rows=0 loops=1)\n"
"   Index Cond: (f1 @&gt; '((0.5,2))'::polygon)\n"
"   Rows Removed by Index Recheck: 1\n"
" Planning time: 0.034 ms\n"
" Execution time: 0.144 ms\n"
"</screen> Here we can see that the index returned one candidate row, which "
"was then rejected by a recheck of the index condition. This happens because "
"a GiST index is <quote>lossy</quote> for polygon containment tests: it "
"actually returns the rows with polygons that overlap the target, and then we "
"have to do the exact containment test on those rows."
msgstr ""
"Похожую ситуацию можно наблюдать при сканировании <quote>неточного</quote> "
"индекса. Например, рассмотрим этот план поиска многоугольников, содержащих "
"указанную точку: <screen>\n"
"EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon "
"'(0.5,2.0)';\n"
"\n"
"                                              QUERY PLAN\n"
"------------------------------------------------------------------------------------------------------\n"
" Seq Scan on polygon_tbl  (cost=0.00..1.05 rows=1 width=32) (actual "
"time=0.044..0.044 rows=0 loops=1)\n"
"   Filter: (f1 @&gt; '((0.5,2))'::polygon)\n"
"   Rows Removed by Filter: 4\n"
" Planning time: 0.040 ms\n"
" Execution time: 0.083 ms\n"
"</screen> Планировщик полагает (и вполне справедливо), что таблица слишком "
"мала для сканирования по индексу, поэтому он выбирает последовательное "
"сканирование, при котором все строки отбрасываются условием фильтра. Но если "
"мы принудим его выбрать сканирование по индексу, мы получим: <screen>\n"
"SET enable_seqscan TO off;\n"
"\n"
"EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon "
"'(0.5,2.0)';\n"
"\n"
"                                                        QUERY PLAN\n"
"--------------------------------------------------------------------------------------------------------------------------\n"
" Index Scan using gpolygonind on polygon_tbl  (cost=0.13..8.15 rows=1 "
"width=32) (actual time=0.062..0.062 rows=0 loops=1)\n"
"   Index Cond: (f1 @&gt; '((0.5,2))'::polygon)\n"
"   Rows Removed by Index Recheck: 1\n"
" Planning time: 0.034 ms\n"
" Execution time: 0.144 ms\n"
"</screen> Здесь мы видим, что индекс вернул одну потенциально подходящую "
"строку, но затем она была отброшена при перепроверке условия индекса. Это "
"объясняется тем, что индекс GiST является <quote>неточным</quote> для "
"проверок включений многоугольников: фактически он возвращает строки с "
"многоугольниками, перекрывающими точку по координатам, а затем для этих "
"строк нужно выполнять точную проверку."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:694(para)
msgid ""
"<command>EXPLAIN</command> has a <literal>BUFFERS</literal> option that can "
"be used with <literal>ANALYZE</literal> to get even more run time "
"statistics: <screen>\n"
"EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND "
"unique2 &gt; 9000;\n"
"\n"
"                                                           QUERY PLAN\n"
"---------------------------------------------------------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244) (actual "
"time=0.323..0.342 rows=10 loops=1)\n"
"   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))\n"
"   Buffers: shared hit=15\n"
"   -&gt;  BitmapAnd  (cost=25.08..25.08 rows=10 width=0) (actual "
"time=0.309..0.309 rows=0 loops=1)\n"
"         Buffers: shared hit=7\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 "
"rows=101 width=0) (actual time=0.043..0.043 rows=100 loops=1)\n"
"               Index Cond: (unique1 &lt; 100)\n"
"               Buffers: shared hit=2\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 "
"rows=999 width=0) (actual time=0.227..0.227 rows=999 loops=1)\n"
"               Index Cond: (unique2 &gt; 9000)\n"
"               Buffers: shared hit=5\n"
" Planning time: 0.088 ms\n"
" Execution time: 0.423 ms\n"
"</screen> The numbers provided by <literal>BUFFERS</literal> help to "
"identify which parts of the query are the most I/O-intensive."
msgstr ""
"<command>EXPLAIN</command> принимает параметр <literal>BUFFERS</literal> "
"(который также можно применять с <literal>ANALYZE</literal>), включающий ещё "
"более подробную статистику выполнения запроса: <screen>\n"
"EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND "
"unique2 &gt; 9000;\n"
"\n"
"                                                           QUERY PLAN\n"
"---------------------------------------------------------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244) (actual "
"time=0.323..0.342 rows=10 loops=1)\n"
"   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))\n"
"   Buffers: shared hit=15\n"
"   -&gt;  BitmapAnd  (cost=25.08..25.08 rows=10 width=0) (actual "
"time=0.309..0.309 rows=0 loops=1)\n"
"         Buffers: shared hit=7\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 "
"rows=101 width=0) (actual time=0.043..0.043 rows=100 loops=1)\n"
"               Index Cond: (unique1 &lt; 100)\n"
"               Buffers: shared hit=2\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 "
"rows=999 width=0) (actual time=0.227..0.227 rows=999 loops=1)\n"
"               Index Cond: (unique2 &gt; 9000)\n"
"               Buffers: shared hit=5\n"
" Planning time: 0.088 ms\n"
" Execution time: 0.423 ms\n"
"</screen> Значения, которые выводятся с параметром <literal>BUFFERS</"
"literal>, помогают понять, на какие части запроса приходится большинство "
"операций ввода-вывода."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:722(para)
msgid ""
"Keep in mind that because <command>EXPLAIN ANALYZE</command> actually runs "
"the query, any side-effects will happen as usual, even though whatever "
"results the query might output are discarded in favor of printing the "
"<command>EXPLAIN</command> data. If you want to analyze a data-modifying "
"query without changing your tables, you can roll the command back "
"afterwards, for example: <screen>\n"
"BEGIN;\n"
"\n"
"EXPLAIN ANALYZE UPDATE tenk1 SET hundred = hundred + 1 WHERE unique1 &lt; "
"100;\n"
"\n"
"                                                           QUERY PLAN\n"
"--------------------------------------------------------------------------------------------------------------------------------\n"
" Update on tenk1  (cost=5.07..229.46 rows=101 width=250) (actual "
"time=14.628..14.628 rows=0 loops=1)\n"
"   -&gt;  Bitmap Heap Scan on tenk1  (cost=5.07..229.46 rows=101 width=250) "
"(actual time=0.101..0.439 rows=100 loops=1)\n"
"         Recheck Cond: (unique1 &lt; 100)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 "
"rows=101 width=0) (actual time=0.043..0.043 rows=100 loops=1)\n"
"               Index Cond: (unique1 &lt; 100)\n"
" Planning time: 0.079 ms\n"
" Execution time: 14.727 ms\n"
"\n"
"ROLLBACK;\n"
"</screen>"
msgstr ""
"Не забывайте, что <command>EXPLAIN ANALYZE</command> действительно выполняет "
"запрос, хотя его результаты могут не показываться, а заменяться выводом "
"команды <command>EXPLAIN</command>. Поэтому при таком анализе возможны "
"побочные эффекты. Если вы хотите проанализировать запрос, изменяющий данные, "
"но при этом сохранить прежние данные таблицы, вы можете откатить транзакцию "
"после запроса: <screen>\n"
"BEGIN;\n"
"\n"
"EXPLAIN ANALYZE UPDATE tenk1 SET hundred = hundred + 1 WHERE unique1 &lt; "
"100;\n"
"\n"
"                                                           QUERY PLAN\n"
"--------------------------------------------------------------------------------------------------------------------------------\n"
" Update on tenk1  (cost=5.07..229.46 rows=101 width=250) (actual "
"time=14.628..14.628 rows=0 loops=1)\n"
"   -&gt;  Bitmap Heap Scan on tenk1  (cost=5.07..229.46 rows=101 width=250) "
"(actual time=0.101..0.439 rows=100 loops=1)\n"
"         Recheck Cond: (unique1 &lt; 100)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 "
"rows=101 width=0) (actual time=0.043..0.043 rows=100 loops=1)\n"
"               Index Cond: (unique1 &lt; 100)\n"
" Planning time: 0.079 ms\n"
" Execution time: 14.727 ms\n"
"\n"
"ROLLBACK;\n"
"</screen>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:749(para)
msgid ""
"As seen in this example, when the query is an <command>INSERT</command>, "
"<command>UPDATE</command>, or <command>DELETE</command> command, the actual "
"work of applying the table changes is done by a top-level Insert, Update, or "
"Delete plan node. The plan nodes underneath this node perform the work of "
"locating the old rows and/or computing the new data. So above, we see the "
"same sort of bitmap table scan we've seen already, and its output is fed to "
"an Update node that stores the updated rows. It's worth noting that although "
"the data-modifying node can take a considerable amount of run time (here, "
"it's consuming the lion's share of the time), the planner does not currently "
"add anything to the cost estimates to account for that work. That's because "
"the work to be done is the same for every correct query plan, so it doesn't "
"affect planning decisions."
msgstr ""
"Как показано в этом примере, когда выполняется команда <command>INSERT</"
"command>, <command>UPDATE</command> или <command>DELETE</command>, "
"собственно изменение данных в таблице происходит в узле верхнего уровня "
"Insert, Update или Delete. Узлы плана более низких уровней выполняют работу "
"по нахождению старых строк и/или вычислению новых данных. Поэтому вверху мы "
"видим тот же тип сканирования битовой карты, что и раньше, только теперь его "
"вывод подаётся узлу Update, который сохраняет изменённые строки. Стоит "
"отметить, что узел, изменяющий данные, может выполняться значительное время "
"(в данном случае это составляет львиную часть всего времени), но планировщик "
"не учитывает эту работу в оценке общей стоимости. Это связано с тем, что эта "
"работа будет одинаковой при любом правильном плане запроса, и поэтому на "
"выбор плана она не влияет."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:765(para)
msgid ""
"When an <command>UPDATE</command> or <command>DELETE</command> command "
"affects an inheritance hierarchy, the output might look like this: <screen>\n"
"EXPLAIN UPDATE parent SET f2 = f2 + 1 WHERE f1 = 101;\n"
"                                    QUERY PLAN\n"
"-----------------------------------------------------------------------------------\n"
" Update on parent  (cost=0.00..24.53 rows=4 width=14)\n"
"   Update on parent\n"
"   Update on child1\n"
"   Update on child2\n"
"   Update on child3\n"
"   -&gt;  Seq Scan on parent  (cost=0.00..0.00 rows=1 width=14)\n"
"         Filter: (f1 = 101)\n"
"   -&gt;  Index Scan using child1_f1_key on child1  (cost=0.15..8.17 rows=1 "
"width=14)\n"
"         Index Cond: (f1 = 101)\n"
"   -&gt;  Index Scan using child2_f1_key on child2  (cost=0.15..8.17 rows=1 "
"width=14)\n"
"         Index Cond: (f1 = 101)\n"
"   -&gt;  Index Scan using child3_f1_key on child3  (cost=0.15..8.17 rows=1 "
"width=14)\n"
"         Index Cond: (f1 = 101)\n"
"</screen> In this example the Update node needs to consider three child "
"tables as well as the originally-mentioned parent table. So there are four "
"input scanning subplans, one per table. For clarity, the Update node is "
"annotated to show the specific target tables that will be updated, in the "
"same order as the corresponding subplans. (These annotations are new as of "
"<productname>PostgreSQL</productname> 9.5; in prior versions the reader had "
"to intuit the target tables by inspecting the subplans.)"
msgstr ""
"Когда команда <command>UPDATE</command> или <command>DELETE</command> имеет "
"дело с иерархией наследования, вывод может быть таким: <screen>\n"
"EXPLAIN UPDATE parent SET f2 = f2 + 1 WHERE f1 = 101;\n"
"                                    QUERY PLAN\n"
"-----------------------------------------------------------------------------------\n"
" Update on parent  (cost=0.00..24.53 rows=4 width=14)\n"
"   Update on parent\n"
"   Update on child1\n"
"   Update on child2\n"
"   Update on child3\n"
"   -&gt;  Seq Scan on parent  (cost=0.00..0.00 rows=1 width=14)\n"
"         Filter: (f1 = 101)\n"
"   -&gt;  Index Scan using child1_f1_key on child1  (cost=0.15..8.17 rows=1 "
"width=14)\n"
"         Index Cond: (f1 = 101)\n"
"   -&gt;  Index Scan using child2_f1_key on child2  (cost=0.15..8.17 rows=1 "
"width=14)\n"
"         Index Cond: (f1 = 101)\n"
"   -&gt;  Index Scan using child3_f1_key on child3  (cost=0.15..8.17 rows=1 "
"width=14)\n"
"         Index Cond: (f1 = 101)\n"
"</screen> В этом примере узлу Update помимо изначально упомянутой в запросе "
"родительской таблицы нужно обработать ещё три дочерние таблицы. Поэтому "
"формируются четыре плана сканирования, по одному для каждой таблицы. Ясности "
"ради для узла Update добавляется примечание, показывающее, какие именно "
"таблицы будут изменяться, в том же порядке, в каком они идут в "
"соответствующих внутренних планах. (Эти примечания появились в "
"<productname>PostgreSQL</productname> 9.5; до этого о целевых таблицах "
"приходилось догадываться, изучая внутренние планы узла.)"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:797(para)
msgid ""
"The <literal>Planning time</literal> shown by <command>EXPLAIN ANALYZE</"
"command> is the time it took to generate the query plan from the parsed "
"query and optimize it. It does not include parsing or rewriting."
msgstr ""
"Под заголовком <literal>Planning time</literal> (Время планирования) команда "
"<command>EXPLAIN ANALYZE</command> выводит время, затраченное на построение "
"плана запроса из разобранного запроса и его оптимизацию. Время собственно "
"разбора или перезаписи запроса в него не включается."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:803(para)
msgid ""
"The <literal>Execution time</literal> shown by <command>EXPLAIN ANALYZE</"
"command> includes executor start-up and shut-down time, as well as the time "
"to run any triggers that are fired, but it does not include parsing, "
"rewriting, or planning time. Time spent executing <literal>BEFORE</literal> "
"triggers, if any, is included in the time for the related Insert, Update, or "
"Delete node; but time spent executing <literal>AFTER</literal> triggers is "
"not counted there because <literal>AFTER</literal> triggers are fired after "
"completion of the whole plan. The total time spent in each trigger (either "
"<literal>BEFORE</literal> or <literal>AFTER</literal>) is also shown "
"separately. Note that deferred constraint triggers will not be executed "
"until end of transaction and are thus not considered at all by "
"<command>EXPLAIN ANALYZE</command>."
msgstr ""
"Значение <literal>Execution time</literal> (Время выполнения), выводимое "
"командой <command>EXPLAIN ANALYZE</command>, включает продолжительность "
"запуска и остановки исполнителя запроса, а также время выполнения всех "
"сработавших триггеров, но не включает время разбора, перезаписи и "
"планирования запроса. Время, потраченное на выполнение триггеров "
"<literal>BEFORE</literal> (если такие имеются) включается во время "
"соответствующих узлов Insert, Update или Delete node; но время выполнения "
"триггеров <literal>AFTER</literal> не учитывается, так как триггеры "
"<literal>AFTER</literal> срабатывают после выполнения всего плана. Общее "
"время, проведённое в каждом триггере (<literal>BEFORE</literal> или "
"<literal>AFTER</literal>), также выводится отдельно. Заметьте, что триггеры "
"отложенных ограничений выполняются только в конце транзакции, так что время "
"их выполнения <command>EXPLAIN ANALYZE</command> не учитывает."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:822(title)
msgid "Caveats"
msgstr "Ограничения"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:824(para)
msgid ""
"There are two significant ways in which run times measured by "
"<command>EXPLAIN ANALYZE</command> can deviate from normal execution of the "
"same query. First, since no output rows are delivered to the client, network "
"transmission costs and I/O conversion costs are not included. Second, the "
"measurement overhead added by <command>EXPLAIN ANALYZE</command> can be "
"significant, especially on machines with slow <function>gettimeofday()</"
"function> operating-system calls. You can use the <xref linkend="
"\"pgtesttiming\"/> tool to measure the overhead of timing on your system."
msgstr ""
"Время выполнения, измеренное командой <command>EXPLAIN ANALYZE</command>, "
"может значительно отличаться от времени выполнения того же запроса в обычном "
"режиме. Тому есть две основных причины. Во-первых, так как при анализе "
"никакие строки результата не передаются клиенту, время ввода/вывода и "
"передачи по сети не учитывается. Во-вторых, может быть существенной "
"дополнительная нагрузка, связанная с функциями измерений <command>EXPLAIN "
"ANALYZE</command>, особенно в системах, где вызов <function>gettimeofday()</"
"function> выполняется медленно. Для измерения этой нагрузки вы можете "
"воспользоваться утилитой <xref linkend=\"pgtesttiming\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:836(para)
msgid ""
"<command>EXPLAIN</command> results should not be extrapolated to situations "
"much different from the one you are actually testing; for example, results "
"on a toy-sized table cannot be assumed to apply to large tables. The "
"planner's cost estimates are not linear and so it might choose a different "
"plan for a larger or smaller table. An extreme example is that on a table "
"that only occupies one disk page, you'll nearly always get a sequential scan "
"plan whether indexes are available or not. The planner realizes that it's "
"going to take one disk page read to process the table in any case, so "
"there's no value in expending additional page reads to look at an index. (We "
"saw this happening in the <literal>polygon_tbl</literal> example above.)"
msgstr ""
"Результаты <command>EXPLAIN</command> не следует распространять на ситуации, "
"значительно отличающиеся от тех, в которых вы проводите тестирование. В "
"частности, не следует полагать, что выводы, полученные для игрушечной "
"таблицы, будут применимы и для настоящих больших таблиц. Оценки стоимости "
"нелинейны и планировщик может выбирать разные планы в зависимости от размера "
"таблицы. Например, в крайнем случае вся таблица может уместиться в одну "
"страницу диска, и тогда вы почти наверняка получите план последовательного "
"сканирования, независимо от того, есть у неё и индексы или нет. Планировщик "
"понимает, что для обработки таблицы ему в любом случае потребуется прочитать "
"одну страницу, так что нет никакого смысла обращаться к ещё одной странице "
"за индексом. (Мы наблюдали это в показанном выше примере с "
"<literal>polygon_tbl</literal>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:850(para)
msgid ""
"There are cases in which the actual and estimated values won't match up "
"well, but nothing is really wrong. One such case occurs when plan node "
"execution is stopped short by a <literal>LIMIT</literal> or similar effect. "
"For example, in the <literal>LIMIT</literal> query we used before, <screen>\n"
"EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; "
"9000 LIMIT 2;\n"
"\n"
"                                                          QUERY PLAN\n"
"-------------------------------------------------------------------------------------------------------------------------------\n"
" Limit  (cost=0.29..14.71 rows=2 width=244) (actual time=0.177..0.249 rows=2 "
"loops=1)\n"
"   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..72.42 rows=10 "
"width=244) (actual time=0.174..0.244 rows=2 loops=1)\n"
"         Index Cond: (unique2 &gt; 9000)\n"
"         Filter: (unique1 &lt; 100)\n"
"         Rows Removed by Filter: 287\n"
" Planning time: 0.096 ms\n"
" Execution time: 0.336 ms\n"
"</screen> the estimated cost and row count for the Index Scan node are shown "
"as though it were run to completion. But in reality the Limit node stopped "
"requesting rows after it got two, so the actual row count is only 2 and the "
"run time is less than the cost estimate would suggest. This is not an "
"estimation error, only a discrepancy in the way the estimates and true "
"values are displayed."
msgstr ""
"Бывает, что фактическое и приближённо оценённое значения не совпадают, но в "
"этом нет ничего плохого. Например, это возможно, когда выполнение плана узла "
"прекращается преждевременно из-за указания <literal>LIMIT</literal> или "
"подобного эффекта. Например, для запроса с <literal>LIMIT</literal>, который "
"мы пробовали раньше: <screen>\n"
"EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; "
"9000 LIMIT 2;\n"
"\n"
"                                                          QUERY PLAN\n"
"-------------------------------------------------------------------------------------------------------------------------------\n"
" Limit  (cost=0.29..14.71 rows=2 width=244) (actual time=0.177..0.249 rows=2 "
"loops=1)\n"
"   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..72.42 rows=10 "
"width=244) (actual time=0.174..0.244 rows=2 loops=1)\n"
"         Index Cond: (unique2 &gt; 9000)\n"
"         Filter: (unique1 &lt; 100)\n"
"         Rows Removed by Filter: 287\n"
" Planning time: 0.096 ms\n"
" Execution time: 0.336 ms\n"
"</screen> Оценки стоимости и числа строк для узла Index Scan показываются в "
"предположении, что этот узел будет выполняться до конца. Но в "
"действительности узел Limit прекратил запрашивать строки, как только получил "
"первые две, так что фактическое число строк равно 2 и время выполнения "
"запроса будет меньше, чем рассчитал планировщик. Но это не ошибка, а просто "
"следствие того, что оценённые и фактические значения выводятся по-разному."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:878(para)
msgid ""
"Merge joins also have measurement artifacts that can confuse the unwary. A "
"merge join will stop reading one input if it's exhausted the other input and "
"the next key value in the one input is greater than the last key value of "
"the other input; in such a case there can be no more matches and so no need "
"to scan the rest of the first input. This results in not reading all of one "
"child, with results like those mentioned for <literal>LIMIT</literal>. Also, "
"if the outer (first) child contains rows with duplicate key values, the "
"inner (second) child is backed up and rescanned for the portion of its rows "
"matching that key value. <command>EXPLAIN ANALYZE</command> counts these "
"repeated emissions of the same inner rows as if they were real additional "
"rows. When there are many outer duplicates, the reported actual row count "
"for the inner child plan node can be significantly larger than the number of "
"rows that are actually in the inner relation."
msgstr ""
"Соединения слиянием также имеют свои особенности, которые могут ввести в "
"заблуждение. Соединение слиянием прекратит читать один источник данных, если "
"второй будет прочитан до конца, а следующее значение ключа в первом больше "
"последнего значения во втором. В этом случае пар строк больше не будет, так "
"что сканировать первый источник дальше нет смысла. В результате будут "
"прочитаны не все строки одного потомка и вы получите тот же эффект, что и с "
"<literal>LIMIT</literal>. Кроме того, если внешний (первый) потомок содержит "
"строки с повторяющимися значениями ключа, внутренний (второй) потомок "
"сдвинется назад и повторно выдаст строки для этого значения ключа. "
"<command>EXPLAIN ANALYZE</command> считает эти повторяющиеся строки, как "
"если бы это действительно были дополнительные строки внутреннего источника. "
"Когда во внешнем узле много таких повторений ключей, фактическое число "
"строк, подсчитанное для внутреннего узла, может значительно превышать число "
"строк в соответствующей таблице."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:894(para)
msgid ""
"BitmapAnd and BitmapOr nodes always report their actual row counts as zero, "
"due to implementation limitations."
msgstr ""
"Для узлов BitmapAnd (Логическое произведение битовых карт) и BitmapOr "
"(Логическое сложение битовых карт) фактическое число строк всегда равно 0 из-"
"за ограничений реализации."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:903(title)
msgid "Statistics Used by the Planner"
msgstr "Статистика, используемая планировщиком"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:905(indexterm) perform.xml:1054(indexterm)
msgid "<primary>statistics</primary> <secondary>of the planner</secondary>"
msgstr "<primary>статистика</primary> <secondary>планировщика</secondary>"

#. +> REL_10
#: perform.xml:911(title)
msgid "Single-Column Statistics"
msgstr "Статистика по одному столбцу"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:912(para)
msgid ""
"As we saw in the previous section, the query planner needs to estimate the "
"number of rows retrieved by a query in order to make good choices of query "
"plans. This section provides a quick look at the statistics that the system "
"uses for these estimates."
msgstr ""
"Как было показано в предыдущем разделе, планировщик запросов должен оценить "
"число строк, возвращаемых запросов, чтобы сделать правильный выбор в "
"отношении плана запроса. В этом разделе кратко описывается статистика, "
"которую использует система для этих оценок."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:919(para)
msgid ""
"One component of the statistics is the total number of entries in each table "
"and index, as well as the number of disk blocks occupied by each table and "
"index. This information is kept in the table <link linkend=\"catalog-pg-class"
"\"><structname>pg_class</structname></link>, in the columns "
"<structfield>reltuples</structfield> and <structfield>relpages</"
"structfield>. We can look at it with queries similar to this one: <screen>\n"
"SELECT relname, relkind, reltuples, relpages\n"
"FROM pg_class\n"
"WHERE relname LIKE 'tenk1%';\n"
"\n"
"       relname        | relkind | reltuples | relpages\n"
"----------------------+---------+-----------+----------\n"
" tenk1                | r       |     10000 |      358\n"
" tenk1_hundred        | i       |     10000 |       30\n"
" tenk1_thous_tenthous | i       |     10000 |       30\n"
" tenk1_unique1        | i       |     10000 |       30\n"
" tenk1_unique2        | i       |     10000 |       30\n"
"(5 rows)\n"
"</screen> Here we can see that <structname>tenk1</structname> contains 10000 "
"rows, as do its indexes, but the indexes are (unsurprisingly) much smaller "
"than the table."
msgstr ""
"В частности, статистика включает общее число записей в каждой таблице и "
"индексе, а также число дисковых блоков, которые они занимают. Эта информация "
"содержится в таблице <link linkend=\"catalog-pg-class"
"\"><structname>pg_class</structname></link>, в столбцах "
"<structfield>reltuples</structfield> и <structfield>relpages</structfield>. "
"Получить её можно, например так: <screen>\n"
"SELECT relname, relkind, reltuples, relpages\n"
"FROM pg_class\n"
"WHERE relname LIKE 'tenk1%';\n"
"\n"
"       relname        | relkind | reltuples | relpages\n"
"----------------------+---------+-----------+----------\n"
" tenk1                | r       |     10000 |      358\n"
" tenk1_hundred        | i       |     10000 |       30\n"
" tenk1_thous_tenthous | i       |     10000 |       30\n"
" tenk1_unique1        | i       |     10000 |       30\n"
" tenk1_unique2        | i       |     10000 |       30\n"
"(5 rows)\n"
"</screen> Здесь мы видим, что <structname>tenk1</structname> содержит 10000 "
"строк данных и столько же строк в индексах (что неудивительно), но объём "
"индексов гораздо меньше таблицы."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:948(para)
msgid ""
"For efficiency reasons, <structfield>reltuples</structfield> and "
"<structfield>relpages</structfield> are not updated on-the-fly, and so they "
"usually contain somewhat out-of-date values. They are updated by "
"<command>VACUUM</command>, <command>ANALYZE</command>, and a few DDL "
"commands such as <command>CREATE INDEX</command>. A <command>VACUUM</"
"command> or <command>ANALYZE</command> operation that does not scan the "
"entire table (which is commonly the case) will incrementally update the "
"<structfield>reltuples</structfield> count on the basis of the part of the "
"table it did scan, resulting in an approximate value. In any case, the "
"planner will scale the values it finds in <structname>pg_class</structname> "
"to match the current physical table size, thus obtaining a closer "
"approximation."
msgstr ""
"Для большей эффективности <structfield>reltuples</structfield> и "
"<structfield>relpages</structfield> не пересчитываются &laquo;на "
"лету&raquo;, так что они обычно содержат несколько устаревшие значения. Их "
"обновляют команды <command>VACUUM</command>, <command>ANALYZE</command> и "
"несколько команд DDL, такие как <command>CREATE INDEX</command>. "
"<command>VACUUM</command> и <command>ANALYZE</command> могут не сканировать "
"всю таблицу (и обычно так и делают), а только вычислить приращение "
"<structfield>reltuples</structfield> по части таблицы, так что результат "
"остаётся приблизительным. В любом случае планировщик пересчитывает значения, "
"полученные из <structname>pg_class</structname>, в пропорции к текущему "
"физическому размеру таблицы и таким образом уточняет приближение."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:964(indexterm)
msgid "<primary>pg_statistic</primary>"
msgstr "<primary>pg_statistic</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:968(para)
msgid ""
"Most queries retrieve only a fraction of the rows in a table, due to "
"<literal>WHERE</literal> clauses that restrict the rows to be examined. The "
"planner thus needs to make an estimate of the <firstterm>selectivity</"
"firstterm> of <literal>WHERE</literal> clauses, that is, the fraction of "
"rows that match each condition in the <literal>WHERE</literal> clause. The "
"information used for this task is stored in the <link linkend=\"catalog-pg-"
"statistic\"><structname>pg_statistic</structname></link> system catalog. "
"Entries in <structname>pg_statistic</structname> are updated by the "
"<command>ANALYZE</command> and <command>VACUUM ANALYZE</command> commands, "
"and are always approximate even when freshly updated."
msgstr ""
"Большинство запросов возвращают не все строки таблицы, а только немногие из "
"них, ограниченные условиями <literal>WHERE</literal>. Поэтому планировщику "
"нужно оценить <firstterm>избирательность</firstterm> условий <literal>WHERE</"
"literal>, то есть определить, какой процент строк будет соответствовать "
"каждому условию в предложении <literal>WHERE</literal>. Нужная для этого "
"информация хранится в системном каталоге <link linkend=\"catalog-pg-statistic"
"\"><structname>pg_statistic</structname></link>. Значения в "
"<structname>pg_statistic</structname> обновляются командами "
"<command>ANALYZE</command> и <command>VACUUM ANALYZE</command> и никогда не "
"бывают точными, даже сразу после обновления."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:983(indexterm)
msgid "<primary>pg_stats</primary>"
msgstr "<primary>pg_stats</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:987(para)
msgid ""
"Rather than look at <structname>pg_statistic</structname> directly, it's "
"better to look at its view <link linkend=\"view-pg-stats"
"\"><structname>pg_stats</structname></link> when examining the statistics "
"manually. <structname>pg_stats</structname> is designed to be more easily "
"readable. Furthermore, <structname>pg_stats</structname> is readable by all, "
"whereas <structname>pg_statistic</structname> is only readable by a "
"superuser. (This prevents unprivileged users from learning something about "
"the contents of other people's tables from the statistics. The "
"<structname>pg_stats</structname> view is restricted to show only rows about "
"tables that the current user can read.) For example, we might do: <screen>\n"
"SELECT attname, inherited, n_distinct,\n"
"       array_to_string(most_common_vals, E'\\n') as most_common_vals\n"
"FROM pg_stats\n"
"WHERE tablename = 'road';\n"
"\n"
" attname | inherited | n_distinct |          most_common_vals\n"
"---------+-----------+------------+------------------------------------\n"
" name    | f         |  -0.363388 | I- 580                        Ramp+\n"
"         |           |            | I- 880                        Ramp+\n"
"         |           |            | Sp Railroad                       +\n"
"         |           |            | I- 580                            +\n"
"         |           |            | I- 680                        Ramp\n"
" name    | t         |  -0.284859 | I- 880                        Ramp+\n"
"         |           |            | I- 580                        Ramp+\n"
"         |           |            | I- 680                        Ramp+\n"
"         |           |            | I- 580                            +\n"
"         |           |            | State Hwy 13                  Ramp\n"
"(2 rows)\n"
"</screen> Note that two rows are displayed for the same column, one "
"corresponding to the complete inheritance hierarchy starting at the "
"<literal>road</literal> table (<literal>inherited</literal>=<literal>t</"
"literal>), and another one including only the <literal>road</literal> table "
"itself (<literal>inherited</literal>=<literal>f</literal>)."
msgstr ""
"Для исследования статистики лучше обращаться не непосредственно к таблице "
"<structname>pg_statistic</structname>, а к представлению <link linkend="
"\"view-pg-stats\"><structname>pg_stats</structname></link>, предназначенному "
"для облегчения восприятия этой информации. Кроме того, представление "
"<structname>pg_stats</structname> доступно для чтения всем, тогда как "
"<structname>pg_statistic</structname> &mdash; только суперпользователям. "
"(Это сделано для того, чтобы непривилегированные пользователи не могли "
"ничего узнать о содержимом таблиц других людей из статистики. Представление "
"<structname>pg_stats</structname> устроено так, что оно показывает строки "
"только для тех таблиц, которые может читать данный пользователь.) Например, "
"мы можем выполнить: <screen>\n"
"SELECT attname, inherited, n_distinct,\n"
"       array_to_string(most_common_vals, E'\\n') as most_common_vals\n"
"FROM pg_stats\n"
"WHERE tablename = 'road';\n"
"\n"
" attname | inherited | n_distinct |          most_common_vals\n"
"---------+-----------+------------+------------------------------------\n"
" name    | f         |  -0.363388 | I- 580                        Ramp+\n"
"         |           |            | I- 880                        Ramp+\n"
"         |           |            | Sp Railroad                       +\n"
"         |           |            | I- 580                            +\n"
"         |           |            | I- 680                        Ramp\n"
" name    | t         |  -0.284859 | I- 880                        Ramp+\n"
"         |           |            | I- 580                        Ramp+\n"
"         |           |            | I- 680                        Ramp+\n"
"         |           |            | I- 580                            +\n"
"         |           |            | State Hwy 13                  Ramp\n"
"(2 rows)\n"
"</screen> Заметьте, что для одного столбца показываются две строки: одна "
"соответствует полной иерархии наследования, построенной для таблицы "
"<literal>road</literal> (<literal>inherited</literal>=<literal>t</literal>), "
"и другая относится непосредственно к таблице <literal>road</literal> "
"(<literal>inherited</literal>=<literal>f</literal>)."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1029(para)
msgid ""
"The amount of information stored in <structname>pg_statistic</structname> by "
"<command>ANALYZE</command>, in particular the maximum number of entries in "
"the <structfield>most_common_vals</structfield> and "
"<structfield>histogram_bounds</structfield> arrays for each column, can be "
"set on a column-by-column basis using the <command>ALTER TABLE SET "
"STATISTICS</command> command, or globally by setting the <xref linkend=\"guc-"
"default-statistics-target\"/> configuration variable. The default limit is "
"presently 100 entries. Raising the limit might allow more accurate planner "
"estimates to be made, particularly for columns with irregular data "
"distributions, at the price of consuming more space in "
"<structname>pg_statistic</structname> and slightly more time to compute the "
"estimates. Conversely, a lower limit might be sufficient for columns with "
"simple data distributions."
msgstr ""
"Объём информации, сохраняемой в <structname>pg_statistic</structname> "
"командой <command>ANALYZE</command>, в частности максимальное число записей "
"в массивах <structfield>most_common_vals</structfield> (самые популярные "
"значения) и <structfield>histogram_bounds</structfield> (границы гистограмм) "
"для каждого столбца, можно ограничить на уровне столбцов с помощью команды "
"<command>ALTER TABLE SET STATISTICS</command> или глобально, установив "
"параметр конфигурации <xref linkend=\"guc-default-statistics-target\"/>. В "
"настоящее время ограничение по умолчанию равно 100 записям. Увеличивая этот "
"предел, можно увеличить точность оценок планировщика, особенно для столбцов "
"с нерегулярным распределением данных, ценой большего объёма "
"<structname>pg_statistic</structname> и, возможно, увеличения времени "
"расчёта этой статистики. И напротив, для столбцов с простым распределением "
"данных может быть достаточно меньшего предела."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1045(para)
msgid ""
"Further details about the planner's use of statistics can be found in <xref "
"linkend=\"planner-stats-details\"/>."
msgstr ""
"Подробнее использование статистики планировщиком описывается в <xref remap="
"\"6\" linkend=\"planner-stats-details\"/>."

#. +> REL_10
#: perform.xml:1052(title)
msgid "Extended Statistics"
msgstr "Расширенная статистика"

#. +> REL_10
#: perform.xml:1059(indexterm)
msgid ""
"<primary>correlation</primary> <secondary>in the query planner</secondary>"
msgstr ""
"<primary>корреляция</primary> <secondary>в планировщике запросов</secondary>"

#. +> REL_10
#: perform.xml:1064(indexterm)
msgid "<primary>pg_statistic_ext</primary>"
msgstr "<primary>pg_statistic_ext</primary>"

#. +> REL_10
#: perform.xml:1068(para)
msgid ""
"It is common to see slow queries running bad execution plans because "
"multiple columns used in the query clauses are correlated. The planner "
"normally assumes that multiple conditions are independent of each other, an "
"assumption that does not hold when column values are correlated. Regular "
"statistics, because of their per-individual-column nature, cannot capture "
"any knowledge about cross-column correlation. However, "
"<productname>PostgreSQL</productname> has the ability to compute "
"<firstterm>multivariate statistics</firstterm>, which can capture such "
"information."
msgstr ""
"Часто наблюдается картина, когда медленное выполнение запросов объясняется "
"плохим выбором плана из-за того, что несколько столбцов, фигурирующих в "
"условиях запроса, оказываются связанными. Обычно планировщик полагает, что "
"несколько условий не зависят друг от друга, а это предположение оказывается "
"неверным, когда значения этих столбцов коррелируют. Обычная статистика, "
"которая по природе своей строится по отдельным столбцам, не может выявить "
"корреляции между столбцами. Однако <productname>PostgreSQL</productname> "
"имеет возможность вычислять <firstterm>многовариантную статистику</"
"firstterm>, которая может собирать необходимую для этого информацию."

#. +> REL_10
#: perform.xml:1081(para)
msgid ""
"Because the number of possible column combinations is very large, it's "
"impractical to compute multivariate statistics automatically. Instead, "
"<firstterm>extended statistics objects</firstterm>, more often called just "
"<firstterm>statistics objects</firstterm>, can be created to instruct the "
"server to obtain statistics across interesting sets of columns."
msgstr ""
"Так как число возможных комбинаций столбцов очень велико, автоматически "
"вычислять многовариантную статистику непрактично. Вместо этого можно создать "
"<firstterm>объекты расширенной статистики</firstterm>, чаще называемые "
"просто <firstterm>объектами статистики</firstterm>, чтобы сервер собирал "
"статистику по некоторым наборам столбцов, представляющим интерес."

#. +> REL_10
#: perform.xml:1089(para)
msgid ""
"Statistics objects are created using <xref linkend=\"sql-createstatistics\"/"
">, which see for more details. Creation of such an object merely creates a "
"catalog entry expressing interest in the statistics. Actual data collection "
"is performed by <command>ANALYZE</command> (either a manual command, or "
"background auto-analyze). The collected values can be examined in the <link "
"linkend=\"catalog-pg-statistic-ext\"><structname>pg_statistic_ext</"
"structname></link> catalog."
msgstr ""
"Объекты статистики создаются командой <xref linkend=\"sql-createstatistics\"/"
"> (за подробностями обратитесь к её описанию). При создании такого объекта "
"просто создаётся запись в каталоге, выражающая востребованность этой "
"статистики. Собственно сбор данных выполняется командой <command>ANALYZE</"
"command> (при запуске вручную или фоновом автоанализе). Изучить собранные "
"значения можно в каталоге <link linkend=\"catalog-pg-statistic-ext"
"\"><structname>pg_statistic_ext</structname></link>."

#. +> REL_10
#: perform.xml:1100(para)
msgid ""
"<command>ANALYZE</command> computes extended statistics based on the same "
"sample of table rows that it takes for computing regular single-column "
"statistics. Since the sample size is increased by increasing the statistics "
"target for the table or any of its columns (as described in the previous "
"section), a larger statistics target will normally result in more accurate "
"extended statistics, as well as more time spent calculating them."
msgstr ""
"Команда <command>ANALYZE</command> вычисляет расширенную статистику по той "
"же выборке строк таблицы, которая используется и для вычисления обычной "
"статистики по отдельным столбцам. Так как размер выборки увеличивается с "
"увеличением целевого ограничения статистики для таблицы или любых её "
"столбцов (как описано в предыдущем разделе), при большем целевом ограничении "
"обычно получается более точная расширенная статистика, но и времени на её "
"вычисление требуется больше."

#. +> REL_10
#: perform.xml:1110(para)
msgid ""
"The following subsections describe the kinds of extended statistics that are "
"currently supported."
msgstr ""
"В следующих подразделах описываются виды расширенной статистики, "
"поддерживаемые в настоящее время."

#. +> REL_10
#: perform.xml:1116(title)
msgid "Functional Dependencies"
msgstr "Функциональные зависимости"

#. +> REL_10
#: perform.xml:1118(para)
msgid ""
"The simplest kind of extended statistics tracks <firstterm>functional "
"dependencies</firstterm>, a concept used in definitions of database normal "
"forms. We say that column <structfield>b</structfield> is functionally "
"dependent on column <structfield>a</structfield> if knowledge of the value "
"of <structfield>a</structfield> is sufficient to determine the value of "
"<structfield>b</structfield>, that is there are no two rows having the same "
"value of <structfield>a</structfield> but different values of "
"<structfield>b</structfield>. In a fully normalized database, functional "
"dependencies should exist only on primary keys and superkeys. However, in "
"practice many data sets are not fully normalized for various reasons; "
"intentional denormalization for performance reasons is a common example. "
"Even in a fully normalized database, there may be partial correlation "
"between some columns, which can be expressed as partial functional "
"dependency."
msgstr ""
"Простейший вид расширенной статистики отслеживает <firstterm>функциональные "
"зависимости</firstterm> (это понятие используется в определении нормальных "
"форм баз данных). Мы называем столбец <structfield>b</structfield> "
"функционально зависимым от столбца <structfield>a</structfield>, если знания "
"значения <structfield>a</structfield> достаточно для определения значения "
"<structfield>b</structfield>, то есть не существует двух строк с одинаковыми "
"значениями <structfield>a</structfield>, но разными значениями "
"<structfield>b</structfield>. В полностью нормализованной базе данных "
"функциональные зависимости должны существовать только в первичных ключах и "
"суперключах. Однако на практике многие наборы данных не нормализуются "
"полностью по разным причинам; например, денормализация часто производится "
"намеренно по соображениям производительности."

#. +> REL_10
#: perform.xml:1135(para)
msgid ""
"The existence of functional dependencies directly affects the accuracy of "
"estimates in certain queries. If a query contains conditions on both the "
"independent and the dependent column(s), the conditions on the dependent "
"columns do not further reduce the result size; but without knowledge of the "
"functional dependency, the query planner will assume that the conditions are "
"independent, resulting in underestimating the result size."
msgstr ""
"Существование функциональных зависимостей напрямую влияет на точность оценок "
"в определённых запросах. Если запрос содержит условия как по независимым, "
"так и по зависимым столбцам, условия по зависимым столбцам дополнительно не "
"сокращают размер результата. Однако без знания о функциональной зависимости "
"планировщик запросов будет полагать, что все условия независимы, и "
"недооценит размер результата."

#. +> REL_10
#: perform.xml:1145(para)
msgid ""
"To inform the planner about functional dependencies, <command>ANALYZE</"
"command> can collect measurements of cross-column dependency. Assessing the "
"degree of dependency between all sets of columns would be prohibitively "
"expensive, so data collection is limited to those groups of columns "
"appearing together in a statistics object defined with the "
"<literal>dependencies</literal> option. It is advisable to create "
"<literal>dependencies</literal> statistics only for column groups that are "
"strongly correlated, to avoid unnecessary overhead in both <command>ANALYZE</"
"command> and later query planning."
msgstr ""
"Для информирования планировщика о функциональных зависимостях команда "
"<command>ANALYZE</command> может собирать показатели зависимостей между "
"столбцами. Оценить степень зависимости между всеми наборами столбцов "
"обошлось бы непозволительно дорого, поэтому сбор данных ограничивается "
"только теми группами столбцов, которые фигурируют вместе в объекте "
"статистики, определённом со свойством <literal>dependencies</literal>. Во "
"избежание ненужных издержек при выполнении <command>ANALYZE</command> и "
"последующем планировании запросов статистику с <literal>dependencies</"
"literal> рекомендуется создавать только для групп сильно коррелирующих "
"столбцов."

#. +> REL_10
#: perform.xml:1159(programlisting)
#, no-wrap
msgid ""
"CREATE STATISTICS stts (dependencies) ON zip, city FROM zipcodes;\n"
"\n"
"ANALYZE zipcodes;\n"
"\n"
"SELECT stxname, stxkeys, stxdependencies\n"
"  FROM pg_statistic_ext\n"
"  WHERE stxname = 'stts';\n"
" stxname | stxkeys |             stxdependencies               \n"
"---------+---------+------------------------------------------\n"
" stts    | 1 5     | {\"1 =&gt; 5\": 1.000000, \"5 =&gt; 1\": 0.423130}\n"
"(1 row)"
msgstr ""
"CREATE STATISTICS stts (dependencies) ON zip, city FROM zipcodes;\n"
"\n"
"ANALYZE zipcodes;\n"
"\n"
"SELECT stxname, stxkeys, stxdependencies\n"
"  FROM pg_statistic_ext\n"
"  WHERE stxname = 'stts';\n"
" stxname | stxkeys |             stxdependencies               \n"
"---------+---------+------------------------------------------\n"
" stts    | 1 5     | {\"1 =&gt; 5\": 1.000000, \"5 =&gt; 1\": 0.423130}\n"
"(1 row)"

#. +> REL_10
#: perform.xml:1157(para)
msgid ""
"Here is an example of collecting functional-dependency statistics: "
"<placeholder-1/> Here it can be seen that column 1 (zip code) fully "
"determines column 5 (city) so the coefficient is 1.0, while city only "
"determines zip code about 42% of the time, meaning that there are many "
"cities (58%) that are represented by more than a single ZIP code."
msgstr ""
"Взгляните на пример сбора статистики функциональной зависимости: "
"<placeholder-1/> В показанном случае столбец 1 (код zip) полностью "
"определяет столбец 5 (city), так что коэффициент равен 1.0, тогда как город "
"(столбец city) определяет код ZIP только в 42% всех случаев, что означает, "
"что многие города (58%) представлены несколькими кодами ZIP."

#. +> REL_10
#: perform.xml:1178(para)
msgid ""
"When computing the selectivity for a query involving functionally dependent "
"columns, the planner adjusts the per-condition selectivity estimates using "
"the dependency coefficients so as not to produce an underestimate."
msgstr ""
"При вычислении избирательности запроса, в котором задействованы "
"функционально зависимые столбцы, планировщик корректирует оценки "
"избирательности по условиям, используя коэффициенты зависимостей, чтобы не "
"допустить недооценки размера результата."

#. +> REL_10
#: perform.xml:1186(title)
msgid "Limitations of Functional Dependencies"
msgstr "Ограничения функциональных зависимостей"

#. +> REL_10
#: perform.xml:1188(para)
msgid ""
"Functional dependencies are currently only applied when considering simple "
"equality conditions that compare columns to constant values. They are not "
"used to improve estimates for equality conditions comparing two columns or "
"comparing a column to an expression, nor for range clauses, <literal>LIKE</"
"literal> or any other type of condition."
msgstr ""
"Функциональные зависимости в настоящее время применяются только при "
"рассмотрении простых условий с равенствами, сравнивающих значения столбцов с "
"константами. Они не используются для улучшения оценок при проверке равенства "
"двух столбцов или сравнении столбца с выражением, а также в условиях с "
"диапазоном, условиях <literal>LIKE</literal> или любых других видах условий."

#. +> REL_10
#: perform.xml:1201(programlisting)
#, no-wrap
msgid "SELECT * FROM zipcodes WHERE city = 'San Francisco' AND zip = '94105';"
msgstr "SELECT * FROM zipcodes WHERE city = 'San Francisco' AND zip = '94105';"

#. +> REL_10
#: perform.xml:1207(programlisting)
#, no-wrap
msgid "SELECT * FROM zipcodes WHERE city = 'San Francisco' AND zip = '90210';"
msgstr "SELECT * FROM zipcodes WHERE city = 'San Francisco' AND zip = '90210';"

#. +> REL_10
#: perform.xml:1196(para)
msgid ""
"When estimating with functional dependencies, the planner assumes that "
"conditions on the involved columns are compatible and hence redundant. If "
"they are incompatible, the correct estimate would be zero rows, but that "
"possibility is not considered. For example, given a query like "
"<placeholder-1/> the planner will disregard the <structfield>city</"
"structfield> clause as not changing the selectivity, which is correct. "
"However, it will make the same assumption about <placeholder-2/> even though "
"there will really be zero rows satisfying this query. Functional dependency "
"statistics do not provide enough information to conclude that, however."
msgstr ""
"Рассматривая функциональные зависимости, планировщик предполагает, что "
"условия по задействованным столбцам совместимы и таким образом избыточны. "
"Если условия несовместимы, правильной оценкой должен быть ноль строк, но эта "
"возможность не рассматривается. Например, с таким запросом <placeholder-1/> "
"планировщик отбросит условие с <structfield>city</structfield>, так как оно "
"не влияет на избирательность, что верно. Однако он сделает то же "
"предположение и в таком случае: <placeholder-2/> хотя на самом деле этому "
"запросу будет удовлетворять ноль строк. Но статистика функциональной "
"зависимости не даёт достаточно информации, чтобы прийти к такому заключению."

#. +> REL_10
#: perform.xml:1215(para)
msgid ""
"In many practical situations, this assumption is usually satisfied; for "
"example, there might be a GUI in the application that only allows selecting "
"compatible city and ZIP code values to use in a query. But if that's not the "
"case, functional dependencies may not be a viable option."
msgstr ""
"Во многих практических ситуациях это предположение обычно удовлетворяется; "
"например, графический интерфейс приложения для последующего формирования "
"запроса может не допускать выбор несовместимого сочетания города и кода ZIP. "
"Но когда это не так, статистика функциональной зависимости может не подойти."

#. +> REL_10
#: perform.xml:1226(title)
msgid "Multivariate N-Distinct Counts"
msgstr "Многовариантное число различных значений"

#. +> REL_10
#: perform.xml:1228(para)
msgid ""
"Single-column statistics store the number of distinct values in each column. "
"Estimates of the number of distinct values when combining more than one "
"column (for example, for <literal>GROUP BY a, b</literal>) are frequently "
"wrong when the planner only has single-column statistical data, causing it "
"to select bad plans."
msgstr ""
"Статистика по одному столбцу содержит число различных значений в каждом "
"отдельном столбце. Оценки числа различных значений в сочетании нескольких "
"столбцов (например, в <literal>GROUP BY a, b</literal>) часто оказываются "
"ошибочными, когда планировщик имеет статистические данные только по "
"отдельным столбцам, что приводит к выбору плохих планов."

#. +> REL_10
#: perform.xml:1236(para)
msgid ""
"To improve such estimates, <command>ANALYZE</command> can collect n-distinct "
"statistics for groups of columns. As before, it's impractical to do this for "
"every possible column grouping, so data is collected only for those groups "
"of columns appearing together in a statistics object defined with the "
"<literal>ndistinct</literal> option. Data will be collected for each "
"possible combination of two or more columns from the set of listed columns."
msgstr ""
"Для улучшения таких оценок операция <command>ANALYZE</command> может "
"собирать статистику по различным значениям для группы столбцов. Как и ранее, "
"это непрактично делать для каждой возможной группы столбцов, так что данные "
"собираются только по тем группам столбцов, которые указаны в определении "
"объекта статистики, создаваемого со свойством <literal>ndistinct</literal>. "
"Данные будут собираться по всем возможным сочетаниям из двух или нескольких "
"столбцов из перечисленных в определении."

#. +> REL_10
#: perform.xml:1249(programlisting)
#, no-wrap
msgid ""
"CREATE STATISTICS stts2 (ndistinct) ON zip, state, city FROM zipcodes;\n"
"\n"
"ANALYZE zipcodes;\n"
"\n"
"SELECT stxkeys AS k, stxndistinct AS nd\n"
"  FROM pg_statistic_ext\n"
"  WHERE stxname = 'stts2';\n"
"-[ RECORD 1 ]--------------------------------------------------------\n"
"k  | 1 2 5\n"
"nd | {\"1, 2\": 33178, \"1, 5\": 33178, \"2, 5\": 27435, \"1, 2, 5\": 33178}\n"
"(1 row)"
msgstr ""
"CREATE STATISTICS stts2 (ndistinct) ON zip, state, city FROM zipcodes;\n"
"\n"
"ANALYZE zipcodes;\n"
"\n"
"SELECT stxkeys AS k, stxndistinct AS nd\n"
"  FROM pg_statistic_ext\n"
"  WHERE stxname = 'stts2';\n"
"-[ RECORD 1 ]--------------------------------------------------------\n"
"k  | 1 2 5\n"
"nd | {\"1, 2\": 33178, \"1, 5\": 33178, \"2, 5\": 27435, \"1, 2, 5\": 33178}\n"
"(1 row)"

#. +> REL_10
#: perform.xml:1246(para)
msgid ""
"Continuing the previous example, the n-distinct counts in a table of ZIP "
"codes might look like the following: <placeholder-1/> This indicates that "
"there are three combinations of columns that have 33178 distinct values: ZIP "
"code and state; ZIP code and city; and ZIP code, city and state (the fact "
"that they are all equal is expected given that ZIP code alone is unique in "
"this table). On the other hand, the combination of city and state has only "
"27435 distinct values."
msgstr ""
"В продолжение предыдущего примера, количества различных значений в таблице "
"ZIP-кодов могут выглядеть так: <placeholder-1/> Как видно, есть три "
"комбинации столбцов, имеющих 33178 различных значений: код ZIP и штат; код "
"ZIP и город; код ZIP, город и штат (то, что все эти числа равны, ожидаемый "
"факт, так как сам по себе код ZIP в этой таблице уникален). С другой "
"стороны, сочетание города и штата даёт только 27435 различных значений."

#. +> REL_10
#: perform.xml:1270(para)
msgid ""
"It's advisable to create <literal>ndistinct</literal> statistics objects "
"only on combinations of columns that are actually used for grouping, and for "
"which misestimation of the number of groups is resulting in bad plans. "
"Otherwise, the <command>ANALYZE</command> cycles are just wasted."
msgstr ""
"Объект статистики <literal>ndistinct</literal> рекомендуется создавать "
"только для тех сочетаний столбцов, которые действительно используются при "
"группировке, и только когда неправильная оценка числа групп может привести к "
"выбору плохих планов. В противном случае усилия, потраченные на выполнение "
"<command>ANALYZE</command>, будут напрасными."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1281(title)
msgid "Controlling the Planner with Explicit <literal>JOIN</literal> Clauses"
msgstr ""
"Управление планировщиком с помощью явных предложений <literal>JOIN</literal>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1283(indexterm)
msgid "<primary>join</primary> <secondary>controlling the order</secondary>"
msgstr ""
"<primary>соединение</primary> <secondary>управление порядком</secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1288(para)
msgid ""
"It is possible to control the query planner to some extent by using the "
"explicit <literal>JOIN</literal> syntax. To see why this matters, we first "
"need some background."
msgstr ""
"Поведением планировщика в некоторой степени можно управлять, используя явный "
"синтаксис <literal>JOIN</literal>. Понять, когда и почему это бывает нужно, "
"поможет небольшое введение."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1296(programlisting)
#, no-wrap
msgid "SELECT * FROM a, b, c WHERE a.id = b.id AND b.ref = c.id;"
msgstr "SELECT * FROM a, b, c WHERE a.id = b.id AND b.ref = c.id;"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1294(para)
msgid ""
"In a simple join query, such as: <placeholder-1/> the planner is free to "
"join the given tables in any order. For example, it could generate a query "
"plan that joins A to B, using the <literal>WHERE</literal> condition "
"<literal>a.id = b.id</literal>, and then joins C to this joined table, using "
"the other <literal>WHERE</literal> condition. Or it could join B to C and "
"then join A to that result. Or it could join A to C and then join them with "
"B &mdash; but that would be inefficient, since the full Cartesian product of "
"A and C would have to be formed, there being no applicable condition in the "
"<literal>WHERE</literal> clause to allow optimization of the join. (All "
"joins in the <productname>PostgreSQL</productname> executor happen between "
"two input tables, so it's necessary to build up the result in one or another "
"of these fashions.) The important point is that these different join "
"possibilities give semantically equivalent results but might have hugely "
"different execution costs. Therefore, the planner will explore all of them "
"to try to find the most efficient query plan."
msgstr ""
"В простом запросе с соединением, например таком: <placeholder-1/> "
"планировщик может соединять данные таблицы в любом порядке. Например, он "
"может разработать план, в котором сначала A соединяется с B по условию "
"<literal>WHERE</literal> <literal>a.id = b.id</literal>, а затем C "
"соединяется с получившейся таблицей по другому условию <literal>WHERE</"
"literal>. Либо он может соединить B с C, а затем с A результатом соединения. "
"Он также может соединить сначала A с C, а затем результат с B &mdash; но это "
"будет не эффективно, так как ему придётся сформировать полное декартово "
"произведение A и C из-за отсутствия в предложении <literal>WHERE</literal> "
"условия, подходящего для оптимизации соединения. (В <productname>PostgreSQL</"
"productname> исполнитель запросов может соединять только по две таблицы, "
"поэтому для получения результата нужно выбрать один из этих способов.) При "
"этом важно понимать, что все эти разные способы соединения дают одинаковые "
"по смыслу результаты, но стоимость их может различаться многократно. Поэтому "
"планировщик должен изучить их все и найти самый эффективный способ "
"выполнения запроса."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1317(para)
msgid ""
"When a query only involves two or three tables, there aren't many join "
"orders to worry about. But the number of possible join orders grows "
"exponentially as the number of tables expands. Beyond ten or so input tables "
"it's no longer practical to do an exhaustive search of all the "
"possibilities, and even for six or seven tables planning might take an "
"annoyingly long time. When there are too many input tables, the "
"<productname>PostgreSQL</productname> planner will switch from exhaustive "
"search to a <firstterm>genetic</firstterm> probabilistic search through a "
"limited number of possibilities. (The switch-over threshold is set by the "
"<xref linkend=\"guc-geqo-threshold\"/> run-time parameter.) The genetic "
"search takes less time, but it won't necessarily find the best possible plan."
msgstr ""
"Когда запрос включает только две или три таблицы, возможны всего несколько "
"вариантов их соединения. Но их число растёт экспоненциально с увеличением "
"числа задействованных таблиц. Если число таблиц больше десяти, уже "
"практически невозможно выполнить полный перебор всех вариантов, и даже для "
"шести или семи таблиц планирование может занять недопустимо много времени. "
"Когда таблиц слишком много, планировщик <productname>PostgreSQL</"
"productname> переключается с полного поиска на алгоритм "
"<firstterm>генетического</firstterm> вероятностного поиска в ограниченном "
"числе вариантов. (Порог для этого переключения задаётся параметром "
"выполнения <xref linkend=\"guc-geqo-threshold\"/>.) Генетический поиск "
"выполняется быстрее, но не гарантирует, что найденный план будет наилучшим."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1336(programlisting)
#, no-wrap
msgid "SELECT * FROM a LEFT JOIN (b JOIN c ON (b.ref = c.id)) ON (a.id = b.id);"
msgstr "SELECT * FROM a LEFT JOIN (b JOIN c ON (b.ref = c.id)) ON (a.id = b.id);"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1347(programlisting)
#, no-wrap
msgid "SELECT * FROM a LEFT JOIN b ON (a.bid = b.id) LEFT JOIN c ON (a.cid = c.id);"
msgstr "SELECT * FROM a LEFT JOIN b ON (a.bid = b.id) LEFT JOIN c ON (a.cid = c.id);"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1333(para)
msgid ""
"When the query involves outer joins, the planner has less freedom than it "
"does for plain (inner) joins. For example, consider: <placeholder-1/> "
"Although this query's restrictions are superficially similar to the previous "
"example, the semantics are different because a row must be emitted for each "
"row of A that has no matching row in the join of B and C. Therefore the "
"planner has no choice of join order here: it must join B to C and then join "
"A to that result. Accordingly, this query takes less time to plan than the "
"previous query. In other cases, the planner might be able to determine that "
"more than one join order is safe. For example, given: <placeholder-2/> it is "
"valid to join A to either B or C first. Currently, only <literal>FULL JOIN</"
"literal> completely constrains the join order. Most practical cases "
"involving <literal>LEFT JOIN</literal> or <literal>RIGHT JOIN</literal> can "
"be rearranged to some extent."
msgstr ""
"Когда запрос включает внешние соединения, планировщик имеет меньше степеней "
"свободы, чем с обычными (внутренними) соединениями. Например, рассмотрим "
"запрос: <placeholder-1/> Хотя ограничения в этом запросе очень похожи на "
"показанные в предыдущем примере, смысл его отличается, так как "
"результирующая строка должна выдаваться для каждой строки A, даже если для "
"неё не находится соответствия в соединении B и C. Таким образом, здесь "
"планировщик не может выбирать порядок соединения: он должен соединить B с C, "
"а затем соединить A с результатом. Соответственно, и план этого запроса "
"построится быстрее, чем предыдущего. В других случаях планировщик сможет "
"определить, что можно безопасно выбрать один из нескольких способов "
"соединения. Например, для запроса: <placeholder-2/> можно соединить A либо с "
"B, либо с C. В настоящее время только <literal>FULL JOIN</literal> полностью "
"ограничивает порядок соединения. На практике в большинстве запросов с "
"<literal>LEFT JOIN</literal> и <literal>RIGHT JOIN</literal> порядком можно "
"управлять в некоторой степени."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1356(para)
msgid ""
"Explicit inner join syntax (<literal>INNER JOIN</literal>, <literal>CROSS "
"JOIN</literal>, or unadorned <literal>JOIN</literal>) is semantically the "
"same as listing the input relations in <literal>FROM</literal>, so it does "
"not constrain the join order."
msgstr ""
"Синтаксис явного внутреннего соединения (<literal>INNER JOIN</literal>, "
"<literal>CROSS JOIN</literal> или лаконичный <literal>JOIN</literal>) по "
"смыслу равнозначен перечислению отношений в предложении <literal>FROM</"
"literal>, так что он никак не ограничивает порядок соединений."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1369(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM a, b, c WHERE a.id = b.id AND b.ref = c.id;\n"
"SELECT * FROM a CROSS JOIN b CROSS JOIN c WHERE a.id = b.id AND b.ref = c.id;\n"
"SELECT * FROM a JOIN (b JOIN c ON (b.ref = c.id)) ON (a.id = b.id);"
msgstr ""
"SELECT * FROM a, b, c WHERE a.id = b.id AND b.ref = c.id;\n"
"SELECT * FROM a CROSS JOIN b CROSS JOIN c WHERE a.id = b.id AND b.ref = c.id;\n"
"SELECT * FROM a JOIN (b JOIN c ON (b.ref = c.id)) ON (a.id = b.id);"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1363(para)
msgid ""
"Even though most kinds of <literal>JOIN</literal> don't completely constrain "
"the join order, it is possible to instruct the <productname>PostgreSQL</"
"productname> query planner to treat all <literal>JOIN</literal> clauses as "
"constraining the join order anyway. For example, these three queries are "
"logically equivalent: <placeholder-1/> But if we tell the planner to honor "
"the <literal>JOIN</literal> order, the second and third take less time to "
"plan than the first. This effect is not worth worrying about for only three "
"tables, but it can be a lifesaver with many tables."
msgstr ""
"Хотя большинство видов <literal>JOIN</literal> не полностью ограничивают "
"порядок соединения, в <productname>PostgreSQL</productname> можно принудить "
"планировщик обрабатывать все предложения <literal>JOIN</literal> как "
"ограничивающие этот порядок. Например, следующие три запроса логически "
"равнозначны: <placeholder-1/> Но если мы укажем планировщику соблюдать "
"порядок <literal>JOIN</literal>, на планирование второго и третьего уйдёт "
"меньше времени. Когда речь идёт только о трёх таблицах, выигрыш будет "
"незначительным, но для множества таблиц это может быть очень эффективно."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1380(para)
msgid ""
"To force the planner to follow the join order laid out by explicit "
"<literal>JOIN</literal>s, set the <xref linkend=\"guc-join-collapse-limit\"/"
"> run-time parameter to 1. (Other possible values are discussed below.)"
msgstr ""
"Чтобы планировщик соблюдал порядок внутреннего соединения, выраженный явно "
"предложениями <literal>JOIN</literal>, нужно присвоить параметру выполнения "
"<xref linkend=\"guc-join-collapse-limit\"/> значение 1. (Другие допустимые "
"значения обсуждаются ниже.)"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1391(programlisting)
#, no-wrap
msgid "SELECT * FROM a CROSS JOIN b, c, d, e WHERE ...;"
msgstr "SELECT * FROM a CROSS JOIN b, c, d, e WHERE ...;"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1387(para)
msgid ""
"You do not need to constrain the join order completely in order to cut "
"search time, because it's OK to use <literal>JOIN</literal> operators within "
"items of a plain <literal>FROM</literal> list. For example, consider: "
"<placeholder-1/> With <varname>join_collapse_limit</varname> = 1, this "
"forces the planner to join A to B before joining them to other tables, but "
"doesn't constrain its choices otherwise. In this example, the number of "
"possible join orders is reduced by a factor of 5."
msgstr ""
"Чтобы сократить время поиска, необязательно полностью ограничивать порядок "
"соединений, в <literal>JOIN</literal> можно соединять элементы как в обычном "
"списке <literal>FROM</literal>. Например, рассмотрите следующий запрос: "
"<placeholder-1/> Если <varname>join_collapse_limit</varname> = 1, "
"планировщик будет вынужден соединить A с B раньше, чем результат с другими "
"таблицами, но в дальнейшем выборе вариантов он не ограничен. В данном "
"примере число возможных вариантов соединения уменьшается в 5 раз."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1400(para)
msgid ""
"Constraining the planner's search in this way is a useful technique both for "
"reducing planning time and for directing the planner to a good query plan. "
"If the planner chooses a bad join order by default, you can force it to "
"choose a better order via <literal>JOIN</literal> syntax &mdash; assuming "
"that you know of a better order, that is. Experimentation is recommended."
msgstr ""
"Упрощать для планировщика задачу перебора вариантов таким способом &mdash; "
"это полезный приём, помогающий не только выбрать сократить время "
"планирования, но и подтолкнуть планировщик к хорошему плану. Если "
"планировщик по умолчанию выбирает неудачный порядок соединения, вы можете "
"заставить его выбрать лучший, применив синтаксис <literal>JOIN</literal>, "
"конечно если вы сами его знаете. Эффект подобной оптимизации рекомендуется "
"подтверждать экспериментально."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1412(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"FROM x, y,\n"
"    (SELECT * FROM a, b, c WHERE something) AS ss\n"
"WHERE somethingelse;"
msgstr ""
"SELECT *\n"
"FROM x, y,\n"
"    (SELECT * FROM a, b, c WHERE something) AS ss\n"
"WHERE somethingelse;"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1422(programlisting)
#, no-wrap
msgid "SELECT * FROM x, y, a, b, c WHERE something AND somethingelse;"
msgstr "SELECT * FROM x, y, a, b, c WHERE something AND somethingelse;"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1409(para)
msgid ""
"A closely related issue that affects planning time is collapsing of "
"subqueries into their parent query. For example, consider: <placeholder-1/> "
"This situation might arise from use of a view that contains a join; the "
"view's <literal>SELECT</literal> rule will be inserted in place of the view "
"reference, yielding a query much like the above. Normally, the planner will "
"try to collapse the subquery into the parent, yielding: <placeholder-2/> "
"This usually results in a better plan than planning the subquery separately. "
"(For example, the outer <literal>WHERE</literal> conditions might be such "
"that joining X to A first eliminates many rows of A, thus avoiding the need "
"to form the full logical output of the subquery.) But at the same time, we "
"have increased the planning time; here, we have a five-way join problem "
"replacing two separate three-way join problems. Because of the exponential "
"growth of the number of possibilities, this makes a big difference. The "
"planner tries to avoid getting stuck in huge join search problems by not "
"collapsing a subquery if more than <varname>from_collapse_limit</varname> "
"<literal>FROM</literal> items would result in the parent query. You can "
"trade off planning time against quality of plan by adjusting this run-time "
"parameter up or down."
msgstr ""
"На время планирования влияет и другой, тесно связанный фактор &mdash; "
"решение о включении подзапросов в родительский запрос. Пример такого "
"запроса: <placeholder-1/> Такая же ситуация может возникнуть с "
"представлением, содержащим соединение; вместо ссылки на это представление "
"будет вставлено его выражение <literal>SELECT</literal> и в результате "
"получится запрос, похожий на показанный выше. Обычно планировщик старается "
"включить подзапрос в родительский запрос и получить таким образом: "
"<placeholder-2/> Часто это позволяет построить лучший план, чем при "
"планировании подзапросов по отдельности. (Например, внешние условия "
"<literal>WHERE</literal> могут быть таковы, что при соединении сначала X с A "
"будет исключено множество строк A, а значит формировать логический результат "
"подзапроса полностью не потребуется.) Но в то же время тем самым мы "
"увеличиваем время планирования; две задачи соединения трёх элементов мы "
"заменяем одной с пятью элементами. Так как число вариантов увеличивается "
"экспоненциально, сложность задачи увеличивается многократно. Планировщик "
"пытается избежать проблем поиска с огромным числом вариантов, рассматривая "
"подзапросы отдельно, если в предложении <literal>FROM</literal> "
"родительского запроса оказывается больше чем <varname>from_collapse_limit</"
"varname> элементов. Изменяя этот параметр выполнения, можно подобрать "
"оптимальное соотношение времени планирования и качества плана."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1439(para)
msgid ""
"<xref linkend=\"guc-from-collapse-limit\"/> and <xref linkend=\"guc-join-"
"collapse-limit\"/> are similarly named because they do almost the same "
"thing: one controls when the planner will <quote>flatten out</quote> "
"subqueries, and the other controls when it will flatten out explicit joins. "
"Typically you would either set <varname>join_collapse_limit</varname> equal "
"to <varname>from_collapse_limit</varname> (so that explicit joins and "
"subqueries act similarly) or set <varname>join_collapse_limit</varname> to 1 "
"(if you want to control join order with explicit joins). But you might set "
"them differently if you are trying to fine-tune the trade-off between "
"planning time and run time."
msgstr ""
"Параметры <xref linkend=\"guc-from-collapse-limit\"/> и <xref linkend=\"guc-"
"join-collapse-limit\"/> называются похоже, потому что они делают практически "
"одно и то же: первый параметр определяет, когда планировщик будет "
"<quote>сносить</quote> в предложение <literal>FROM</literal> подзапросы, а "
"второй &mdash; явные соединения. Обычно <varname>join_collapse_limit</"
"varname> устанавливается равным <varname>from_collapse_limit</varname> "
"(чтобы явные соединения и подзапросы обрабатывались одинаково) или 1 (если "
"требуется управлять порядком соединений). Но вы можете задать другие "
"значения, чтобы добиться оптимального соотношения времени планирования и "
"времени выполнения запросов."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1455(title)
msgid "Populating a Database"
msgstr "Наполнение базы данных"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1457(para)
msgid ""
"One might need to insert a large amount of data when first populating a "
"database. This section contains some suggestions on how to make this process "
"as efficient as possible."
msgstr ""
"Довольно часто в начале или в процессе использования базы данных возникает "
"необходимость загрузить в неё большой объём данных. В этом разделе приведены "
"рекомендации, которые помогут сделать это максимально эффективно."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1464(title)
msgid "Disable Autocommit"
msgstr "Отключите автофиксацию транзакций"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1466(indexterm)
msgid "<primary>autocommit</primary> <secondary>bulk-loading data</secondary>"
msgstr ""
"<primary>автофиксация</primary> <secondary>массовая загрузка данных</"
"secondary>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1471(para)
msgid ""
"When using multiple <command>INSERT</command>s, turn off autocommit and just "
"do one commit at the end. (In plain SQL, this means issuing <command>BEGIN</"
"command> at the start and <command>COMMIT</command> at the end. Some client "
"libraries might do this behind your back, in which case you need to make "
"sure the library does it when you want it done.) If you allow each insertion "
"to be committed separately, <productname>PostgreSQL</productname> is doing a "
"lot of work for each row that is added. An additional benefit of doing all "
"insertions in one transaction is that if the insertion of one row were to "
"fail then the insertion of all rows inserted up to that point would be "
"rolled back, so you won't be stuck with partially loaded data."
msgstr ""
"Выполняя серию команд <command>INSERT</command>, выключите автофиксацию "
"транзакций и зафиксируйте транзакцию только один раз в самом конце. (В "
"обычном SQL это означает, что нужно выполнить <command>BEGIN</command> до, и "
"<command>COMMIT</command> после этой серии. Некоторые клиентские библиотеки "
"могут делать это автоматически, в таких случаях нужно убедиться, что это "
"так.) Если вы будете фиксировать каждое добавление по отдельности, "
"<productname>PostgreSQL</productname> придётся проделать много действий для "
"каждой добавляемой строки. Выполнять все операции в одной транзакции хорошо "
"ещё и потому, что в случае ошибки добавления одной из строк произойдёт откат "
"к исходному состоянию и вы не окажетесь в сложной ситуации с частично "
"загруженными данными."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1489(title)
msgid "Use <command>COPY</command>"
msgstr "Используйте <command>COPY</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1491(para)
msgid ""
"Use <xref linkend=\"sql-copy\"/> to load all the rows in one command, "
"instead of using a series of <command>INSERT</command> commands. The "
"<command>COPY</command> command is optimized for loading large numbers of "
"rows; it is less flexible than <command>INSERT</command>, but incurs "
"significantly less overhead for large data loads. Since <command>COPY</"
"command> is a single command, there is no need to disable autocommit if you "
"use this method to populate a table."
msgstr ""
"Используйте <xref linkend=\"sql-copy\"/>, чтобы загрузить все строки одной "
"командой вместо серии <command>INSERT</command>. Команда <command>COPY</"
"command> оптимизирована для загрузки большого количества строк; хотя она не "
"так гибка, как <command>INSERT</command>, но при загрузке больших объёмов "
"данных она влечёт гораздо меньше накладных расходов. Так как <command>COPY</"
"command> &mdash; это одна команда, применяя её, нет необходимости отключать "
"автофиксацию транзакций."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1502(para)
msgid ""
"If you cannot use <command>COPY</command>, it might help to use <xref "
"linkend=\"sql-prepare\"/> to create a prepared <command>INSERT</command> "
"statement, and then use <command>EXECUTE</command> as many times as "
"required. This avoids some of the overhead of repeatedly parsing and "
"planning <command>INSERT</command>. Different interfaces provide this "
"facility in different ways; look for <quote>prepared statements</quote> in "
"the interface documentation."
msgstr ""
"В случаях, когда <command>COPY</command> не подходит, может быть полезно "
"создать подготовленный оператор <command>INSERT</command> с помощью <xref "
"linkend=\"sql-prepare\"/>, а затем выполнять <command>EXECUTE</command> "
"столько раз, сколько потребуется. Это позволит избежать накладных расходов, "
"связанных с разбором и анализом каждой команды <command>INSERT</command>. В "
"разных интерфейсах это может выглядеть по-разному; за подробностями "
"обратитесь к описанию <quote>подготовленных операторов</quote> в "
"документации конкретного интерфейса."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1513(para)
msgid ""
"Note that loading a large number of rows using <command>COPY</command> is "
"almost always faster than using <command>INSERT</command>, even if "
"<command>PREPARE</command> is used and multiple insertions are batched into "
"a single transaction."
msgstr ""
"Заметьте, что с помощью <command>COPY</command> большое количество строк "
"практически всегда загружается быстрее, чем с помощью <command>INSERT</"
"command>, даже если используется <command>PREPARE</command> и серия операций "
"добавления заключена в одну транзакцию."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1520(para)
msgid ""
"<command>COPY</command> is fastest when used within the same transaction as "
"an earlier <command>CREATE TABLE</command> or <command>TRUNCATE</command> "
"command. In such cases no WAL needs to be written, because in case of an "
"error, the files containing the newly loaded data will be removed anyway. "
"However, this consideration only applies when <xref linkend=\"guc-wal-level"
"\"/> is <literal>minimal</literal> as all commands must write WAL otherwise."
msgstr ""
"<command>COPY</command> работает быстрее всего, если она выполняется в одной "
"транзакции с командами <command>CREATE TABLE</command> или "
"<command>TRUNCATE</command>. В таких случаях записывать WAL не нужно, так "
"как в случае ошибки файлы, содержащие загружаемые данные, будут всё равно "
"удалены. Однако это замечание справедливо, только когда параметр <xref "
"linkend=\"guc-wal-level\"/> равен <literal>minimal</literal>, так как в "
"противном случае все команды должны записывать свои изменения в WAL."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1534(title)
msgid "Remove Indexes"
msgstr "Удалите индексы"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1536(para)
msgid ""
"If you are loading a freshly created table, the fastest method is to create "
"the table, bulk load the table's data using <command>COPY</command>, then "
"create any indexes needed for the table. Creating an index on pre-existing "
"data is quicker than updating it incrementally as each row is loaded."
msgstr ""
"Если вы загружаете данные в только что созданную таблицу, быстрее всего "
"будет загрузить данные с помощью <command>COPY</command>, а затем создать "
"все необходимые для неё индексы. На создание индекса для уже существующих "
"данных уйдёт меньше времени, чем на последовательное его обновление при "
"добавлении каждой строки."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1544(para)
msgid ""
"If you are adding large amounts of data to an existing table, it might be a "
"win to drop the indexes, load the table, and then recreate the indexes. Of "
"course, the database performance for other users might suffer during the "
"time the indexes are missing. One should also think twice before dropping a "
"unique index, since the error checking afforded by the unique constraint "
"will be lost while the index is missing."
msgstr ""
"Если вы добавляете данные в существующую таблицу, может иметь смысл удалить "
"индексы, загрузить таблицу, а затем пересоздать индексы. Конечно, при этом "
"надо учитывать, что временное отсутствие индексов может отрицательно "
"повлиять на скорость работы других пользователей. Кроме того, следует дважды "
"подумать, прежде чем удалять уникальные индексы, так как без них "
"соответствующие проверки ключей не будут выполняться."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1557(title)
msgid "Remove Foreign Key Constraints"
msgstr "Удалите ограничения внешних ключей"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1559(para)
msgid ""
"Just as with indexes, a foreign key constraint can be checked <quote>in "
"bulk</quote> more efficiently than row-by-row. So it might be useful to drop "
"foreign key constraints, load data, and re-create the constraints. Again, "
"there is a trade-off between data load speed and loss of error checking "
"while the constraint is missing."
msgstr ""
"Как и с индексами, проверки, связанные с ограничениями внешних ключей, "
"выгоднее выполнять <quote>массово</quote>, а не для каждой строки в "
"отдельности. Поэтому может быть полезно удалить ограничения внешних ключей, "
"загрузить данные, а затем восстановить прежние ограничения. И в этом случае "
"тоже приходится выбирать между скоростью загрузки данных и риском допустить "
"ошибки в отсутствие ограничений."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1567(para)
msgid ""
"What's more, when you load data into a table with existing foreign key "
"constraints, each new row requires an entry in the server's list of pending "
"trigger events (since it is the firing of a trigger that checks the row's "
"foreign key constraint). Loading many millions of rows can cause the trigger "
"event queue to overflow available memory, leading to intolerable swapping or "
"even outright failure of the command. Therefore it may be "
"<emphasis>necessary</emphasis>, not just desirable, to drop and re-apply "
"foreign keys when loading large amounts of data. If temporarily removing the "
"constraint isn't acceptable, the only other recourse may be to split up the "
"load operation into smaller transactions."
msgstr ""
"Более того, когда вы загружаете данные в таблицу с существующими "
"ограничениями внешнего ключа, для каждой новой строки добавляется запись в "
"очередь событий триггера (так как именно срабатывающий триггер проверяет "
"такие ограничения для строки). При загрузке многих миллионов строк очередь "
"событий триггера может занять всю доступную память, что приведёт к "
"недопустимой нагрузке на файл подкачки или даже к сбою команды. Таким "
"образом, загружая большие объёмы данных, может быть не просто желательно, а "
"<emphasis>необходимо</emphasis> удалять, а затем восстанавливать внешние "
"ключи. Если же временное отключение этого ограничения неприемлемо, "
"единственно возможным решением может быть разделение всей операции загрузки "
"на меньшие транзакции."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1582(title)
msgid "Increase <varname>maintenance_work_mem</varname>"
msgstr "Увеличьте <varname>maintenance_work_mem</varname>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1584(para)
msgid ""
"Temporarily increasing the <xref linkend=\"guc-maintenance-work-mem\"/> "
"configuration variable when loading large amounts of data can lead to "
"improved performance. This will help to speed up <command>CREATE INDEX</"
"command> commands and <command>ALTER TABLE ADD FOREIGN KEY</command> "
"commands. It won't do much for <command>COPY</command> itself, so this "
"advice is only useful when you are using one or both of the above techniques."
msgstr ""
"Ускорить загрузку больших объёмов данных можно, увеличив параметр "
"конфигурации <xref linkend=\"guc-maintenance-work-mem\"/> на время загрузки. "
"Это приведёт к увеличению быстродействия <command>CREATE INDEX</command> и "
"<command>ALTER TABLE ADD FOREIGN KEY</command>. На скорость самой команды "
"<command>COPY</command> это не повлияет, так что этот совет будет полезен, "
"только если вы применяете какой-либо из двух вышеописанных приёмов."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1595(title)
msgid "Increase <varname>max_wal_size</varname>"
msgstr "Увеличьте <varname>max_wal_size</varname>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1597(para)
msgid ""
"Temporarily increasing the <xref linkend=\"guc-max-wal-size\"/> "
"configuration variable can also make large data loads faster. This is "
"because loading a large amount of data into <productname>PostgreSQL</"
"productname> will cause checkpoints to occur more often than the normal "
"checkpoint frequency (specified by the <varname>checkpoint_timeout</varname> "
"configuration variable). Whenever a checkpoint occurs, all dirty pages must "
"be flushed to disk. By increasing <varname>max_wal_size</varname> "
"temporarily during bulk data loads, the number of checkpoints that are "
"required can be reduced."
msgstr ""
"Также массовую загрузку данных можно ускорить, изменив на время загрузки "
"параметр конфигурации <xref linkend=\"guc-max-wal-size\"/>. Загружая большие "
"объёмы данных, <productname>PostgreSQL</productname> вынужден увеличивать "
"частоту контрольных точек по сравнению с обычной (которая задаётся "
"параметром <varname>checkpoint_timeout</varname>), а значит и чаще "
"сбрасывать &laquo;грязные&raquo; страницы на диск. Временно увеличив "
"<varname>max_wal_size</varname>, можно уменьшить частоту контрольных точек и "
"связанных с ними операций ввода-вывода."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1613(title)
msgid "Disable WAL Archival and Streaming Replication"
msgstr "Отключите архивацию WAL и потоковую репликацию"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1615(para)
msgid ""
"When loading large amounts of data into an installation that uses WAL "
"archiving or streaming replication, it might be faster to take a new base "
"backup after the load has completed than to process a large amount of "
"incremental WAL data. To prevent incremental WAL logging while loading, "
"disable archiving and streaming replication, by setting <xref linkend=\"guc-"
"wal-level\"/> to <literal>minimal</literal>, <xref linkend=\"guc-archive-mode"
"\"/> to <literal>off</literal>, and <xref linkend=\"guc-max-wal-senders\"/> "
"to zero. But note that changing these settings requires a server restart."
msgstr ""
"Для загрузки больших объёмов данных в среде, где используется архивация WAL "
"или потоковая репликация, быстрее будет сделать копию базы данных после "
"загрузки данных, чем обрабатывать множество операций изменений в WAL. Чтобы "
"отключить передачу изменений через WAL в процессе загрузки, отключите "
"архивацию и потоковую репликацию, назначьте параметру <xref linkend=\"guc-"
"wal-level\"/> значение <literal>minimal</literal>, <xref linkend=\"guc-"
"archive-mode\"/> &mdash; <literal>off</literal>, а <xref linkend=\"guc-max-"
"wal-senders\"/> &mdash; 0. Но имейте в виду, что изменённые параметры "
"вступят в силу только после перезапуска сервера."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1638(command)
msgid "CREATE TABLE AS SELECT"
msgstr "CREATE TABLE AS SELECT"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1642(para)
msgid ""
"<command>CREATE INDEX</command> (and variants such as <command>ALTER TABLE "
"ADD PRIMARY KEY</command>)"
msgstr ""
"<command>CREATE INDEX</command> (и подобные команды, как например "
"<command>ALTER TABLE ADD PRIMARY KEY</command>)"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1649(command)
msgid "ALTER TABLE SET TABLESPACE"
msgstr "ALTER TABLE SET TABLESPACE"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1654(command)
msgid "CLUSTER"
msgstr "CLUSTER"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1658(para)
msgid ""
"<command>COPY FROM</command>, when the target table has been created or "
"truncated earlier in the same transaction"
msgstr ""
"<command>COPY FROM</command>, когда целевая таблица была создана или "
"опустошена ранее в той же транзакции"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1627(para)
msgid ""
"Aside from avoiding the time for the archiver or WAL sender to process the "
"WAL data, doing this will actually make certain commands faster, because "
"they are designed not to write WAL at all if <varname>wal_level</varname> is "
"<literal>minimal</literal>. (They can guarantee crash safety more cheaply by "
"doing an <function>fsync</function> at the end than by writing WAL.) This "
"applies to the following commands: <placeholder-1/>"
msgstr ""
"Это не только поможет сэкономить время архивации и передачи WAL, но и "
"непосредственно ускорит некоторые команды, которые могут вовсе не "
"использовать WAL, если <varname>wal_level</varname> равен <literal>minimal</"
"literal>. (Они могут гарантировать безопасность при сбое, не записывая все "
"изменения в WAL, а выполнив только <function>fsync</function> в конце "
"операции, что будет гораздо дешевле.) Это относится к следующим командам: "
"<placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1668(title)
msgid "Run <command>ANALYZE</command> Afterwards"
msgstr "Выполните в конце <command>ANALYZE</command>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1670(para)
msgid ""
"Whenever you have significantly altered the distribution of data within a "
"table, running <xref linkend=\"sql-analyze\"/> is strongly recommended. This "
"includes bulk loading large amounts of data into the table. Running "
"<command>ANALYZE</command> (or <command>VACUUM ANALYZE</command>) ensures "
"that the planner has up-to-date statistics about the table. With no "
"statistics or obsolete statistics, the planner might make poor decisions "
"during query planning, leading to poor performance on any tables with "
"inaccurate or nonexistent statistics. Note that if the autovacuum daemon is "
"enabled, it might run <command>ANALYZE</command> automatically; see <xref "
"linkend=\"vacuum-for-statistics\"/> and <xref linkend=\"autovacuum\"/> for "
"more information."
msgstr ""
"Всякий раз, когда распределение данных в таблице значительно меняется, "
"настоятельно рекомендуется выполнять <xref linkend=\"sql-analyze\"/>. Эта "
"рекомендация касается и загрузки в таблицу большого объёма данных. Выполнив "
"<command>ANALYZE</command> (или <command>VACUUM ANALYZE</command>), вы тем "
"самым обновите статистику по данной таблице для планировщика. Когда "
"планировщик не имеет статистики или она не соответствует действительности, "
"он не сможет правильно планировать запросы, что приведёт к снижению "
"быстродействия при работе с соответствующими таблицами. Заметьте, что если "
"включён демон автоочистки, он может запускать <command>ANALYZE</command> "
"автоматически; подробнее об этом можно узнать в <xref remap=\"6\" linkend="
"\"vacuum-for-statistics\"/> и <xref remap=\"6\" linkend=\"autovacuum\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1687(title)
msgid "Some Notes About <application>pg_dump</application>"
msgstr "Несколько замечаний относительно <application>pg_dump</application>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1689(para)
msgid ""
"Dump scripts generated by <application>pg_dump</application> automatically "
"apply several, but not all, of the above guidelines. To reload a "
"<application>pg_dump</application> dump as quickly as possible, you need to "
"do a few extra things manually. (Note that these points apply while "
"<emphasis>restoring</emphasis> a dump, not while <emphasis>creating</"
"emphasis> it. The same points apply whether loading a text dump with "
"<application>psql</application> or using <application>pg_restore</"
"application> to load from a <application>pg_dump</application> archive file.)"
msgstr ""
"В скриптах загрузки данных, которые генерирует <application>pg_dump</"
"application>, автоматически учитываются некоторые, но не все из этих "
"рекомендаций. Чтобы загрузить данные, которые выгрузил <application>pg_dump</"
"application>, максимально быстро, вам нужно будет выполнить некоторые "
"дополнительные действия вручную. (Заметьте, что эти замечания относятся "
"только к <emphasis>восстановлению</emphasis> данных, но не к "
"<emphasis>выгрузке</emphasis> их. Следующие рекомендации применимы вне "
"зависимости от того, загружается ли архивный файл <application>pg_dump</"
"application> в <application>psql</application> или в "
"<application>pg_restore</application>.)"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1708(para)
msgid ""
"Set appropriate (i.e., larger than normal) values for "
"<varname>maintenance_work_mem</varname> and <varname>max_wal_size</varname>."
msgstr ""
"Установите подходящие (то есть превышающие обычные) значения для "
"<varname>maintenance_work_mem</varname> и <varname>max_wal_size</varname>."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1715(para)
msgid ""
"If using WAL archiving or streaming replication, consider disabling them "
"during the restore. To do that, set <varname>archive_mode</varname> to "
"<literal>off</literal>, <varname>wal_level</varname> to <literal>minimal</"
"literal>, and <varname>max_wal_senders</varname> to zero before loading the "
"dump. Afterwards, set them back to the right values and take a fresh base "
"backup."
msgstr ""
"Если вы используете архивацию WAL или потоковую репликацию, по возможности "
"отключите их на время восстановления. Для этого перед загрузкой данных, "
"присвойте параметру <varname>archive_mode</varname> значение <literal>off</"
"literal>, <varname>wal_level</varname> &mdash; <literal>minimal</literal>, а "
"<varname>max_wal_senders</varname> &mdash; 0. Закончив восстановление, "
"верните их обычные значения и сделайте свежую базовую резервную копию."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1726(para)
msgid ""
"Experiment with the parallel dump and restore modes of both "
"<application>pg_dump</application> and <application>pg_restore</application> "
"and find the optimal number of concurrent jobs to use. Dumping and restoring "
"in parallel by means of the <option>-j</option> option should give you a "
"significantly higher performance over the serial mode."
msgstr ""
"Поэкспериментируйте с режимами параллельного копирования и восстановления "
"команд <application>pg_dump</application> и <application>pg_restore</"
"application>, и подберите оптимальное число параллельных заданий. "
"Параллельное копирование и восстановление данных, управляемое параметром "
"<option>-j</option>, должно дать значительный выигрыш в скорости по "
"сравнению с последовательным режимом."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1735(para)
msgid ""
"Consider whether the whole dump should be restored as a single transaction. "
"To do that, pass the <option>-1</option> or <option>--single-transaction</"
"option> command-line option to <application>psql</application> or "
"<application>pg_restore</application>. When using this mode, even the "
"smallest of errors will rollback the entire restore, possibly discarding "
"many hours of processing. Depending on how interrelated the data is, that "
"might seem preferable to manual cleanup, or not. <command>COPY</command> "
"commands will run fastest if you use a single transaction and have WAL "
"archiving turned off."
msgstr ""
"Если это возможно в вашей ситуации, восстановите все данные в рамках одной "
"транзакции. Для этого передайте параметр <option>-1</option> или <option>--"
"single-transaction</option> команде <application>psql</application> или "
"<application>pg_restore</application>. Но учтите, что в этом режиме даже "
"незначительная ошибка приведёт к откату всех изменений и часы восстановления "
"будут потрачены зря. В зависимости от того, насколько взаимосвязаны данные, "
"предпочтительнее может быть вычистить их вручную. Команды <command>COPY</"
"command> будут работать максимально быстро, когда они выполняются в одной "
"транзакции и архивация WAL выключена."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1748(para)
msgid ""
"If multiple CPUs are available in the database server, consider using "
"<application>pg_restore</application>'s <option>--jobs</option> option. This "
"allows concurrent data loading and index creation."
msgstr ""
"Если на сервере баз данных установлено несколько процессоров, полезным может "
"оказаться параметр <option>--jobs</option> команды <application>pg_restore</"
"application>. С его помощью можно выполнить загрузку данных и создание "
"индексов параллельно."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1755(para)
msgid "Run <command>ANALYZE</command> afterwards."
msgstr "После загрузки данных запустите <command>ANALYZE</command>."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1700(para)
msgid ""
"By default, <application>pg_dump</application> uses <command>COPY</command>, "
"and when it is generating a complete schema-and-data dump, it is careful to "
"load data before creating indexes and foreign keys. So in this case several "
"guidelines are handled automatically. What is left for you to do is to: "
"<placeholder-1/>"
msgstr ""
"По умолчанию <application>pg_dump</application> использует команду "
"<command>COPY</command> и когда она выгружает полностью схему и данные, в "
"сгенерированном скрипте она сначала предусмотрительно загружает данные, а "
"потом создаёт индексы и внешние ключи. Так что в этом случае часть "
"рекомендаций выполняется автоматически. Вам остаётся учесть только "
"следующие: <placeholder-1/>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1768(para)
msgid ""
"You can get the effect of disabling foreign keys by using the <option>--"
"disable-triggers</option> option &mdash; but realize that that eliminates, "
"rather than just postpones, foreign key validation, and so it is possible to "
"insert bad data if you use it."
msgstr ""
"Вы можете отключить внешние ключи, используя параметр <option>--disable-"
"triggers</option> &mdash; но при этом нужно понимать, что тем самым вы не "
"просто отложите, а полностью выключите соответствующие проверки, что "
"позволит вставить недопустимые данные."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1762(para)
msgid ""
"A data-only dump will still use <command>COPY</command>, but it does not "
"drop or recreate indexes, and it does not normally touch foreign keys. "
"<placeholder-1/> So when loading a data-only dump, it is up to you to drop "
"and recreate indexes and foreign keys if you wish to use those techniques. "
"It's still useful to increase <varname>max_wal_size</varname> while loading "
"the data, but don't bother increasing <varname>maintenance_work_mem</"
"varname>; rather, you'd do that while manually recreating indexes and "
"foreign keys afterwards. And don't forget to <command>ANALYZE</command> when "
"you're done; see <xref linkend=\"vacuum-for-statistics\"/> and <xref linkend="
"\"autovacuum\"/> for more information."
msgstr ""
"При выгрузке данных без схемы тоже используется команда <command>COPY</"
"command>, но индексы, как обычно и внешние ключи, при этом не удаляются и не "
"пересоздаются. <placeholder-1/> Поэтому, загружая только данные, вы сами "
"должны решить, нужно ли для ускорения загрузки удалять и пересоздавать "
"индексы и внешние ключи. При этом будет так же полезно увеличить параметр "
"<varname>max_wal_size</varname>, но не <varname>maintenance_work_mem</"
"varname>; его стоит менять, только если вы впоследствии пересоздаёте индексы "
"и внешние ключи вручную. И не забудьте выполнить <command>ANALYZE</command> "
"после; подробнее об этом можно узнать в <xref remap=\"6\" linkend=\"vacuum-"
"for-statistics\"/> и <xref remap=\"6\" linkend=\"autovacuum\"/>."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1790(title)
msgid "Non-Durable Settings"
msgstr "Оптимизация, угрожающая стабильности"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1792(indexterm)
msgid "<primary>non-durable</primary>"
msgstr "<primary>угроза стабильности</primary>"

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1810(para)
msgid ""
"Place the database cluster's data directory in a memory-backed file system "
"(i.e. <acronym>RAM</acronym> disk). This eliminates all database disk I/O, "
"but limits data storage to the amount of available memory (and perhaps swap)."
msgstr ""
"Поместите каталог данных кластера БД в файловую систему, размещённую в "
"памяти (т. е. в <acronym>RAM</acronym>-диск). Так вы исключите всю "
"активность ввода/вывода, связанную с базой данных, если только размер базы "
"данных не превышает объём свободной памяти (возможно, с учётом файла "
"подкачки)."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1819(para)
msgid ""
"Turn off <xref linkend=\"guc-fsync\"/>; there is no need to flush data to "
"disk."
msgstr ""
"Выключите <xref linkend=\"guc-fsync\"/>; сбрасывать данные на диск не нужно."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1826(para)
msgid ""
"Turn off <xref linkend=\"guc-synchronous-commit\"/>; there might be no need "
"to force <acronym>WAL</acronym> writes to disk on every commit. This setting "
"does risk transaction loss (though not data corruption) in case of a crash "
"of the <emphasis>database</emphasis>."
msgstr ""
"Выключите <xref linkend=\"guc-synchronous-commit\"/>; нет необходимости "
"принудительно записывать <acronym>WAL</acronym> на диск при фиксации каждой "
"транзакции. Но учтите, это может привести к потере транзакций (хотя данные "
"останутся согласованными) в случае сбоя <emphasis>базы данных</emphasis>."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1835(para)
msgid ""
"Turn off <xref linkend=\"guc-full-page-writes\"/>; there is no need to guard "
"against partial page writes."
msgstr ""
"Выключите <xref linkend=\"guc-full-page-writes\"/>; защита от частичной "
"записи страниц не нужна."

#. +> REL_10
#: perform.xml:1842(para)
msgid ""
"Increase <xref linkend=\"guc-max-wal-size\"/> and <xref linkend=\"guc-"
"checkpoint-timeout\"/>; this reduces the frequency of checkpoints, but "
"increases the storage requirements of <filename>/pg_wal</filename>."
msgstr ""
"Увеличьте <xref linkend=\"guc-max-wal-size\"/> и <xref linkend=\"guc-"
"checkpoint-timeout\"/>; это уменьшит частоту контрольных точек, хотя объём "
"<filename>/pg_wal</filename> при этом вырастет."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1851(para)
msgid ""
"Create <link linkend=\"sql-createtable-unlogged\">unlogged tables</link> to "
"avoid <acronym>WAL</acronym> writes, though it makes the tables non-crash-"
"safe."
msgstr ""
"Создавайте <link linkend=\"sql-createtable-unlogged\">нежурналируемые "
"таблицы</link> для оптимизации записи в <acronym>WAL</acronym> (но учтите, "
"что такие таблицы не защищены от сбоя)."

#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:1796(para)
msgid ""
"Durability is a database feature that guarantees the recording of committed "
"transactions even if the server crashes or loses power. However, durability "
"adds significant database overhead, so if your site does not require such a "
"guarantee, <productname>PostgreSQL</productname> can be configured to run "
"much faster. The following are configuration changes you can make to improve "
"performance in such cases. Except as noted below, durability is still "
"guaranteed in case of a crash of the database software; only abrupt "
"operating system stoppage creates a risk of data loss or corruption when "
"these settings are used. <placeholder-1/>"
msgstr ""
"Стабильность &mdash; это свойство базы данных, гарантирующее, что результат "
"зафиксированных транзакций будет сохранён даже в случае сбоя сервера или "
"отключения питания. Однако обеспечивается стабильность за счёт значительной "
"дополнительной нагрузки. Поэтому, если вы можете отказаться от такой "
"гарантии, <productname>PostgreSQL</productname> можно ускорить ещё больше, "
"применив следующие методы оптимизации. Кроме явно описанных исключений, даже "
"с такими изменениями конфигурации при сбое программного ядра СУБД гарантия "
"стабильности сохраняется; риск потери или разрушения данных возможен только "
"в случае внезапной остановки операционной системы. <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#. +> REL_10 REL9_6_3 REL9_6
#: perform.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#. +> REL9_6_3 REL9_6
#: perform.xml:1612(para)
msgid ""
"Increase <xref linkend=\"guc-max-wal-size\"/> and <xref linkend=\"guc-"
"checkpoint-timeout\"/> ; this reduces the frequency of checkpoints, but "
"increases the storage requirements of <filename>/pg_xlog</filename>."
msgstr ""
"Увеличьте <xref linkend=\"guc-max-wal-size\"/> и <xref linkend=\"guc-"
"checkpoint-timeout\"/>; это уменьшит частоту контрольных точек, хотя объём "
"<filename>/pg_xlog</filename> при этом вырастет."
