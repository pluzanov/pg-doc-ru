# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-06-27 17:40+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: pageinspect.xml:5(title)
msgid "pageinspect"
msgstr "pageinspect"

#: pageinspect.xml:7(indexterm)
msgid "<primary>pageinspect</primary>"
msgstr "<primary>pageinspect</primary>"

#: pageinspect.xml:11(para)
msgid ""
"The <filename>pageinspect</filename> module provides functions that allow "
"you to inspect the contents of database pages at a low level, which is "
"useful for debugging purposes. All of these functions may be used only by "
"superusers."
msgstr ""
"Модуль <filename>pageinspect</filename> предоставляет функции, позволяющие "
"исследовать страницы баз данных на низком уровне, что бывает полезно для "
"отладки. Все эти функции могут вызывать только суперпользователи."

#: pageinspect.xml:18(title)
msgid "Functions"
msgstr "Функции"

#: pageinspect.xml:23(function)
msgid "get_raw_page(relname text, fork text, blkno int) returns bytea"
msgstr "get_raw_page(relname text, fork text, blkno int) returns bytea"

#: pageinspect.xml:24(indexterm)
msgid "<primary>get_raw_page</primary>"
msgstr "<primary>get_raw_page</primary>"

#: pageinspect.xml:30(para)
msgid ""
"<function>get_raw_page</function> reads the specified block of the named "
"relation and returns a copy as a <type>bytea</type> value. This allows a "
"single time-consistent copy of the block to be obtained. <replaceable>fork</"
"replaceable> should be <literal>'main'</literal> for the main data fork, "
"<literal>'fsm'</literal> for the free space map, <literal>'vm'</literal> for "
"the visibility map, or <literal>'init'</literal> for the initialization fork."
msgstr ""
"Функция <function>get_raw_page</function> считывает указанный блок отношения "
"с заданным именем и возвращает копию значения <type>bytea</type>. Это "
"позволяет получить одну согласованную во времени копию блока. В параметре "
"<parameter>fork</parameter> нужно передать <literal>'main'</literal>, чтобы "
"обратиться к основному слою данных, <literal>'fsm'</literal> — к карте "
"свободного пространства, <literal>'vm'</literal> — к карте видимости, либо "
"<literal>'init'</literal> — к слою инициализации."

#: pageinspect.xml:44(function)
msgid "get_raw_page(relname text, blkno int) returns bytea"
msgstr "get_raw_page(relname text, blkno int) returns bytea"

#: pageinspect.xml:48(para)
msgid ""
"A shorthand version of <function>get_raw_page</function>, for reading from "
"the main fork. Equivalent to <literal>get_raw_page(relname, 'main', blkno)</"
"literal>"
msgstr ""
"Упрощённая версия <function>get_raw_page</function> для чтения данных из "
"основного слоя. Синоним <literal>get_raw_page(relname, 'main', blkno)</"
"literal>"

#: pageinspect.xml:58(function)
msgid "page_header(page bytea) returns record"
msgstr "page_header(page bytea) returns record"

#: pageinspect.xml:59(indexterm)
msgid "<primary>page_header</primary>"
msgstr "<primary>page_header</primary>"

#: pageinspect.xml:65(para)
msgid ""
"<function>page_header</function> shows fields that are common to all "
"<productname>PostgreSQL</productname> heap and index pages."
msgstr ""
"Функция <function>page_header</function> показывает поля, общие для всех "
"страниц кучи и индекса <productname>PostgreSQL</productname>."

#: pageinspect.xml:70(para)
msgid ""
"A page image obtained with <function>get_raw_page</function> should be "
"passed as argument. For example: <screen>test=# SELECT * FROM "
"page_header(get_raw_page('pg_class', 0));\n"
"    lsn    | checksum | flags  | lower | upper | special | pagesize | "
"version | prune_xid\n"
"-----------+----------+--------+-------+-------+---------+----------"
"+---------+-----------\n"
" 0/24A1B50 |        1 |      1 |   232 |   368 |    8192 |     8192 |       "
"4 |         0</screen> The returned columns correspond to the fields in the "
"<structname>PageHeaderData</structname> struct. See <filename>src/include/"
"storage/bufpage.h</filename> for details."
msgstr ""
"В качестве аргумента ей передаётся образ страницы, полученный в результате "
"вызова <function>get_raw_page</function>. Например: <screen>test=# SELECT * "
"FROM page_header(get_raw_page('pg_class', 0));\n"
"    lsn    | checksum | flags  | lower | upper | special | pagesize | "
"version | prune_xid\n"
"-----------+----------+--------+-------+-------+---------+----------"
"+---------+-----------\n"
" 0/24A1B50 |        1 |      1 |   232 |   368 |    8192 |     8192 |       "
"4 |         0</screen> Возвращаемые столбцы соответствуют полям в структуре "
"<structname>PageHeaderData</structname>. За подробностями обратитесь к "
"<filename>src/include/storage/bufpage.h</filename>."

#: pageinspect.xml:86(function)
msgid "heap_page_items(page bytea) returns setof record"
msgstr "heap_page_items(page bytea) returns setof record"

#: pageinspect.xml:87(indexterm)
msgid "<primary>heap_page_items</primary>"
msgstr "<primary>heap_page_items</primary>"

#: pageinspect.xml:93(para)
msgid ""
"<function>heap_page_items</function> shows all line pointers on a heap page. "
"For those line pointers that are in use, tuple headers as well as tuple raw "
"data are also shown. All tuples are shown, whether or not the tuples were "
"visible to an MVCC snapshot at the time the raw page was copied."
msgstr ""
"Функция <function>heap_page_items</function> показывает все указатели "
"линейных блоков на странице кучи. Для используемых блоков также выводятся "
"заголовки кортежей. При этом показываются все кортежи, независимо от того, "
"были ли видны они в снимке MVCC в момент копирования исходной страницы."

#: pageinspect.xml:100(para)
msgid ""
"A heap page image obtained with <function>get_raw_page</function> should be "
"passed as argument. For example: <screen>test=# SELECT * FROM "
"heap_page_items(get_raw_page('pg_class', 0));</screen> See <filename>src/"
"include/storage/itemid.h</filename> and <filename>src/include/access/"
"htup_details.h</filename> for explanations of the fields returned."
msgstr ""
"В качестве аргумента ей нужно передать образ страницы кучи, полученный в "
"результате вызова <function>get_raw_page</function>. Например: "
"<screen>test=# SELECT * FROM heap_page_items(get_raw_page('pg_class', 0));</"
"screen> Описание возвращаемых полей можно найти в <filename>src/include/"
"storage/itemid.h</filename> и <filename>src/include/access/htup_details.h</"
"filename>."

#: pageinspect.xml:113(function)
msgid ""
"tuple_data_split(rel_oid, t_data bytea, t_infomask integer, t_infomask2 "
"integer, t_bits text [, do_detoast bool]) returns bytea[]"
msgstr ""
"tuple_data_split(rel_oid, t_data bytea, t_infomask integer, t_infomask2 "
"integer, t_bits text [, do_detoast bool]) returns bytea[]"

#: pageinspect.xml:114(indexterm)
msgid "<primary>tuple_data_split</primary>"
msgstr "<primary>tuple_data_split</primary>"

#: pageinspect.xml:119(para)
msgid ""
"<function>tuple_data_split</function> splits tuple data into attributes in "
"the same way as backend internals. <screen>test=# SELECT "
"tuple_data_split('pg_class'::regclass, t_data, t_infomask, t_infomask2, "
"t_bits) FROM heap_page_items(get_raw_page('pg_class', 0));</screen> This "
"function should be called with the same arguments as the return attributes "
"of <function>heap_page_items</function>."
msgstr ""
"Функция <function>tuple_data_split</function> разделяет данные кортежей на "
"атрибуты так, как это происходит внутри сервера. <screen>test=# SELECT "
"tuple_data_split('pg_class'::regclass, t_data, t_infomask, t_infomask2, "
"t_bits) FROM heap_page_items(get_raw_page('pg_class', 0));</screen> В "
"качестве аргументов этой функции должны передаваться атрибуты, возвращаемые "
"функцией <function>heap_page_items</function>."

#: pageinspect.xml:126(para)
msgid ""
"If <parameter>do_detoast</parameter> is <literal>true</literal>, attribute "
"that will be detoasted as needed. Default value is <literal>false</literal>."
msgstr ""
"Если параметр <parameter>do_detoast</parameter> равен <literal>true</"
"literal>, полученные атрибуты будут распакованы по мере необходимости. Если "
"он не задан, подразумевается <literal>false</literal>."

#: pageinspect.xml:136(function)
msgid ""
"heap_page_item_attrs(rel_oid, t_data bytea, [, do_detoast bool]) returns "
"bytea[]"
msgstr ""
"heap_page_item_attrs(rel_oid, t_data bytea, [, do_detoast bool]) returns "
"bytea[]"

#: pageinspect.xml:137(indexterm)
msgid "<primary>heap_page_item_attrs</primary>"
msgstr "<primary>heap_page_item_attrs</primary>"

#: pageinspect.xml:142(para)
msgid ""
"<function>heap_page_item_attrs</function> is equivalent to "
"<function>heap_page_items</function> except that it returns tuple raw data "
"as an array of attributes that can optionally be detoasted by "
"<parameter>do_detoast</parameter> which is <literal>false</literal> by "
"default."
msgstr ""
"Функция <function>heap_page_item_attrs</function> похожа на "
"<function>heap_page_items</function>, но возвращает неструктурированное "
"содержимое кортежа в виде массива атрибутов, которые могут быть распакованы, "
"если установлен флаг <parameter>do_detoast</parameter> (по умолчанию они не "
"распаковываются)."

#: pageinspect.xml:149(para)
msgid ""
"A heap page image obtained with <function>get_raw_page</function> should be "
"passed as argument. For example: <screen>test=# SELECT * FROM "
"heap_page_item_attrs(get_raw_page('pg_class', 0), 'pg_class'::regclass);</"
"screen>"
msgstr ""
"В качестве аргумента ей должен передаваться образ страницы, выданный "
"функцией <function>get_raw_page</function>. Например: <screen>test=# SELECT "
"* FROM heap_page_item_attrs(get_raw_page('pg_class', 0), 'pg_class'::"
"regclass);</screen>"

#: pageinspect.xml:159(function)
msgid "bt_metap(relname text) returns record"
msgstr "bt_metap(relname text) returns record"

#: pageinspect.xml:160(indexterm)
msgid "<primary>bt_metap</primary>"
msgstr "<primary>bt_metap</primary>"

#: pageinspect.xml:166(para)
msgid ""
"<function>bt_metap</function> returns information about a B-tree index's "
"metapage. For example: <screen>test=# SELECT * FROM "
"bt_metap('pg_cast_oid_index');\n"
"-[ RECORD 1 ]-----\n"
"magic     | 340322\n"
"version   | 2\n"
"root      | 1\n"
"level     | 0\n"
"fastroot  | 1\n"
"fastlevel | 0</screen>"
msgstr ""
"Функция <function>bt_metap</function> возвращает информацию о метастранице "
"индекса-B-дерева. Например: <screen>test=# SELECT * FROM "
"bt_metap('pg_cast_oid_index');\n"
"-[ RECORD 1 ]-----\n"
"magic     | 340322\n"
"version   | 2\n"
"root      | 1\n"
"level     | 0\n"
"fastroot  | 1\n"
"fastlevel | 0</screen>"

#: pageinspect.xml:183(function)
msgid "bt_page_stats(relname text, blkno int) returns record"
msgstr "bt_page_stats(relname text, blkno int) returns record"

#: pageinspect.xml:184(indexterm)
msgid "<primary>bt_page_stats</primary>"
msgstr "<primary>bt_page_stats</primary>"

#: pageinspect.xml:190(para)
msgid ""
"<function>bt_page_stats</function> returns summary information about single "
"pages of B-tree indexes. For example: <screen>test=# SELECT * FROM "
"bt_page_stats('pg_cast_oid_index', 1);\n"
"-[ RECORD 1 ]-+-----\n"
"blkno         | 1\n"
"type          | l\n"
"live_items    | 256\n"
"dead_items    | 0\n"
"avg_item_size | 12\n"
"page_size     | 8192\n"
"free_size     | 4056\n"
"btpo_prev     | 0\n"
"btpo_next     | 0\n"
"btpo          | 0\n"
"btpo_flags    | 3</screen>"
msgstr ""
"<function>bt_page_stats</function> возвращает сводную информацию по "
"единичным страницам B-дерева. Например: <screen>test=# SELECT * FROM "
"bt_page_stats('pg_cast_oid_index', 1);\n"
"-[ RECORD 1 ]-+-----\n"
"blkno         | 1\n"
"type          | l\n"
"live_items    | 256\n"
"dead_items    | 0\n"
"avg_item_size | 12\n"
"page_size     | 8192\n"
"free_size     | 4056\n"
"btpo_prev     | 0\n"
"btpo_next     | 0\n"
"btpo          | 0\n"
"btpo_flags    | 3</screen>"

#: pageinspect.xml:212(function)
msgid "bt_page_items(relname text, blkno int) returns setof record"
msgstr "bt_page_items(relname text, blkno int) returns setof record"

#: pageinspect.xml:213(indexterm)
msgid "<primary>bt_page_items</primary>"
msgstr "<primary>bt_page_items</primary>"

#: pageinspect.xml:219(para)
msgid ""
"<function>bt_page_items</function> returns detailed information about all of "
"the items on a B-tree index page. For example: <screen>test=# SELECT * FROM "
"bt_page_items('pg_cast_oid_index', 1);\n"
" itemoffset |  ctid   | itemlen | nulls | vars |    data\n"
"------------+---------+---------+-------+------+-------------\n"
"          1 | (0,1)   |      12 | f     | f    | 23 27 00 00\n"
"          2 | (0,2)   |      12 | f     | f    | 24 27 00 00\n"
"          3 | (0,3)   |      12 | f     | f    | 25 27 00 00\n"
"          4 | (0,4)   |      12 | f     | f    | 26 27 00 00\n"
"          5 | (0,5)   |      12 | f     | f    | 27 27 00 00\n"
"          6 | (0,6)   |      12 | f     | f    | 28 27 00 00\n"
"          7 | (0,7)   |      12 | f     | f    | 29 27 00 00\n"
"          8 | (0,8)   |      12 | f     | f    | 2a 27 00 00</screen> In a B-"
"tree leaf page, <structfield>ctid</structfield> points to a heap tuple. In "
"an internal page, the block number part of <structfield>ctid</structfield> "
"points to another page in the index itself, while the offset part (the "
"second number) is ignored and is usually 1."
msgstr ""
"<function>bt_page_items</function> возвращает детализированную информацию "
"обо всех элементах на странице B-дерева. Например: <screen>test=# SELECT * "
"FROM bt_page_items('pg_cast_oid_index', 1);\n"
" itemoffset |  ctid   | itemlen | nulls | vars |    data\n"
"------------+---------+---------+-------+------+-------------\n"
"          1 | (0,1)   |      12 | f     | f    | 23 27 00 00\n"
"          2 | (0,2)   |      12 | f     | f    | 24 27 00 00\n"
"          3 | (0,3)   |      12 | f     | f    | 25 27 00 00\n"
"          4 | (0,4)   |      12 | f     | f    | 26 27 00 00\n"
"          5 | (0,5)   |      12 | f     | f    | 27 27 00 00\n"
"          6 | (0,6)   |      12 | f     | f    | 28 27 00 00\n"
"          7 | (0,7)   |      12 | f     | f    | 29 27 00 00\n"
"          8 | (0,8)   |      12 | f     | f    | 2a 27 00 00</screen> На "
"странице уровня листьев B-дерева, <structfield>ctid</structfield> указывает "
"на кортеж в куче. На внутренней странице часть <structfield>ctid</"
"structfield>, содержащая номер блока, указывает на другую страницу в самом "
"индексе, а часть смещения (второе число) игнорируется и обычно равняется 1."

#: pageinspect.xml:238(para)
msgid ""
"Note that the first item on any non-rightmost page (any page with a non-zero "
"value in the <structfield>btpo_next</structfield> field) is the page's "
"<quote>high key</quote>, meaning its <structfield>data</structfield> serves "
"as an upper bound on all items appearing on the page, while its "
"<structfield>ctid</structfield> field is meaningless. Also, on non-leaf "
"pages, the first real data item (the first item that is not a high key) is a "
"<quote>minus infinity</quote> item, with no actual value in its "
"<structfield>data</structfield> field. Such an item does have a valid "
"downlink in its <structfield>ctid</structfield> field, however."
msgstr ""
"Заметьте, что первый элемент в любой, кроме самой правой, странице (то есть "
"в любой странице с ненулевым значением в поле <structfield>btpo_next</"
"structfield>) представляет собой <quote>верхний ключ</quote>, то есть его "
"поле <structfield>data</structfield> задаёт верхнюю границу всех элементов, "
"находящихся на странице, а поле <structfield>ctid</structfield> лишено "
"смысла. Кроме того, на внутренних страницах первый действительный элемент "
"данных (первый элемент после верхнего ключа) представляет элемент "
"<quote>минус бесконечность</quote>, без фактического значения в поле "
"<structfield>data</structfield>. Однако такой элемент содержит в своём поле "
"<structfield>ctid</structfield> корректную ссылку на данные."

#: pageinspect.xml:254(function)
msgid "brin_page_type(page bytea) returns text"
msgstr "brin_page_type(page bytea) returns text"

#: pageinspect.xml:255(indexterm)
msgid "<primary>brin_page_type</primary>"
msgstr "<primary>brin_page_type</primary>"

#: pageinspect.xml:261(para)
msgid ""
"<function>brin_page_type</function> returns the page type of the given "
"<acronym>BRIN</acronym> index page, or throws an error if the page is not a "
"valid <acronym>BRIN</acronym> page. For example: <screen>test=# SELECT "
"brin_page_type(get_raw_page('brinidx', 0));\n"
" brin_page_type \n"
"----------------\n"
" meta</screen>"
msgstr ""
"Функция <function>brin_page_type</function> возвращает тип страницы для "
"заданной страницы индекса <acronym>BRIN</acronym> или выдаёт ошибку, если "
"эта страница не является корректной страницей индекса <acronym>BRIN</"
"acronym>. Например: <screen>test=# SELECT "
"brin_page_type(get_raw_page('brinidx', 0));\n"
" brin_page_type \n"
"----------------\n"
" meta</screen>"

#: pageinspect.xml:275(function)
msgid "brin_metapage_info(page bytea) returns record"
msgstr "brin_metapage_info(page bytea) returns record"

#: pageinspect.xml:276(indexterm)
msgid "<primary>brin_metapage_info</primary>"
msgstr "<primary>brin_metapage_info</primary>"

#: pageinspect.xml:282(para)
msgid ""
"<function>brin_metapage_info</function> returns assorted information about a "
"<acronym>BRIN</acronym> index metapage. For example: <screen>test=# SELECT * "
"FROM brin_metapage_info(get_raw_page('brinidx', 0));\n"
"   magic    | version | pagesperrange | lastrevmappage \n"
"------------+---------+---------------+----------------\n"
" 0xA8109CFA |       1 |             4 |              2</screen>"
msgstr ""
"Функция <function>brin_metapage_info</function> возвращает разнообразные "
"сведения о метастранице индекса <acronym>BRIN</acronym>. Например: "
"<screen>test=# SELECT * FROM brin_metapage_info(get_raw_page('brinidx', "
"0));\n"
"   magic    | version | pagesperrange | lastrevmappage \n"
"------------+---------+---------------+----------------\n"
" 0xA8109CFA |       1 |             4 |              2</screen>"

#: pageinspect.xml:295(function)
msgid "brin_revmap_data(page bytea) returns setof tid"
msgstr "brin_revmap_data(page bytea) returns setof tid"

#: pageinspect.xml:296(indexterm)
msgid "<primary>brin_revmap_data</primary>"
msgstr "<primary>brin_revmap_data</primary>"

#: pageinspect.xml:302(para)
msgid ""
"<function>brin_revmap_data</function> returns the list of tuple identifiers "
"in a <acronym>BRIN</acronym> index range map page. For example: "
"<screen>test=# SELECT * FROM brin_revmap_data(get_raw_page('brinidx', 2)) "
"limit 5;\n"
"  pages  \n"
"---------\n"
" (6,137)\n"
" (6,138)\n"
" (6,139)\n"
" (6,140)\n"
" (6,141)</screen>"
msgstr ""
"Функция <function>brin_revmap_data</function> выдаёт список идентификаторов "
"кортежей со страницы сопоставлений зон индекса <acronym>BRIN</acronym>. "
"Например: <screen>test=# SELECT * FROM "
"brin_revmap_data(get_raw_page('brinidx', 2)) limit 5;\n"
"  pages  \n"
"---------\n"
" (6,137)\n"
" (6,138)\n"
" (6,139)\n"
" (6,140)\n"
" (6,141)</screen>"

#: pageinspect.xml:320(function)
msgid "brin_page_items(page bytea, index oid) returns setof record"
msgstr "brin_page_items(page bytea, index oid) returns setof record"

#: pageinspect.xml:321(indexterm)
msgid "<primary>brin_page_items</primary>"
msgstr "<primary>brin_page_items</primary>"

#: pageinspect.xml:327(para)
msgid ""
"<function>brin_page_items</function> returns the data stored in the "
"<acronym>BRIN</acronym> data page. For example: <screen>test=# SELECT * FROM "
"brin_page_items(get_raw_page('brinidx', 5),\n"
"                                     'brinidx')\n"
"       ORDER BY blknum, attnum LIMIT 6;\n"
" itemoffset | blknum | attnum | allnulls | hasnulls | placeholder |    "
"value     \n"
"------------+--------+--------+----------+----------+-------------"
"+--------------\n"
"        137 |      0 |      1 | t        | f        | f           | \n"
"        137 |      0 |      2 | f        | f        | f           | {1 .. "
"88}\n"
"        138 |      4 |      1 | t        | f        | f           | \n"
"        138 |      4 |      2 | f        | f        | f           | {89 .. "
"176}\n"
"        139 |      8 |      1 | t        | f        | f           | \n"
"        139 |      8 |      2 | f        | f        | f           | {177 .. "
"264}</screen> The returned columns correspond to the fields in the "
"<structname>BrinMemTuple</structname> and <structname>BrinValues</"
"structname> structs. See <filename>src/include/access/brin_tuple.h</"
"filename> for details."
msgstr ""
"Функция <function>brin_page_items</function> выдаёт содержимое, сохранённое "
"в странице данных <acronym>BRIN</acronym>. Например: <screen>test=# SELECT * "
"FROM brin_page_items(get_raw_page('brinidx', 5),\n"
"                                     'brinidx')\n"
"       ORDER BY blknum, attnum LIMIT 6;\n"
" itemoffset | blknum | attnum | allnulls | hasnulls | placeholder |    "
"value     \n"
"------------+--------+--------+----------+----------+-------------"
"+--------------\n"
"        137 |      0 |      1 | t        | f        | f           | \n"
"        137 |      0 |      2 | f        | f        | f           | {1 .. "
"88}\n"
"        138 |      4 |      1 | t        | f        | f           | \n"
"        138 |      4 |      2 | f        | f        | f           | {89 .. "
"176}\n"
"        139 |      8 |      1 | t        | f        | f           | \n"
"        139 |      8 |      2 | f        | f        | f           | {177 .. "
"264}</screen> Возвращаемые столбцы соответствуют полям в структурах "
"<structname>BrinMemTuple</structname> и <structname>BrinValues</structname>. "
"Подробнее они описаны в <filename>src/include/access/brin_tuple.h</filename>."

#: pageinspect.xml:350(function)
msgid "gin_metapage_info(page bytea) returns record"
msgstr "gin_metapage_info(page bytea) returns record"

#: pageinspect.xml:351(indexterm)
msgid "<primary>gin_metapage_info</primary>"
msgstr "<primary>gin_metapage_info</primary>"

#: pageinspect.xml:357(para)
msgid ""
"<function>gin_metapage_info</function> returns information about a "
"<acronym>GIN</acronym> index metapage. For example: <screen>test=# SELECT * "
"FROM gin_metapage_info(get_raw_page('gin_index', 0));\n"
"-[ RECORD 1 ]----+-----------\n"
"pending_head     | 4294967295\n"
"pending_tail     | 4294967295\n"
"tail_free_size   | 0\n"
"n_pending_pages  | 0\n"
"n_pending_tuples | 0\n"
"n_total_pages    | 7\n"
"n_entry_pages    | 6\n"
"n_data_pages     | 0\n"
"n_entries        | 693\n"
"version          | 2</screen>"
msgstr ""
"Функция <function>gin_metapage_info</function> выдаёт информацию о "
"метастранице индекса <acronym>GIN</acronym>. Например: <screen>test=# SELECT "
"* FROM gin_metapage_info(get_raw_page('gin_index', 0));\n"
"-[ RECORD 1 ]----+-----------\n"
"pending_head     | 4294967295\n"
"pending_tail     | 4294967295\n"
"tail_free_size   | 0\n"
"n_pending_pages  | 0\n"
"n_pending_tuples | 0\n"
"n_total_pages    | 7\n"
"n_entry_pages    | 6\n"
"n_data_pages     | 0\n"
"n_entries        | 693\n"
"version          | 2</screen>"

#: pageinspect.xml:378(function)
msgid "gin_page_opaque_info(page bytea) returns record"
msgstr "gin_page_opaque_info(page bytea) returns record"

#: pageinspect.xml:379(indexterm)
msgid "<primary>gin_page_opaque_info</primary>"
msgstr "<primary>gin_page_opaque_info</primary>"

#: pageinspect.xml:385(para)
msgid ""
"<function>gin_page_opaque_info</function> returns information about a "
"<acronym>GIN</acronym> index opaque area, like the page type. For example: "
"<screen>test=# SELECT * FROM gin_page_opaque_info(get_raw_page('gin_index', "
"2));\n"
" rightlink | maxoff |         flags\n"
"-----------+--------+------------------------\n"
"         5 |      0 | {data,leaf,compressed}\n"
"(1 row)</screen>"
msgstr ""
"Функция <function>gin_page_opaque_info</function> выдаёт информацию из "
"непрозрачной области индекса <acronym>GIN</acronym>, например, тип страницы. "
"Например: <screen>test=# SELECT * FROM "
"gin_page_opaque_info(get_raw_page('gin_index', 2));\n"
" rightlink | maxoff |         flags\n"
"-----------+--------+------------------------\n"
"         5 |      0 | {data,leaf,compressed}\n"
"(1 row)</screen>"

#: pageinspect.xml:400(function)
msgid "gin_leafpage_items(page bytea) returns setof record"
msgstr "gin_leafpage_items(page bytea) returns setof record"

#: pageinspect.xml:401(indexterm)
msgid "<primary>gin_leafpage_items</primary>"
msgstr "<primary>gin_leafpage_items</primary>"

#: pageinspect.xml:407(para)
msgid ""
"<function>gin_leafpage_items</function> returns information about the data "
"stored in a <acronym>GIN</acronym> leaf page. For example: <screen>test=# "
"SELECT first_tid, nbytes, tids[0:5] as some_tids\n"
"        FROM gin_leafpage_items(get_raw_page('gin_test_idx', 2));\n"
" first_tid | nbytes |                        some_tids\n"
"-----------+--------"
"+----------------------------------------------------------\n"
" (8,41)    |    244 | {\"(8,41)\",\"(8,43)\",\"(8,44)\",\"(8,45)\","
"\"(8,46)\"}\n"
" (10,45)   |    248 | {\"(10,45)\",\"(10,46)\",\"(10,47)\",\"(10,48)\","
"\"(10,49)\"}\n"
" (12,52)   |    248 | {\"(12,52)\",\"(12,53)\",\"(12,54)\",\"(12,55)\","
"\"(12,56)\"}\n"
" (14,59)   |    320 | {\"(14,59)\",\"(14,60)\",\"(14,61)\",\"(14,62)\","
"\"(14,63)\"}\n"
" (167,16)  |    376 | {\"(167,16)\",\"(167,17)\",\"(167,18)\",\"(167,19)\","
"\"(167,20)\"}\n"
" (170,30)  |    376 | {\"(170,30)\",\"(170,31)\",\"(170,32)\",\"(170,33)\","
"\"(170,34)\"}\n"
" (173,44)  |    197 | {\"(173,44)\",\"(173,45)\",\"(173,46)\",\"(173,47)\","
"\"(173,48)\"}\n"
"(7 rows)</screen>"
msgstr ""
"Функция <function>gin_leafpage_items</function> выдаёт информацию о данных, "
"хранящихся в странице индекса <acronym>GIN</acronym> на уровне листьев. "
"Например: <screen>test=# SELECT first_tid, nbytes, tids[0:5] as some_tids\n"
"        FROM gin_leafpage_items(get_raw_page('gin_test_idx', 2));\n"
" first_tid | nbytes |                        some_tids\n"
"-----------+--------"
"+----------------------------------------------------------\n"
" (8,41)    |    244 | {\"(8,41)\",\"(8,43)\",\"(8,44)\",\"(8,45)\","
"\"(8,46)\"}\n"
" (10,45)   |    248 | {\"(10,45)\",\"(10,46)\",\"(10,47)\",\"(10,48)\","
"\"(10,49)\"}\n"
" (12,52)   |    248 | {\"(12,52)\",\"(12,53)\",\"(12,54)\",\"(12,55)\","
"\"(12,56)\"}\n"
" (14,59)   |    320 | {\"(14,59)\",\"(14,60)\",\"(14,61)\",\"(14,62)\","
"\"(14,63)\"}\n"
" (167,16)  |    376 | {\"(167,16)\",\"(167,17)\",\"(167,18)\",\"(167,19)\","
"\"(167,20)\"}\n"
" (170,30)  |    376 | {\"(170,30)\",\"(170,31)\",\"(170,32)\",\"(170,33)\","
"\"(170,34)\"}\n"
" (173,44)  |    197 | {\"(173,44)\",\"(173,45)\",\"(173,46)\",\"(173,47)\","
"\"(173,48)\"}\n"
"(7 rows)</screen>"

#: pageinspect.xml:428(function)
msgid "fsm_page_contents(page bytea) returns text"
msgstr "fsm_page_contents(page bytea) returns text"

#: pageinspect.xml:429(indexterm)
msgid "<primary>fsm_page_contents</primary>"
msgstr "<primary>fsm_page_contents</primary>"

#: pageinspect.xml:435(para)
msgid ""
"<function>fsm_page_contents</function> shows the internal node structure of "
"a FSM page. The output is a multiline string, with one line per node in the "
"binary tree within the page. Only those nodes that are not zero are printed. "
"The so-called \"next\" pointer, which points to the next slot to be returned "
"from the page, is also printed."
msgstr ""
"Функция <function>fsm_page_contents</function> показывает внутреннюю "
"структуру узла на странице FSM. Она выдаёт текст из нескольких строк, по "
"одной строке на узел двоичного дерева на заданной странице. При этом "
"выдаются только ненулевые узлы. Также выводится так называемый указатель "
"&laquo;следующего слота&raquo;, который указывает на следующий слот, "
"получаемый с этой страницы."

#: pageinspect.xml:442(para)
msgid ""
"See <filename>src/backend/storage/freespace/README</filename> for more "
"information on the structure of an FSM page."
msgstr ""
"Подробнее структура страницы FSM описана в <filename>src/backend/storage/"
"freespace/README</filename>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: pageinspect.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
