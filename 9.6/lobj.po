# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-09 11:02+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: lobj.xml:5(title)
msgid "Large Objects"
msgstr "Большие объекты"

#: lobj.xml:7(indexterm)
msgid "<primary>large object</primary>"
msgstr "<primary>большой объект</primary>"

#: lobj.xml:8(indexterm)
msgid "<primary>BLOB</primary><see>large object</see>"
msgstr "<primary>BLOB</primary><see>большой объект</see>"

#: lobj.xml:10(para)
msgid ""
"<productname>PostgreSQL</productname> has a <firstterm>large object</"
"firstterm> facility, which provides stream-style access to user data that is "
"stored in a special large-object structure. Streaming access is useful when "
"working with data values that are too large to manipulate conveniently as a "
"whole."
msgstr ""
"В <productname>PostgreSQL</productname> имеется механизм для работы с "
"<firstterm>большими объектами</firstterm>, предоставляющий доступ в "
"потоковом режиме к пользовательским данным, сохранённым в специальной "
"структуре больших объектов. Потоковый доступ удобен, когда нужно "
"обрабатывать данные, объём которых слишком велик, чтобы оперировать ими как "
"единым целым."

#: lobj.xml:18(para)
msgid ""
"This chapter describes the implementation and the programming and query "
"language interfaces to <productname>PostgreSQL</productname> large object "
"data. We use the <application>libpq</application> C library for the examples "
"in this chapter, but most programming interfaces native to "
"<productname>PostgreSQL</productname> support equivalent functionality. "
"Other interfaces might use the large object interface internally to provide "
"generic support for large values. This is not described here."
msgstr ""
"В этой главе описывается реализация, а также программный интерфейс и функции "
"языка запросов для работы с данными больших объектов "
"<productname>PostgreSQL</productname>. В примерах в этой главе будет "
"использоваться библиотека <application>libpq</application> для языка C, но "
"та же функциональность поддерживается и другими программными интерфейсами "
"<productname>PostgreSQL</productname>. Другие интерфейсы могут использовать "
"внутри себя интерфейс больших объектов для реализации общего подхода к "
"работе с большими значениями. Здесь это не описывается."

#: lobj.xml:30(title)
msgid "Introduction"
msgstr "Введение"

#: lobj.xml:32(indexterm)
msgid "<primary>TOAST</primary><secondary>versus large objects</secondary>"
msgstr ""
"<primary>TOAST</primary><secondary>в сравнении с большими объектами</"
"secondary>"

#: lobj.xml:36(para)
msgid ""
"All large objects are stored in a single system table named <link linkend="
"\"catalog-pg-largeobject\"><structname>pg_largeobject</structname></link>. "
"Each large object also has an entry in the system table <link linkend="
"\"catalog-pg-largeobject-metadata\"><structname>pg_largeobject_metadata</"
"structname></link>. Large objects can be created, modified, and deleted "
"using a read/write API that is similar to standard operations on files."
msgstr ""
"Все большие объекты хранятся в одной системной таблице с именем <link "
"linkend=\"catalog-pg-largeobject\"><structname>pg_largeobject</structname></"
"link>. Для каждого большого объекта также имеется запись в системной таблице "
"<link linkend=\"catalog-pg-largeobject-metadata"
"\"><structname>pg_largeobject_metadata</structname></link>. Большие объекты "
"можно создавать, изменять и удалять, используя API чтения/записи, подобный "
"стандартному API для работы с файлами."

#: lobj.xml:45(para)
msgid ""
"<productname>PostgreSQL</productname> also supports a storage system called "
"<link linkend=\"storage-toast\"><quote><acronym>TOAST</acronym></quote></"
"link>, which automatically stores values larger than a single database page "
"into a secondary storage area per table. This makes the large object "
"facility partially obsolete. One remaining advantage of the large object "
"facility is that it allows values up to 4 TB in size, whereas "
"<acronym>TOAST</acronym>ed fields can be at most 1 GB. Also, reading and "
"updating portions of a large object can be done efficiently, while most "
"operations on a <acronym>TOAST</acronym>ed field will read or write the "
"whole value as a unit."
msgstr ""
"<productname>PostgreSQL</productname> также поддерживает систему хранения, "
"названную <link linkend=\"storage-toast\"><quote><acronym>TOAST</acronym></"
"quote></link>, которая автоматически переносит значения, не умещающиеся в "
"одну страницу таблицы, в дополнительную область хранилища. Вследствие этого "
"подсистема больших объектов отчасти оказывается устаревшей. Однако её "
"преимуществом остаётся то, что она позволяет сохранять значения размером до "
"4 Тбайт, тогда как поля в <acronym>TOAST</acronym> ограничиваются 1 Гбайтом. "
"Кроме того, чтение и изменение больших объектов можно выполнять эффективнее "
"по сравнению с полями <acronym>TOAST</acronym>, которые при большинстве "
"операций считываются и записываются как единое целое."

#: lobj.xml:62(title)
msgid "Implementation Features"
msgstr "Особенности реализации"

#: lobj.xml:64(para)
msgid ""
"The large object implementation breaks large objects up into <quote>chunks</"
"quote> and stores the chunks in rows in the database. A B-tree index "
"guarantees fast searches for the correct chunk number when doing random "
"access reads and writes."
msgstr ""
"Механизм больших объектов разбивает большие объекты на <quote>фрагменты</"
"quote> и сохраняет эти фрагменты в строках таблицы. При произвольном доступе "
"на запись и чтение быстрый поиск нужного фрагмента обеспечивается индексом-B-"
"деревом в этой таблице."

#: lobj.xml:72(para)
msgid ""
"The chunks stored for a large object do not have to be contiguous. For "
"example, if an application opens a new large object, seeks to offset "
"1000000, and writes a few bytes there, this does not result in allocation of "
"1000000 bytes worth of storage; only of chunks covering the range of data "
"bytes actually written. A read operation will, however, read out zeroes for "
"any unallocated locations preceding the last existing chunk. This "
"corresponds to the common behavior of <quote>sparsely allocated</quote> "
"files in <acronym>Unix</acronym> file systems."
msgstr ""
"Фрагменты больших объектов не должны быть последовательными. Например, если "
"приложение откроет новый большой объект, переместится к смещению 1000000 "
"байт и запишет несколько байт, это не приведёт к выделению лишнего 1000000 "
"байт в хранилище; записаны будут только фрагменты, покрывающие диапазон "
"собственно записанных байт. Операция чтения, однако, прочитает нули для всех "
"неразмещённых в хранилище байт, предшествующих последнему записанному "
"фрагменту. Это соответствует принятому поведению <quote>разреженных</quote> "
"файлов в файловых системах <acronym>Unix</acronym>."

#: lobj.xml:83(para)
msgid ""
"As of <productname>PostgreSQL</productname> 9.0, large objects have an owner "
"and a set of access permissions, which can be managed using <xref linkend="
"\"sql-grant\"/> and <xref linkend=\"sql-revoke\"/>. <literal>SELECT</"
"literal> privileges are required to read a large object, and "
"<literal>UPDATE</literal> privileges are required to write or truncate it. "
"Only the large object's owner (or a database superuser) can delete, comment "
"on, or change the owner of a large object. To adjust this behavior for "
"compatibility with prior releases, see the <xref linkend=\"guc-lo-compat-"
"privileges\"/> run-time parameter."
msgstr ""
"Начиная с <productname>PostgreSQL</productname> 9.0, для больших объектов "
"назначается владелец и набор прав доступа, которыми можно управлять "
"командами <xref linkend=\"sql-grant\"/> и <xref linkend=\"sql-revoke\"/>. "
"Для чтения большого объекта требуются права <literal>SELECT</literal>, а для "
"записи или усечения его — права <literal>UPDATE</literal>. Удалять большой "
"объект, задавать комментарий для него, либо сменять его владельца "
"разрешается только его владельцу (или суперпользователю базы данных). Для "
"совместимости с предыдущими версиями можно скорректировать это поведение, "
"изменив параметр времени выполнения <xref linkend=\"guc-lo-compat-privileges"
"\"/>."

#: lobj.xml:100(title)
msgid "Client Interfaces"
msgstr "Клиентские интерфейсы"

#: lobj.xml:102(para)
msgid ""
"This section describes the facilities that <productname>PostgreSQL</"
"productname>'s <application>libpq</application> client interface library "
"provides for accessing large objects. The <productname>PostgreSQL</"
"productname> large object interface is modeled after the <acronym>Unix</"
"acronym> file-system interface, with analogues of <function>open</function>, "
"<function>read</function>, <function>write</function>, <function>lseek</"
"function>, etc."
msgstr ""
"В этом разделе описываются средства, которые предоставляет клиентская "
"библиотека <productname>PostgreSQL</productname> <application>libpq</"
"application> для обращения к большим объектам. Интерфейс работы с большими "
"объектами <productname>PostgreSQL</productname> создан по подобию интерфейса "
"файловых систем <acronym>Unix</acronym>, так что он включает аналоги функций "
"<function>open</function>, <function>read</function>, <function>write</"
"function>, <function>lseek</function> и т. д."

#: lobj.xml:113(para)
msgid ""
"All large object manipulation using these functions <emphasis>must</"
"emphasis> take place within an SQL transaction block, since large object "
"file descriptors are only valid for the duration of a transaction."
msgstr ""
"Все операции с большими объектами с применением этих функций "
"<emphasis>должны</emphasis> иметь место в блоке транзакции SQL, так как "
"дескрипторы больших объектов актуальны только во время транзакции."

#: lobj.xml:120(para)
msgid ""
"If an error occurs while executing any one of these functions, the function "
"will return an otherwise-impossible value, typically 0 or -1. A message "
"describing the error is stored in the connection object and can be retrieved "
"with <function>PQerrorMessage</function>."
msgstr ""
"Если при выполнении одной из этих функций происходит ошибка, эта функция "
"возвращает значение, иначе невозможное, обычно 0 или -1. Сообщение, "
"описывающее ошибку, сохраняется в объекте соединения; получить его можно с "
"помощью <function>PQerrorMessage</function>."

#: lobj.xml:127(para)
msgid ""
"Client applications that use these functions should include the header file "
"<filename>libpq/libpq-fs.h</filename> and link with the <application>libpq</"
"application> library."
msgstr ""
"Клиентские приложения, которые используют эти функции, должны включать "
"заголовочный файл <filename>libpq/libpq-fs.h</filename> и компоноваться с "
"библиотекой <application>libpq</application>."

#: lobj.xml:134(title)
msgid "Creating a Large Object"
msgstr "Создание большого объекта"

#: lobj.xml:137(indexterm) lobj.xml:564(indexterm)
msgid "<primary>lo_creat</primary>"
msgstr "<primary>lo_creat</primary>"

#: lobj.xml:136(para)
msgid ""
"<placeholder-1/> The function <synopsis>Oid lo_creat(PGconn *conn, int mode);"
"</synopsis> creates a new large object. The return value is the OID that was "
"assigned to the new large object, or <symbol>InvalidOid</symbol> (zero) on "
"failure. <replaceable class=\"parameter\">mode</replaceable> is unused and "
"ignored as of <productname>PostgreSQL</productname> 8.1; however, for "
"backward compatibility with earlier releases it is best to set it to "
"<symbol>INV_READ</symbol>, <symbol>INV_WRITE</symbol>, or <symbol>INV_READ</"
"symbol> <literal>|</literal> <symbol>INV_WRITE</symbol>. (These symbolic "
"constants are defined in the header file <filename>libpq/libpq-fs.h</"
"filename>.)"
msgstr ""
"<placeholder-1/> Функция <synopsis>Oid lo_creat(PGconn *conn, int mode);</"
"synopsis> создаёт новый большой объект. Возвращаемым значением будет OID, "
"назначенный новому объекту, либо <symbol>InvalidOid</symbol> (ноль) в случае "
"ошибки. Параметр <replaceable class=\"parameter\">mode</replaceable> не "
"используется и игнорируется, начиная с <productname>PostgreSQL</productname> "
"8.1; однако для обратной совместимости с более ранними выпусками в нём лучше "
"задать значение <symbol>INV_READ</symbol>, <symbol>INV_WRITE</symbol> или "
"<symbol>INV_READ</symbol> <literal>|</literal> <symbol>INV_WRITE</symbol>. "
"(Эти константы определены в заголовочном файле <filename>libpq/libpq-fs.h</"
"filename>.)"

#: lobj.xml:155(programlisting)
#, no-wrap
msgid "inv_oid = lo_creat(conn, INV_READ|INV_WRITE);"
msgstr "inv_oid = lo_creat(conn, INV_READ|INV_WRITE);"

#: lobj.xml:153(para) lobj.xml:178(para) lobj.xml:279(para)
msgid "An example: <placeholder-1/>"
msgstr "Пример: <placeholder-1/>"

#: lobj.xml:159(indexterm)
msgid "<primary>lo_create</primary>"
msgstr "<primary>lo_create</primary>"

#: lobj.xml:158(para)
msgid ""
"<placeholder-1/> The function <synopsis>Oid lo_create(PGconn *conn, Oid "
"lobjId);</synopsis> also creates a new large object. The OID to be assigned "
"can be specified by <replaceable class=\"parameter\">lobjId</replaceable>; "
"if so, failure occurs if that OID is already in use for some large object. "
"If <replaceable class=\"parameter\">lobjId</replaceable> is "
"<symbol>InvalidOid</symbol> (zero) then <function>lo_create</function> "
"assigns an unused OID (this is the same behavior as <function>lo_creat</"
"function>). The return value is the OID that was assigned to the new large "
"object, or <symbol>InvalidOid</symbol> (zero) on failure."
msgstr ""
"<placeholder-1/> Функция <synopsis>Oid lo_create(PGconn *conn, Oid lobjId);</"
"synopsis> также создаёт новый большой объект. В <replaceable class="
"\"parameter\">lobjId</replaceable> можно задать назначаемый ему OID; при "
"этом произойдёт ошибка, если этот OID уже присвоен какому-либо большому "
"объекту. Если в <replaceable class=\"parameter\">lobjId</replaceable> "
"передаётся <symbol>InvalidOid</symbol> (ноль), <function>lo_create</"
"function> присваивает большому объекту свободный OID (так же, как и "
"<function>lo_creat</function>). Возвращаемым значением будет OID, "
"назначенный новому большому объекту, либо <symbol>InvalidOid</symbol> (ноль) "
"в случае ошибки."

#: lobj.xml:172(para)
msgid ""
"<function>lo_create</function> is new as of <productname>PostgreSQL</"
"productname> 8.1; if this function is run against an older server version, "
"it will fail and return <symbol>InvalidOid</symbol>."
msgstr ""
"Функция <function>lo_create</function> появилась в <productname>PostgreSQL</"
"productname> 8.1; если попытаться выполнить её с сервером более старой "
"версии, произойдёт ошибка и будет возвращено <symbol>InvalidOid</symbol>."

#: lobj.xml:180(programlisting)
#, no-wrap
msgid "inv_oid = lo_create(conn, desired_oid);"
msgstr "inv_oid = lo_create(conn, desired_oid);"

#: lobj.xml:185(title)
msgid "Importing a Large Object"
msgstr "Импорт большого объекта"

#: lobj.xml:188(indexterm) lobj.xml:567(indexterm)
msgid "<primary>lo_import</primary>"
msgstr "<primary>lo_import</primary>"

#: lobj.xml:187(para)
msgid ""
"<placeholder-1/> To import an operating system file as a large object, call "
"<synopsis>Oid lo_import(PGconn *conn, const char *filename);</synopsis>\n"
"     <replaceable class=\"parameter\">filename</replaceable> specifies the "
"operating system name of the file to be imported as a large object. The "
"return value is the OID that was assigned to the new large object, or "
"<symbol>InvalidOid</symbol> (zero) on failure. Note that the file is read by "
"the client interface library, not by the server; so it must exist in the "
"client file system and be readable by the client application."
msgstr ""
"<placeholder-1/> Чтобы импортировать в качестве большого объекта файл "
"операционной системы, вызовите <synopsis>Oid lo_import(PGconn *conn, const "
"char *filename);</synopsis>\n"
"     В <replaceable class=\"parameter\">filename</replaceable> задаётся имя "
"файла в операционной системе, который будет импортирован как большой объект. "
"Возвращаемым значением будет OID, назначенный новому большому объекту, либо "
"<symbol>InvalidOid</symbol> (ноль) в случае ошибки. Заметьте, что этот файл "
"читает библиотека клиентского интерфейса, а не сервер; таким образом, он "
"должен существовать в файловой системе на стороне клиента и быть доступным "
"для чтения клиентскому приложению."

#: lobj.xml:202(indexterm)
msgid "<primary>lo_import_with_oid</primary>"
msgstr "<primary>lo_import_with_oid</primary>"

#: lobj.xml:201(para)
msgid ""
"<placeholder-1/> The function <synopsis>Oid lo_import_with_oid(PGconn *conn, "
"const char *filename, Oid lobjId);</synopsis> also imports a new large "
"object. The OID to be assigned can be specified by <replaceable class="
"\"parameter\">lobjId</replaceable>; if so, failure occurs if that OID is "
"already in use for some large object. If <replaceable class=\"parameter"
"\">lobjId</replaceable> is <symbol>InvalidOid</symbol> (zero) then "
"<function>lo_import_with_oid</function> assigns an unused OID (this is the "
"same behavior as <function>lo_import</function>). The return value is the "
"OID that was assigned to the new large object, or <symbol>InvalidOid</"
"symbol> (zero) on failure."
msgstr ""
"<placeholder-1/> Функция <synopsis>Oid lo_import_with_oid(PGconn *conn, "
"const char *filename, Oid lobjId);</synopsis> также импортирует новый "
"большой объект. В <replaceable class=\"parameter\">lobjId</replaceable> "
"можно задать назначаемый ему OID; при этом произойдёт ошибка, если этот OID "
"уже присвоен какому-либо большому объекту. Если в <replaceable class="
"\"parameter\">lobjId</replaceable> передаётся <symbol>InvalidOid</symbol> "
"(ноль), <function>lo_import_with_oid</function> присваивает большому объекту "
"свободный OID (так же, как и <function>lo_import</function>). Возвращаемым "
"значением будет OID, назначенный новому большому объекту, либо "
"<symbol>InvalidOid</symbol> (ноль) в случае ошибки."

#: lobj.xml:215(para)
msgid ""
"<function>lo_import_with_oid</function> is new as of "
"<productname>PostgreSQL</productname> 8.4 and uses <function>lo_create</"
"function> internally which is new in 8.1; if this function is run against "
"8.0 or before, it will fail and return <symbol>InvalidOid</symbol>."
msgstr ""
"Функция <function>lo_import_with_oid</function> появилась в "
"<productname>PostgreSQL</productname> 8.4 и вызывает внутри "
"<function>lo_create</function>, появившуюся в 8.1; если попытаться выполнить "
"её с сервером версии 8.0 или ранней, она завершится ошибкой и возвратит "
"<symbol>InvalidOid</symbol>."

#: lobj.xml:223(title)
msgid "Exporting a Large Object"
msgstr "Экспорт большого объекта"

#: lobj.xml:226(indexterm) lobj.xml:568(indexterm)
msgid "<primary>lo_export</primary>"
msgstr "<primary>lo_export</primary>"

#: lobj.xml:225(para)
msgid ""
"<placeholder-1/> To export a large object into an operating system file, "
"call <synopsis>int lo_export(PGconn *conn, Oid lobjId, const char *filename);"
"</synopsis> The <parameter>lobjId</parameter> argument specifies the OID of "
"the large object to export and the <parameter>filename</parameter> argument "
"specifies the operating system name of the file. Note that the file is "
"written by the client interface library, not by the server. Returns 1 on "
"success, -1 on failure."
msgstr ""
"<placeholder-1/> Чтобы экспортировать большой объект в файл операционной "
"системы, вызовите <synopsis>int lo_export(PGconn *conn, Oid lobjId, const "
"char *filename);</synopsis> В аргументе <parameter>lobjId</parameter> "
"задаётся OID экспортируемого большого объекта, а в аргументе "
"<parameter>filename</parameter> задаётся имя файла в операционной системе. "
"Заметьте, что файл записывается библиотекой клиентского интерфейса, а не "
"сервером. Возвращает 1 при успешном выполнении, -1 при ошибке."

#: lobj.xml:239(title)
msgid "Opening an Existing Large Object"
msgstr "Открытие существующего большого объекта"

#: lobj.xml:242(indexterm)
msgid "<primary>lo_open</primary>"
msgstr "<primary>lo_open</primary>"

#: lobj.xml:241(para)
msgid ""
"<placeholder-1/> To open an existing large object for reading or writing, "
"call <synopsis>int lo_open(PGconn *conn, Oid lobjId, int mode);</synopsis> "
"The <parameter>lobjId</parameter> argument specifies the OID of the large "
"object to open. The <parameter>mode</parameter> bits control whether the "
"object is opened for reading (<symbol>INV_READ</symbol>), writing "
"(<symbol>INV_WRITE</symbol>), or both. (These symbolic constants are defined "
"in the header file <filename>libpq/libpq-fs.h</filename>.) "
"<function>lo_open</function> returns a (non-negative) large object "
"descriptor for later use in <function>lo_read</function>, "
"<function>lo_write</function>, <function>lo_lseek</function>, "
"<function>lo_lseek64</function>, <function>lo_tell</function>, "
"<function>lo_tell64</function>, <function>lo_truncate</function>, "
"<function>lo_truncate64</function>, and <function>lo_close</function>. The "
"descriptor is only valid for the duration of the current transaction. On "
"failure, -1 is returned."
msgstr ""
"<placeholder-1/> Чтобы открыть существующий большой объект для чтения или "
"записи, вызовите <synopsis>int lo_open(PGconn *conn, Oid lobjId, int mode);</"
"synopsis> В аргументе <parameter>lobjId</parameter> задаётся OID "
"открываемого большого объекта. Биты в аргументе <parameter>mode</parameter> "
"определяют, открывается ли файл для чтения (<symbol>INV_READ</symbol>), для "
"записи (<symbol>INV_WRITE</symbol>), либо для чтения/записи. (Эти константы "
"определяются в заголовочном файле <filename>libpq/libpq-fs.h</filename>.) "
"Функция <function>lo_open</function> возвращает дескриптор большого объекта "
"(неотрицательный) для последующего использования в функциях "
"<function>lo_read</function>, <function>lo_write</function>, "
"<function>lo_lseek</function>, <function>lo_lseek64</function>, "
"<function>lo_tell</function>, <function>lo_tell64</function>, "
"<function>lo_truncate</function>, <function>lo_truncate64</function> и "
"<function>lo_close</function>. Этот дескриптор актуален только до завершения "
"текущей транзакции. В случае ошибки возвращается -1."

#: lobj.xml:262(para)
msgid ""
"The server currently does not distinguish between modes <symbol>INV_WRITE</"
"symbol> and <symbol>INV_READ</symbol> <literal>|</literal>\n"
"     <symbol>INV_WRITE</symbol>: you are allowed to read from the descriptor "
"in either case. However there is a significant difference between these "
"modes and <symbol>INV_READ</symbol> alone: with <symbol>INV_READ</symbol> "
"you cannot write on the descriptor, and the data read from it will reflect "
"the contents of the large object at the time of the transaction snapshot "
"that was active when <function>lo_open</function> was executed, regardless "
"of later writes by this or other transactions. Reading from a descriptor "
"opened with <symbol>INV_WRITE</symbol> returns data that reflects all writes "
"of other committed transactions as well as writes of the current "
"transaction. This is similar to the behavior of <literal>REPEATABLE READ</"
"literal> versus <literal>READ COMMITTED</literal> transaction modes for "
"ordinary SQL <command>SELECT</command> commands."
msgstr ""
"В настоящее время сервер не различает режимы <symbol>INV_WRITE</symbol> и "
"<symbol>INV_READ</symbol> <literal>|</literal>\n"
"     <symbol>INV_WRITE</symbol>: с таким дескриптором можно читать данные в "
"любом случае. Однако есть значительное отличие этих режимов от одиночного "
"<symbol>INV_READ</symbol>: с дескриптором <symbol>INV_READ</symbol> "
"записывать данные нельзя, а данные, считываемые через него, будут отражать "
"содержимое большого объекта в снимке транзакции, который был активен при "
"выполнении <function>lo_open</function>, то есть не будут включать "
"изменения, произведённые позже этой или другими транзакциями. При чтении с "
"дескриптором <symbol>INV_WRITE</symbol> возвращаются данные, отражающие все "
"изменения, произведённые другими зафиксированными транзакциями, а также "
"текущей транзакцией. Это подобно различиям режимов <literal>REPEATABLE READ</"
"literal> и <literal>READ COMMITTED</literal> для обычных команд SQL "
"<command>SELECT</command>."

#: lobj.xml:281(programlisting)
#, no-wrap
msgid "inv_fd = lo_open(conn, inv_oid, INV_READ|INV_WRITE);"
msgstr "inv_fd = lo_open(conn, inv_oid, INV_READ|INV_WRITE);"

#: lobj.xml:286(title)
msgid "Writing Data to a Large Object"
msgstr "Запись данных в большой объект"

#: lobj.xml:289(indexterm)
msgid "<primary>lo_write</primary>"
msgstr "<primary>lo_write</primary>"

#: lobj.xml:288(para)
msgid ""
"<placeholder-1/> The function <synopsis>int lo_write(PGconn *conn, int fd, "
"const char *buf, size_t len);</synopsis> writes <parameter>len</parameter> "
"bytes from <parameter>buf</parameter> (which must be of size <parameter>len</"
"parameter>) to large object descriptor <parameter>fd</parameter>. The "
"<parameter>fd</parameter> argument must have been returned by a previous "
"<function>lo_open</function>. The number of bytes actually written is "
"returned (in the current implementation, this will always equal "
"<parameter>len</parameter> unless there is an error). In the event of an "
"error, the return value is -1."
msgstr ""
"<placeholder-1/> Функция <synopsis>int lo_write(PGconn *conn, int fd, const "
"char *buf, size_t len);</synopsis> записывает <parameter>len</parameter> "
"байт из буфера <parameter>buf</parameter> (который должен иметь размер "
"<parameter>len</parameter>) в дескриптор большого объекта <parameter>fd</"
"parameter>. В <parameter>fd</parameter> должно передаваться значение, "
"возвращённое предыдущим вызовом <function>lo_open</function>. Возвращает эта "
"функция число фактически записанных байт (в текущей реализации это всегда "
"<parameter>len</parameter>, если только не произошла ошибка). В случае "
"ошибки возвращается значение -1."

#: lobj.xml:301(para) lobj.xml:326(para)
msgid ""
"Although the <parameter>len</parameter> parameter is declared as "
"<type>size_t</type>, this function will reject length values larger than "
"<literal>INT_MAX</literal>. In practice, it's best to transfer data in "
"chunks of at most a few megabytes anyway."
msgstr ""
"Хотя параметр <parameter>len</parameter> объявлен как <type>size_t</type>, "
"эта функция не принимает значение длины, превышающее <literal>INT_MAX</"
"literal>. На практике всё равно лучше передавать данные фрагментами не "
"больше нескольких мегабайт."

#: lobj.xml:310(title)
msgid "Reading Data from a Large Object"
msgstr "Чтение данных из большого объекта"

#: lobj.xml:313(indexterm)
msgid "<primary>lo_read</primary>"
msgstr "<primary>lo_read</primary>"

#: lobj.xml:312(para)
msgid ""
"<placeholder-1/> The function <synopsis>int lo_read(PGconn *conn, int fd, "
"char *buf, size_t len);</synopsis> reads up to <parameter>len</parameter> "
"bytes from large object descriptor <parameter>fd</parameter> into "
"<parameter>buf</parameter> (which must be of size <parameter>len</"
"parameter>). The <parameter>fd</parameter> argument must have been returned "
"by a previous <function>lo_open</function>. The number of bytes actually "
"read is returned; this will be less than <parameter>len</parameter> if the "
"end of the large object is reached first. In the event of an error, the "
"return value is -1."
msgstr ""
"<placeholder-1/> Функция <synopsis>int lo_read(PGconn *conn, int fd, char "
"*buf, size_t len);</synopsis> читает до <parameter>len</parameter> байт из "
"дескриптора большого объекта <parameter>fd</parameter> в буфер "
"<parameter>buf</parameter> (который должен иметь размер <parameter>len</"
"parameter>). В <parameter>fd</parameter> должно передаваться значение, "
"возвращённое предыдущим вызовом <function>lo_open</function>. Возвращает эта "
"функция число фактически прочитанных байт; это число должно быть меньше "
"<parameter>len</parameter>, если при чтении был достигнут конец объекта. В "
"случае ошибки возвращается -1."

#: lobj.xml:335(title)
msgid "Seeking in a Large Object"
msgstr "Перемещение в большом объекте"

#: lobj.xml:338(indexterm)
msgid "<primary>lo_lseek</primary>"
msgstr "<primary>lo_lseek</primary>"

#: lobj.xml:337(para)
msgid ""
"<placeholder-1/> To change the current read or write location associated "
"with a large object descriptor, call <synopsis>int lo_lseek(PGconn *conn, "
"int fd, int offset, int whence);</synopsis> This function moves the current "
"location pointer for the large object descriptor identified by "
"<parameter>fd</parameter> to the new location specified by "
"<parameter>offset</parameter>. The valid values for <parameter>whence</"
"parameter> are <symbol>SEEK_SET</symbol> (seek from object start), "
"<symbol>SEEK_CUR</symbol> (seek from current position), and "
"<symbol>SEEK_END</symbol> (seek from object end). The return value is the "
"new location pointer, or -1 on error."
msgstr ""
"<placeholder-1/> Чтобы изменить текущее положение чтения или записи, "
"связанное с дескриптором большого объекта, вызовите <synopsis>int "
"lo_lseek(PGconn *conn, int fd, int offset, int whence);</synopsis> Эта "
"функция перемещает указатель текущего положения для дескриптора большого "
"объекта <parameter>fd</parameter> в новое положение, заданное аргументом "
"<parameter>offset</parameter>. Для аргумента <parameter>whence</parameter> "
"задаются значения <symbol>SEEK_SET</symbol> (перемещение от начала объекта), "
"<symbol>SEEK_CUR</symbol> (перемещение от текущего положения) и "
"<symbol>SEEK_END</symbol> (перемещение от конца объекта). Возвращает эта "
"функция новое положение указателя, либо -1 в случае ошибки."

#: lobj.xml:353(indexterm)
msgid "<primary>lo_lseek64</primary>"
msgstr "<primary>lo_lseek64</primary>"

#: lobj.xml:352(para)
msgid ""
"<placeholder-1/> When dealing with large objects that might exceed 2GB in "
"size, instead use <synopsis>pg_int64 lo_lseek64(PGconn *conn, int fd, "
"pg_int64 offset, int whence);</synopsis> This function has the same behavior "
"as <function>lo_lseek</function>, but it can accept an <parameter>offset</"
"parameter> larger than 2GB and/or deliver a result larger than 2GB. Note "
"that <function>lo_lseek</function> will fail if the new location pointer "
"would be greater than 2GB."
msgstr ""
"<placeholder-1/> Оперируя с большими объектами, размер которых превышает 2 "
"ГБ, используйте <synopsis>pg_int64 lo_lseek64(PGconn *conn, int fd, pg_int64 "
"offset, int whence);</synopsis> Эта функция действует так же, как и "
"<function>lo_lseek</function>, но может принять значение <parameter>offset</"
"parameter>, превышающее 2 ГБ, и/или вернуть результат, превышающий 2 ГБ. "
"Заметьте, что если новое положение указателя оказывается за границей в 2ГБ, "
"функция <function>lo_lseek</function> выдаёт ошибку."

#: lobj.xml:365(para)
msgid ""
"<function>lo_lseek64</function> is new as of <productname>PostgreSQL</"
"productname> 9.3. If this function is run against an older server version, "
"it will fail and return -1."
msgstr ""
"Функция <function>lo_lseek64</function> появилась в <productname>PostgreSQL</"
"productname> 9.3. Если попытаться выполнить её с сервером более старой "
"версии, произойдёт ошибка и будет возвращено -1."

#: lobj.xml:374(title)
msgid "Obtaining the Seek Position of a Large Object"
msgstr "Получение текущего положения в большом объекте"

#: lobj.xml:377(indexterm)
msgid "<primary>lo_tell</primary>"
msgstr "<primary>lo_tell</primary>"

#: lobj.xml:376(para)
msgid ""
"<placeholder-1/> To obtain the current read or write location of a large "
"object descriptor, call <synopsis>int lo_tell(PGconn *conn, int fd);</"
"synopsis> If there is an error, the return value is -1."
msgstr ""
"<placeholder-1/> Чтобы получить текущее положение чтения или записи для "
"дескриптора большого объекта, вызовите <synopsis>int lo_tell(PGconn *conn, "
"int fd);</synopsis> Если возникает ошибка, возвращается -1."

#: lobj.xml:385(indexterm)
msgid "<primary>lo_tell64</primary>"
msgstr "<primary>lo_tell64</primary>"

#: lobj.xml:384(para)
msgid ""
"<placeholder-1/> When dealing with large objects that might exceed 2GB in "
"size, instead use <synopsis>pg_int64 lo_tell64(PGconn *conn, int fd);</"
"synopsis> This function has the same behavior as <function>lo_tell</"
"function>, but it can deliver a result larger than 2GB. Note that "
"<function>lo_tell</function> will fail if the current read/write location is "
"greater than 2GB."
msgstr ""
"<placeholder-1/> Оперируя с большими объектами, размер которых может "
"превышать 2 ГБ, используйте <synopsis>pg_int64 lo_tell64(PGconn *conn, int "
"fd);</synopsis> Эта функция действует так же, как <function>lo_tell</"
"function>, но может выдавать результат, превышающий 2 ГБ. Заметьте, что "
"<function>lo_tell</function> выдаёт ошибку, если текущее положение чтения/"
"записи оказывается за границей в 2 ГБ."

#: lobj.xml:396(para)
msgid ""
"<function>lo_tell64</function> is new as of <productname>PostgreSQL</"
"productname> 9.3. If this function is run against an older server version, "
"it will fail and return -1."
msgstr ""
"Функция <function>lo_tell64</function> появилась в <productname>PostgreSQL</"
"productname> 9.3. Если попытаться выполнить её с сервером более старой "
"версии, произойдёт ошибка и будет возвращено -1."

#: lobj.xml:404(title)
msgid "Truncating a Large Object"
msgstr "Усечение большого объекта"

#: lobj.xml:407(indexterm)
msgid "<primary>lo_truncate</primary>"
msgstr "<primary>lo_truncate</primary>"

#: lobj.xml:406(para)
msgid ""
"<placeholder-1/> To truncate a large object to a given length, call "
"<synopsis>int lo_truncate(PGcon *conn, int fd, size_t len);</synopsis> This "
"function truncates the large object descriptor <parameter>fd</parameter> to "
"length <parameter>len</parameter>. The <parameter>fd</parameter> argument "
"must have been returned by a previous <function>lo_open</function>. If "
"<parameter>len</parameter> is greater than the large object's current "
"length, the large object is extended to the specified length with null bytes "
"('\\0'). On success, <function>lo_truncate</function> returns zero. On "
"error, the return value is -1."
msgstr ""
"<placeholder-1/> Чтобы усечь большой объект до требуемой длины, вызовите "
"<synopsis>int lo_truncate(PGcon *conn, int fd, size_t len);</synopsis> Эта "
"функция усекает большой объект с дескриптором <parameter>fd</parameter> до "
"длины <parameter>len</parameter>. В <parameter>fd</parameter> должно "
"передаваться значение, возвращённое предыдущим вызовом <function>lo_open</"
"function>. Если <parameter>len</parameter> превышает текущую длину большого "
"объекта, большой объект расширяется до заданной длины нулевыми байтами "
"('\\0'). В случае успеха <function>lo_truncate</function> возвращает ноль, а "
"при ошибке возвращается -1."

#: lobj.xml:420(para)
msgid ""
"The read/write location associated with the descriptor <parameter>fd</"
"parameter> is not changed."
msgstr ""
"Положение чтения/записи, связанное с дескриптором <parameter>fd</parameter>, "
"при этом не меняется."

#: lobj.xml:425(para)
msgid ""
"Although the <parameter>len</parameter> parameter is declared as "
"<type>size_t</type>, <function>lo_truncate</function> will reject length "
"values larger than <literal>INT_MAX</literal>."
msgstr ""
"Хотя параметр <parameter>len</parameter> объявлен как <type>size_t</type>, "
"<function>lo_truncate</function> не принимает значение длины, превышающее "
"<literal>INT_MAX</literal>."

#: lobj.xml:432(indexterm)
msgid "<primary>lo_truncate64</primary>"
msgstr "<primary>lo_truncate64</primary>"

#: lobj.xml:431(para)
msgid ""
"<placeholder-1/> When dealing with large objects that might exceed 2GB in "
"size, instead use <synopsis>int lo_truncate64(PGcon *conn, int fd, pg_int64 "
"len);</synopsis> This function has the same behavior as "
"<function>lo_truncate</function>, but it can accept a <parameter>len</"
"parameter> value exceeding 2GB."
msgstr ""
"<placeholder-1/> Оперируя с большими объектами, размер которых может "
"превышать 2 ГБ, используйте <synopsis>int lo_truncate64(PGcon *conn, int fd, "
"pg_int64 len);</synopsis> Эта функция действует так же, как "
"<function>lo_truncate</function>, но может принимать значения "
"<parameter>len</parameter>, превышающие 2 ГБ."

#: lobj.xml:441(para)
msgid ""
"<function>lo_truncate</function> is new as of <productname>PostgreSQL</"
"productname> 8.3; if this function is run against an older server version, "
"it will fail and return -1."
msgstr ""
"Функция <function>lo_truncate</function> появилась в "
"<productname>PostgreSQL</productname> 8.3; если попытаться выполнить её с "
"сервером более старой версии, произойдёт ошибка и будет возвращено -1."

#: lobj.xml:447(para)
msgid ""
"<function>lo_truncate64</function> is new as of <productname>PostgreSQL</"
"productname> 9.3; if this function is run against an older server version, "
"it will fail and return -1."
msgstr ""
"Функция <function>lo_truncate64</function> появилась в "
"<productname>PostgreSQL</productname> 9.3; если попытаться выполнить её с "
"сервером более старой версии, произойдёт ошибка и будет возвращено -1."

#: lobj.xml:455(title)
msgid "Closing a Large Object Descriptor"
msgstr "Закрытие дескриптора большого объекта"

#: lobj.xml:458(indexterm)
msgid "<primary>lo_close</primary>"
msgstr "<primary>lo_close</primary>"

#: lobj.xml:457(para)
msgid ""
"<placeholder-1/> A large object descriptor can be closed by calling "
"<synopsis>int lo_close(PGconn *conn, int fd);</synopsis> where "
"<parameter>fd</parameter> is a large object descriptor returned by "
"<function>lo_open</function>. On success, <function>lo_close</function> "
"returns zero. On error, the return value is -1."
msgstr ""
"<placeholder-1/> Дескриптор большого объекта можно закрыть, вызвав "
"<synopsis>int lo_close(PGconn *conn, int fd);</synopsis> Здесь "
"<parameter>fd</parameter> — дескриптор большого объекта, возвращённый "
"функцией <function>lo_open</function>. В случае успеха <function>lo_close</"
"function> возвращает ноль. При ошибке возвращается -1."

#: lobj.xml:467(para)
msgid ""
"Any large object descriptors that remain open at the end of a transaction "
"will be closed automatically."
msgstr ""
"Все дескрипторы больших объектов, остающиеся открытыми в конце транзакции, "
"закрываются автоматически."

#: lobj.xml:474(title)
msgid "Removing a Large Object"
msgstr "Удаление большого объекта"

#: lobj.xml:477(indexterm) lobj.xml:566(indexterm)
msgid "<primary>lo_unlink</primary>"
msgstr "<primary>lo_unlink</primary>"

#: lobj.xml:476(para)
msgid ""
"<placeholder-1/> To remove a large object from the database, call "
"<synopsis>int lo_unlink(PGconn *conn, Oid lobjId);</synopsis> The "
"<parameter>lobjId</parameter> argument specifies the OID of the large object "
"to remove. Returns 1 if successful, -1 on failure."
msgstr ""
"<placeholder-1/> Чтобы удалить большой объект из базы данных, вызовите "
"<synopsis>int lo_unlink(PGconn *conn, Oid lobjId);</synopsis> В аргументе "
"<parameter>lobjId</parameter> задаётся OID большого объекта, который нужно "
"удалить. В случае успеха возвращается 1, а в случае ошибки -1."

#: lobj.xml:488(title)
msgid "Server-side Functions"
msgstr "Серверные функции"

#: lobj.xml:490(para)
msgid ""
"Server-side functions tailored for manipulating large objects from SQL are "
"listed in <xref linkend=\"lo-funcs-table\"/>."
msgstr ""
"Функции, предназначенные для работы с большими объектами на стороне сервера "
"из SQL, перечислены в <xref remap=\"6\" linkend=\"lo-funcs-table\"/>."

#: lobj.xml:496(title)
msgid "SQL-oriented Large Object Functions"
msgstr "SQL-ориентированные функции для работы с большими объектами"

#: lobj.xml:500(entry)
msgid "Function"
msgstr "Функция"

#: lobj.xml:501(entry)
msgid "Return Type"
msgstr "Тип результата"

#: lobj.xml:502(entry)
msgid "Description"
msgstr "Описание"

#: lobj.xml:503(entry)
msgid "Example"
msgstr "Пример"

#: lobj.xml:504(entry)
msgid "Result"
msgstr "Результат"

#: lobj.xml:511(indexterm)
msgid "<primary>lo_from_bytea</primary>"
msgstr "<primary>lo_from_bytea</primary>"

#: lobj.xml:514(parameter) lobj.xml:530(parameter) lobj.xml:545(parameter)
msgid "loid"
msgstr "loid"

#: lobj.xml:514(type) lobj.xml:516(type) lobj.xml:530(type) lobj.xml:545(type)
msgid "oid"
msgstr "oid"

#: lobj.xml:514(parameter)
msgid "string"
msgstr "string"

#: lobj.xml:514(type) lobj.xml:530(type) lobj.xml:547(type)
msgid "bytea"
msgstr "bytea"

#: lobj.xml:514(function)
msgid ""
"lo_from_bytea(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"lo_from_bytea(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: lobj.xml:517(entry)
msgid ""
"Create a large object and store data there, returning its OID. Pass "
"<literal>0</literal> to have the system choose an OID."
msgstr ""
"Создаёт большой объект, сохраняет в нём данные и возвращает его OID. С "
"<literal>0</literal> система выбирает OID сама."

#: lobj.xml:521(literal)
msgid "lo_from_bytea(0, E'\\\\xffffff00')"
msgstr "lo_from_bytea(0, E'\\\\xffffff00')"

#: lobj.xml:522(literal)
msgid "24528"
msgstr "24528"

#: lobj.xml:527(indexterm)
msgid "<primary>lo_put</primary>"
msgstr "<primary>lo_put</primary>"

#: lobj.xml:530(parameter)
msgid "offset"
msgstr "offset"

#: lobj.xml:530(type) lobj.xml:545(type)
msgid "bigint"
msgstr "bigint"

#: lobj.xml:530(parameter)
msgid "str"
msgstr "str"

#: lobj.xml:530(function)
msgid ""
"lo_put(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>, "
"<placeholder-5/> <placeholder-6/>)"
msgstr ""
"lo_put(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>, "
"<placeholder-5/> <placeholder-6/>)"

#: lobj.xml:532(type)
msgid "void"
msgstr "void"

#: lobj.xml:533(entry)
msgid "Write data at the given offset."
msgstr "Записывает данные по заданному смещению."

#: lobj.xml:536(literal)
msgid "lo_put(24528, 1, E'\\\\xaa')"
msgstr "lo_put(24528, 1, E'\\\\xaa')"

#: lobj.xml:542(indexterm)
msgid "<primary>lo_get</primary>"
msgstr "<primary>lo_get</primary>"

#: lobj.xml:545(parameter)
msgid "from"
msgstr "from"

#: lobj.xml:545(parameter)
msgid "for"
msgstr "for"

#: lobj.xml:545(type)
msgid "int"
msgstr "int"

#: lobj.xml:545(optional)
msgid ", <placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>"
msgstr ", <placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>"

#: lobj.xml:545(function)
msgid "lo_get(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "lo_get(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: lobj.xml:548(entry)
msgid "Extract contents or a substring thereof."
msgstr "Извлекает содержимое подстроки."

#: lobj.xml:551(literal)
msgid "lo_get(24528, 0, 3)"
msgstr "lo_get(24528, 0, 3)"

#: lobj.xml:552(literal)
msgid "\\xffaaff"
msgstr "\\xffaaff"

#: lobj.xml:571(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE image (\n"
"    name            text,\n"
"    raster          oid\n"
");\n"
"\n"
"SELECT lo_creat(-1);       -- returns OID of new, empty large object\n"
"\n"
"SELECT lo_create(43213);   -- attempts to create large object with OID 43213\n"
"\n"
"SELECT lo_unlink(173454);  -- deletes large object with OID 173454\n"
"\n"
"INSERT INTO image (name, raster)\n"
"    VALUES ('beautiful image', lo_import('/etc/motd'));\n"
"\n"
"INSERT INTO image (name, raster)  -- same as above, but specify OID to use\n"
"    VALUES ('beautiful image', lo_import('/etc/motd', 68583));\n"
"\n"
"SELECT lo_export(image.raster, '/tmp/motd') FROM image\n"
"    WHERE name = 'beautiful image';"
msgstr ""
"CREATE TABLE image (\n"
"    name            text,\n"
"    raster          oid\n"
");\n"
"\n"
"SELECT lo_creat(-1);       -- возвращает OID нового пустого большого объекта\n"
"\n"
"SELECT lo_create(43213);   -- пытается создать большой объект с OID 43213\n"
"\n"
"SELECT lo_unlink(173454);  -- удаляет большой объект с OID 173454\n"
"\n"
"INSERT INTO image (name, raster)\n"
"    VALUES ('beautiful image', lo_import('/etc/motd'));\n"
"\n"
"INSERT INTO image (name, raster)  -- то же, что выше, но с предопределённым OID\n"
"    VALUES ('beautiful image', lo_import('/etc/motd', 68583));\n"
"\n"
"SELECT lo_export(image.raster, '/tmp/motd') FROM image\n"
"    WHERE name = 'beautiful image';"

#: lobj.xml:559(para)
msgid ""
"There are additional server-side functions corresponding to each of the "
"client-side functions described earlier; indeed, for the most part the "
"client-side functions are simply interfaces to the equivalent server-side "
"functions. The ones just as convenient to call via SQL commands are "
"<function>lo_creat</function><placeholder-1/>, <function>lo_create</"
"function>, <function>lo_unlink</function><placeholder-2/>, "
"<function>lo_import</function><placeholder-3/>, and <function>lo_export</"
"function><placeholder-4/>. Here are examples of their use: <placeholder-5/>"
msgstr ""
"Каждой из клиентских функций, описанных ранее, соответствуют дополнительные "
"функции на стороне сервера; на самом деле, по большей части клиентские "
"функции представляют собой просто интерфейсы к равнозначным серверным "
"функциям. К функциям, которые так же удобно вызывать командами SQL, "
"относятся: <function>lo_creat</function><placeholder-1/>, "
"<function>lo_create</function>, <function>lo_unlink</function><placeholder-2/"
">, <function>lo_import</function><placeholder-3/> и <function>lo_export</"
"function><placeholder-4/>. Ниже приведены примеры их использования: "
"<placeholder-5/>"

#: lobj.xml:592(para)
msgid ""
"The server-side <function>lo_import</function> and <function>lo_export</"
"function> functions behave considerably differently from their client-side "
"analogs. These two functions read and write files in the server's file "
"system, using the permissions of the database's owning user. Therefore, "
"their use is restricted to superusers. In contrast, the client-side import "
"and export functions read and write files in the client's file system, using "
"the permissions of the client program. The client-side functions do not "
"require superuser privilege."
msgstr ""
"Серверные функции <function>lo_import</function> и <function>lo_export</"
"function> значительно отличаются от их аналогов, выполняемых на стороне "
"клиента. Эти две функции читают и пишут файлы в файловой системе сервера, с "
"правами пользователя, владеющего базами данных. Поэтому использовать их "
"разрешено только суперпользователям. Клиентские функции импорта и экспорта, "
"напротив, читают и пишут файлы в файловой системе клиента, с правами "
"клиентской программы. Для выполнения клиентских функций права "
"суперпользователя не требуются."

#: lobj.xml:603(para)
msgid ""
"The functionality of <function>lo_read</function> and <function>lo_write</"
"function> is also available via server-side calls, but the names of the "
"server-side functions differ from the client side interfaces in that they do "
"not contain underscores. You must call these functions as <function>loread</"
"function> and <function>lowrite</function>."
msgstr ""
"Функциональность <function>lo_read</function> и <function>lo_write</"
"function> также представляется через вызовы на стороне сервера, но имена "
"серверных функций, в отличие от клиентских, не содержат символы "
"подчёркивания. Эти функции нужно вызывать по именам <function>loread</"
"function> и <function>lowrite</function>."

#: lobj.xml:614(title)
msgid "Example Program"
msgstr "Пример программы"

#: lobj.xml:616(para)
msgid ""
"<xref linkend=\"lo-example\"/> is a sample program which shows how the large "
"object interface in <application>libpq</application> can be used. Parts of "
"the program are commented out but are left in the source for the reader's "
"benefit. This program can also be found in <filename>src/test/examples/"
"testlo.c</filename> in the source distribution."
msgstr ""
"В <xref remap=\"6\" linkend=\"lo-example\"/> представлена пробная программа, "
"демонстрирующая использование интерфейса больших объектов в "
"<application>libpq</application>. Части этой программы закомментированы, но "
"оставлены в тексте для читателя. Эту программу также можно найти в "
"<filename>src/test/examples/testlo.c</filename> в дистрибутиве исходного "
"кода."

#: lobj.xml:626(title)
msgid "Large Objects with <application>libpq</application> Example Program"
msgstr ""
"Пример использования больших объектов с применением <application>libpq</"
"application>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: lobj.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
