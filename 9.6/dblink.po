# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-09 11:01+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: dblink.xml:5(title)
msgctxt "title"
msgid "dblink"
msgstr "dblink"

#: dblink.xml:7(indexterm) dblink.xml:309(indexterm)
msgid "<primary>dblink</primary>"
msgstr "<primary>dblink</primary>"

#: dblink.xml:11(para)
msgid ""
"<filename>dblink</filename> is a module that supports connections to other "
"<productname>PostgreSQL</productname> databases from within a database "
"session."
msgstr ""
"Модуль <filename>dblink</filename> обеспечивает подключения к другим базам "
"данных <productname>PostgreSQL</productname> из сеанса базы данных."

#: dblink.xml:17(para)
msgid ""
"See also <xref linkend=\"postgres-fdw\"/>, which provides roughly the same "
"functionality using a more modern and standards-compliant infrastructure."
msgstr ""
"См. также описание модуля <xref linkend=\"postgres-fdw\"/>, который "
"предоставляет примерно ту же функциональность, но через более современную и "
"стандартизированную инфраструктуру."

#: dblink.xml:23(indexterm)
msgid "<primary>dblink_connect</primary>"
msgstr "<primary>dblink_connect</primary>"

#: dblink.xml:28(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_connect"
msgstr "dblink_connect"

#: dblink.xml:29(manvolnum) dblink.xml:189(manvolnum) dblink.xml:244(manvolnum)
#: dblink.xml:315(manvolnum) dblink.xml:525(manvolnum)
#: dblink.xml:658(manvolnum) dblink.xml:778(manvolnum)
#: dblink.xml:927(manvolnum) dblink.xml:1034(manvolnum)
#: dblink.xml:1075(manvolnum) dblink.xml:1134(manvolnum)
#: dblink.xml:1212(manvolnum) dblink.xml:1271(manvolnum)
#: dblink.xml:1349(manvolnum) dblink.xml:1509(manvolnum)
#: dblink.xml:1573(manvolnum) dblink.xml:1659(manvolnum)
#: dblink.xml:1790(manvolnum) dblink.xml:1904(manvolnum)
msgid "3"
msgstr "3"

#: dblink.xml:33(refname)
msgctxt "refname"
msgid "dblink_connect"
msgstr "dblink_connect"

#: dblink.xml:34(refpurpose)
msgid "opens a persistent connection to a remote database"
msgstr "открывает постоянное подключение к удалённой базе данных"

#: dblink.xml:38(synopsis)
#, no-wrap
msgid ""
"dblink_connect(text connstr) returns text\n"
"dblink_connect(text connname, text connstr) returns text"
msgstr ""
"dblink_connect(text connstr) returns text\n"
"dblink_connect(text connname, text connstr) returns text"

#: dblink.xml:43(title) dblink.xml:203(title) dblink.xml:258(title)
#: dblink.xml:330(title) dblink.xml:540(title) dblink.xml:672(title)
#: dblink.xml:792(title) dblink.xml:941(title) dblink.xml:1047(title)
#: dblink.xml:1088(title) dblink.xml:1147(title) dblink.xml:1225(title)
#: dblink.xml:1285(title) dblink.xml:1362(title) dblink.xml:1522(title)
#: dblink.xml:1588(title) dblink.xml:1679(title) dblink.xml:1808(title)
#: dblink.xml:1923(title)
msgid "Description"
msgstr "Описание"

#: dblink.xml:45(para)
msgid ""
"<function>dblink_connect()</function> establishes a connection to a remote "
"<productname>PostgreSQL</productname> database. The server and database to "
"be contacted are identified through a standard <application>libpq</"
"application> connection string. Optionally, a name can be assigned to the "
"connection. Multiple named connections can be open at once, but only one "
"unnamed connection is permitted at a time. The connection will persist until "
"closed or until the database session is ended."
msgstr ""
"Функция <function>dblink_connect()</function> устанавливает подключение к "
"удалённой базе данных <productname>PostgreSQL</productname>. Целевой сервер "
"и база данных указываются в стандартной строке подключения "
"<application>libpq</application>. Если требуется, этому подключению можно "
"назначить имя. В один момент времени могут быть открытыми несколько "
"именованных подключений, но только одно подключение без имени. Подключение "
"будет сохраняться, пока не будет закрыто или до завершения сеанса базы "
"данных."

#: dblink.xml:55(para)
msgid ""
"The connection string may also be the name of an existing foreign server. It "
"is recommended to use the foreign-data wrapper <literal>dblink_fdw</literal> "
"when defining the foreign server. See the example below, as well as <xref "
"linkend=\"sql-createserver\"/> and <xref linkend=\"sql-createusermapping\"/>."
msgstr ""
"В строке подключения также может задаваться имя существующего стороннего "
"сервера. Для определения стороннего сервера рекомендуется использовать "
"обёртку сторонних данных <literal>dblink_fdw</literal>. См. пример ниже, а "
"также <xref remap=\"4\" linkend=\"sql-createserver\"/> и <xref remap=\"4\" "
"linkend=\"sql-createusermapping\"/>."

#: dblink.xml:67(title) dblink.xml:268(title) dblink.xml:347(title)
#: dblink.xml:557(title) dblink.xml:682(title) dblink.xml:801(title)
#: dblink.xml:950(title) dblink.xml:1097(title) dblink.xml:1166(title)
#: dblink.xml:1233(title) dblink.xml:1298(title) dblink.xml:1373(title)
#: dblink.xml:1536(title) dblink.xml:1598(title) dblink.xml:1693(title)
#: dblink.xml:1819(title) dblink.xml:1940(title)
msgid "Arguments"
msgstr "Аргументы"

#: dblink.xml:71(parameter) dblink.xml:272(parameter) dblink.xml:351(parameter)
#: dblink.xml:561(parameter) dblink.xml:686(parameter)
#: dblink.xml:805(parameter) dblink.xml:954(parameter)
#: dblink.xml:1101(parameter) dblink.xml:1170(parameter)
#: dblink.xml:1237(parameter) dblink.xml:1302(parameter)
#: dblink.xml:1377(parameter) dblink.xml:1540(parameter)
msgid "connname"
msgstr "connname"

#: dblink.xml:73(para)
msgid ""
"The name to use for this connection; if omitted, an unnamed connection is "
"opened, replacing any existing unnamed connection."
msgstr ""
"Имя, назначаемое этому подключению; если опускается, открывается безымянное "
"подключение, заменяющее ранее существующее безымянное подключение."

#: dblink.xml:81(parameter) dblink.xml:361(parameter) dblink.xml:571(parameter)
msgid "connstr"
msgstr "connstr"

#: dblink.xml:83(para)
msgid ""
"<application>libpq</application>-style connection info string, for example "
"<literal>hostaddr=127.0.0.1 port=5432 dbname=mydb user=postgres "
"password=mypasswd</literal>. For details see <xref linkend=\"libpq-connstring"
"\"/>. Alternatively, the name of a foreign server."
msgstr ""
"Строка подключения в стиле <application>libpq</application>, например "
"<literal>hostaddr=127.0.0.1 port=5432 dbname=mydb user=postgres "
"password=mypasswd</literal>. За подробностями обратитесь к <xref remap=\"3\" "
"linkend=\"libpq-connstring\"/>. В ней также может задаваться имя стороннего "
"сервера."

#: dblink.xml:95(title) dblink.xml:283(title) dblink.xml:395(title)
#: dblink.xml:606(title) dblink.xml:729(title) dblink.xml:849(title)
#: dblink.xml:987(title) dblink.xml:1056(title) dblink.xml:1112(title)
#: dblink.xml:1191(title) dblink.xml:1248(title) dblink.xml:1313(title)
#: dblink.xml:1400(title) dblink.xml:1551(title) dblink.xml:1617(title)
#: dblink.xml:1753(title) dblink.xml:1867(title) dblink.xml:2000(title)
msgid "Return Value"
msgstr "Возвращаемое значение"

#: dblink.xml:97(para) dblink.xml:285(para)
msgid ""
"Returns status, which is always <literal>OK</literal> (since any error "
"causes the function to throw an error instead of returning)."
msgstr ""
"Возвращает состояние (это всегда строка <literal>OK</literal>, так как в "
"случае любой ошибки функция прерывается, выдавая исключение)."

#: dblink.xml:104(title) dblink.xml:429(title) dblink.xml:737(title)
#: dblink.xml:859(title) dblink.xml:995(title) dblink.xml:1419(title)
#: dblink.xml:1759(title) dblink.xml:1873(title) dblink.xml:2006(title)
msgid "Notes"
msgstr "Замечания"

#: dblink.xml:106(para)
msgid ""
"Only superusers may use <function>dblink_connect</function> to create non-"
"password-authenticated connections. If non-superusers need this capability, "
"use <function>dblink_connect_u</function> instead."
msgstr ""
"Создавать подключения, не требующие аутентификации по паролю, с помощью "
"<function>dblink_connect</function> разрешено только суперпользователям. "
"Если эта возможность нужна обычным пользователям, следует воспользоваться "
"функцией <function>dblink_connect_u</function>."

#: dblink.xml:112(para)
msgid ""
"It is unwise to choose connection names that contain equal signs, as this "
"opens a risk of confusion with connection info strings in other "
"<filename>dblink</filename> functions."
msgstr ""
"Использовать в именах подключений знаки &laquo;равно&raquo; не "
"рекомендуется, так как при этом возможна путаница со строками подключений в "
"других функциях <filename>dblink</filename>."

#: dblink.xml:120(title) dblink.xml:292(title) dblink.xml:446(title)
#: dblink.xml:614(title) dblink.xml:755(title) dblink.xml:872(title)
#: dblink.xml:1005(title) dblink.xml:1062(title) dblink.xml:1121(title)
#: dblink.xml:1199(title) dblink.xml:1258(title) dblink.xml:1318(title)
#: dblink.xml:1443(title) dblink.xml:1560(title) dblink.xml:1632(title)
#: dblink.xml:1773(title) dblink.xml:1887(title) dblink.xml:2020(title)
msgid "Examples"
msgstr "Примеры"

#: dblink.xml:122(screen)
#, no-wrap
msgid ""
"SELECT dblink_connect('dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_connect('myconn', 'dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"-- FOREIGN DATA WRAPPER functionality\n"
"-- Note: local connection must require password authentication for this to work properly\n"
"--       Otherwise, you will receive the following error from dblink_connect():\n"
"--       ----------------------------------------------------------------------\n"
"--       ERROR:  password is required\n"
"--       DETAIL:  Non-superuser cannot connect if the server does not request a password.\n"
"--       HINT:  Target server's authentication method must be changed.\n"
"\n"
"CREATE SERVER fdtest FOREIGN DATA WRAPPER dblink_fdw OPTIONS (hostaddr '127.0.0.1', dbname 'contrib_regression');\n"
"\n"
"CREATE USER regress_dblink_user WITH PASSWORD 'secret';\n"
"CREATE USER MAPPING FOR regress_dblink_user SERVER fdtest OPTIONS (user 'regress_dblink_user', password 'secret');\n"
"GRANT USAGE ON FOREIGN SERVER fdtest TO regress_dblink_user;\n"
"GRANT SELECT ON TABLE foo TO regress_dblink_user;\n"
"\n"
"\\set ORIGINAL_USER :USER\n"
"\\c - regress_dblink_user\n"
"SELECT dblink_connect('myconn', 'fdtest');\n"
" dblink_connect \n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT * FROM dblink('myconn','SELECT * FROM foo') AS t(a int, b text, c text[]);\n"
" a  | b |       c       \n"
"----+---+---------------\n"
"  0 | a | {a0,b0,c0}\n"
"  1 | b | {a1,b1,c1}\n"
"  2 | c | {a2,b2,c2}\n"
"  3 | d | {a3,b3,c3}\n"
"  4 | e | {a4,b4,c4}\n"
"  5 | f | {a5,b5,c5}\n"
"  6 | g | {a6,b6,c6}\n"
"  7 | h | {a7,b7,c7}\n"
"  8 | i | {a8,b8,c8}\n"
"  9 | j | {a9,b9,c9}\n"
" 10 | k | {a10,b10,c10}\n"
"(11 rows)\n"
"\n"
"\\c - :ORIGINAL_USER\n"
"REVOKE USAGE ON FOREIGN SERVER fdtest FROM regress_dblink_user;\n"
"REVOKE SELECT ON TABLE foo FROM regress_dblink_user;\n"
"DROP USER MAPPING FOR regress_dblink_user SERVER fdtest;\n"
"DROP USER regress_dblink_user;\n"
"DROP SERVER fdtest;"
msgstr ""
"SELECT dblink_connect('dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_connect('myconn', 'dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"-- Функциональность обёртки сторонних данных (FOREIGN DATA WRAPPER)\n"
"-- Замечание: чтобы это работало, для локальных подключений требуется аутентификация по паролю\n"
"--       В противном случае, вызвав dblink_connect(), вы получите:\n"
"--       ----------------------------------------------------------------------\n"
"--       ERROR:  password is required\n"
"--       DETAIL:  Non-superuser cannot connect if the server does not request a password.\n"
"--       HINT:  Target server's authentication method must be changed.\n"
"--\n"
"--       ОШИБКА:  требуется пароль\n"
"--       ПОДРОБНОСТИ:  Обычный пользователь не может подключиться, если сервер не требует пароль.\n"
"--       ПОДСКАЗКА:  Необходимо изменить метод аутентификации целевого сервера.\n"
"\n"
"CREATE SERVER fdtest FOREIGN DATA WRAPPER dblink_fdw OPTIONS (hostaddr '127.0.0.1', dbname 'contrib_regression');\n"
"\n"
"CREATE USER regress_dblink_user WITH PASSWORD 'secret';\n"
"CREATE USER MAPPING FOR regress_dblink_user SERVER fdtest OPTIONS (user 'regress_dblink_user', password 'secret');\n"
"GRANT USAGE ON FOREIGN SERVER fdtest TO regress_dblink_user;\n"
"GRANT SELECT ON TABLE foo TO regress_dblink_user;\n"
"\n"
"\\set ORIGINAL_USER :USER\n"
"\\c - regress_dblink_user\n"
"SELECT dblink_connect('myconn', 'fdtest');\n"
" dblink_connect \n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT * FROM dblink('myconn','SELECT * FROM foo') AS t(a int, b text, c text[]);\n"
" a  | b |       c       \n"
"----+---+---------------\n"
"  0 | a | {a0,b0,c0}\n"
"  1 | b | {a1,b1,c1}\n"
"  2 | c | {a2,b2,c2}\n"
"  3 | d | {a3,b3,c3}\n"
"  4 | e | {a4,b4,c4}\n"
"  5 | f | {a5,b5,c5}\n"
"  6 | g | {a6,b6,c6}\n"
"  7 | h | {a7,b7,c7}\n"
"  8 | i | {a8,b8,c8}\n"
"  9 | j | {a9,b9,c9}\n"
" 10 | k | {a10,b10,c10}\n"
"(11 rows)\n"
"\n"
"\\c - :ORIGINAL_USER\n"
"REVOKE USAGE ON FOREIGN SERVER fdtest FROM regress_dblink_user;\n"
"REVOKE SELECT ON TABLE foo FROM regress_dblink_user;\n"
"DROP USER MAPPING FOR regress_dblink_user SERVER fdtest;\n"
"DROP USER regress_dblink_user;\n"
"DROP SERVER fdtest;"

#: dblink.xml:183(indexterm)
msgid "<primary>dblink_connect_u</primary>"
msgstr "<primary>dblink_connect_u</primary>"

#: dblink.xml:188(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_connect_u"
msgstr "dblink_connect_u"

#: dblink.xml:193(refname)
msgctxt "refname"
msgid "dblink_connect_u"
msgstr "dblink_connect_u"

#: dblink.xml:194(refpurpose)
msgid "opens a persistent connection to a remote database, insecurely"
msgstr "открывает постоянное подключение к удалённой базе данных, небезопасно"

#: dblink.xml:198(synopsis)
#, no-wrap
msgid ""
"dblink_connect_u(text connstr) returns text\n"
"dblink_connect_u(text connname, text connstr) returns text"
msgstr ""
"dblink_connect_u(text connstr) returns text\n"
"dblink_connect_u(text connname, text connstr) returns text"

#: dblink.xml:205(para)
msgid ""
"<function>dblink_connect_u()</function> is identical to "
"<function>dblink_connect()</function>, except that it will allow non-"
"superusers to connect using any authentication method."
msgstr ""
"Функция <function>dblink_connect_u()</function> не отличается от "
"<function>dblink_connect()</function>, за исключением того, что она "
"позволяет подключаться с любым методом аутентификации обычным пользователям."

#: dblink.xml:211(para)
msgid ""
"If the remote server selects an authentication method that does not involve "
"a password, then impersonation and subsequent escalation of privileges can "
"occur, because the session will appear to have originated from the user as "
"which the local <productname>PostgreSQL</productname> server runs. Also, "
"even if the remote server does demand a password, it is possible for the "
"password to be supplied from the server environment, such as a <filename>~/."
"pgpass</filename> file belonging to the server's user. This opens not only a "
"risk of impersonation, but the possibility of exposing a password to an "
"untrustworthy remote server. Therefore, <function>dblink_connect_u()</"
"function> is initially installed with all privileges revoked from "
"<literal>PUBLIC</literal>, making it un-callable except by superusers. In "
"some situations it may be appropriate to grant <literal>EXECUTE</literal> "
"permission for <function>dblink_connect_u()</function> to specific users who "
"are considered trustworthy, but this should be done with care. It is also "
"recommended that any <filename>~/.pgpass</filename> file belonging to the "
"server's user <emphasis>not</emphasis> contain any records specifying a "
"wildcard host name."
msgstr ""
"Если удалённый сервер выбирает режим аутентификации без пароля, возможно "
"олицетворение и последующее повышение привилегий, так как сеанс будет "
"установлен от имени пользователя, который исполняет локальный процесс "
"<productname>PostgreSQL</productname>. Кроме того, даже если удалённый "
"сервер запрашивает пароль, этот пароль можно получить из среды сервера, "
"например, из файла <filename>~/.pgpass</filename>, принадлежащего "
"пользователю сервера. Это чревато не только олицетворением, но и выдачей "
"пароля не заслуживающему доверия удалённому серверу. Поэтому "
"<function>dblink_connect_u()</function> изначально устанавливается так, что "
"роль <literal>PUBLIC</literal> лишена всех прав на её использование, то есть "
"вызывать её могут только суперпользователи. В некоторых ситуациях допустимо "
"дать право <literal>EXECUTE</literal> для <function>dblink_connect_u()</"
"function> определённым пользователям, которым можно доверять, но это нужно "
"делать осторожно. Также рекомендуется убедиться в том, что файл <filename>~/."
"pgpass</filename>, принадлежащий пользователю сервера, <emphasis>не</"
"emphasis> содержит никаких записей со звёздочкой в качестве имени узла."

#: dblink.xml:231(para)
msgid "For further details see <function>dblink_connect()</function>."
msgstr ""
"За дополнительными подробностями обратитесь к описанию "
"<function>dblink_connect()</function>."

#: dblink.xml:238(indexterm)
msgid "<primary>dblink_disconnect</primary>"
msgstr "<primary>dblink_disconnect</primary>"

#: dblink.xml:243(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_disconnect"
msgstr "dblink_disconnect"

#: dblink.xml:248(refname)
msgctxt "refname"
msgid "dblink_disconnect"
msgstr "dblink_disconnect"

#: dblink.xml:249(refpurpose)
msgid "closes a persistent connection to a remote database"
msgstr "закрывает постоянное подключение к удалённой базе данных"

#: dblink.xml:253(synopsis)
#, no-wrap
msgid ""
"dblink_disconnect() returns text\n"
"dblink_disconnect(text connname) returns text"
msgstr ""
"dblink_disconnect() returns text\n"
"dblink_disconnect(text connname) returns text"

#: dblink.xml:260(para)
msgid ""
"<function>dblink_disconnect()</function> closes a connection previously "
"opened by <function>dblink_connect()</function>. The form with no arguments "
"closes an unnamed connection."
msgstr ""
"<function>dblink_disconnect()</function> закрывает подключение, ранее "
"открытое функцией <function>dblink_connect()</function>. Форма без "
"аргументов закрывает безымянное подключение."

#: dblink.xml:274(para)
msgid "The name of a named connection to be closed."
msgstr "Имя закрываемого именованного подключения."

#: dblink.xml:294(screen)
#, no-wrap
msgid ""
"SELECT dblink_disconnect();\n"
" dblink_disconnect\n"
"-------------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_disconnect('myconn');\n"
" dblink_disconnect\n"
"-------------------\n"
" OK\n"
"(1 row)"
msgstr ""
"SELECT dblink_disconnect();\n"
" dblink_disconnect\n"
"-------------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_disconnect('myconn');\n"
" dblink_disconnect\n"
"-------------------\n"
" OK\n"
"(1 row)"

#: dblink.xml:314(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink"
msgstr "dblink"

#: dblink.xml:319(refname)
msgctxt "refname"
msgid "dblink"
msgstr "dblink"

#: dblink.xml:320(refpurpose)
msgid "executes a query in a remote database"
msgstr "выполняет запрос в удалённой базе данных"

#: dblink.xml:324(synopsis)
#, no-wrap
msgid ""
"dblink(text connname, text sql [, bool fail_on_error]) returns setof record\n"
"dblink(text connstr, text sql [, bool fail_on_error]) returns setof record\n"
"dblink(text sql [, bool fail_on_error]) returns setof record"
msgstr ""
"dblink(text connname, text sql [, bool fail_on_error]) returns setof record\n"
"dblink(text connstr, text sql [, bool fail_on_error]) returns setof record\n"
"dblink(text sql [, bool fail_on_error]) returns setof record"

#: dblink.xml:332(para)
msgid ""
"<function>dblink</function> executes a query (usually a <command>SELECT</"
"command>, but it can be any SQL statement that returns rows) in a remote "
"database."
msgstr ""
"<function>dblink</function> выполняет запрос (обычно <command>SELECT</"
"command>, но это может быть и любой другой оператор SQL, возвращающий "
"строки) в удалённой базе данных."

#: dblink.xml:337(para) dblink.xml:547(para)
msgid ""
"When two <type>text</type> arguments are given, the first one is first "
"looked up as a persistent connection's name; if found, the command is "
"executed on that connection. If not found, the first argument is treated as "
"a connection info string as for <function>dblink_connect</function>, and the "
"indicated connection is made just for the duration of this command."
msgstr ""
"Когда этой функции передаются два аргумента типа <type>text</type>, первый "
"сначала рассматривается как имя постоянного подключения; если такое "
"подключение находится, команда выполняется для него. Если не находится, "
"первый аргумент воспринимается как строка подключения, как для функции "
"<function>dblink_connect</function>, и заданное подключение устанавливается "
"только на время выполнения этой команды."

#: dblink.xml:353(para) dblink.xml:563(para) dblink.xml:688(para)
#: dblink.xml:807(para) dblink.xml:956(para)
msgid ""
"Name of the connection to use; omit this parameter to use the unnamed "
"connection."
msgstr ""
"Имя используемого подключения; опустите этот параметр, чтобы использовать "
"безымянное подключение."

#: dblink.xml:363(para) dblink.xml:573(para)
msgid ""
"A connection info string, as previously described for "
"<function>dblink_connect</function>."
msgstr ""
"Строка подключения, описанная ранее для <function>dblink_connect</function>"

#: dblink.xml:371(parameter) dblink.xml:581(parameter)
#: dblink.xml:705(parameter) dblink.xml:1179(parameter)
msgid "sql"
msgstr "sql"

#: dblink.xml:373(para)
msgid ""
"The SQL query that you wish to execute in the remote database, for example "
"<literal>select * from foo</literal>."
msgstr ""
"SQL-запрос, который вы хотите выполнить в удалённой базе данных, например "
"<literal>select * from foo</literal>."

#: dblink.xml:381(parameter) dblink.xml:592(parameter)
#: dblink.xml:715(parameter) dblink.xml:835(parameter)
#: dblink.xml:973(parameter) dblink.xml:1386(parameter)
msgid "fail_on_error"
msgstr "fail_on_error"

#: dblink.xml:383(para) dblink.xml:837(para) dblink.xml:1388(para)
msgid ""
"If true (the default when omitted) then an error thrown on the remote side "
"of the connection causes an error to also be thrown locally. If false, the "
"remote error is locally reported as a NOTICE, and the function returns no "
"rows."
msgstr ""
"Если равен true (это значение по умолчанию), в случае ошибки, выданной на "
"удалённой стороне соединения, ошибка также выдаётся локально. Если равен "
"false, удалённая ошибка выдаётся локально как ЗАМЕЧАНИЕ, и функция не "
"возвращает строки."

#: dblink.xml:406(programlisting)
#, no-wrap
msgid ""
"SELECT *\n"
"    FROM dblink('dbname=mydb', 'select proname, prosrc from pg_proc')\n"
"      AS t1(proname name, prosrc text)\n"
"    WHERE proname LIKE 'bytea%';"
msgstr ""
"SELECT *\n"
"    FROM dblink('dbname=mydb', 'select proname, prosrc from pg_proc')\n"
"      AS t1(proname name, prosrc text)\n"
"    WHERE proname LIKE 'bytea%';"

#: dblink.xml:397(para)
msgid ""
"The function returns the row(s) produced by the query. Since "
"<function>dblink</function> can be used with any query, it is declared to "
"return <type>record</type>, rather than specifying any particular set of "
"columns. This means that you must specify the expected set of columns in the "
"calling query &mdash; otherwise <productname>PostgreSQL</productname> would "
"not know what to expect. Here is an example: <placeholder-1/> The "
"<quote>alias</quote> part of the <literal>FROM</literal> clause must specify "
"the column names and types that the function will return. (Specifying column "
"names in an alias is actually standard SQL syntax, but specifying column "
"types is a <productname>PostgreSQL</productname> extension.) This allows the "
"system to understand what <literal>*</literal> should expand to, and what "
"<structname>proname</structname> in the <literal>WHERE</literal> clause "
"refers to, in advance of trying to execute the function. At run time, an "
"error will be thrown if the actual query result from the remote database "
"does not have the same number of columns shown in the <literal>FROM</"
"literal> clause. The column names need not match, however, and "
"<function>dblink</function> does not insist on exact type matches either. It "
"will succeed so long as the returned data strings are valid input for the "
"column type declared in the <literal>FROM</literal> clause."
msgstr ""
"Эта функция возвращает строки, выдаваемые в результате запроса. Так как "
"<function>dblink</function> может выполнять произвольные запросы, она "
"объявлена как возвращающая тип <type>record</type>, а не некоторый "
"определённый набор столбцов. Это означает, что вы должны указать ожидаемый "
"набор столбцов в вызывающем запросе &mdash; в противном случае "
"<productname>PostgreSQL</productname> не будет знать, чего ожидать. "
"Например: <placeholder-1/> В части <quote>псевдонима</quote> предложения "
"<literal>FROM</literal> должны указываться имена столбцов и типы, которые "
"будет возвращать функция. (Указание имён столбцов в псевдониме таблицы "
"предусмотрено стандартом SQL, но определение типов столбцов является "
"расширением <productname>PostgreSQL</productname>.) Это позволяет системе "
"понять, во что должно разворачиваться обозначение <literal>*</literal>, и на "
"что ссылается <structname>proname</structname> в предложении <literal>WHERE</"
"literal>, прежде чем пытаться выполнять эту функцию. Во время выполнения "
"произойдёт ошибка, если действительный результат запроса из удалённой базы "
"данных не будет содержать столько столбцов, сколько указано в предложении "
"<literal>FROM</literal>. Однако имена столбцов могут не совпадать, так же, "
"как <function>dblink</function> не настаивает на точном совпадении типов. "
"Функция завершится успешно, если возвращаемые строки данных будут "
"допустимыми для ввода в тип столбца, объявленный в предложении "
"<literal>FROM</literal>."

#: dblink.xml:437(programlisting)
#, no-wrap
msgid ""
"CREATE VIEW myremote_pg_proc AS\n"
"  SELECT *\n"
"    FROM dblink('dbname=postgres', 'select proname, prosrc from pg_proc')\n"
"    AS t1(proname name, prosrc text);\n"
"\n"
"SELECT * FROM myremote_pg_proc WHERE proname LIKE 'bytea%';"
msgstr ""
"CREATE VIEW myremote_pg_proc AS\n"
"  SELECT *\n"
"    FROM dblink('dbname=postgres', 'select proname, prosrc from pg_proc')\n"
"    AS t1(proname name, prosrc text);\n"
"\n"
"SELECT * FROM myremote_pg_proc WHERE proname LIKE 'bytea%';"

#: dblink.xml:431(para)
msgid ""
"A convenient way to use <function>dblink</function> with predetermined "
"queries is to create a view. This allows the column type information to be "
"buried in the view, instead of having to spell it out in every query. For "
"example, <placeholder-1/>"
msgstr ""
"Использовать <function>dblink</function> с предопределёнными запросами будет "
"удобнее, если создать представление. Это позволит скрыть в его определении "
"информацию о типах столбцов и не выписывать её в каждом запросе. Например: "
"<placeholder-1/>"

#: dblink.xml:448(screen)
#, no-wrap
msgid ""
"SELECT * FROM dblink('dbname=postgres', 'select proname, prosrc from pg_proc')\n"
"  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';\n"
"  proname   |   prosrc\n"
"------------+------------\n"
" byteacat   | byteacat\n"
" byteaeq    | byteaeq\n"
" bytealt    | bytealt\n"
" byteale    | byteale\n"
" byteagt    | byteagt\n"
" byteage    | byteage\n"
" byteane    | byteane\n"
" byteacmp   | byteacmp\n"
" bytealike  | bytealike\n"
" byteanlike | byteanlike\n"
" byteain    | byteain\n"
" byteaout   | byteaout\n"
"(12 rows)\n"
"\n"
"SELECT dblink_connect('dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT * FROM dblink('select proname, prosrc from pg_proc')\n"
"  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';\n"
"  proname   |   prosrc\n"
"------------+------------\n"
" byteacat   | byteacat\n"
" byteaeq    | byteaeq\n"
" bytealt    | bytealt\n"
" byteale    | byteale\n"
" byteagt    | byteagt\n"
" byteage    | byteage\n"
" byteane    | byteane\n"
" byteacmp   | byteacmp\n"
" bytealike  | bytealike\n"
" byteanlike | byteanlike\n"
" byteain    | byteain\n"
" byteaout   | byteaout\n"
"(12 rows)\n"
"\n"
"SELECT dblink_connect('myconn', 'dbname=regression');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT * FROM dblink('myconn', 'select proname, prosrc from pg_proc')\n"
"  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';\n"
"  proname   |   prosrc\n"
"------------+------------\n"
" bytearecv  | bytearecv\n"
" byteasend  | byteasend\n"
" byteale    | byteale\n"
" byteagt    | byteagt\n"
" byteage    | byteage\n"
" byteane    | byteane\n"
" byteacmp   | byteacmp\n"
" bytealike  | bytealike\n"
" byteanlike | byteanlike\n"
" byteacat   | byteacat\n"
" byteaeq    | byteaeq\n"
" bytealt    | bytealt\n"
" byteain    | byteain\n"
" byteaout   | byteaout\n"
"(14 rows)"
msgstr ""
"SELECT * FROM dblink('dbname=postgres', 'select proname, prosrc from pg_proc')\n"
"  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';\n"
"  proname   |   prosrc\n"
"------------+------------\n"
" byteacat   | byteacat\n"
" byteaeq    | byteaeq\n"
" bytealt    | bytealt\n"
" byteale    | byteale\n"
" byteagt    | byteagt\n"
" byteage    | byteage\n"
" byteane    | byteane\n"
" byteacmp   | byteacmp\n"
" bytealike  | bytealike\n"
" byteanlike | byteanlike\n"
" byteain    | byteain\n"
" byteaout   | byteaout\n"
"(12 rows)\n"
"\n"
"SELECT dblink_connect('dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT * FROM dblink('select proname, prosrc from pg_proc')\n"
"  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';\n"
"  proname   |   prosrc\n"
"------------+------------\n"
" byteacat   | byteacat\n"
" byteaeq    | byteaeq\n"
" bytealt    | bytealt\n"
" byteale    | byteale\n"
" byteagt    | byteagt\n"
" byteage    | byteage\n"
" byteane    | byteane\n"
" byteacmp   | byteacmp\n"
" bytealike  | bytealike\n"
" byteanlike | byteanlike\n"
" byteain    | byteain\n"
" byteaout   | byteaout\n"
"(12 rows)\n"
"\n"
"SELECT dblink_connect('myconn', 'dbname=regression');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT * FROM dblink('myconn', 'select proname, prosrc from pg_proc')\n"
"  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';\n"
"  proname   |   prosrc\n"
"------------+------------\n"
" bytearecv  | bytearecv\n"
" byteasend  | byteasend\n"
" byteale    | byteale\n"
" byteagt    | byteagt\n"
" byteage    | byteage\n"
" byteane    | byteane\n"
" byteacmp   | byteacmp\n"
" bytealike  | bytealike\n"
" byteanlike | byteanlike\n"
" byteacat   | byteacat\n"
" byteaeq    | byteaeq\n"
" bytealt    | bytealt\n"
" byteain    | byteain\n"
" byteaout   | byteaout\n"
"(14 rows)"

#: dblink.xml:519(indexterm)
msgid "<primary>dblink_exec</primary>"
msgstr "<primary>dblink_exec</primary>"

#: dblink.xml:524(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_exec"
msgstr "dblink_exec"

#: dblink.xml:529(refname)
msgctxt "refname"
msgid "dblink_exec"
msgstr "dblink_exec"

#: dblink.xml:530(refpurpose)
msgid "executes a command in a remote database"
msgstr "выполняет команду в удалённой базе данных"

#: dblink.xml:534(synopsis)
#, no-wrap
msgid ""
"dblink_exec(text connname, text sql [, bool fail_on_error]) returns text\n"
"dblink_exec(text connstr, text sql [, bool fail_on_error]) returns text\n"
"dblink_exec(text sql [, bool fail_on_error]) returns text"
msgstr ""
"dblink_exec(text connname, text sql [, bool fail_on_error]) returns text\n"
"dblink_exec(text connstr, text sql [, bool fail_on_error]) returns text\n"
"dblink_exec(text sql [, bool fail_on_error]) returns text"

#: dblink.xml:542(para)
msgid ""
"<function>dblink_exec</function> executes a command (that is, any SQL "
"statement that doesn't return rows) in a remote database."
msgstr ""
"Функция <function>dblink_exec</function> выполняет команду (то есть любой "
"SQL-оператор, не возвращающий строки) в удалённой базе данных."

#: dblink.xml:583(para)
msgid ""
"The SQL command that you wish to execute in the remote database, for example "
"<literal>insert into foo values(0,'a','{\"a0\",\"b0\",\"c0\"}')</literal>."
msgstr ""
"SQL-запрос, который вы хотите выполнить в удалённой базе данных, например "
"<literal>insert into foo values(0,'a','{\"a0\",\"b0\",\"c0\"}')</literal>."

#: dblink.xml:594(para) dblink.xml:717(para) dblink.xml:975(para)
msgid ""
"If true (the default when omitted) then an error thrown on the remote side "
"of the connection causes an error to also be thrown locally. If false, the "
"remote error is locally reported as a NOTICE, and the function's return "
"value is set to <literal>ERROR</literal>."
msgstr ""
"Если равен true (это значение по умолчанию), в случае ошибки, выданной на "
"удалённой стороне соединения, ошибка также выдаётся локально. Если равен "
"false, удалённая ошибка выдаётся локально как ЗАМЕЧАНИЕ, и возвращаемым "
"значением функции будет <literal>ERROR</literal>."

#: dblink.xml:608(para)
msgid ""
"Returns status, either the command's status string or <literal>ERROR</"
"literal>."
msgstr ""
"Возвращает состояние (либо строку состояния команды, либо <literal>ERROR</"
"literal>)."

#: dblink.xml:616(screen)
#, no-wrap
msgid ""
"SELECT dblink_connect('dbname=dblink_test_standby');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_exec('insert into foo values(21,''z'',''{\"a0\",\"b0\",\"c0\"}'');');\n"
"   dblink_exec\n"
"-----------------\n"
" INSERT 943366 1\n"
"(1 row)\n"
"\n"
"SELECT dblink_connect('myconn', 'dbname=regression');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_exec('myconn', 'insert into foo values(21,''z'',''{\"a0\",\"b0\",\"c0\"}'');');\n"
"   dblink_exec\n"
"------------------\n"
" INSERT 6432584 1\n"
"(1 row)\n"
"\n"
"SELECT dblink_exec('myconn', 'insert into pg_class values (''foo'')',false);\n"
"NOTICE:  sql error\n"
"DETAIL:  ERROR:  null value in column \"relnamespace\" violates not-null constraint\n"
"\n"
" dblink_exec\n"
"-------------\n"
" ERROR\n"
"(1 row)"
msgstr ""
"SELECT dblink_connect('dbname=dblink_test_standby');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_exec('insert into foo values(21,''z'',''{\"a0\",\"b0\",\"c0\"}'');');\n"
"   dblink_exec\n"
"-----------------\n"
" INSERT 943366 1\n"
"(1 row)\n"
"\n"
"SELECT dblink_connect('myconn', 'dbname=regression');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_exec('myconn', 'insert into foo values(21,''z'',''{\"a0\",\"b0\",\"c0\"}'');');\n"
"   dblink_exec\n"
"------------------\n"
" INSERT 6432584 1\n"
"(1 row)\n"
"\n"
"SELECT dblink_exec('myconn', 'insert into pg_class values (''foo'')',false);\n"
"NOTICE:  sql error\n"
"DETAIL:  ERROR:  null value in column \"relnamespace\" violates not-null constraint\n"
"\n"
" dblink_exec\n"
"-------------\n"
" ERROR\n"
"(1 row)"

#: dblink.xml:652(indexterm)
msgid "<primary>dblink_open</primary>"
msgstr "<primary>dblink_open</primary>"

#: dblink.xml:657(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_open"
msgstr "dblink_open"

#: dblink.xml:662(refname)
msgctxt "refname"
msgid "dblink_open"
msgstr "dblink_open"

#: dblink.xml:663(refpurpose)
msgid "opens a cursor in a remote database"
msgstr "открывает курсор в удалённой базе данных"

#: dblink.xml:667(synopsis)
#, no-wrap
msgid ""
"dblink_open(text cursorname, text sql [, bool fail_on_error]) returns text\n"
"dblink_open(text connname, text cursorname, text sql [, bool fail_on_error]) returns text"
msgstr ""
"dblink_open(text cursorname, text sql [, bool fail_on_error]) returns text\n"
"dblink_open(text connname, text cursorname, text sql [, bool fail_on_error]) returns text"

#: dblink.xml:674(para)
msgid ""
"<function>dblink_open()</function> opens a cursor in a remote database. The "
"cursor can subsequently be manipulated with <function>dblink_fetch()</"
"function> and <function>dblink_close()</function>."
msgstr ""
"Функция <function>dblink_open()</function> открывает курсор в удалённой базе "
"данных. Открытым курсором можно будет манипулировать функциями "
"<function>dblink_fetch()</function> и <function>dblink_close()</function>."

#: dblink.xml:696(parameter) dblink.xml:815(parameter)
#: dblink.xml:964(parameter)
msgid "cursorname"
msgstr "cursorname"

#: dblink.xml:698(para)
msgid "The name to assign to this cursor."
msgstr "Имя, назначаемое курсору."

#: dblink.xml:707(para)
msgid ""
"The <command>SELECT</command> statement that you wish to execute in the "
"remote database, for example <literal>select * from pg_class</literal>."
msgstr ""
"Оператор <command>SELECT</command>, который вы хотите выполнять в удалённой "
"базе данных, например <literal>select * from pg_class</literal>."

#: dblink.xml:731(para) dblink.xml:989(para)
msgid ""
"Returns status, either <literal>OK</literal> or <literal>ERROR</literal>."
msgstr ""
"Возвращает состояние, <literal>OK</literal> или <literal>ERROR</literal>."

#: dblink.xml:739(para)
msgid ""
"Since a cursor can only persist within a transaction, <function>dblink_open</"
"function> starts an explicit transaction block (<command>BEGIN</command>) on "
"the remote side, if the remote side was not already within a transaction. "
"This transaction will be closed again when the matching "
"<function>dblink_close</function> is executed. Note that if you use "
"<function>dblink_exec</function> to change data between "
"<function>dblink_open</function> and <function>dblink_close</function>, and "
"then an error occurs or you use <function>dblink_disconnect</function> "
"before <function>dblink_close</function>, your change <emphasis>will be "
"lost</emphasis> because the transaction will be aborted."
msgstr ""
"Так как курсор может существовать только в рамках транзакции, функция "
"<function>dblink_open</function> начинает явный блок транзакции (командой "
"<command>BEGIN</command>) на удалённой стороне, если транзакция там ещё не "
"открыта. Эта транзакция будет снова закрыта при соответствующем вызове "
"<function>dblink_close</function>. Заметьте, что если вы с помощью "
"<function>dblink_exec</function> изменяете данные между вызовами "
"<function>dblink_open</function> и <function>dblink_close</function>, а "
"затем происходит ошибка, либо если вы вызываете <function>dblink_disconnect</"
"function> перед <function>dblink_close</function>, ваши изменения "
"<emphasis>будут потеряны</emphasis>, так как транзакция будет прервана."

#: dblink.xml:757(screen)
#, no-wrap
msgid ""
"SELECT dblink_connect('dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');\n"
" dblink_open\n"
"-------------\n"
" OK\n"
"(1 row)"
msgstr ""
"SELECT dblink_connect('dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');\n"
" dblink_open\n"
"-------------\n"
" OK\n"
"(1 row)"

#: dblink.xml:772(indexterm)
msgid "<primary>dblink_fetch</primary>"
msgstr "<primary>dblink_fetch</primary>"

#: dblink.xml:777(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_fetch"
msgstr "dblink_fetch"

#: dblink.xml:782(refname)
msgctxt "refname"
msgid "dblink_fetch"
msgstr "dblink_fetch"

#: dblink.xml:783(refpurpose)
msgid "returns rows from an open cursor in a remote database"
msgstr "возвращает строки из открытого курсора в удалённой базе данных"

#: dblink.xml:787(synopsis)
#, no-wrap
msgid ""
"dblink_fetch(text cursorname, int howmany [, bool fail_on_error]) returns setof record\n"
"dblink_fetch(text connname, text cursorname, int howmany [, bool fail_on_error]) returns setof record"
msgstr ""
"dblink_fetch(text cursorname, int howmany [, bool fail_on_error]) returns setof record\n"
"dblink_fetch(text connname, text cursorname, int howmany [, bool fail_on_error]) returns setof record"

#: dblink.xml:794(para)
msgid ""
"<function>dblink_fetch</function> fetches rows from a cursor previously "
"established by <function>dblink_open</function>."
msgstr ""
"<function>dblink_fetch</function> выбирает строки из курсора, ранее "
"открытого функцией <function>dblink_open</function>."

#: dblink.xml:817(para)
msgid "The name of the cursor to fetch from."
msgstr "Имя курсора, из которого выбираются данные."

#: dblink.xml:824(parameter)
msgid "howmany"
msgstr "howmany"

#: dblink.xml:826(para)
msgid ""
"The maximum number of rows to retrieve. The next <parameter>howmany</"
"parameter> rows are fetched, starting at the current cursor position, moving "
"forward. Once the cursor has reached its end, no more rows are produced."
msgstr ""
"Максимальное число строк, которое нужно получить. Данная функция выбирает "
"через курсор следующие <parameter>howmany</parameter> строк, начиная с "
"текущей позиции курсора и двигаясь вперёд. Когда курсор доходит до конца, "
"строки больше не выдаются."

#: dblink.xml:851(para)
msgid ""
"The function returns the row(s) fetched from the cursor. To use this "
"function, you will need to specify the expected set of columns, as "
"previously discussed for <function>dblink</function>."
msgstr ""
"Эта функция возвращает строки, выбираемые через курсор. Для использования "
"этой функции необходимо задать ожидаемый набор столбцов, как ранее "
"говорилось в описании <function>dblink</function>."

#: dblink.xml:861(para)
msgid ""
"On a mismatch between the number of return columns specified in the "
"<literal>FROM</literal> clause, and the actual number of columns returned by "
"the remote cursor, an error will be thrown. In this event, the remote cursor "
"is still advanced by as many rows as it would have been if the error had not "
"occurred. The same is true for any other error occurring in the local query "
"after the remote <command>FETCH</command> has been done."
msgstr ""
"При несовпадении числа возвращаемых столбцов, определённого в предложении "
"<literal>FROM</literal>, с фактическим числом столбцов, возвращённых "
"удалённым курсором, выдаётся ошибка. В этом случае удалённый курсор всё "
"равно продвигается на столько строк, на сколько он продвинулся бы, если бы "
"ошибка не произошла. То же самое верно для любых других ошибок, происходящих "
"при локальной обработке результатов после выполнения удалённой команды "
"<command>FETCH</command>."

#: dblink.xml:874(screen)
#, no-wrap
msgid ""
"SELECT dblink_connect('dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_open('foo', 'select proname, prosrc from pg_proc where proname like ''bytea%''');\n"
" dblink_open\n"
"-------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);\n"
" funcname |  source\n"
"----------+----------\n"
" byteacat | byteacat\n"
" byteacmp | byteacmp\n"
" byteaeq  | byteaeq\n"
" byteage  | byteage\n"
" byteagt  | byteagt\n"
"(5 rows)\n"
"\n"
"SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);\n"
" funcname  |  source\n"
"-----------+-----------\n"
" byteain   | byteain\n"
" byteale   | byteale\n"
" bytealike | bytealike\n"
" bytealt   | bytealt\n"
" byteane   | byteane\n"
"(5 rows)\n"
"\n"
"SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);\n"
"  funcname  |   source\n"
"------------+------------\n"
" byteanlike | byteanlike\n"
" byteaout   | byteaout\n"
"(2 rows)\n"
"\n"
"SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);\n"
" funcname | source\n"
"----------+--------\n"
"(0 rows)"
msgstr ""
"SELECT dblink_connect('dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_open('foo', 'select proname, prosrc from pg_proc where proname like ''bytea%''');\n"
" dblink_open\n"
"-------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);\n"
" funcname |  source\n"
"----------+----------\n"
" byteacat | byteacat\n"
" byteacmp | byteacmp\n"
" byteaeq  | byteaeq\n"
" byteage  | byteage\n"
" byteagt  | byteagt\n"
"(5 rows)\n"
"\n"
"SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);\n"
" funcname  |  source\n"
"-----------+-----------\n"
" byteain   | byteain\n"
" byteale   | byteale\n"
" bytealike | bytealike\n"
" bytealt   | bytealt\n"
" byteane   | byteane\n"
"(5 rows)\n"
"\n"
"SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);\n"
"  funcname  |   source\n"
"------------+------------\n"
" byteanlike | byteanlike\n"
" byteaout   | byteaout\n"
"(2 rows)\n"
"\n"
"SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);\n"
" funcname | source\n"
"----------+--------\n"
"(0 rows)"

#: dblink.xml:921(indexterm)
msgid "<primary>dblink_close</primary>"
msgstr "<primary>dblink_close</primary>"

#: dblink.xml:926(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_close"
msgstr "dblink_close"

#: dblink.xml:931(refname)
msgctxt "refname"
msgid "dblink_close"
msgstr "dblink_close"

#: dblink.xml:932(refpurpose)
msgid "closes a cursor in a remote database"
msgstr "закрывает курсор в текущей базе данных"

#: dblink.xml:936(synopsis)
#, no-wrap
msgid ""
"dblink_close(text cursorname [, bool fail_on_error]) returns text\n"
"dblink_close(text connname, text cursorname [, bool fail_on_error]) returns text"
msgstr ""
"dblink_close(text cursorname [, bool fail_on_error]) returns text\n"
"dblink_close(text connname, text cursorname [, bool fail_on_error]) returns text"

#: dblink.xml:943(para)
msgid ""
"<function>dblink_close</function> closes a cursor previously opened with "
"<function>dblink_open</function>."
msgstr ""
"<function>dblink_close</function> закрывает курсор, ранее открытый функцией "
"<function>dblink_open</function>."

#: dblink.xml:966(para)
msgid "The name of the cursor to close."
msgstr "Имя курсора, который будет закрыт."

#: dblink.xml:997(para)
msgid ""
"If <function>dblink_open</function> started an explicit transaction block, "
"and this is the last remaining open cursor in this connection, "
"<function>dblink_close</function> will issue the matching <command>COMMIT</"
"command>."
msgstr ""
"Если вызов <function>dblink_open</function> начал явный блок транзакции и "
"это последний открытый курсор, остававшийся в этом подключении, то "
"<function>dblink_close</function> выполнит соответствующую команду "
"<command>COMMIT</command>."

#: dblink.xml:1007(screen)
#, no-wrap
msgid ""
"SELECT dblink_connect('dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');\n"
" dblink_open\n"
"-------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_close('foo');\n"
" dblink_close\n"
"--------------\n"
" OK\n"
"(1 row)"
msgstr ""
"SELECT dblink_connect('dbname=postgres');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');\n"
" dblink_open\n"
"-------------\n"
" OK\n"
"(1 row)\n"
"\n"
"SELECT dblink_close('foo');\n"
" dblink_close\n"
"--------------\n"
" OK\n"
"(1 row)"

#: dblink.xml:1028(indexterm)
msgid "<primary>dblink_get_connections</primary>"
msgstr "<primary>dblink_get_connections</primary>"

#: dblink.xml:1033(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_get_connections"
msgstr "dblink_get_connections"

#: dblink.xml:1038(refname)
msgctxt "refname"
msgid "dblink_get_connections"
msgstr "dblink_get_connections"

#: dblink.xml:1039(refpurpose)
msgid "returns the names of all open named dblink connections"
msgstr "возвращает имена всех открытых именованных подключений dblink"

#: dblink.xml:1043(synopsis)
#, no-wrap
msgid "dblink_get_connections() returns text[]"
msgstr "dblink_get_connections() returns text[]"

#: dblink.xml:1049(para)
msgid ""
"<function>dblink_get_connections</function> returns an array of the names of "
"all open named <filename>dblink</filename> connections."
msgstr ""
"<function>dblink_get_connections</function> возвращает массив имён всех "
"открытых именованных подключений <filename>dblink</filename>."

#: dblink.xml:1058(para)
msgid "Returns a text array of connection names, or NULL if none."
msgstr ""
"Возвращает текстовый массив имён подключений, либо NULL, если они "
"отсутствуют."

#: dblink.xml:1064(programlisting)
#, no-wrap
msgid "SELECT dblink_get_connections();"
msgstr "SELECT dblink_get_connections();"

#: dblink.xml:1069(indexterm)
msgid "<primary>dblink_error_message</primary>"
msgstr "<primary>dblink_error_message</primary>"

#: dblink.xml:1074(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_error_message"
msgstr "dblink_error_message"

#: dblink.xml:1079(refname)
msgctxt "refname"
msgid "dblink_error_message"
msgstr "dblink_error_message"

#: dblink.xml:1080(refpurpose)
msgid "gets last error message on the named connection"
msgstr "выдаёт сообщение последней ошибки для именованного подключения"

#: dblink.xml:1084(synopsis)
#, no-wrap
msgid "dblink_error_message(text connname) returns text"
msgstr "dblink_error_message(text connname) returns text"

#: dblink.xml:1090(para)
msgid ""
"<function>dblink_error_message</function> fetches the most recent remote "
"error message for a given connection."
msgstr ""
"<function>dblink_error_message</function> извлекает самое последнее "
"сообщение удалённой ошибки для заданного подключения."

#: dblink.xml:1103(para) dblink.xml:1172(para) dblink.xml:1379(para)
#: dblink.xml:1542(para)
msgid "Name of the connection to use."
msgstr "Имя используемого подключения."

#: dblink.xml:1114(para)
msgid ""
"Returns last error message, or an empty string if there has been no error in "
"this connection."
msgstr ""
"Возвращает сообщение последней ошибки, либо пустую строку, если в сеансе "
"этого подключения не было ошибок."

#: dblink.xml:1123(programlisting)
#, no-wrap
msgid "SELECT dblink_error_message('dtest1');"
msgstr "SELECT dblink_error_message('dtest1');"

#: dblink.xml:1128(indexterm)
msgid "<primary>dblink_send_query</primary>"
msgstr "<primary>dblink_send_query</primary>"

#: dblink.xml:1133(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_send_query"
msgstr "dblink_send_query"

#: dblink.xml:1138(refname)
msgctxt "refname"
msgid "dblink_send_query"
msgstr "dblink_send_query"

#: dblink.xml:1139(refpurpose)
msgid "sends an async query to a remote database"
msgstr "передаёт асинхронный запрос в удалённую базу данных"

#: dblink.xml:1143(synopsis)
#, no-wrap
msgid "dblink_send_query(text connname, text sql) returns int"
msgstr "dblink_send_query(text connname, text sql) returns int"

#: dblink.xml:1149(para)
msgid ""
"<function>dblink_send_query</function> sends a query to be executed "
"asynchronously, that is, without immediately waiting for the result. There "
"must not be an async query already in progress on the connection."
msgstr ""
"<function>dblink_send_query</function> передаёт запрос для асинхронного "
"выполнения, то есть не дожидается получения результата. С этим подключением "
"не должен быть связан уже выполняющийся асинхронный запрос."

#: dblink.xml:1156(para)
msgid ""
"After successfully dispatching an async query, completion status can be "
"checked with <function>dblink_is_busy</function>, and the results are "
"ultimately collected with <function>dblink_get_result</function>. It is also "
"possible to attempt to cancel an active async query using "
"<function>dblink_cancel_query</function>."
msgstr ""
"После успешной передачи асинхронного запроса состояние его завершения можно "
"проверять, вызывая функцию <function>dblink_is_busy</function>, и в итоге "
"получать данные, вызвав <function>dblink_get_result</function>. Также можно "
"попытаться отменить активный асинхронный запрос, вызвав "
"<function>dblink_cancel_query</function>."

#: dblink.xml:1181(para)
msgid ""
"The SQL statement that you wish to execute in the remote database, for "
"example <literal>select * from pg_class</literal>."
msgstr ""
"Оператор SQL, который вы хотите выполнить в удалённой базе данных, например "
"<literal>select * from pg_class</literal>."

#: dblink.xml:1193(para)
msgid "Returns 1 if the query was successfully dispatched, 0 otherwise."
msgstr ""
"Возвращает 1, если запрос был успешно отправлен на обработку, или 0 в "
"противном случае."

#: dblink.xml:1201(programlisting)
#, no-wrap
msgid "SELECT dblink_send_query('dtest1', 'SELECT * FROM foo WHERE f1 &lt; 3');"
msgstr "SELECT dblink_send_query('dtest1', 'SELECT * FROM foo WHERE f1 &lt; 3');"

#: dblink.xml:1206(indexterm)
msgid "<primary>dblink_is_busy</primary>"
msgstr "<primary>dblink_is_busy</primary>"

#: dblink.xml:1211(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_is_busy"
msgstr "dblink_is_busy"

#: dblink.xml:1216(refname)
msgctxt "refname"
msgid "dblink_is_busy"
msgstr "dblink_is_busy"

#: dblink.xml:1217(refpurpose)
msgid "checks if connection is busy with an async query"
msgstr "проверяет, не выполняется ли через подключение асинхронный запрос"

#: dblink.xml:1221(synopsis)
#, no-wrap
msgid "dblink_is_busy(text connname) returns int"
msgstr "dblink_is_busy(text connname) returns int"

#: dblink.xml:1227(para)
msgid ""
"<function>dblink_is_busy</function> tests whether an async query is in "
"progress."
msgstr ""
"<function>dblink_is_busy</function> проверяет, не выполняется ли асинхронный "
"запрос."

#: dblink.xml:1239(para)
msgid "Name of the connection to check."
msgstr "Имя проверяемого подключения."

#: dblink.xml:1250(para)
msgid ""
"Returns 1 if connection is busy, 0 if it is not busy. If this function "
"returns 0, it is guaranteed that <function>dblink_get_result</function> will "
"not block."
msgstr ""
"Возвращает 1, если подключение занято, или 0 в противном случае. Если эта "
"функция возвращает 0, гарантируется, что вызов <function>dblink_get_result</"
"function> не будет заблокирован."

#: dblink.xml:1260(programlisting)
#, no-wrap
msgid "SELECT dblink_is_busy('dtest1');"
msgstr "SELECT dblink_is_busy('dtest1');"

#: dblink.xml:1265(indexterm)
msgid "<primary>dblink_get_notify</primary>"
msgstr "<primary>dblink_get_notify</primary>"

#: dblink.xml:1270(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_get_notify"
msgstr "dblink_get_notify"

#: dblink.xml:1275(refname)
msgctxt "refname"
msgid "dblink_get_notify"
msgstr "dblink_get_notify"

#: dblink.xml:1276(refpurpose)
msgid "retrieve async notifications on a connection"
msgstr "выдаёт асинхронные уведомления подключения"

#: dblink.xml:1280(synopsis)
#, no-wrap
msgid ""
"dblink_get_notify() returns setof (notify_name text, be_pid int, extra text)\n"
"dblink_get_notify(text connname) returns setof (notify_name text, be_pid int, extra text)"
msgstr ""
"dblink_get_notify() returns setof (notify_name text, be_pid int, extra text)\n"
"dblink_get_notify(text connname) returns setof (notify_name text, be_pid int, extra text)"

#: dblink.xml:1287(para)
msgid ""
"<function>dblink_get_notify</function> retrieves notifications on either the "
"unnamed connection, or on a named connection if specified. To receive "
"notifications via dblink, <function>LISTEN</function> must first be issued, "
"using <function>dblink_exec</function>. For details see <xref linkend=\"sql-"
"listen\"/> and <xref linkend=\"sql-notify\"/>."
msgstr ""
"<function>dblink_get_notify</function> выдаёт уведомления либо безымянного "
"подключения, либо подключения с заданным именем. Чтобы получать уведомления "
"через dblink, необходимо сначала выполнить <function>LISTEN</function>, "
"воспользовавшись функцией <function>dblink_exec</function>. За подробностями "
"обратитесь к <xref remap=\"3\" linkend=\"sql-listen\"/> и <xref remap=\"3\" "
"linkend=\"sql-notify\"/>."

#: dblink.xml:1304(para)
msgid "The name of a named connection to get notifications on."
msgstr "Имя именованного подключения, уведомления которого нужно получить."

#: dblink.xml:1314(para)
msgid ""
"Returns <type>setof (notify_name text, be_pid int, extra text)</type>, or an "
"empty set if none."
msgstr ""
"Возвращает <type>setof (notify_name text, be_pid int, extra text)</type> или "
"пустой набор, если уведомлений нет."

#: dblink.xml:1320(screen)
#, no-wrap
msgid ""
"SELECT dblink_exec('LISTEN virtual');\n"
" dblink_exec \n"
"-------------\n"
" LISTEN\n"
"(1 row)\n"
"\n"
"SELECT * FROM dblink_get_notify();\n"
" notify_name | be_pid | extra\n"
"-------------+--------+-------\n"
"(0 rows)\n"
"\n"
"NOTIFY virtual;\n"
"NOTIFY\n"
"\n"
"SELECT * FROM dblink_get_notify();\n"
" notify_name | be_pid | extra\n"
"-------------+--------+-------\n"
" virtual     |   1229 |\n"
"(1 row)"
msgstr ""
"SELECT dblink_exec('LISTEN virtual');\n"
" dblink_exec \n"
"-------------\n"
" LISTEN\n"
"(1 row)\n"
"\n"
"SELECT * FROM dblink_get_notify();\n"
" notify_name | be_pid | extra\n"
"-------------+--------+-------\n"
"(0 rows)\n"
"\n"
"NOTIFY virtual;\n"
"NOTIFY\n"
"\n"
"SELECT * FROM dblink_get_notify();\n"
" notify_name | be_pid | extra\n"
"-------------+--------+-------\n"
" virtual     |   1229 |\n"
"(1 row)"

#: dblink.xml:1343(indexterm)
msgid "<primary>dblink_get_result</primary>"
msgstr "<primary>dblink_get_result</primary>"

#: dblink.xml:1348(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_get_result"
msgstr "dblink_get_result"

#: dblink.xml:1353(refname)
msgctxt "refname"
msgid "dblink_get_result"
msgstr "dblink_get_result"

#: dblink.xml:1354(refpurpose)
msgid "gets an async query result"
msgstr "получает результат асинхронного запроса"

#: dblink.xml:1358(synopsis)
#, no-wrap
msgid "dblink_get_result(text connname [, bool fail_on_error]) returns setof record"
msgstr "dblink_get_result(text connname [, bool fail_on_error]) returns setof record"

#: dblink.xml:1364(para)
msgid ""
"<function>dblink_get_result</function> collects the results of an "
"asynchronous query previously sent with <function>dblink_send_query</"
"function>. If the query is not already completed, "
"<function>dblink_get_result</function> will wait until it is."
msgstr ""
"<function>dblink_get_result</function> получает результаты асинхронного "
"запроса, запущенного ранее вызовом <function>dblink_send_query</function>. "
"Если запрос ещё выполняется, <function>dblink_get_result</function> будет "
"ждать его завершения."

#: dblink.xml:1402(para)
msgid ""
"For an async query (that is, a SQL statement returning rows), the function "
"returns the row(s) produced by the query. To use this function, you will "
"need to specify the expected set of columns, as previously discussed for "
"<function>dblink</function>."
msgstr ""
"Для асинхронного запроса (то есть, SQL-оператора, возвращающего строки) эта "
"функция выдаёт строки, полученные в результате запроса. Чтобы использовать "
"эту функцию, вы должны задать ожидаемый набор столбцов, как ранее говорилось "
"в описании <function>dblink</function>."

#: dblink.xml:1409(para)
msgid ""
"For an async command (that is, a SQL statement not returning rows), the "
"function returns a single row with a single text column containing the "
"command's status string. It is still necessary to specify that the result "
"will have a single text column in the calling <literal>FROM</literal> clause."
msgstr ""
"Для асинхронной команды (то есть, SQL-оператора, не возвращающего строки), "
"эта функция возвращает одну строку с одним текстовым столбцом, содержащим "
"строку состояния команды. Для такого вызова в предложении <literal>FROM</"
"literal> так же необходимо определить, что результат будет содержать один "
"текстовый столбец."

#: dblink.xml:1421(para)
msgid ""
"This function <emphasis>must</emphasis> be called if "
"<function>dblink_send_query</function> returned 1. It must be called once "
"for each query sent, and one additional time to obtain an empty set result, "
"before the connection can be used again."
msgstr ""
"Эта функция <emphasis>должна</emphasis> вызываться, если "
"<function>dblink_send_query</function> возвращает 1. Её нужно вызывать по "
"одному разу для каждого отправленного запроса, а затем ещё раз для получения "
"пустого набора данных, прежде чем подключением можно будет пользоваться "
"снова."

#: dblink.xml:1429(para)
msgid ""
"When using <function>dblink_send_query</function> and "
"<function>dblink_get_result</function>, <application>dblink</application> "
"fetches the entire remote query result before returning any of it to the "
"local query processor. If the query returns a large number of rows, this can "
"result in transient memory bloat in the local session. It may be better to "
"open such a query as a cursor with <function>dblink_open</function> and then "
"fetch a manageable number of rows at a time. Alternatively, use plain "
"<function>dblink()</function>, which avoids memory bloat by spooling large "
"result sets to disk."
msgstr ""
"Когда используются <function>dblink_send_query</function> и "
"<function>dblink_get_result</function>, подсистема <application>dblink</"
"application> получает весь набор удалённых результатов, прежде чем "
"передавать его для локальной обработки. Если запрос возвращает большое "
"количество строк, это может занимать много памяти в локальном сеансе. "
"Поэтому может быть лучше открыть такой запрос как курсор, вызвав "
"<function>dblink_open</function>, а затем выбирать результаты удобоваримыми "
"порциями. Кроме того, можно воспользоваться простой функцией "
"<function>dblink()</function>, которая не допускает заполнения памяти, "
"выгружая большие наборы результатов на диск."

#: dblink.xml:1445(screen)
#, no-wrap
msgid ""
"contrib_regression=# SELECT dblink_connect('dtest1', 'dbname=contrib_regression');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"contrib_regression=# SELECT * FROM\n"
"contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3') AS t1;\n"
" t1\n"
"----\n"
"  1\n"
"(1 row)\n"
"\n"
"contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);\n"
" f1 | f2 |     f3\n"
"----+----+------------\n"
"  0 | a  | {a0,b0,c0}\n"
"  1 | b  | {a1,b1,c1}\n"
"  2 | c  | {a2,b2,c2}\n"
"(3 rows)\n"
"\n"
"contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);\n"
" f1 | f2 | f3\n"
"----+----+----\n"
"(0 rows)\n"
"\n"
"contrib_regression=# SELECT * FROM\n"
"contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3; select * from foo where f1 &gt; 6') AS t1;\n"
" t1\n"
"----\n"
"  1\n"
"(1 row)\n"
"\n"
"contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);\n"
" f1 | f2 |     f3\n"
"----+----+------------\n"
"  0 | a  | {a0,b0,c0}\n"
"  1 | b  | {a1,b1,c1}\n"
"  2 | c  | {a2,b2,c2}\n"
"(3 rows)\n"
"\n"
"contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);\n"
" f1 | f2 |      f3\n"
"----+----+---------------\n"
"  7 | h  | {a7,b7,c7}\n"
"  8 | i  | {a8,b8,c8}\n"
"  9 | j  | {a9,b9,c9}\n"
" 10 | k  | {a10,b10,c10}\n"
"(4 rows)\n"
"\n"
"contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);\n"
" f1 | f2 | f3\n"
"----+----+----\n"
"(0 rows)"
msgstr ""
"contrib_regression=# SELECT dblink_connect('dtest1', 'dbname=contrib_regression');\n"
" dblink_connect\n"
"----------------\n"
" OK\n"
"(1 row)\n"
"\n"
"contrib_regression=# SELECT * FROM\n"
"contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3') AS t1;\n"
" t1\n"
"----\n"
"  1\n"
"(1 row)\n"
"\n"
"contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);\n"
" f1 | f2 |     f3\n"
"----+----+------------\n"
"  0 | a  | {a0,b0,c0}\n"
"  1 | b  | {a1,b1,c1}\n"
"  2 | c  | {a2,b2,c2}\n"
"(3 rows)\n"
"\n"
"contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);\n"
" f1 | f2 | f3\n"
"----+----+----\n"
"(0 rows)\n"
"\n"
"contrib_regression=# SELECT * FROM\n"
"contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3; select * from foo where f1 &gt; 6') AS t1;\n"
" t1\n"
"----\n"
"  1\n"
"(1 row)\n"
"\n"
"contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);\n"
" f1 | f2 |     f3\n"
"----+----+------------\n"
"  0 | a  | {a0,b0,c0}\n"
"  1 | b  | {a1,b1,c1}\n"
"  2 | c  | {a2,b2,c2}\n"
"(3 rows)\n"
"\n"
"contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);\n"
" f1 | f2 |      f3\n"
"----+----+---------------\n"
"  7 | h  | {a7,b7,c7}\n"
"  8 | i  | {a8,b8,c8}\n"
"  9 | j  | {a9,b9,c9}\n"
" 10 | k  | {a10,b10,c10}\n"
"(4 rows)\n"
"\n"
"contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);\n"
" f1 | f2 | f3\n"
"----+----+----\n"
"(0 rows)"

#: dblink.xml:1503(indexterm)
msgid "<primary>dblink_cancel_query</primary>"
msgstr "<primary>dblink_cancel_query</primary>"

#: dblink.xml:1508(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_cancel_query"
msgstr "dblink_cancel_query"

#: dblink.xml:1513(refname)
msgctxt "refname"
msgid "dblink_cancel_query"
msgstr "dblink_cancel_query"

#: dblink.xml:1514(refpurpose)
msgid "cancels any active query on the named connection"
msgstr "отменяет любой активный запрос в заданном подключении"

#: dblink.xml:1518(synopsis)
#, no-wrap
msgid "dblink_cancel_query(text connname) returns text"
msgstr "dblink_cancel_query(text connname) returns text"

#: dblink.xml:1524(para)
msgid ""
"<function>dblink_cancel_query</function> attempts to cancel any query that "
"is in progress on the named connection. Note that this is not certain to "
"succeed (since, for example, the remote query might already have finished). "
"A cancel request simply improves the odds that the query will fail soon. You "
"must still complete the normal query protocol, for example by calling "
"<function>dblink_get_result</function>."
msgstr ""
"Функция <function>dblink_cancel_query</function> пытается отменить любой "
"запрос, выполняющийся через заданное подключение. Заметьте, что её вызов не "
"обязательно будет успешным (например, потому что удалённый запрос уже "
"завершился). Запрос отмены просто увеличивает шансы того, что выполняющийся "
"запрос будет вскоре прерван. При этом всё равно нужно завершить обычную "
"процедуру обработки запроса, например, вызвать <function>dblink_get_result</"
"function>."

#: dblink.xml:1553(para)
msgid ""
"Returns <literal>OK</literal> if the cancel request has been sent, or the "
"text of an error message on failure."
msgstr ""
"Возвращает <literal>OK</literal>, если запрос отмены был отправлен, либо "
"текст сообщения об ошибке в случае неудачи."

#: dblink.xml:1562(programlisting)
#, no-wrap
msgid "SELECT dblink_cancel_query('dtest1');"
msgstr "SELECT dblink_cancel_query('dtest1');"

#: dblink.xml:1567(indexterm)
msgid "<primary>dblink_get_pkey</primary>"
msgstr "<primary>dblink_get_pkey</primary>"

#: dblink.xml:1572(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_get_pkey"
msgstr "dblink_get_pkey"

#: dblink.xml:1577(refname)
msgctxt "refname"
msgid "dblink_get_pkey"
msgstr "dblink_get_pkey"

#: dblink.xml:1578(refpurpose)
msgid ""
"returns the positions and field names of a relation's primary key fields"
msgstr "возвращает позиции и имена полей первичного ключа отношения"

#: dblink.xml:1584(synopsis)
#, no-wrap
msgid "dblink_get_pkey(text relname) returns setof dblink_pkey_results"
msgstr "dblink_get_pkey(text relname) returns setof dblink_pkey_results"

#: dblink.xml:1590(para)
msgid ""
"<function>dblink_get_pkey</function> provides information about the primary "
"key of a relation in the local database. This is sometimes useful in "
"generating queries to be sent to remote databases."
msgstr ""
"Функция <function>dblink_get_pkey</function> выдаёт информацию о первичном "
"ключе отношения в локальной базе данных. Иногда это полезно при формировании "
"запросов, отправляемых в удалённые базы данных."

#: dblink.xml:1602(parameter) dblink.xml:1697(parameter)
#: dblink.xml:1823(parameter) dblink.xml:1944(parameter)
msgid "relname"
msgstr "relname"

#: dblink.xml:1604(para) dblink.xml:1699(para) dblink.xml:1825(para)
#: dblink.xml:1946(para)
msgid ""
"Name of a local relation, for example <literal>foo</literal> or "
"<literal>myschema.mytab</literal>. Include double quotes if the name is "
"mixed-case or contains special characters, for example <literal>\"FooBar\"</"
"literal>; without quotes, the string will be folded to lower case."
msgstr ""
"Имя локального отношения, например <literal>foo</literal> или "
"<literal>myschema.mytab</literal>. Заключите его в двойные кавычки, если это "
"имя в смешанном регистре или содержит специальные символы, например <literal>"
"\"FooBar\"</literal>; без кавычек эта строка приводится к нижнему регистру."

#: dblink.xml:1623(programlisting)
#, no-wrap
msgid "CREATE TYPE dblink_pkey_results AS (position int, colname text);"
msgstr "CREATE TYPE dblink_pkey_results AS (position int, colname text);"

#: dblink.xml:1619(para)
msgid ""
"Returns one row for each primary key field, or no rows if the relation has "
"no primary key. The result row type is defined as <placeholder-1/> The "
"<literal>position</literal> column simply runs from 1 to <replaceable>N</"
"replaceable>; it is the number of the field within the primary key, not the "
"number within the table's columns."
msgstr ""
"Возвращает одну строку для каждого поля первичного ключа, либо не возвращает "
"строк, если в отношении нет первичного ключа. Тип результирующей строки "
"определён как <placeholder-1/> В столбце <literal>position</literal> "
"содержится число от 1 до <replaceable>N</replaceable>; это номер поля в "
"первичном ключе, а не номер столбца в списке столбцов таблицы."

#: dblink.xml:1634(screen)
#, no-wrap
msgid ""
"CREATE TABLE foobar (\n"
"    f1 int,\n"
"    f2 int,\n"
"    f3 int,\n"
"    PRIMARY KEY (f1, f2, f3)\n"
");\n"
"CREATE TABLE\n"
"\n"
"SELECT * FROM dblink_get_pkey('foobar');\n"
" position | colname\n"
"----------+---------\n"
"        1 | f1\n"
"        2 | f2\n"
"        3 | f3\n"
"(3 rows)"
msgstr ""
"CREATE TABLE foobar (\n"
"    f1 int,\n"
"    f2 int,\n"
"    f3 int,\n"
"    PRIMARY KEY (f1, f2, f3)\n"
");\n"
"CREATE TABLE\n"
"\n"
"SELECT * FROM dblink_get_pkey('foobar');\n"
" position | colname\n"
"----------+---------\n"
"        1 | f1\n"
"        2 | f2\n"
"        3 | f3\n"
"(3 rows)"

#: dblink.xml:1653(indexterm)
msgid "<primary>dblink_build_sql_insert</primary>"
msgstr "<primary>dblink_build_sql_insert</primary>"

#: dblink.xml:1658(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_build_sql_insert"
msgstr "dblink_build_sql_insert"

#: dblink.xml:1663(refname)
msgctxt "refname"
msgid "dblink_build_sql_insert"
msgstr "dblink_build_sql_insert"

#: dblink.xml:1664(refpurpose)
msgid ""
"builds an INSERT statement using a local tuple, replacing the primary key "
"field values with alternative supplied values"
msgstr ""
"формирует оператор INSERT из локального кортежа, заменяя значения полей "
"первичного ключа переданными альтернативными значениями"

#: dblink.xml:1671(synopsis)
#, no-wrap
msgid ""
"dblink_build_sql_insert(text relname,\n"
"                        int2vector primary_key_attnums,\n"
"                        integer num_primary_key_atts,\n"
"                        text[] src_pk_att_vals_array,\n"
"                        text[] tgt_pk_att_vals_array) returns text"
msgstr ""
"dblink_build_sql_insert(text relname,\n"
"                        int2vector primary_key_attnums,\n"
"                        integer num_primary_key_atts,\n"
"                        text[] src_pk_att_vals_array,\n"
"                        text[] tgt_pk_att_vals_array) returns text"

#: dblink.xml:1681(para)
msgid ""
"<function>dblink_build_sql_insert</function> can be useful in doing "
"selective replication of a local table to a remote database. It selects a "
"row from the local table based on primary key, and then builds a SQL "
"<command>INSERT</command> command that will duplicate that row, but with the "
"primary key values replaced by the values in the last argument. (To make an "
"exact copy of the row, just specify the same values for the last two "
"arguments.)"
msgstr ""
"Функция <function>dblink_build_sql_insert</function> может быть полезна при "
"избирательной репликации локальной таблицы с удалённой базой данных. Она "
"выбирает строку из локальной таблицы по заданному первичному ключу, а затем "
"формирует SQL-команду <command>INSERT</command>, дублирующую эту строку, но "
"заменяет в ней значения первичного ключа данными из последнего аргумента. "
"(Чтобы получить точную копию строки, просто укажите одинаковые значения в "
"двух последних аргументах.)"

#: dblink.xml:1710(parameter) dblink.xml:1836(parameter)
#: dblink.xml:1957(parameter)
msgid "primary_key_attnums"
msgstr "primary_key_attnums"

#: dblink.xml:1712(para) dblink.xml:1838(para) dblink.xml:1959(para)
msgid ""
"Attribute numbers (1-based) of the primary key fields, for example "
"<literal>1 2</literal>."
msgstr ""
"Номера атрибутов (начиная с 1) полей первичного ключа, например <literal>1 "
"2</literal>."

#: dblink.xml:1720(parameter) dblink.xml:1846(parameter)
#: dblink.xml:1967(parameter)
msgid "num_primary_key_atts"
msgstr "num_primary_key_atts"

#: dblink.xml:1722(para) dblink.xml:1848(para) dblink.xml:1969(para)
msgid "The number of primary key fields."
msgstr "Число полей первичного ключа."

#: dblink.xml:1729(parameter) dblink.xml:1976(parameter)
msgid "src_pk_att_vals_array"
msgstr "src_pk_att_vals_array"

#: dblink.xml:1731(para) dblink.xml:1978(para)
msgid ""
"Values of the primary key fields to be used to look up the local tuple. Each "
"field is represented in text form. An error is thrown if there is no local "
"row with these primary key values."
msgstr ""
"Значения полей первичного ключа, по которым будет выполняться поиск "
"локального кортежа. Каждое поле здесь представляется в текстовом виде. Если "
"локальной строки с этими значениями первичного ключа нет, выдаётся ошибка."

#: dblink.xml:1741(parameter) dblink.xml:1855(parameter)
#: dblink.xml:1988(parameter)
msgid "tgt_pk_att_vals_array"
msgstr "tgt_pk_att_vals_array"

#: dblink.xml:1743(para)
msgid ""
"Values of the primary key fields to be placed in the resulting "
"<command>INSERT</command> command. Each field is represented in text form."
msgstr ""
"Значения полей первичного ключа, которые будут помещены в результирующую "
"команду <command>INSERT</command>. Каждое поле представляется в текстовом "
"виде."

#: dblink.xml:1755(para) dblink.xml:1869(para) dblink.xml:2002(para)
msgid "Returns the requested SQL statement as text."
msgstr "Возвращает запрошенный SQL-оператор в текстовом виде."

#: dblink.xml:1761(para) dblink.xml:1875(para) dblink.xml:2008(para)
msgid ""
"As of <productname>PostgreSQL</productname> 9.0, the attribute numbers in "
"<parameter>primary_key_attnums</parameter> are interpreted as logical column "
"numbers, corresponding to the column's position in <literal>SELECT * FROM "
"relname</literal>. Previous versions interpreted the numbers as physical "
"column positions. There is a difference if any column(s) to the left of the "
"indicated column have been dropped during the lifetime of the table."
msgstr ""
"Начиная с <productname>PostgreSQL</productname> 9.0, номера атрибутов в "
"<parameter>primary_key_attnums</parameter> воспринимаются как логические "
"номера столбцов, соответствующие позициям столбцов в <literal>SELECT * FROM "
"relname</literal>. Предыдущие версии воспринимали эти номера как физические "
"позиции столбцов. Отличие этих подходов проявляется, когда на протяжении "
"жизни таблицы из неё удаляются столбцы левее указанных."

#: dblink.xml:1775(screen)
#, no-wrap
msgid ""
"SELECT dblink_build_sql_insert('foo', '1 2', 2, '{\"1\", \"a\"}', '{\"1\", \"b''a\"}');\n"
"             dblink_build_sql_insert\n"
"--------------------------------------------------\n"
" INSERT INTO foo(f1,f2,f3) VALUES('1','b''a','1')\n"
"(1 row)"
msgstr ""
"SELECT dblink_build_sql_insert('foo', '1 2', 2, '{\"1\", \"a\"}', '{\"1\", \"b''a\"}');\n"
"             dblink_build_sql_insert\n"
"--------------------------------------------------\n"
" INSERT INTO foo(f1,f2,f3) VALUES('1','b''a','1')\n"
"(1 row)"

#: dblink.xml:1784(indexterm)
msgid "<primary>dblink_build_sql_delete</primary>"
msgstr "<primary>dblink_build_sql_delete</primary>"

#: dblink.xml:1789(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_build_sql_delete"
msgstr "dblink_build_sql_delete"

#: dblink.xml:1794(refname)
msgctxt "refname"
msgid "dblink_build_sql_delete"
msgstr "dblink_build_sql_delete"

#: dblink.xml:1795(refpurpose)
msgid ""
"builds a DELETE statement using supplied values for primary key field values"
msgstr ""
"формирует оператор DELETE со значениями, передаваемыми для полей первичного "
"ключа"

#: dblink.xml:1801(synopsis)
#, no-wrap
msgid ""
"dblink_build_sql_delete(text relname,\n"
"                        int2vector primary_key_attnums,\n"
"                        integer num_primary_key_atts,\n"
"                        text[] tgt_pk_att_vals_array) returns text"
msgstr ""
"dblink_build_sql_delete(text relname,\n"
"                        int2vector primary_key_attnums,\n"
"                        integer num_primary_key_atts,\n"
"                        text[] tgt_pk_att_vals_array) returns text"

#: dblink.xml:1810(para)
msgid ""
"<function>dblink_build_sql_delete</function> can be useful in doing "
"selective replication of a local table to a remote database. It builds a SQL "
"<command>DELETE</command> command that will delete the row with the given "
"primary key values."
msgstr ""
"Функция <function>dblink_build_sql_delete</function> может быть полезна при "
"избирательной репликации локальной таблицы с удалённой базой данных. Она "
"формирует SQL-команду <command>DELETE</command>, которая удалит строку с "
"заданными значениями первичного ключа."

#: dblink.xml:1857(para)
msgid ""
"Values of the primary key fields to be used in the resulting "
"<command>DELETE</command> command. Each field is represented in text form."
msgstr ""
"Значения полей первичного ключа, которые будут использоваться в "
"результирующей команде <command>DELETE</command>. Каждое поле представляется "
"в текстовом виде."

#: dblink.xml:1889(screen)
#, no-wrap
msgid ""
"SELECT dblink_build_sql_delete('\"MyFoo\"', '1 2', 2, '{\"1\", \"b\"}');\n"
"           dblink_build_sql_delete\n"
"---------------------------------------------\n"
" DELETE FROM \"MyFoo\" WHERE f1='1' AND f2='b'\n"
"(1 row)"
msgstr ""
"SELECT dblink_build_sql_delete('\"MyFoo\"', '1 2', 2, '{\"1\", \"b\"}');\n"
"           dblink_build_sql_delete\n"
"---------------------------------------------\n"
" DELETE FROM \"MyFoo\" WHERE f1='1' AND f2='b'\n"
"(1 row)"

#: dblink.xml:1898(indexterm)
msgid "<primary>dblink_build_sql_update</primary>"
msgstr "<primary>dblink_build_sql_update</primary>"

#: dblink.xml:1903(refentrytitle)
msgctxt "refentrytitle"
msgid "dblink_build_sql_update"
msgstr "dblink_build_sql_update"

#: dblink.xml:1908(refname)
msgctxt "refname"
msgid "dblink_build_sql_update"
msgstr "dblink_build_sql_update"

#: dblink.xml:1909(refpurpose)
msgid ""
"builds an UPDATE statement using a local tuple, replacing the primary key "
"field values with alternative supplied values"
msgstr ""
"формирует оператор UPDATE из локального кортежа, заменяя значения первичного "
"ключа переданными альтернативными значениями"

#: dblink.xml:1915(synopsis)
#, no-wrap
msgid ""
"dblink_build_sql_update(text relname,\n"
"                        int2vector primary_key_attnums,\n"
"                        integer num_primary_key_atts,\n"
"                        text[] src_pk_att_vals_array,\n"
"                        text[] tgt_pk_att_vals_array) returns text"
msgstr ""
"dblink_build_sql_update(text relname,\n"
"                        int2vector primary_key_attnums,\n"
"                        integer num_primary_key_atts,\n"
"                        text[] src_pk_att_vals_array,\n"
"                        text[] tgt_pk_att_vals_array) returns text"

#: dblink.xml:1925(para)
msgid ""
"<function>dblink_build_sql_update</function> can be useful in doing "
"selective replication of a local table to a remote database. It selects a "
"row from the local table based on primary key, and then builds a SQL "
"<command>UPDATE</command> command that will duplicate that row, but with the "
"primary key values replaced by the values in the last argument. (To make an "
"exact copy of the row, just specify the same values for the last two "
"arguments.) The <command>UPDATE</command> command always assigns all fields "
"of the row &mdash; the main difference between this and "
"<function>dblink_build_sql_insert</function> is that it's assumed that the "
"target row already exists in the remote table."
msgstr ""
"Функция <function>dblink_build_sql_update</function> может быть полезна при "
"избирательной репликации локальной таблицы с удалённой базой данных. Она "
"выбирает строку из локальной таблицы по заданному первичному ключу, а затем "
"формирует SQL-команду <command>UPDATE</command>, дублирующую эту строку, но "
"заменяющую в ней значения первичного ключа данными из последнего аргумента. "
"(Чтобы получить точную копию строки, просто укажите одинаковые значения в "
"двух последних аргументах.) Команда <command>UPDATE</command> всегда "
"присваивает значения всем полям строки &mdash; основное отличие этой функции "
"от <function>dblink_build_sql_insert</function> в том, что она предполагает, "
"что целевая строка уже существует в удалённой таблице."

#: dblink.xml:1990(para)
msgid ""
"Values of the primary key fields to be placed in the resulting "
"<command>UPDATE</command> command. Each field is represented in text form."
msgstr ""
"Значения полей первичного ключа, которые будут помещены в результирующую "
"команду <command>UPDATE</command>. Каждое поле представляется в текстовом "
"виде."

#: dblink.xml:2022(screen)
#, no-wrap
msgid ""
"SELECT dblink_build_sql_update('foo', '1 2', 2, '{\"1\", \"a\"}', '{\"1\", \"b\"}');\n"
"                   dblink_build_sql_update\n"
"-------------------------------------------------------------\n"
" UPDATE foo SET f1='1',f2='b',f3='1' WHERE f1='1' AND f2='b'\n"
"(1 row)"
msgstr ""
"SELECT dblink_build_sql_update('foo', '1 2', 2, '{\"1\", \"a\"}', '{\"1\", \"b\"}');\n"
"                   dblink_build_sql_update\n"
"-------------------------------------------------------------\n"
" UPDATE foo SET f1='1',f2='b',f3='1' WHERE f1='1' AND f2='b'\n"
"(1 row)"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: dblink.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
