# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:33+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: textsearch.xml:5(title)
msgid "Full Text Search"
msgstr "Полнотекстовый поиск"

#: textsearch.xml:7(indexterm)
msgid "<primary>full text search</primary>"
msgstr "<primary>полнотекстовый поиск</primary>"

#: textsearch.xml:11(indexterm)
msgid "<primary>text search</primary>"
msgstr "<primary>поиск текста</primary>"

#: textsearch.xml:16(title)
msgid "Introduction"
msgstr "Введение"

#: textsearch.xml:18(para)
msgid ""
"Full Text Searching (or just <firstterm>text search</firstterm>) provides "
"the capability to identify natural-language <firstterm>documents</firstterm> "
"that satisfy a <firstterm>query</firstterm>, and optionally to sort them by "
"relevance to the query. The most common type of search is to find all "
"documents containing given <firstterm>query terms</firstterm> and return "
"them in order of their <firstterm>similarity</firstterm> to the query. "
"Notions of <varname>query</varname> and <varname>similarity</varname> are "
"very flexible and depend on the specific application. The simplest search "
"considers <varname>query</varname> as a set of words and "
"<varname>similarity</varname> as the frequency of query words in the "
"document."
msgstr ""
"Полнотекстовый поиск (или просто <firstterm>поиск текста</firstterm>) "
"&mdash; это возможность находить <firstterm>документы</firstterm> на "
"естественном языке, соответствующие <firstterm>запросу</firstterm>, и, "
"возможно, дополнительно сортировать их по релевантности для этого запроса. "
"Наиболее распространённая задача &mdash; найти все документы, содержащие "
"<firstterm>слова запроса</firstterm>, и выдать их отсортированными по "
"степени <firstterm>соответствия</firstterm> запросу. Понятия "
"<varname>запроса</varname> и <varname>соответствия</varname> довольно "
"расплывчаты и зависят от конкретного приложения. В самом простом случае "
"<varname>запросом</varname> считается набор слов, а <varname>соответствие</"
"varname> определяется частотой слов в документе."

#: textsearch.xml:32(para)
msgid ""
"Textual search operators have existed in databases for years. "
"<productname>PostgreSQL</productname> has <literal>~</literal>, <literal>~*</"
"literal>, <literal>LIKE</literal>, and <literal>ILIKE</literal> operators "
"for textual data types, but they lack many essential properties required by "
"modern information systems:"
msgstr ""
"Операторы текстового поиска существуют в СУБД уже многие годы. В "
"<productname>PostgreSQL</productname> для текстовых типов данных есть "
"операторы <literal>~</literal>, <literal>~*</literal>, <literal>LIKE</"
"literal> и <literal>ILIKE</literal>, но им не хватает очень важных вещей, "
"которые требуются сегодня от информационных систем:"

#: textsearch.xml:42(para)
msgid ""
"There is no linguistic support, even for English. Regular expressions are "
"not sufficient because they cannot easily handle derived words, e.g., "
"<literal>satisfies</literal> and <literal>satisfy</literal>. You might miss "
"documents that contain <literal>satisfies</literal>, although you probably "
"would like to find them when searching for <literal>satisfy</literal>. It is "
"possible to use <literal>OR</literal> to search for multiple derived forms, "
"but this is tedious and error-prone (some words can have several thousand "
"derivatives)."
msgstr ""
"Нет поддержки лингвистического функционала, даже для английского языка. "
"Возможности регулярных выражений ограничены &mdash; они не рассчитаны на "
"работу со словоформами, например, <literal>подходят</literal> и "
"<literal>подходить</literal>. С ними вы можете пропустить документы, которые "
"содержат <literal>подходят</literal>, но, вероятно, и они представляют "
"интерес при поиске по ключевому слову <literal>подходить</literal>. Конечно, "
"можно попытаться перечислить в регулярном выражении все варианты слова, но "
"это будет очень трудоёмко и чревато ошибками (некоторые слова могут иметь "
"десятки словоформ)."

#: textsearch.xml:55(para)
msgid ""
"They provide no ordering (ranking) of search results, which makes them "
"ineffective when thousands of matching documents are found."
msgstr ""
"Они не позволяют упорядочивать результаты поиска (по релевантности), а без "
"этого поиск неэффективен, когда находятся сотни подходящих документов."

#: textsearch.xml:62(para)
msgid ""
"They tend to be slow because there is no index support, so they must process "
"all documents for every search."
msgstr ""
"Они обычно выполняются медленно из-за отсутствия индексов, так как при "
"каждом поиске приходится просматривать все документы."

#: textsearch.xml:69(para)
msgid ""
"Full text indexing allows documents to be <emphasis>preprocessed</emphasis> "
"and an index saved for later rapid searching. Preprocessing includes:"
msgstr ""
"Полнотекстовая индексация заключается в <emphasis>предварительной обработке</"
"emphasis> документов и сохранении индекса для последующего быстрого поиска. "
"Предварительная обработка включает следующие операции:"

#: textsearch.xml:76(para)
msgid ""
"<emphasis>Parsing documents into <firstterm>tokens</firstterm></emphasis>. "
"It is useful to identify various classes of tokens, e.g., numbers, words, "
"complex words, email addresses, so that they can be processed differently. "
"In principle token classes depend on the specific application, but for most "
"purposes it is adequate to use a predefined set of classes. "
"<productname>PostgreSQL</productname> uses a <firstterm>parser</firstterm> "
"to perform this step. A standard parser is provided, and custom parsers can "
"be created for specific needs."
msgstr ""
"<emphasis>Разбор документов на <firstterm>фрагменты</firstterm></emphasis>. "
"При этом полезно выделить различные классы фрагментов, например, числа, "
"слова, словосочетания, почтовые адреса и т. д., которые будут обрабатываться "
"по-разному. В принципе классы фрагментов могут зависеть от приложения, но "
"для большинства применений вполне подойдёт предопределённый набор классов. "
"Эту операцию в <productname>PostgreSQL</productname> выполняет "
"<firstterm>анализатор</firstterm> (parser). Вы можете использовать как "
"стандартный анализатор, так и создавать свои, узкоспециализированные."

#: textsearch.xml:90(para)
msgid ""
"<emphasis>Converting tokens into <firstterm>lexemes</firstterm></emphasis>. "
"A lexeme is a string, just like a token, but it has been "
"<firstterm>normalized</firstterm> so that different forms of the same word "
"are made alike. For example, normalization almost always includes folding "
"upper-case letters to lower-case, and often involves removal of suffixes "
"(such as <literal>s</literal> or <literal>es</literal> in English). This "
"allows searches to find variant forms of the same word, without tediously "
"entering all the possible variants. Also, this step typically eliminates "
"<firstterm>stop words</firstterm>, which are words that are so common that "
"they are useless for searching. (In short, then, tokens are raw fragments of "
"the document text, while lexemes are words that are believed useful for "
"indexing and searching.) <productname>PostgreSQL</productname> uses "
"<firstterm>dictionaries</firstterm> to perform this step. Various standard "
"dictionaries are provided, and custom ones can be created for specific needs."
msgstr ""
"<emphasis>Преобразование фрагментов в <firstterm>лексемы</firstterm></"
"emphasis>. Лексема &mdash; это <firstterm>нормализованный</firstterm> "
"фрагмент, в котором разные словоформы приведены к одной. Например, при "
"нормализации буквы верхнего регистра приводятся к нижнему, а из слов обычно "
"убираются окончания (в частности, <literal>s</literal> или <literal>es</"
"literal> в английском). Благодаря этому можно находить разные формы одного "
"слова, не вводя вручную все возможные варианты. Кроме того, на данном шаге "
"обычно исключаются <firstterm>стоп-слова</firstterm>, то есть слова, "
"настолько распространённые, что искать их нет смысла. (Другими словами, "
"фрагменты представляют собой просто подстроки текста документа, а лексемы "
"&mdash; это слова, имеющие ценность для индексации и поиска.) Для выполнения "
"этого шага в <productname>PostgreSQL</productname> используются "
"<firstterm>словари</firstterm>. Набор существующих стандартных словарей при "
"необходимости можно расширять, создавая свои собственные."

#: textsearch.xml:110(para)
msgid ""
"<emphasis>Storing preprocessed documents optimized for searching</emphasis>. "
"For example, each document can be represented as a sorted array of "
"normalized lexemes. Along with the lexemes it is often desirable to store "
"positional information to use for <firstterm>proximity ranking</firstterm>, "
"so that a document that contains a more <quote>dense</quote> region of query "
"words is assigned a higher rank than one with scattered query words."
msgstr ""
"<emphasis>Хранение документов в форме, подготовленной для поиска</emphasis>. "
"Например, каждый документ может быть представлен в виде сортированного "
"массива нормализованных лексем. Помимо лексем часто желательно хранить "
"информацию об их положении для <firstterm>ранжирования по близости</"
"firstterm>, чтобы документ, в котором слова запроса расположены "
"<quote>плотнее</quote>, получал более высокий ранг, чем документ с "
"разбросанными словами."

#: textsearch.xml:122(para)
msgid ""
"Dictionaries allow fine-grained control over how tokens are normalized. With "
"appropriate dictionaries, you can:"
msgstr ""
"Словари позволяют управлять нормализацией фрагментов с большой гибкостью. "
"Создавая словари, можно:"

#: textsearch.xml:129(para)
msgid "Define stop words that should not be indexed."
msgstr "Определять стоп-слова, которые не будут индексироваться."

#: textsearch.xml:135(para)
msgid "Map synonyms to a single word using <application>Ispell</application>."
msgstr ""
"Сопоставлять синонимы с одним словом, используя <application>Ispell</"
"application>."

#: textsearch.xml:141(para)
msgid "Map phrases to a single word using a thesaurus."
msgstr "Сопоставлять словосочетания с одним словом, используя тезаурус."

#: textsearch.xml:147(para)
msgid ""
"Map different variations of a word to a canonical form using an "
"<application>Ispell</application> dictionary."
msgstr ""
"Сопоставлять различные склонения слова с канонической формой, используя "
"словарь <application>Ispell</application>."

#: textsearch.xml:154(para)
msgid ""
"Map different variations of a word to a canonical form using "
"<application>Snowball</application> stemmer rules."
msgstr ""
"Сопоставлять различные склонения слова с канонической формой, используя "
"стеммер <application>Snowball</application>."

#: textsearch.xml:161(para)
msgid ""
"A data type <type>tsvector</type> is provided for storing preprocessed "
"documents, along with a type <type>tsquery</type> for representing processed "
"queries (<xref linkend=\"datatype-textsearch\"/>). There are many functions "
"and operators available for these data types (<xref linkend=\"functions-"
"textsearch\"/>), the most important of which is the match operator "
"<literal>@@</literal>, which we introduce in <xref linkend=\"textsearch-"
"matching\"/>. Full text searches can be accelerated using indexes (<xref "
"linkend=\"textsearch-indexes\"/>)."
msgstr ""
"Для хранения подготовленных документов в <productname>PostgreSQL</"
"productname> предназначен тип данных <type>tsvector</type>, а для "
"представления обработанных запросов &mdash; тип <type>tsquery</type> (<xref "
"linkend=\"datatype-textsearch\"/>). С этими типами данных работают целый ряд "
"функций и операторов (<xref linkend=\"functions-textsearch\"/>), и наиболее "
"важный из них &mdash; оператор соответствия <literal>@@</literal>, с которым "
"мы познакомимся в <xref remap=\"6\" linkend=\"textsearch-matching\"/>. Для "
"ускорения полнотекстового поиска могут применяться индексы (<xref linkend="
"\"textsearch-indexes\"/>)."

#: textsearch.xml:174(title)
msgid "What Is a Document?"
msgstr "Что такое документ?"

#: textsearch.xml:176(indexterm)
msgid "<primary>document</primary> <secondary>text search</secondary>"
msgstr "<primary>документ</primary> <secondary>поиск текста</secondary>"

#: textsearch.xml:181(para)
msgid ""
"A <firstterm>document</firstterm> is the unit of searching in a full text "
"search system; for example, a magazine article or email message. The text "
"search engine must be able to parse documents and store associations of "
"lexemes (key words) with their parent document. Later, these associations "
"are used to search for documents that contain query words."
msgstr ""
"<firstterm>Документ</firstterm> &mdash; это единица обработки в системе "
"полнотекстового поиска; например, журнальная статья или почтовое сообщение. "
"Система поиска текста должна уметь разбирать документы и сохранять связи "
"лексем (ключевых слов) с содержащим их документом. Впоследствии эти связи "
"могут использоваться для поиска документов с заданными ключевыми словами."

#: textsearch.xml:197(programlisting)
#, no-wrap
msgid ""
"SELECT title || ' ' ||  author || ' ' ||  abstract || ' ' || body AS document\n"
"FROM messages\n"
"WHERE mid = 12;\n"
"\n"
"SELECT m.title || ' ' || m.author || ' ' || m.abstract || ' ' || d.body AS document\n"
"FROM messages m, docs d\n"
"WHERE mid = did AND mid = 12;"
msgstr ""
"SELECT title || ' ' ||  author || ' ' ||  abstract || ' ' || body\n"
"  AS document\n"
"FROM messages\n"
"WHERE mid = 12;\n"
"\n"
"SELECT m.title || ' ' || m.author || ' ' || m.abstract || ' ' || d.body\n"
"  AS document\n"
"FROM messages m, docs d\n"
"WHERE mid = did AND mid = 12;"

#: textsearch.xml:189(para)
msgid ""
"For searches within <productname>PostgreSQL</productname>, a document is "
"normally a textual field within a row of a database table, or possibly a "
"combination (concatenation) of such fields, perhaps stored in several tables "
"or obtained dynamically. In other words, a document can be constructed from "
"different parts for indexing and it might not be stored anywhere as a whole. "
"For example: <placeholder-1/>"
msgstr ""
"В контексте поиска в <productname>PostgreSQL</productname> документ &mdash; "
"это обычно содержимое текстового поля в строке таблицы или, возможно, "
"сочетание (объединение) таких полей, которые могут храниться в разных "
"таблицах или формироваться динамически. Другими словами, документ для "
"индексации может создаваться из нескольких частей и не храниться где-либо "
"как единое целое. Например: <placeholder-1/>"

#: textsearch.xml:209(para)
msgid ""
"Actually, in these example queries, <function>coalesce</function> should be "
"used to prevent a single <literal>NULL</literal> attribute from causing a "
"<literal>NULL</literal> result for the whole document."
msgstr ""
"На самом деле в этих примерах запросов следует использовать функцию "
"<function>coalesce</function>, чтобы значение <literal>NULL</literal> в "
"каком-либо одном атрибуте не привело к тому, что результирующим документом "
"окажется <literal>NULL</literal>."

#: textsearch.xml:216(para)
msgid ""
"Another possibility is to store the documents as simple text files in the "
"file system. In this case, the database can be used to store the full text "
"index and to execute searches, and some unique identifier can be used to "
"retrieve the document from the file system. However, retrieving files from "
"outside the database requires superuser permissions or special function "
"support, so this is usually less convenient than keeping all the data inside "
"<productname>PostgreSQL</productname>. Also, keeping everything inside the "
"database allows easy access to document metadata to assist in indexing and "
"display."
msgstr ""
"Документы также можно хранить в обычных текстовых файлах в файловой системе. "
"В этом случае база данных может быть просто хранилищем полнотекстового "
"индекса и исполнителем запросов, а найденные документы будут загружаться из "
"файловой системы по некоторым уникальным идентификаторам. Однако для "
"загрузки внешних файлов требуются права суперпользователя или поддержка "
"специальных функций, так что это обычно менее удобно, чем хранить все данные "
"внутри БД <productname>PostgreSQL</productname>. Кроме того, когда всё "
"хранится в базе данных, это упрощает доступ к метаданным документов при "
"индексации и выводе результатов."

#: textsearch.xml:228(para)
msgid ""
"For text search purposes, each document must be reduced to the preprocessed "
"<type>tsvector</type> format. Searching and ranking are performed entirely "
"on the <type>tsvector</type> representation of a document &mdash; the "
"original text need only be retrieved when the document has been selected for "
"display to a user. We therefore often speak of the <type>tsvector</type> as "
"being the document, but of course it is only a compact representation of the "
"full document."
msgstr ""
"Для нужд текстового поиска каждый документ должен быть сведён к специальному "
"формату <type>tsvector</type>. Поиск и ранжирование выполняется "
"исключительно с этим представлением документа &mdash; исходный текст "
"потребуется извлечь, только когда документ будет отобран для вывода "
"пользователю. Поэтому мы часто подразумеваем под <type>tsvector</type> "
"документ, тогда как этот тип, конечно, содержит только компактное "
"представление всего документа."

#: textsearch.xml:241(title)
msgid "Basic Text Matching"
msgstr "Простое соответствие текста"

#: textsearch.xml:250(programlisting)
#, no-wrap
msgid ""
"SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector @@ 'cat &amp; rat'::tsquery;\n"
" ?column?\n"
"----------\n"
" t\n"
"\n"
"SELECT 'fat &amp; cow'::tsquery @@ 'a fat cat sat on a mat and ate a fat rat'::tsvector;\n"
" ?column?\n"
"----------\n"
" f"
msgstr ""
"SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector @@\n"
"  'cat &amp; rat'::tsquery;\n"
" ?column?\n"
"----------\n"
" t\n"
"\n"
"SELECT 'fat &amp; cow'::tsquery @@\n"
"  'a fat cat sat on a mat and ate a fat rat'::tsvector;\n"
" ?column?\n"
"----------\n"
" f"

#: textsearch.xml:243(para)
msgid ""
"Full text searching in <productname>PostgreSQL</productname> is based on the "
"match operator <literal>@@</literal>, which returns <literal>true</literal> "
"if a <type>tsvector</type> (document) matches a <type>tsquery</type> "
"(query). It doesn't matter which data type is written first: <placeholder-1/>"
msgstr ""
"Полнотекстовый поиск в <productname>PostgreSQL</productname> реализован на "
"базе оператора соответствия <literal>@@</literal>, который возвращает "
"<literal>true</literal>, если <type>tsvector</type> (документ) соответствует "
"<type>tsquery</type> (запросу). Для этого оператора не важно, какой тип "
"записан первым: <placeholder-1/>"

#: textsearch.xml:277(programlisting)
#, no-wrap
msgid ""
"SELECT to_tsvector('fat cats ate fat rats') @@ to_tsquery('fat &amp; rat');\n"
" ?column? \n"
"----------\n"
" t"
msgstr ""
"SELECT to_tsvector('fat cats ate fat rats') @@ to_tsquery('fat &amp; rat');\n"
" ?column? \n"
"----------\n"
" t"

#: textsearch.xml:286(programlisting)
#, no-wrap
msgid ""
"SELECT 'fat cats ate fat rats'::tsvector @@ to_tsquery('fat &amp; rat');\n"
" ?column? \n"
"----------\n"
" f"
msgstr ""
"SELECT 'fat cats ate fat rats'::tsvector @@ to_tsquery('fat &amp; rat');\n"
" ?column? \n"
"----------\n"
" f"

#: textsearch.xml:263(para)
msgid ""
"As the above example suggests, a <type>tsquery</type> is not just raw text, "
"any more than a <type>tsvector</type> is. A <type>tsquery</type> contains "
"search terms, which must be already-normalized lexemes, and may combine "
"multiple terms using AND, OR, NOT, and FOLLOWED BY operators. (For details "
"see <xref linkend=\"datatype-tsquery\"/>.) There are functions "
"<function>to_tsquery</function>, <function>plainto_tsquery</function>, and "
"<function>phraseto_tsquery</function> that are helpful in converting user-"
"written text into a proper <type>tsquery</type>, primarily by normalizing "
"words appearing in the text. Similarly, <function>to_tsvector</function> is "
"used to parse and normalize a document string. So in practice a text search "
"match would look more like this: <placeholder-1/> Observe that this match "
"would not succeed if written as <placeholder-2/> since here no normalization "
"of the word <literal>rats</literal> will occur. The elements of a "
"<type>tsvector</type> are lexemes, which are assumed already normalized, so "
"<literal>rats</literal> does not match <literal>rat</literal>."
msgstr ""
"Как можно догадаться из этого примера, <type>tsquery</type> &mdash; это не "
"просто текст, как и <type>tsvector</type>. Значение типа <type>tsquery</"
"type> содержит искомые слова, это должны быть уже нормализованные лексемы, "
"возможно объединённые в выражение операторами И, ИЛИ, НЕ и ПРЕДШЕСТВУЕТ. "
"(Подробнее об этом см. <xref remap=\"4\" linkend=\"datatype-tsquery\"/>.) Вы "
"можете воспользоваться функциями <function>to_tsquery</function>, "
"<function>plainto_tsquery</function> и <function>phraseto_tsquery</"
"function>, которые могут преобразовать заданный пользователем текст в "
"значение <type>tsquery</type>, прежде всего нормализуя слова в этом тексте. "
"Функция <function>to_tsvector</function> подобным образом может разобрать и "
"нормализовать текстовое содержимое документа. Так что запрос с поиском "
"соответствия на практике выглядит скорее так: <placeholder-1/> Заметьте, что "
"соответствие не будет обнаружено, если запрос записан как <placeholder-2/> "
"так как слово <literal>rats</literal> не будет нормализовано. Элементами "
"<type>tsvector</type> являются лексемы, предположительно уже "
"нормализованные, так что <literal>rats</literal> считается не "
"соответствующим <literal>rat</literal>."

#: textsearch.xml:304(programlisting)
#, no-wrap
msgid ""
"tsvector @@ tsquery\n"
"tsquery  @@ tsvector\n"
"text @@ tsquery\n"
"text @@ text"
msgstr ""
"tsvector @@ tsquery\n"
"tsquery  @@ tsvector\n"
"text @@ tsquery\n"
"text @@ text"

#: textsearch.xml:298(para)
msgid ""
"The <literal>@@</literal> operator also supports <type>text</type> input, "
"allowing explicit conversion of a text string to <type>tsvector</type> or "
"<type>tsquery</type> to be skipped in simple cases. The variants available "
"are: <placeholder-1/>"
msgstr ""
"Оператор <literal>@@</literal> также может принимать типы <type>text</type>, "
"позволяя опустить явные преобразования текстовых строк в типы "
"<type>tsvector</type> и <type>tsquery</type> в простых случаях. Всего есть "
"четыре варианта этого оператора: <placeholder-1/>"

#: textsearch.xml:312(para)
msgid ""
"The first two of these we saw already. The form <type>text</type> "
"<literal>@@</literal> <type>tsquery</type> is equivalent to "
"<literal>to_tsvector(x) @@ y</literal>. The form <type>text</type> "
"<literal>@@</literal> <type>text</type> is equivalent to "
"<literal>to_tsvector(x) @@ plainto_tsquery(y)</literal>."
msgstr ""
"Первые два мы уже видели раньше. Форма <type>text</type><literal>@@</"
"literal><type>tsquery</type> равнозначна выражению <literal>to_tsvector(x) "
"@@ y</literal>, а форма <type>text</type><literal>@@</literal><type>text</"
"type> &mdash; выражению <literal>to_tsvector(x) @@ plainto_tsquery(y)</"
"literal>."

#: textsearch.xml:320(para)
msgid ""
"Within a <type>tsquery</type>, the <literal>&amp;</literal> (AND) operator "
"specifies that both its arguments must appear in the document to have a "
"match. Similarly, the <literal>|</literal> (OR) operator specifies that at "
"least one of its arguments must appear, while the <literal>!</literal> (NOT) "
"operator specifies that its argument must <emphasis>not</emphasis> appear in "
"order to have a match."
msgstr ""
"В значении <type>tsquery</type> оператор <literal>&amp;</literal> (И) "
"указывает, что оба его операнда должны присутствовать в документе, чтобы он "
"удовлетворял запросу. Подобным образом, оператор <literal>|</literal> (ИЛИ) "
"указывает, что в документе должен присутствовать минимум один из его "
"операндов, тогда как оператор <literal>!</literal> (НЕ) указывает, что его "
"операнд <emphasis>не</emphasis> должен присутствовать, чтобы условие "
"удовлетворялось."

#: textsearch.xml:335(programlisting)
#, no-wrap
msgid ""
"SELECT to_tsvector('fatal error') @@ to_tsquery('fatal &lt;-&gt; error');\n"
" ?column? \n"
"----------\n"
" t\n"
"\n"
"SELECT to_tsvector('error is not fatal') @@ to_tsquery('fatal &lt;-&gt; error');\n"
" ?column? \n"
"----------\n"
" f"
msgstr ""
"SELECT to_tsvector('fatal error') @@ to_tsquery('fatal &lt;-&gt; error');\n"
" ?column? \n"
"----------\n"
" t\n"
"\n"
"SELECT to_tsvector('error is not fatal') @@ to_tsquery('fatal &lt;-&gt; error');\n"
" ?column? \n"
"----------\n"
" f"

#: textsearch.xml:357(programlisting)
#, no-wrap
msgid ""
"SELECT phraseto_tsquery('cats ate rats');\n"
"       phraseto_tsquery        \n"
"-------------------------------\n"
" 'cat' &lt;-&gt; 'ate' &lt;-&gt; 'rat'\n"
"\n"
"SELECT phraseto_tsquery('the cats ate the rats');\n"
"       phraseto_tsquery        \n"
"-------------------------------\n"
" 'cat' &lt;-&gt; 'ate' &lt;2&gt; 'rat'"
msgstr ""
"SELECT phraseto_tsquery('cats ate rats');\n"
"       phraseto_tsquery        \n"
"-------------------------------\n"
" 'cat' &lt;-&gt; 'ate' &lt;-&gt; 'rat'\n"
"\n"
"SELECT phraseto_tsquery('the cats ate the rats');\n"
"       phraseto_tsquery        \n"
"-------------------------------\n"
" 'cat' &lt;-&gt; 'ate' &lt;2&gt; 'rat'"

#: textsearch.xml:329(para)
msgid ""
"Searching for phrases is possible with the help of the <literal>&lt;-&gt;</"
"literal> (FOLLOWED BY) <type>tsquery</type> operator, which matches only if "
"its arguments have matches that are adjacent and in the given order. For "
"example: <placeholder-1/> There is a more general version of the FOLLOWED BY "
"operator having the form <literal>&lt;<replaceable>N</replaceable>&gt;</"
"literal>, where <replaceable>N</replaceable> is an integer standing for the "
"difference between the positions of the matching lexemes. <literal>&lt;1&gt;"
"</literal> is the same as <literal>&lt;-&gt;</literal>, while "
"<literal>&lt;2&gt;</literal> allows exactly one other lexeme to appear "
"between the matches, and so on. The <literal>phraseto_tsquery</literal> "
"function makes use of this operator to construct a <literal>tsquery</"
"literal> that can match a multi-word phrase when some of the words are stop "
"words. For example: <placeholder-2/>"
msgstr ""
"Фразовый поиск возможен с использованием оператора <literal>&lt;-&gt;</"
"literal> (ПРЕДШЕСТВУЕТ) типа <type>tsquery</type>, который находит "
"соответствие, только если его операнды расположены рядом и в заданном "
"порядке. Например: <placeholder-1/> Более общая версия оператора "
"ПРЕДШЕСТВУЕТ имеет вид <literal>&lt;<replaceable>N</replaceable>&gt;</"
"literal>, где <replaceable>N</replaceable> — целое число, выражающее "
"разность между позициями найденных лексем. Запись <literal>&lt;1&gt;</"
"literal> равнозначна <literal>&lt;-&gt;</literal>, тогда как "
"<literal>&lt;2&gt;</literal> допускает существование ровно одной лексемы "
"между этими лексемами и т. д. Функция <literal>phraseto_tsquery</literal> "
"задействует этот оператор для конструирования <literal>tsquery</literal>, "
"который может содержать многословную фразу, включающую в себя стоп-слова. "
"Например: <placeholder-2/>"

#: textsearch.xml:370(para)
msgid ""
"A special case that's sometimes useful is that <literal>&lt;0&gt;</literal> "
"can be used to require that two patterns match the same word."
msgstr ""
"Особый случай, который иногда бывает полезен, представляет собой запись "
"<literal>&lt;0&gt;</literal>, требующая, чтобы обоим лексемам "
"соответствовало одно слово."

#: textsearch.xml:375(para)
msgid ""
"Parentheses can be used to control nesting of the <type>tsquery</type> "
"operators. Without parentheses, <literal>|</literal> binds least tightly, "
"then <literal>&amp;</literal>, then <literal>&lt;-&gt;</literal>, and "
"<literal>!</literal> most tightly."
msgstr ""
"Сочетанием операторов <type>tsquery</type> можно управлять, применяя скобки. "
"Без скобок операторы имеют следующие приоритеты, в порядке возрастания: "
"<literal>|</literal>, <literal>&amp;</literal>, <literal>&lt;-&gt;</literal> "
"и самый приоритетный — <literal>!</literal>."

#: textsearch.xml:384(title)
msgid "Configurations"
msgstr "Конфигурации"

#: textsearch.xml:386(para)
msgid ""
"The above are all simple text search examples. As mentioned before, full "
"text search functionality includes the ability to do many more things: skip "
"indexing certain words (stop words), process synonyms, and use sophisticated "
"parsing, e.g., parse based on more than just white space. This functionality "
"is controlled by <firstterm>text search configurations</firstterm>. "
"<productname>PostgreSQL</productname> comes with predefined configurations "
"for many languages, and you can easily create your own configurations. "
"(<application>psql</application>'s <command>\\dF</command> command shows all "
"available configurations.)"
msgstr ""
"До этого мы рассматривали очень простые примеры поиска текста. Как было "
"упомянуто выше, весь функционал текстового поиска позволяет делать гораздо "
"больше: пропускать определённые слова (стоп-слова), обрабатывать синонимы и "
"выполнять сложный анализ слов, например, выделять фрагменты не только по "
"пробелам. Все эти функции управляются <firstterm>конфигурациями текстового "
"поиска</firstterm>. В <productname>PostgreSQL</productname> есть набор "
"предопределённых конфигураций для многих языков, но вы также можете "
"создавать собственные конфигурации. (Все доступные конфигурации можно "
"просмотреть с помощью команды <command>\\dF</command> в <application>psql</"
"application>.)"

#: textsearch.xml:398(para)
msgid ""
"During installation an appropriate configuration is selected and <xref "
"linkend=\"guc-default-text-search-config\"/> is set accordingly in "
"<filename>postgresql.conf</filename>. If you are using the same text search "
"configuration for the entire cluster you can use the value in "
"<filename>postgresql.conf</filename>. To use different configurations "
"throughout the cluster but the same configuration within any one database, "
"use <command>ALTER DATABASE ... SET</command>. Otherwise, you can set "
"<varname>default_text_search_config</varname> in each session."
msgstr ""
"Подходящая конфигурация для данной среды выбирается во время установки и "
"записывается в параметре <xref linkend=\"guc-default-text-search-config\"/> "
"в <filename>postgresql.conf</filename>. Если вы используете для всего "
"кластера одну конфигурацию текстового поиска, вам будет достаточно этого "
"параметра в <filename>postgresql.conf</filename>. Если же требуется "
"использовать в кластере разные конфигурации, но для каждой базы данных одну "
"определённую, её можно задать командой <command>ALTER DATABASE ... SET</"
"command>. В противном случае конфигурацию можно выбрать в рамках сеанса, "
"определив параметр <varname>default_text_search_config</varname>."

#: textsearch.xml:409(para)
msgid ""
"Each text search function that depends on a configuration has an optional "
"<type>regconfig</type> argument, so that the configuration to use can be "
"specified explicitly. <varname>default_text_search_config</varname> is used "
"only when this argument is omitted."
msgstr ""
"У каждой функции текстового поиска, зависящей от конфигурации, есть "
"необязательный аргумент <type>regconfig</type>, в котором можно явно указать "
"конфигурацию для данной функции. Значение "
"<varname>default_text_search_config</varname> используется, только когда "
"этот аргумент опущен."

#: textsearch.xml:416(para)
msgid ""
"To make it easier to build custom text search configurations, a "
"configuration is built up from simpler database objects. "
"<productname>PostgreSQL</productname>'s text search facility provides four "
"types of configuration-related database objects:"
msgstr ""
"Для упрощения создания конфигураций текстового поиска они строятся из более "
"простых объектов. В <productname>PostgreSQL</productname> есть четыре типа "
"таких объектов:"

#: textsearch.xml:425(para)
msgid ""
"<firstterm>Text search parsers</firstterm> break documents into tokens and "
"classify each token (for example, as words or numbers)."
msgstr ""
"<firstterm>Анализаторы текстового поиска</firstterm> разделяют документ на "
"фрагменты и классифицируют их (например, как слова или числа)."

#: textsearch.xml:432(para)
msgid ""
"<firstterm>Text search dictionaries</firstterm> convert tokens to normalized "
"form and reject stop words."
msgstr ""
"<firstterm>Словари текстового поиска</firstterm> приводят фрагменты к "
"нормализованной форме и отбрасывают стоп-слова."

#: textsearch.xml:439(para)
msgid ""
"<firstterm>Text search templates</firstterm> provide the functions "
"underlying dictionaries. (A dictionary simply specifies a template and a set "
"of parameters for the template.)"
msgstr ""
"<firstterm>Шаблоны текстового поиска</firstterm> предоставляют функции, "
"образующие реализацию словарей. (При создании словаря просто задаётся шаблон "
"и набор параметров для него.)"

#: textsearch.xml:447(para)
msgid ""
"<firstterm>Text search configurations</firstterm> select a parser and a set "
"of dictionaries to use to normalize the tokens produced by the parser."
msgstr ""
"<firstterm>Конфигурации текстового поиска</firstterm> выбирают анализатор и "
"набор словарей, который будет использоваться для нормализации фрагментов, "
"выданных анализатором."

#: textsearch.xml:454(para)
msgid ""
"Text search parsers and templates are built from low-level C functions; "
"therefore it requires C programming ability to develop new ones, and "
"superuser privileges to install one into a database. (There are examples of "
"add-on parsers and templates in the <filename>contrib/</filename> area of "
"the <productname>PostgreSQL</productname> distribution.) Since dictionaries "
"and configurations just parameterize and connect together some underlying "
"parsers and templates, no special privilege is needed to create a new "
"dictionary or configuration. Examples of creating custom dictionaries and "
"configurations appear later in this chapter."
msgstr ""
"Анализаторы и шаблоны текстового поиска строятся из низкоуровневых функций "
"на языке C; чтобы создать их, нужно программировать на C, а подключить их к "
"базе данных может только суперпользователь. (В подкаталоге <filename>contrib/"
"</filename> инсталляции <productname>PostgreSQL</productname> можно найти "
"примеры дополнительных анализаторов и шаблонов.) Так как словари и "
"конфигурации представляют собой просто наборы параметров, связывающие "
"анализаторы и шаблоны, их можно создавать, не имея административных прав. "
"Далее в этой главе будут приведены примеры их создания."

#: textsearch.xml:471(title)
msgid "Tables and Indexes"
msgstr "Таблицы и индексы"

#: textsearch.xml:473(para)
msgid ""
"The examples in the previous section illustrated full text matching using "
"simple constant strings. This section shows how to search table data, "
"optionally using indexes."
msgstr ""
"В предыдущем разделе приводились примеры, которые показывали, как можно "
"выполнить сопоставление с простыми текстовыми константами. В этом разделе "
"показывается, как находить текст в таблице, возможно с применением индексов."

#: textsearch.xml:480(title)
msgid "Searching a Table"
msgstr "Поиск в таблице"

#: textsearch.xml:487(programlisting)
#, no-wrap
msgid ""
"SELECT title\n"
"FROM pgweb\n"
"WHERE to_tsvector('english', body) @@ to_tsquery('english', 'friend');"
msgstr ""
"SELECT title\n"
"FROM pgweb\n"
"WHERE to_tsvector('english', body) @@ to_tsquery('english', 'friend');"

#: textsearch.xml:482(para)
msgid ""
"It is possible to do a full text search without an index. A simple query to "
"print the <structname>title</structname> of each row that contains the word "
"<literal>friend</literal> in its <structfield>body</structfield> field is: "
"<placeholder-1/> This will also find related words such as <literal>friends</"
"literal> and <literal>friendly</literal>, since all these are reduced to the "
"same normalized lexeme."
msgstr ""
"Полнотекстовый поиск можно выполнить, не применяя индекс. Следующий простой "
"запрос выводит заголовок (<structname>title</structname>) каждой строки, "
"содержащей слово <literal>friend</literal> в поле <structfield>body</"
"structfield>: <placeholder-1/> При этом также будут найдены связанные слова, "
"такие как <literal>friends</literal> и <literal>friendly</literal>, так как "
"все они сводятся к одной нормализованной лексеме."

#: textsearch.xml:503(programlisting)
#, no-wrap
msgid ""
"SELECT title\n"
"FROM pgweb\n"
"WHERE to_tsvector(body) @@ to_tsquery('friend');"
msgstr ""
"SELECT title\n"
"FROM pgweb\n"
"WHERE to_tsvector(body) @@ to_tsquery('friend');"

#: textsearch.xml:498(para)
msgid ""
"The query above specifies that the <literal>english</literal> configuration "
"is to be used to parse and normalize the strings. Alternatively we could "
"omit the configuration parameters: <placeholder-1/> This query will use the "
"configuration set by <xref linkend=\"guc-default-text-search-config\"/>."
msgstr ""
"В показанном выше примере для разбора и нормализации строки явно выбирается "
"конфигурация <literal>english</literal>. Хотя параметры, задающие "
"конфигурацию, можно опустить: <placeholder-1/> Такой запрос будет "
"использовать конфигурацию, заданную в параметре <xref linkend=\"guc-default-"
"text-search-config\"/>."

#: textsearch.xml:518(programlisting)
#, no-wrap
msgid ""
"SELECT title\n"
"FROM pgweb\n"
"WHERE to_tsvector(title || ' ' || body) @@ to_tsquery('create &amp; table')\n"
"ORDER BY last_mod_date DESC\n"
"LIMIT 10;"
msgstr ""
"SELECT title\n"
"FROM pgweb\n"
"WHERE to_tsvector(title || ' ' || body) @@ to_tsquery('create &amp; table')\n"
"ORDER BY last_mod_date DESC\n"
"LIMIT 10;"

#: textsearch.xml:513(para)
msgid ""
"A more complex example is to select the ten most recent documents that "
"contain <literal>create</literal> and <literal>table</literal> in the "
"<structname>title</structname> or <structname>body</structname>: "
"<placeholder-1/> For clarity we omitted the <function>coalesce</function> "
"function calls which would be needed to find rows that contain "
"<literal>NULL</literal> in one of the two fields."
msgstr ""
"В следующем более сложном примере выбираются десять документов, изменённых "
"последними, со словами <literal>create</literal> и <literal>table</literal> "
"в полях <structname>title</structname> или <structname>body</structname>: "
"<placeholder-1/> Чтобы найти строки, содержащие <literal>NULL</literal> в "
"одном из полей, нужно воспользоваться функцией <function>coalesce</"
"function>, но здесь мы опустили её вызовы для краткости."

#: textsearch.xml:531(para)
msgid ""
"Although these queries will work without an index, most applications will "
"find this approach too slow, except perhaps for occasional ad-hoc searches. "
"Practical use of text searching usually requires creating an index."
msgstr ""
"Хотя такие запросы будут работать и без индекса, для большинства приложений "
"скорость будет неприемлемой; этот подход рекомендуется только для "
"нерегулярного поиска и динамического содержимого. Для практического "
"применения полнотекстового поиска обычно создаются индексы."

#: textsearch.xml:541(title)
msgid "Creating Indexes"
msgstr "Создание индексов"

#: textsearch.xml:547(programlisting)
#, no-wrap
msgid "CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', body));"
msgstr "CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', body));"

#: textsearch.xml:543(para)
msgid ""
"We can create a <acronym>GIN</acronym> index (<xref linkend=\"textsearch-"
"indexes\"/>) to speed up text searches: <placeholder-1/> Notice that the 2-"
"argument version of <function>to_tsvector</function> is used. Only text "
"search functions that specify a configuration name can be used in expression "
"indexes (<xref linkend=\"indexes-expressional\"/>). This is because the "
"index contents must be unaffected by <xref linkend=\"guc-default-text-search-"
"config\"/>. If they were affected, the index contents might be inconsistent "
"because different entries could contain <type>tsvector</type>s that were "
"created with different text search configurations, and there would be no way "
"to guess which was which. It would be impossible to dump and restore such an "
"index correctly."
msgstr ""
"Для ускорения текстового поиска мы можем создать индекс <acronym>GIN</"
"acronym> (см. <xref remap=\"4\" linkend=\"textsearch-indexes\"/>): "
"<placeholder-1/> Заметьте, что здесь используется функция "
"<function>to_tsvector</function> с двумя аргументами. В выражениях, "
"определяющих индексы, можно использовать только функции, в которых явно "
"задаётся имя конфигурации текстового поиска (см. <xref remap=\"4\" linkend="
"\"indexes-expressional\"/>). Это объясняется тем, что содержимое индекса не "
"должно зависеть от значения параметра <xref linkend=\"guc-default-text-"
"search-config\"/>. В противном случае содержимое индекса может быть "
"неактуальным, если разные его элементы <type>tsvector</type> будут "
"создаваться с разными конфигурациями текстового поиска и нельзя будет "
"понять, какую именно использовать. Выгрузить и восстановить такой индекс "
"будет невозможно."

#: textsearch.xml:562(para)
msgid ""
"Because the two-argument version of <function>to_tsvector</function> was "
"used in the index above, only a query reference that uses the 2-argument "
"version of <function>to_tsvector</function> with the same configuration name "
"will use that index. That is, <literal>WHERE to_tsvector('english', body) @@ "
"'a &amp; b'</literal> can use the index, but <literal>WHERE "
"to_tsvector(body) @@ 'a &amp; b'</literal> cannot. This ensures that an "
"index will be used only with the same configuration used to create the index "
"entries."
msgstr ""
"Так как при создании индекса использовалась версия <function>to_tsvector</"
"function> с двумя аргументами, этот индекс будет использоваться только в "
"запросах, где <function>to_tsvector</function> вызывается с двумя "
"аргументами и во втором передаётся имя той же конфигурации. То есть, "
"<literal>WHERE to_tsvector('english', body) @@ 'a &amp; b'</literal> сможет "
"использовать этот индекс, а <literal>WHERE to_tsvector(body) @@ 'a &amp; b'</"
"literal> &mdash; нет. Это гарантирует, что индекс будет использоваться "
"только с той конфигурацией, с которой создавались его элементы."

#: textsearch.xml:577(programlisting)
#, no-wrap
msgid "CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector(config_name, body));"
msgstr "CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector(config_name, body));"

#: textsearch.xml:573(para)
msgid ""
"It is possible to set up more complex expression indexes wherein the "
"configuration name is specified by another column, e.g.: <placeholder-1/> "
"where <literal>config_name</literal> is a column in the <literal>pgweb</"
"literal> table. This allows mixed configurations in the same index while "
"recording which configuration was used for each index entry. This would be "
"useful, for example, if the document collection contained documents in "
"different languages. Again, queries that are meant to use the index must be "
"phrased to match, e.g., <literal>WHERE to_tsvector(config_name, body) @@ 'a "
"&amp; b'</literal>."
msgstr ""
"Индекс можно создать более сложным образом, определив для него имя "
"конфигурации в другом столбце таблицы, например: <placeholder-1/> где "
"<literal>config_name</literal> &mdash; имя столбца в таблице <literal>pgweb</"
"literal>. Так можно сохранить имя конфигурации, связанной с элементом "
"индекса, и, таким образом, иметь в одном индексе элементы с разными "
"конфигурациями. Это может быть полезно, например, когда в коллекции "
"документов хранятся документы на разных языках. И в этом случае в запросах "
"должен использоваться тот же индекс (с таким же образом задаваемой "
"конфигурацией), например, так: <literal>WHERE to_tsvector(config_name, body) "
"@@ 'a &amp; b'</literal>."

#: textsearch.xml:593(programlisting)
#, no-wrap
msgid "CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', title || ' ' || body));"
msgstr "CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', title || ' ' || body));"

#: textsearch.xml:590(para)
msgid "Indexes can even concatenate columns: <placeholder-1/>"
msgstr ""
"Индексы могут создаваться даже по объединению столбцов: <placeholder-1/>"

#: textsearch.xml:605(programlisting)
#, no-wrap
msgid ""
"ALTER TABLE pgweb ADD COLUMN textsearchable_index_col tsvector;\n"
"UPDATE pgweb SET textsearchable_index_col =\n"
"     to_tsvector('english', coalesce(title,'') || ' ' || coalesce(body,''));"
msgstr ""
"ALTER TABLE pgweb ADD COLUMN textsearchable_index_col tsvector;\n"
"UPDATE pgweb SET textsearchable_index_col =\n"
"     to_tsvector('english', coalesce(title,'') || ' ' || coalesce(body,''));"

#: textsearch.xml:613(programlisting)
#, no-wrap
msgid "CREATE INDEX textsearch_idx ON pgweb USING GIN (textsearchable_index_col);"
msgstr "CREATE INDEX textsearch_idx ON pgweb USING GIN (textsearchable_index_col);"

#: textsearch.xml:619(programlisting)
#, no-wrap
msgid ""
"SELECT title\n"
"FROM pgweb\n"
"WHERE textsearchable_index_col @@ to_tsquery('create &amp; table')\n"
"ORDER BY last_mod_date DESC\n"
"LIMIT 10;"
msgstr ""
"SELECT title\n"
"FROM pgweb\n"
"WHERE textsearchable_index_col @@ to_tsquery('create &amp; table')\n"
"ORDER BY last_mod_date DESC\n"
"LIMIT 10;"

#: textsearch.xml:598(para)
msgid ""
"Another approach is to create a separate <type>tsvector</type> column to "
"hold the output of <function>to_tsvector</function>. This example is a "
"concatenation of <literal>title</literal> and <literal>body</literal>, using "
"<function>coalesce</function> to ensure that one field will still be indexed "
"when the other is <literal>NULL</literal>: <placeholder-1/> Then we create a "
"<acronym>GIN</acronym> index to speed up the search: <placeholder-2/> Now we "
"are ready to perform a fast full text search: <placeholder-3/>"
msgstr ""
"Ещё один вариант &mdash; создать отдельный столбец <type>tsvector</type>, в "
"котором сохранить результат <function>to_tsvector</function>. Следующий "
"пример показывает, как можно подготовить для индексации объединённое "
"содержимое столбцов <literal>title</literal> и <literal>body</literal>, "
"применив функцию <function>coalesce</function> для получения желаемого "
"результата, даже когда один из столбцов <literal>NULL</literal>: "
"<placeholder-1/> Затем мы создаём индекс <acronym>GIN</acronym> для "
"ускорения поиска: <placeholder-2/> Теперь мы можем быстро выполнять "
"полнотекстовый поиск: <placeholder-3/>"

#: textsearch.xml:628(para)
msgid ""
"When using a separate column to store the <type>tsvector</type> "
"representation, it is necessary to create a trigger to keep the "
"<type>tsvector</type> column current anytime <literal>title</literal> or "
"<literal>body</literal> changes. <xref linkend=\"textsearch-update-triggers"
"\"/> explains how to do that."
msgstr ""
"Когда представление <type>tsvector</type> хранится в отдельном столбце, "
"необходимо создать триггер, который будет поддерживать столбец с "
"<type>tsvector</type> в актуальном состоянии при любых изменениях "
"<literal>title</literal> или <literal>body</literal>. Как это сделать, "
"рассказывается в <xref remap=\"6\" linkend=\"textsearch-update-triggers\"/>."

#: textsearch.xml:636(para)
msgid ""
"One advantage of the separate-column approach over an expression index is "
"that it is not necessary to explicitly specify the text search configuration "
"in queries in order to make use of the index. As shown in the example above, "
"the query can depend on <varname>default_text_search_config</varname>. "
"Another advantage is that searches will be faster, since it will not be "
"necessary to redo the <function>to_tsvector</function> calls to verify index "
"matches. (This is more important when using a GiST index than a GIN index; "
"see <xref linkend=\"textsearch-indexes\"/>.) The expression-index approach "
"is simpler to set up, however, and it requires less disk space since the "
"<type>tsvector</type> representation is not stored explicitly."
msgstr ""
"Хранение вычисленного выражения индекса в отдельном столбце даёт ряд "
"преимуществ. Во-первых, для использования индекса в запросах не нужно явно "
"указывать имя конфигурации текстового поиска. Как показано в вышеприведённом "
"примере, в этом случае запрос может зависеть от "
"<varname>default_text_search_config</varname>. Во-вторых, поиск выполняется "
"быстрее, так как для проверки соответствия данных индексу не нужно повторно "
"выполнять <function>to_tsvector</function>. (Это актуально больше для "
"индексов GiST, чем для GIN; см. <xref remap=\"4\" linkend=\"textsearch-"
"indexes\"/>.) С другой стороны, схему с индексом по выражению проще "
"реализовать и она позволяет сэкономить место на диске, так как представление "
"<type>tsvector</type> не хранится явно."

#: textsearch.xml:655(title)
msgid "Controlling Text Search"
msgstr "Управление текстовым поиском"

#: textsearch.xml:657(para)
msgid ""
"To implement full text searching there must be a function to create a "
"<type>tsvector</type> from a document and a <type>tsquery</type> from a user "
"query. Also, we need to return results in a useful order, so we need a "
"function that compares documents with respect to their relevance to the "
"query. It's also important to be able to display the results nicely. "
"<productname>PostgreSQL</productname> provides support for all of these "
"functions."
msgstr ""
"Для реализации полнотекстового поиска необходимы функции, позволяющие "
"создать <type>tsvector</type> из документа и <type>tsquery</type> из запроса "
"пользователя. Кроме того, результаты нужно выдавать в удобном порядке, так "
"что нам потребуется функция, оценивающая релевантность документа для данного "
"запроса. Важно также иметь возможность выводить найденный текст подходящим "
"образом. В <productname>PostgreSQL</productname> есть все необходимые для "
"этого функции."

#: textsearch.xml:668(title)
msgid "Parsing Documents"
msgstr "Разбор документов"

#: textsearch.xml:670(para)
msgid ""
"<productname>PostgreSQL</productname> provides the function "
"<function>to_tsvector</function> for converting a document to the "
"<type>tsvector</type> data type."
msgstr ""
"Для преобразования документа в тип <type>tsvector</type> "
"<productname>PostgreSQL</productname> предоставляет функцию "
"<function>to_tsvector</function>."

#: textsearch.xml:676(indexterm)
msgid "<primary>to_tsvector</primary>"
msgstr "<primary>to_tsvector</primary>"

#: textsearch.xml:681(replaceable) textsearch.xml:791(replaceable)
#: textsearch.xml:864(replaceable) textsearch.xml:904(replaceable)
#: textsearch.xml:1179(replaceable) textsearch.xml:3169(replaceable)
msgid "config"
msgstr "конфигурация"

#: textsearch.xml:681(type) textsearch.xml:791(type) textsearch.xml:864(type)
#: textsearch.xml:904(type) textsearch.xml:1179(type) textsearch.xml:3169(type)
msgid "regconfig"
msgstr "regconfig"

#: textsearch.xml:681(optional) textsearch.xml:791(optional)
#: textsearch.xml:864(optional) textsearch.xml:904(optional)
#: textsearch.xml:974(optional) textsearch.xml:991(optional)
#: textsearch.xml:1179(optional) textsearch.xml:1878(optional)
#: textsearch.xml:3169(optional)
msgid "<placeholder-1/> <placeholder-2/>,"
msgstr "<placeholder-1/> <placeholder-2/>,"

#: textsearch.xml:681(replaceable) textsearch.xml:1179(replaceable)
#: textsearch.xml:3169(replaceable) textsearch.xml:3352(replaceable)
#: textsearch.xml:3354(replaceable)
msgid "document"
msgstr "документ"

#: textsearch.xml:681(type) textsearch.xml:791(type) textsearch.xml:864(type)
#: textsearch.xml:904(type) textsearch.xml:1179(type) textsearch.xml:1601(type)
#: textsearch.xml:1678(type) textsearch.xml:1878(type)
#: textsearch.xml:1879(type) textsearch.xml:3169(type)
#: textsearch.xml:3170(type) textsearch.xml:3171(type)
#: textsearch.xml:3172(type) textsearch.xml:3352(type)
#: textsearch.xml:3353(type) textsearch.xml:3354(type)
#: textsearch.xml:3355(type) textsearch.xml:3383(type)
#: textsearch.xml:3384(type) textsearch.xml:3386(type)
#: textsearch.xml:3441(type)
msgid "text"
msgstr "text"

#: textsearch.xml:681(type) textsearch.xml:974(type) textsearch.xml:991(type)
#: textsearch.xml:1341(type) textsearch.xml:1380(type)
#: textsearch.xml:1408(type) textsearch.xml:1425(type)
msgid "tsvector"
msgstr "tsvector"

#: textsearch.xml:680(synopsis)
#, no-wrap
msgid "to_tsvector(<placeholder-1/> <placeholder-2/> <placeholder-3/>) returns <placeholder-4/>"
msgstr "to_tsvector(<optional> <replaceable class=\"parameter\">конфигурация</replaceable> <type>regconfig</type>, </optional> <replaceable class=\"parameter\">документ</replaceable> <type>text</type>) возвращает <type>tsvector</type>"

#: textsearch.xml:684(para)
msgid ""
"<function>to_tsvector</function> parses a textual document into tokens, "
"reduces the tokens to lexemes, and returns a <type>tsvector</type> which "
"lists the lexemes together with their positions in the document. The "
"document is processed according to the specified or default text search "
"configuration. Here is a simple example: <screen>\n"
"SELECT to_tsvector('english', 'a fat  cat sat on a mat - it ate a fat "
"rats');\n"
"                  to_tsvector\n"
"-----------------------------------------------------\n"
" 'ate':9 'cat':3 'fat':2,11 'mat':7 'rat':12 'sat':4\n"
"</screen>"
msgstr ""
"<function>to_tsvector</function> разбирает текстовые документ на фрагменты, "
"сводит фрагменты к лексемам и возвращает значение <type>tsvector</type>, в "
"котором перечисляются лексемы и их позиции в документе. При обработке "
"документа используется указанная конфигурация текстового поиска или "
"конфигурация по умолчанию. Простой пример: <screen>\n"
"SELECT to_tsvector('english', 'a fat  cat sat on a mat - it ate a fat "
"rats');\n"
"                  to_tsvector\n"
"-----------------------------------------------------\n"
" 'ate':9 'cat':3 'fat':2,11 'mat':7 'rat':12 'sat':4\n"
"</screen>"

#: textsearch.xml:700(para)
msgid ""
"In the example above we see that the resulting <type>tsvector</type> does "
"not contain the words <literal>a</literal>, <literal>on</literal>, or "
"<literal>it</literal>, the word <literal>rats</literal> became <literal>rat</"
"literal>, and the punctuation sign <literal>-</literal> was ignored."
msgstr ""
"В этом примере мы видим, что результирующий <type>tsvector</type> не "
"содержит слова <literal>a</literal>, <literal>on</literal> и <literal>it</"
"literal>, слово <literal>rats</literal> превратилось <literal>rat</literal>, "
"а знак препинания <quote><literal>-</literal></quote> был проигнорирован."

#: textsearch.xml:708(para)
msgid ""
"The <function>to_tsvector</function> function internally calls a parser "
"which breaks the document text into tokens and assigns a type to each token. "
"For each token, a list of dictionaries (<xref linkend=\"textsearch-"
"dictionaries\"/>) is consulted, where the list can vary depending on the "
"token type. The first dictionary that <firstterm>recognizes</firstterm> the "
"token emits one or more normalized <firstterm>lexemes</firstterm> to "
"represent the token. For example, <literal>rats</literal> became "
"<literal>rat</literal> because one of the dictionaries recognized that the "
"word <literal>rats</literal> is a plural form of <literal>rat</literal>. "
"Some words are recognized as <firstterm>stop words</firstterm> (<xref "
"linkend=\"textsearch-stopwords\"/>), which causes them to be ignored since "
"they occur too frequently to be useful in searching. In our example these "
"are <literal>a</literal>, <literal>on</literal>, and <literal>it</literal>. "
"If no dictionary in the list recognizes the token then it is also ignored. "
"In this example that happened to the punctuation sign <literal>-</literal> "
"because there are in fact no dictionaries assigned for its token type "
"(<literal>Space symbols</literal>), meaning space tokens will never be "
"indexed. The choices of parser, dictionaries and which types of tokens to "
"index are determined by the selected text search configuration (<xref "
"linkend=\"textsearch-configuration\"/>). It is possible to have many "
"different configurations in the same database, and predefined configurations "
"are available for various languages. In our example we used the default "
"configuration <literal>english</literal> for the English language."
msgstr ""
"Функция <function>to_tsvector</function> внутри вызывает анализатор, который "
"разбивает текст документа на фрагменты и классифицирует их. Для каждого "
"фрагмента она проверяет список словарей (<xref linkend=\"textsearch-"
"dictionaries\"/>), определяемый типом фрагмента. Первый же словарь, "
"<firstterm>распознавший</firstterm> фрагмент, выдаёт одну или несколько "
"представляющих его <firstterm>лексем</firstterm>. Например, <literal>rats</"
"literal> превращается в <literal>rat</literal>, так как один из словарей "
"понимает, что слово <literal>rats</literal> &mdash; это слово <literal>rat</"
"literal> во множественном числе. Некоторое слова распознаются как "
"<firstterm>стоп-слова</firstterm> (<xref linkend=\"textsearch-stopwords\"/>) "
"и игнорируются как слова, фигурирующие в тексте настолько часто, что искать "
"их бессмысленно. В нашем примере это <literal>a</literal>, <literal>on</"
"literal> и <literal>it</literal>. Если фрагмент не воспринимается ни одним "
"словарём из списка, он так же игнорируется. В данном примере это происходит "
"со знаком препинания <literal>-</literal>, так как с таким типом фрагмента "
"(<literal>символы-разделители</literal>) не связан никакой словарь и значит "
"такие фрагменты никогда не будут индексироваться. Выбор анализатора, "
"словарей и индексируемых типов фрагментов определяется конфигурацией "
"текстового поиска (<xref linkend=\"textsearch-configuration\"/>). В одной "
"базе данных можно использовать разные конфигурации, в том числе, "
"предопределённые конфигурации для разных языков. В нашем примере мы "
"использовали конфигурацию по умолчанию для английского языка &mdash; "
"<literal>english</literal>."

#: textsearch.xml:736(para)
msgid ""
"The function <function>setweight</function> can be used to label the entries "
"of a <type>tsvector</type> with a given <firstterm>weight</firstterm>, where "
"a weight is one of the letters <literal>A</literal>, <literal>B</literal>, "
"<literal>C</literal>, or <literal>D</literal>. This is typically used to "
"mark entries coming from different parts of a document, such as title versus "
"body. Later, this information can be used for ranking of search results."
msgstr ""
"Для назначения элементам <type>tsvector</type> разных <firstterm>весов</"
"firstterm> используется функция <function>setweight</function>. Вес элемента "
"задаётся буквой <literal>A</literal>, <literal>B</literal>, <literal>C</"
"literal> или <literal>D</literal>. Обычно это применяется для обозначения "
"важности слов в разных частях документа, например в заголовке или в теле "
"документа. Затем эта информация может использоваться при ранжировании "
"результатов поиска."

#: textsearch.xml:753(programlisting)
#, no-wrap
msgid ""
"UPDATE tt SET ti =\n"
"    setweight(to_tsvector(coalesce(title,'')), 'A')    ||\n"
"    setweight(to_tsvector(coalesce(keyword,'')), 'B')  ||\n"
"    setweight(to_tsvector(coalesce(abstract,'')), 'C') ||\n"
"    setweight(to_tsvector(coalesce(body,'')), 'D');"
msgstr ""
"UPDATE tt SET ti =\n"
"    setweight(to_tsvector(coalesce(title,'')), 'A')    ||\n"
"    setweight(to_tsvector(coalesce(keyword,'')), 'B')  ||\n"
"    setweight(to_tsvector(coalesce(abstract,'')), 'C') ||\n"
"    setweight(to_tsvector(coalesce(body,'')), 'D');"

#: textsearch.xml:746(para)
msgid ""
"Because <function>to_tsvector</function>(<literal>NULL</literal>) will "
"return <literal>NULL</literal>, it is recommended to use <function>coalesce</"
"function> whenever a field might be null. Here is the recommended method for "
"creating a <type>tsvector</type> from a structured document: <placeholder-1/"
"> Here we have used <function>setweight</function> to label the source of "
"each lexeme in the finished <type>tsvector</type>, and then merged the "
"labeled <type>tsvector</type> values using the <type>tsvector</type> "
"concatenation operator <literal>||</literal>. (<xref linkend=\"textsearch-"
"manipulate-tsvector\"/> gives details about these operations.)"
msgstr ""
"Так как <function>to_tsvector</function>(<literal>NULL</literal>) вернёт "
"<literal>NULL</literal>, мы советуем использовать <function>coalesce</"
"function> везде, где соответствующее поле может быть NULL. Создавать "
"<type>tsvector</type> из структурированного документа рекомендуется так: "
"<placeholder-1/> Здесь мы использовали <function>setweight</function> для "
"пометки происхождения каждой лексемы в сформированных значениях "
"<type>tsvector</type> и объединили помеченные значения с помощью оператора "
"конкатенации типов <type>tsvector</type> <literal>||</literal>. (Подробнее "
"эти операции рассматриваются в <xref remap=\"6\" linkend=\"textsearch-"
"manipulate-tsvector\"/>.)"

#: textsearch.xml:772(title)
msgid "Parsing Queries"
msgstr "Разбор запросов"

#: textsearch.xml:774(para)
msgid ""
"<productname>PostgreSQL</productname> provides the functions "
"<function>to_tsquery</function>, <function>plainto_tsquery</function>, and "
"<function>phraseto_tsquery</function> for converting a query to the "
"<type>tsquery</type> data type. <function>to_tsquery</function> offers "
"access to more features than either <function>plainto_tsquery</function> or "
"<function>phraseto_tsquery</function>, but it is less forgiving about its "
"input."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет функции "
"<function>to_tsquery</function>, <function>plainto_tsquery</function> и "
"<function>phraseto_tsquery</function> для приведения запроса к типу данных "
"<type>tsquery</type>. Функция <function>to_tsquery</function> даёт больше "
"возможностей, чем <function>plainto_tsquery</function> и "
"<function>phraseto_tsquery</function>, но более строга к входному запросу."

#: textsearch.xml:786(indexterm)
msgid "<primary>to_tsquery</primary>"
msgstr "<primary>to_tsquery</primary>"

#: textsearch.xml:791(replaceable) textsearch.xml:864(replaceable)
#: textsearch.xml:904(replaceable)
msgid "querytext"
msgstr "текст_запроса"

#: textsearch.xml:791(type) textsearch.xml:864(type) textsearch.xml:904(type)
#: textsearch.xml:974(type) textsearch.xml:991(type) textsearch.xml:1179(type)
#: textsearch.xml:1468(type) textsearch.xml:1482(type)
#: textsearch.xml:1496(type) textsearch.xml:1510(type)
#: textsearch.xml:1538(type) textsearch.xml:1567(type)
#: textsearch.xml:1601(type) textsearch.xml:1654(type)
#: textsearch.xml:1678(type)
msgid "tsquery"
msgstr "tsquery"

#: textsearch.xml:790(synopsis)
#, no-wrap
msgid "to_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>) returns <placeholder-4/>"
msgstr "to_tsquery(<optional> <replaceable class=\"parameter\">конфигурация</replaceable> <type>regconfig</type>, </optional> <replaceable class=\"parameter\">текст_запроса</replaceable> <type>text</type>) возвращает <type>tsquery</type>"

#: textsearch.xml:794(para)
msgid ""
"<function>to_tsquery</function> creates a <type>tsquery</type> value from "
"<replaceable>querytext</replaceable>, which must consist of single tokens "
"separated by the <type>tsquery</type> operators <literal>&amp;</literal> "
"(AND), <literal>|</literal> (OR), <literal>!</literal> (NOT), and "
"<literal>&lt;-&gt;</literal> (FOLLOWED BY), possibly grouped using "
"parentheses. In other words, the input to <function>to_tsquery</function> "
"must already follow the general rules for <type>tsquery</type> input, as "
"described in <xref linkend=\"datatype-tsquery\"/>. The difference is that "
"while basic <type>tsquery</type> input takes the tokens at face value, "
"<function>to_tsquery</function> normalizes each token into a lexeme using "
"the specified or default configuration, and discards any tokens that are "
"stop words according to the configuration. For example: <screen>\n"
"SELECT to_tsquery('english', 'The &amp; Fat &amp; Rats');\n"
"  to_tsquery   \n"
"---------------\n"
" 'fat' &amp; 'rat'\n"
"</screen> As in basic <type>tsquery</type> input, weight(s) can be attached "
"to each lexeme to restrict it to match only <type>tsvector</type> lexemes of "
"those weight(s). For example: <screen>\n"
"SELECT to_tsquery('english', 'Fat | Rats:AB');\n"
"    to_tsquery    \n"
"------------------\n"
" 'fat' | 'rat':AB\n"
"</screen> Also, <literal>*</literal> can be attached to a lexeme to specify "
"prefix matching: <screen>\n"
"SELECT to_tsquery('supern:*A &amp; star:A*B');\n"
"        to_tsquery        \n"
"--------------------------\n"
" 'supern':*A &amp; 'star':*AB\n"
"</screen> Such a lexeme will match any word in a <type>tsvector</type> that "
"begins with the given string."
msgstr ""
"<function>to_tsquery</function> создаёт значение <type>tsquery</type> из "
"<replaceable>текста_запроса</replaceable>, который может состоять из простых "
"фрагментов, разделённых логическими операторами <type>tsquery</type>: "
"<literal>&amp;</literal> (И), <literal>|</literal> (ИЛИ), <literal>!</"
"literal> (НЕ) и <literal>&lt;-&gt;</literal> (ПРЕДШЕСТВУЕТ), возможно, "
"сгруппированных скобками. Другими словами, входное значение для "
"<function>to_tsquery</function> должно уже соответствовать общим правилам "
"для значений <type>tsquery</type>, описанным в <xref remap=\"6\" linkend="
"\"datatype-tsquery\"/>. Различие их состоит в том, что во вводимом в "
"<type>tsquery</type> значении фрагменты воспринимаются буквально, тогда как "
"<function>to_tsquery</function> нормализует фрагменты, приводя их к "
"лексемам, используя явно указанную или подразумеваемую конфигурацию, и "
"отбрасывая стоп-слова. Например: <screen>\n"
"SELECT to_tsquery('english', 'The &amp; Fat &amp; Rats');\n"
"  to_tsquery   \n"
"---------------\n"
" 'fat' &amp; 'rat'\n"
"</screen> Как и при вводе значения <type>tsquery</type>, для каждой лексемы "
"можно задать вес(а), чтобы при поиске можно было выбрать из <type>tsvector</"
"type> только лексемы с заданными весами. Например: <screen>\n"
"SELECT to_tsquery('english', 'Fat | Rats:AB');\n"
"    to_tsquery    \n"
"------------------\n"
" 'fat' | 'rat':AB\n"
"</screen> К лексеме также можно добавить <literal>*</literal>, определив "
"таким образом условие поиска по префиксу: <screen>\n"
"SELECT to_tsquery('supern:*A &amp; star:A*B');\n"
"        to_tsquery        \n"
"--------------------------\n"
" 'supern':*A &amp; 'star':*AB\n"
"</screen> Такая лексема будет соответствовать любому слову в <type>tsvector</"
"type>, начинающемуся с данной подстроки."

#: textsearch.xml:840(para)
msgid ""
"<function>to_tsquery</function> can also accept single-quoted phrases. This "
"is primarily useful when the configuration includes a thesaurus dictionary "
"that may trigger on such phrases. In the example below, a thesaurus contains "
"the rule <literal>supernovae stars : sn</literal>: <screen>\n"
"SELECT to_tsquery('''supernovae stars'' &amp; !crab');\n"
"  to_tsquery\n"
"---------------\n"
" 'sn' &amp; !'crab'\n"
"</screen> Without quotes, <function>to_tsquery</function> will generate a "
"syntax error for tokens that are not separated by an AND, OR, or FOLLOWED BY "
"operator."
msgstr ""
"<function>to_tsquery</function> может также принимать фразы в апострофах. "
"Это полезно в основном когда конфигурация включает тезаурус, который может "
"обрабатывать такие фразы. В показанном ниже примере предполагается, что "
"тезаурус содержит правило <literal>supernovae stars : sn</literal>: "
"<screen>\n"
"SELECT to_tsquery('''supernovae stars'' &amp; !crab');\n"
"  to_tsquery\n"
"---------------\n"
" 'sn' &amp; !'crab'\n"
"</screen> Если убрать эти апострофы, <function>to_tsquery</function> не "
"примет фрагменты, не разделённые операторами И, ИЛИ и ПРЕДШЕСТВУЕТ, и выдаст "
"синтаксическую ошибку."

#: textsearch.xml:859(indexterm)
msgid "<primary>plainto_tsquery</primary>"
msgstr "<primary>plainto_tsquery</primary>"

#: textsearch.xml:863(synopsis)
#, no-wrap
msgid "plainto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>) returns <placeholder-4/>"
msgstr "plainto_tsquery(<optional> <replaceable class=\"parameter\">конфигурация</replaceable> <type>regconfig</type>, </optional> <replaceable class=\"parameter\">текст_запроса</replaceable> <type>text</type>) возвращает <type>tsquery</type>"

#: textsearch.xml:867(para)
msgid ""
"<function>plainto_tsquery</function> transforms the unformatted text "
"<replaceable>querytext</replaceable> to a <type>tsquery</type> value. The "
"text is parsed and normalized much as for <function>to_tsvector</function>, "
"then the <literal>&amp;</literal> (AND) <type>tsquery</type> operator is "
"inserted between surviving words."
msgstr ""
"<function>plainto_tsquery</function> преобразует неформатированный "
"<replaceable>текст_запроса</replaceable> в значение <type>tsquery</type>. "
"Текст разбирается и нормализуется подобно тому, как это делает "
"<function>to_tsvector</function>, а затем между оставшимися словами "
"вставляются операторы <literal>&amp;</literal> (И) типа <type>tsquery</type>."

#: textsearch.xml:875(para)
msgid ""
"Example: <screen>\n"
"SELECT plainto_tsquery('english', 'The Fat Rats');\n"
" plainto_tsquery \n"
"-----------------\n"
" 'fat' &amp; 'rat'\n"
"</screen> Note that <function>plainto_tsquery</function> will not recognize "
"<type>tsquery</type> operators, weight labels, or prefix-match labels in its "
"input: <screen>\n"
"SELECT plainto_tsquery('english', 'The Fat &amp; Rats:C');\n"
"   plainto_tsquery   \n"
"---------------------\n"
" 'fat' &amp; 'rat' &amp; 'c'\n"
"</screen> Here, all the input punctuation was discarded as being space "
"symbols."
msgstr ""
"Пример: <screen>\n"
"SELECT plainto_tsquery('english', 'The Fat Rats');\n"
" plainto_tsquery \n"
"-----------------\n"
" 'fat' &amp; 'rat'\n"
"</screen> Заметьте, что <function>plainto_tsquery</function> не распознает "
"во входной строке операторы <type>tsquery</type>, метки весов или "
"обозначения префиксов: <screen>\n"
"SELECT plainto_tsquery('english', 'The Fat &amp; Rats:C');\n"
"   plainto_tsquery   \n"
"---------------------\n"
" 'fat' &amp; 'rat' &amp; 'c'\n"
"</screen> В данном случае все знаки пунктуации были отброшены как символы-"
"разделители."

#: textsearch.xml:899(indexterm)
msgid "<primary>phraseto_tsquery</primary>"
msgstr "<primary>phraseto_tsquery</primary>"

#: textsearch.xml:903(synopsis)
#, no-wrap
msgid "phraseto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>) returns <placeholder-4/>"
msgstr "phraseto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>) returns <placeholder-4/>"

#: textsearch.xml:907(para)
msgid ""
"<function>phraseto_tsquery</function> behaves much like "
"<function>plainto_tsquery</function>, except that it inserts the "
"<literal>&lt;-&gt;</literal> (FOLLOWED BY) operator between surviving words "
"instead of the <literal>&amp;</literal> (AND) operator. Also, stop words are "
"not simply discarded, but are accounted for by inserting <literal>&lt;"
"<replaceable>N</replaceable>&gt;</literal> operators rather than "
"<literal>&lt;-&gt;</literal> operators. This function is useful when "
"searching for exact lexeme sequences, since the FOLLOWED BY operators check "
"lexeme order not just the presence of all the lexemes."
msgstr ""
"<function>phraseto_tsquery</function> ведёт себя подобно "
"<function>plainto_tsquery</function>, за исключением того, что она вставляет "
"между оставшимися словами оператор <literal>&lt;-&gt;</literal> "
"(ПРЕДШЕСТВУЕТ) вместо оператора <literal>&amp;</literal> (И). Кроме того, "
"стоп-слова не просто отбрасываются, а подсчитываются, и вместо операторов "
"<literal>&lt;-&gt;</literal> используются операторы <literal>&lt;"
"<replaceable>N</replaceable>&gt;</literal> с подсчитанным числом. Эта "
"функция полезна при поиске точных последовательностей лексем, так как "
"операторы ПРЕДШЕСТВУЕТ проверяют не только наличие всех лексем, но и их "
"порядок."

#: textsearch.xml:919(para)
msgid ""
"Example: <screen>\n"
"SELECT phraseto_tsquery('english', 'The Fat Rats');\n"
" phraseto_tsquery\n"
"------------------\n"
" 'fat' &lt;-&gt; 'rat'\n"
"</screen> Like <function>plainto_tsquery</function>, the "
"<function>phraseto_tsquery</function> function will not recognize "
"<type>tsquery</type> operators, weight labels, or prefix-match labels in its "
"input: <screen>\n"
"SELECT phraseto_tsquery('english', 'The Fat &amp; Rats:C');\n"
"      phraseto_tsquery\n"
"-----------------------------\n"
" 'fat' &lt;-&gt; 'rat' &lt;-&gt; 'c'\n"
"</screen>"
msgstr ""
"Пример: <screen>\n"
"SELECT phraseto_tsquery('english', 'The Fat Rats');\n"
" phraseto_tsquery\n"
"------------------\n"
" 'fat' &lt;-&gt; 'rat'\n"
"</screen> Как и <function>plainto_tsquery</function>, функция "
"<function>phraseto_tsquery</function> не распознает во входной строке "
"операторы типа <type>tsquery</type>, метки весов или обозначения префиксов: "
"<screen>\n"
"SELECT phraseto_tsquery('english', 'The Fat &amp; Rats:C');\n"
"      phraseto_tsquery\n"
"-----------------------------\n"
" 'fat' &lt;-&gt; 'rat' &lt;-&gt; 'c'\n"
"</screen>"

#: textsearch.xml:945(title)
msgid "Ranking Search Results"
msgstr "Ранжирование результатов поиска"

#: textsearch.xml:947(para)
msgid ""
"Ranking attempts to measure how relevant documents are to a particular "
"query, so that when there are many matches the most relevant ones can be "
"shown first. <productname>PostgreSQL</productname> provides two predefined "
"ranking functions, which take into account lexical, proximity, and "
"structural information; that is, they consider how often the query terms "
"appear in the document, how close together the terms are in the document, "
"and how important is the part of the document where they occur. However, the "
"concept of relevancy is vague and very application-specific. Different "
"applications might require additional information for ranking, e.g., "
"document modification time. The built-in ranking functions are only "
"examples. You can write your own ranking functions and/or combine their "
"results with additional factors to fit your specific needs."
msgstr ""
"Ранжирование документов можно представить как попытку оценить, насколько они "
"релевантны заданному запросу и отсортировать их так, чтобы наиболее "
"релевантные выводились первыми. В <productname>PostgreSQL</productname> "
"встроены две функции ранжирования, принимающие во внимание лексическую, "
"позиционную и структурную информацию; то есть, они учитывают, насколько "
"часто и насколько близко встречаются в документе ключевые слова и какова "
"важность содержащей их части документа. Однако само понятие релевантности "
"довольно размытое и во многом определяется приложением. Приложения могут "
"использовать для ранжирования и другую информацию, например, время изменения "
"документа. Встроенные функции ранжирования можно рассматривать лишь как "
"примеры реализации. Для своих конкретных задач вы можете разработать "
"собственные функции ранжирования и/или учесть при обработке их результатов "
"дополнительные факторы."

#: textsearch.xml:970(indexterm)
msgid "<primary>ts_rank</primary>"
msgstr "<primary>ts_rank</primary>"

#: textsearch.xml:974(replaceable) textsearch.xml:991(replaceable)
#: textsearch.xml:1878(replaceable)
msgid "weights"
msgstr "веса"

#: textsearch.xml:974(type) textsearch.xml:991(type)
msgid "float4[]"
msgstr "float4[]"

#: textsearch.xml:974(replaceable) textsearch.xml:991(replaceable)
#: textsearch.xml:1380(replaceable) textsearch.xml:1408(replaceable)
#: textsearch.xml:1425(replaceable)
msgid "vector"
msgstr "вектор"

#: textsearch.xml:974(replaceable) textsearch.xml:991(replaceable)
#: textsearch.xml:1179(replaceable) textsearch.xml:1567(replaceable)
#: textsearch.xml:1601(replaceable) textsearch.xml:1654(replaceable)
#: textsearch.xml:1678(replaceable)
msgid "query"
msgstr "запрос"

#: textsearch.xml:974(replaceable) textsearch.xml:991(replaceable)
msgid "normalization"
msgstr "нормализация"

#: textsearch.xml:974(type) textsearch.xml:991(type) textsearch.xml:1408(type)
#: textsearch.xml:1538(type) textsearch.xml:1567(type)
#: textsearch.xml:1879(type) textsearch.xml:1880(type)
#: textsearch.xml:3353(type) textsearch.xml:3355(type)
#: textsearch.xml:3383(type) textsearch.xml:3385(type)
msgid "integer"
msgstr "integer"

#: textsearch.xml:974(optional) textsearch.xml:991(optional)
#: textsearch.xml:1179(optional)
msgid ", <placeholder-1/> <placeholder-2/>"
msgstr ", <placeholder-1/> <placeholder-2/>"

#: textsearch.xml:974(type) textsearch.xml:991(type)
msgid "float4"
msgstr "float4"

#: textsearch.xml:974(literal)
msgid ""
"ts_rank(<placeholder-1/> <placeholder-2/> <placeholder-3/>, <placeholder-4/> "
"<placeholder-5/> <placeholder-6/>) returns <placeholder-7/>"
msgstr ""
"ts_rank(<placeholder-1/> <placeholder-2/> <placeholder-3/>, <placeholder-4/> "
"<placeholder-5/> <placeholder-6/>) возвращает <placeholder-7/>"

#: textsearch.xml:978(para)
msgid "Ranks vectors based on the frequency of their matching lexemes."
msgstr "Ранжирует векторы по частоте найденных лексем."

#: textsearch.xml:987(indexterm)
msgid "<primary>ts_rank_cd</primary>"
msgstr "<primary>ts_rank_cd</primary>"

#: textsearch.xml:991(literal)
msgid ""
"ts_rank_cd(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>) returns <placeholder-7/>"
msgstr ""
"ts_rank_cd(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>) возвращает "
"<placeholder-7/>"

#: textsearch.xml:995(para)
msgid ""
"This function computes the <firstterm>cover density</firstterm> ranking for "
"the given document vector and query, as described in Clarke, Cormack, and "
"Tudhope's \"Relevance Ranking for One to Three Term Queries\" in the journal "
"\"Information Processing and Management\", 1999. Cover density is similar to "
"<function>ts_rank</function> ranking except that the proximity of matching "
"lexemes to each other is taken into consideration."
msgstr ""
"Эта функция вычисляет <firstterm>плотность покрытия</firstterm> для данного "
"вектора документа и запроса, используя метод, разработанный Кларком, "
"Кормаком и Тадхоуп и описанный в статье \"Relevance Ranking for One to Three "
"Term Queries\" в журнале \"Information Processing and Management\" в 1999 г. "
"Плотность покрытия вычисляется подобно рангу <function>ts_rank</function>, "
"но в расчёт берётся ещё и близость соответствующих лексем друг к другу."

#: textsearch.xml:1005(para)
msgid ""
"This function requires lexeme positional information to perform its "
"calculation. Therefore, it ignores any <quote>stripped</quote> lexemes in "
"the <type>tsvector</type>. If there are no unstripped lexemes in the input, "
"the result will be zero. (See <xref linkend=\"textsearch-manipulate-tsvector"
"\"/> for more information about the <function>strip</function> function and "
"positional information in <type>tsvector</type>s.)"
msgstr ""
"Для вычисления результата этой функции требуется информация о позиции "
"лексем. Поэтому она игнорируют <quote>очищенные</quote> от этой информации "
"лексемы в <type>tsvector</type>. Если во входных данных нет неочищенных "
"лексем, результат будет равен нулю. (За дополнительными сведениями о функции "
"<function>strip</function> и позиционной информации в данных <type>tsvector</"
"type> обратитесь к <xref remap=\"3\" linkend=\"textsearch-manipulate-tsvector"
"\"/>.)"

#: textsearch.xml:962(para)
msgid "The two ranking functions currently available are: <placeholder-1/>"
msgstr "Ниже описаны две встроенные функции ранжирования: <placeholder-1/>"

#: textsearch.xml:1035(programlisting)
#, no-wrap
msgid "{0.1, 0.2, 0.4, 1.0}"
msgstr "{0.1, 0.2, 0.4, 1.0}"

#: textsearch.xml:1021(para)
msgid ""
"For both these functions, the optional <replaceable class=\"parameter"
"\">weights</replaceable> argument offers the ability to weigh word instances "
"more or less heavily depending on how they are labeled. The weight arrays "
"specify how heavily to weigh each category of word, in the order: "
"<synopsis>\n"
"{D-weight, C-weight, B-weight, A-weight}\n"
"</synopsis> If no <replaceable class=\"parameter\">weights</replaceable> are "
"provided, then these defaults are used: <placeholder-1/> Typically weights "
"are used to mark words from special areas of the document, like the title or "
"an initial abstract, so they can be treated with more or less importance "
"than words in the document body."
msgstr ""
"Для обеих этих функций аргумент <replaceable class=\"parameter\">веса</"
"replaceable> позволяет придать больший или меньший вес словам, в зависимости "
"от их меток. В передаваемом массиве весов определяется, насколько весома "
"каждая категория слов, в следующем порядке: <synopsis>\n"
"{вес D, вес C, вес B, вес A}\n"
"</synopsis> Если этот аргумент опускается, подразумеваются следующие "
"значения: <placeholder-1/> Обычно весами выделяются слова из особых областей "
"документа, например из заголовка или краткого введения, с тем, чтобы эти "
"слова считались более и менее значимыми, чем слова в основном тексте "
"документа."

#: textsearch.xml:1057(para)
msgid "0 (the default) ignores the document length"
msgstr "0 (по умолчанию): длина документа не учитывается"

#: textsearch.xml:1062(para)
msgid "1 divides the rank by 1 + the logarithm of the document length"
msgstr "1: ранг документа делится на 1 + логарифм длины документа"

#: textsearch.xml:1067(para)
msgid "2 divides the rank by the document length"
msgstr "2: ранг документа делится на его длину"

#: textsearch.xml:1072(para)
msgid ""
"4 divides the rank by the mean harmonic distance between extents (this is "
"implemented only by <function>ts_rank_cd</function>)"
msgstr ""
"4: ранг документа делится на среднее гармоническое расстояние между блоками "
"(это реализовано только в <function>ts_rank_cd</function>)"

#: textsearch.xml:1078(para)
msgid "8 divides the rank by the number of unique words in document"
msgstr "8: ранг документа делится на число уникальных слов в документе"

#: textsearch.xml:1083(para)
msgid ""
"16 divides the rank by 1 + the logarithm of the number of unique words in "
"document"
msgstr ""
"16: ранг документа делится на 1 + логарифм числа уникальных слов в документе"

#: textsearch.xml:1089(para)
msgid "32 divides the rank by itself + 1"
msgstr "32: ранг делится своё же значение + 1"

#: textsearch.xml:1044(para)
msgid ""
"Since a longer document has a greater chance of containing a query term it "
"is reasonable to take into account document size, e.g., a hundred-word "
"document with five instances of a search word is probably more relevant than "
"a thousand-word document with five instances. Both ranking functions take an "
"integer <replaceable>normalization</replaceable> option that specifies "
"whether and how a document's length should impact its rank. The integer "
"option controls several behaviors, so it is a bit mask: you can specify one "
"or more behaviors using <literal>|</literal> (for example, <literal>2|4</"
"literal>). <placeholder-1/> If more than one flag bit is specified, the "
"transformations are applied in the order listed."
msgstr ""
"Так как вероятность найти ключевые слова увеличивается с размером документа, "
"при ранжировании имеет смысл учитывать его, чтобы, например, документ с "
"сотней слов, содержащий пять вхождений искомых слов, считался более "
"релевантным, чем документ с тысячей слов и теми же пятью вхождениями. Обе "
"функции ранжирования принимают целочисленный параметр "
"<replaceable>нормализации</replaceable>, определяющий, как ранг документа "
"будет зависеть от его размера. Этот параметр представляет собой битовую "
"маску и управляет несколькими режимами: вы можете включить сразу несколько "
"режимов, объединив значения оператором <literal>|</literal> (например так: "
"<literal>2|4</literal>). <placeholder-1/> Если включены несколько флагов, "
"соответствующие операции выполняются в показанном порядке."

#: textsearch.xml:1099(para)
msgid ""
"It is important to note that the ranking functions do not use any global "
"information, so it is impossible to produce a fair normalization to 1% or "
"100% as sometimes desired. Normalization option 32 (<literal>rank/(rank+1)</"
"literal>) can be applied to scale all ranks into the range zero to one, but "
"of course this is just a cosmetic change; it will not affect the ordering of "
"the search results."
msgstr ""
"Важно заметить, что функции ранжирования не используют никакую внешнюю "
"информацию, так что добиться нормализации до 1% или 100% невозможно, хотя "
"иногда это желательно. Применив параметр 32 (<literal>rank/(rank+1)</"
"literal>), можно свести все ранги к диапазону 0..1, но это изменение будет "
"лишь косметическим, на порядке сортировки результатов это не отразится."

#: textsearch.xml:1108(para)
msgid ""
"Here is an example that selects only the ten highest-ranked matches: "
"<screen>\n"
"SELECT title, ts_rank_cd(textsearch, query) AS rank\n"
"FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query\n"
"WHERE query @@ textsearch\n"
"ORDER BY rank DESC\n"
"LIMIT 10;\n"
"                     title                     |   rank\n"
"-----------------------------------------------+----------\n"
" Neutrinos in the Sun                          |      3.1\n"
" The Sudbury Neutrino Detector                 |      2.4\n"
" A MACHO View of Galactic Dark Matter          |  2.01317\n"
" Hot Gas and Dark Matter                       |  1.91171\n"
" The Virgo Cluster: Hot Plasma and Dark Matter |  1.90953\n"
" Rafting for Solar Neutrinos                   |      1.9\n"
" NGC 4650A: Strange Galaxy and Dark Matter     |  1.85774\n"
" Hot Gas and Dark Matter                       |   1.6123\n"
" Ice Fishing for Cosmic Neutrinos              |      1.6\n"
" Weak Lensing Distorts the Universe            | 0.818218\n"
"</screen> This is the same example using normalized ranking: <screen>\n"
"SELECT title, ts_rank_cd(textsearch, query, 32 /* rank/(rank+1) */ ) AS "
"rank\n"
"FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query\n"
"WHERE  query @@ textsearch\n"
"ORDER BY rank DESC\n"
"LIMIT 10;\n"
"                     title                     |        rank\n"
"-----------------------------------------------+-------------------\n"
" Neutrinos in the Sun                          | 0.756097569485493\n"
" The Sudbury Neutrino Detector                 | 0.705882361190954\n"
" A MACHO View of Galactic Dark Matter          | 0.668123210574724\n"
" Hot Gas and Dark Matter                       |  0.65655958650282\n"
" The Virgo Cluster: Hot Plasma and Dark Matter | 0.656301290640973\n"
" Rafting for Solar Neutrinos                   | 0.655172410958162\n"
" NGC 4650A: Strange Galaxy and Dark Matter     | 0.650072921219637\n"
" Hot Gas and Dark Matter                       | 0.617195790024749\n"
" Ice Fishing for Cosmic Neutrinos              | 0.615384618911517\n"
" Weak Lensing Distorts the Universe            | 0.450010798361481\n"
"</screen>"
msgstr ""
"В данном примере выбираются десять найденных документов с максимальным "
"рангом: <screen>\n"
"SELECT title, ts_rank_cd(textsearch, query) AS rank\n"
"FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query\n"
"WHERE query @@ textsearch\n"
"ORDER BY rank DESC\n"
"LIMIT 10;\n"
"                     title                     |   rank\n"
"-----------------------------------------------+----------\n"
" Neutrinos in the Sun                          |      3.1\n"
" The Sudbury Neutrino Detector                 |      2.4\n"
" A MACHO View of Galactic Dark Matter          |  2.01317\n"
" Hot Gas and Dark Matter                       |  1.91171\n"
" The Virgo Cluster: Hot Plasma and Dark Matter |  1.90953\n"
" Rafting for Solar Neutrinos                   |      1.9\n"
" NGC 4650A: Strange Galaxy and Dark Matter     |  1.85774\n"
" Hot Gas and Dark Matter                       |   1.6123\n"
" Ice Fishing for Cosmic Neutrinos              |      1.6\n"
" Weak Lensing Distorts the Universe            | 0.818218\n"
"</screen> Тот же пример с нормализованным рангом: <screen>\n"
"SELECT title, ts_rank_cd(textsearch, query, 32 /* rank/(rank+1) */ ) AS "
"rank\n"
"FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query\n"
"WHERE  query @@ textsearch\n"
"ORDER BY rank DESC\n"
"LIMIT 10;\n"
"                     title                     |        rank\n"
"-----------------------------------------------+-------------------\n"
" Neutrinos in the Sun                          | 0.756097569485493\n"
" The Sudbury Neutrino Detector                 | 0.705882361190954\n"
" A MACHO View of Galactic Dark Matter          | 0.668123210574724\n"
" Hot Gas and Dark Matter                       |  0.65655958650282\n"
" The Virgo Cluster: Hot Plasma and Dark Matter | 0.656301290640973\n"
" Rafting for Solar Neutrinos                   | 0.655172410958162\n"
" NGC 4650A: Strange Galaxy and Dark Matter     | 0.650072921219637\n"
" Hot Gas and Dark Matter                       | 0.617195790024749\n"
" Ice Fishing for Cosmic Neutrinos              | 0.615384618911517\n"
" Weak Lensing Distorts the Universe            | 0.450010798361481\n"
"</screen>"

#: textsearch.xml:1154(para)
msgid ""
"Ranking can be expensive since it requires consulting the <type>tsvector</"
"type> of each matching document, which can be I/O bound and therefore slow. "
"Unfortunately, it is almost impossible to avoid since practical queries "
"often result in large numbers of matches."
msgstr ""
"Ранжирование может быть довольно дорогостоящей операцией, так как для "
"вычисления ранга необходимо прочитать <type>tsvector</type> каждого "
"подходящего документа и это займёт значительное время, если придётся "
"обращаться к диску. К сожалению, избежать этого вряд ли возможно, так как на "
"практике по многим запросам выдаётся большое количество результатов."

#: textsearch.xml:1164(title)
msgid "Highlighting Results"
msgstr "Выделение результатов"

#: textsearch.xml:1166(para)
msgid ""
"To present search results it is ideal to show a part of each document and "
"how it is related to the query. Usually, search engines show fragments of "
"the document with marked search terms. <productname>PostgreSQL</productname> "
"provides a function <function>ts_headline</function> that implements this "
"functionality."
msgstr ""
"Представляя результаты поиска, в идеале нужно выделять часть документа и "
"показывать, как он связан с запросом. Обычно поисковые системы показывают "
"фрагменты документа с отмеченными искомыми словами. В "
"<productname>PostgreSQL</productname> для реализации этой возможности "
"представлена функция <function>ts_headline</function>."

#: textsearch.xml:1174(indexterm)
msgid "<primary>ts_headline</primary>"
msgstr "<primary>ts_headline</primary>"

#: textsearch.xml:1179(replaceable)
msgid "options"
msgstr "параметры"

#: textsearch.xml:1178(synopsis)
#, no-wrap
msgid "ts_headline(<placeholder-1/> <placeholder-2/> <placeholder-3/>, <placeholder-4/> <placeholder-5/> <placeholder-6/>) returns <placeholder-7/>"
msgstr ""
"ts_headline(<placeholder-1/> <placeholder-2/> <placeholder-3/>, <placeholder-4/> <placeholder-5/> <placeholder-6/>)\n"
"  returns <placeholder-7/>"

#: textsearch.xml:1182(para)
msgid ""
"<function>ts_headline</function> accepts a document along with a query, and "
"returns an excerpt from the document in which terms from the query are "
"highlighted. The configuration to be used to parse the document can be "
"specified by <replaceable>config</replaceable>; if <replaceable>config</"
"replaceable> is omitted, the <varname>default_text_search_config</varname> "
"configuration is used."
msgstr ""
"<function>ts_headline</function> принимает документ вместе с запросом и "
"возвращает выдержку из документа, в которой выделяются слова из запроса. "
"Применяемую для разбора документа конфигурацию можно указать в параметре "
"<replaceable>config</replaceable>; если этот параметр опущен, применяется "
"конфигурация <varname>default_text_search_config</varname>."

#: textsearch.xml:1200(para)
msgid ""
"<literal>StartSel</literal>, <literal>StopSel</literal>: the strings with "
"which to delimit query words appearing in the document, to distinguish them "
"from other excerpted words. You must double-quote these strings if they "
"contain spaces or commas."
msgstr ""
"<literal>StartSel</literal>, <literal>StopSel</literal>: строки, которые "
"будут разграничивать слова запроса в документе, выделяя их среди остальных. "
"Если эти строки содержат пробелы или запятые, их нужно заключить в кавычки."

#: textsearch.xml:1208(para)
msgid ""
"<literal>MaxWords</literal>, <literal>MinWords</literal>: these numbers "
"determine the longest and shortest headlines to output."
msgstr ""
"<literal>MaxWords</literal>, <literal>MinWords</literal>: эти числа "
"определяет нижний и верхний предел размера выдержки."

#: textsearch.xml:1214(para)
msgid ""
"<literal>ShortWord</literal>: words of this length or less will be dropped "
"at the start and end of a headline. The default value of three eliminates "
"common English articles."
msgstr ""
"<literal>ShortWord</literal>: слова такой длины или короче в начале и конце "
"выдержки будут отбрасываться. Значение по умолчанию, равное 3, исключает "
"распространённые английские артикли."

#: textsearch.xml:1221(para)
msgid ""
"<literal>HighlightAll</literal>: Boolean flag; if <literal>true</literal> "
"the whole document will be used as the headline, ignoring the preceding "
"three parameters."
msgstr ""
"<literal>HighlightAll</literal>: логический флаг; если он равен "
"<literal>true</literal>, выдержкой будет весь документ и три предыдущие "
"параметра игнорируются."

#: textsearch.xml:1228(para)
msgid ""
"<literal>MaxFragments</literal>: maximum number of text excerpts or "
"fragments to display. The default value of zero selects a non-fragment-"
"oriented headline generation method. A value greater than zero selects "
"fragment-based headline generation. This method finds text fragments with as "
"many query words as possible and stretches those fragments around the query "
"words. As a result query words are close to the middle of each fragment and "
"have words on each side. Each fragment will be of at most <literal>MaxWords</"
"literal> and words of length <literal>ShortWord</literal> or less are "
"dropped at the start and end of each fragment. If not all query words are "
"found in the document, then a single fragment of the first "
"<literal>MinWords</literal> in the document will be displayed."
msgstr ""
"<literal>MaxFragments</literal>: максимальное число выводимых текстовых "
"выдержек или фрагментов. Значение по умолчанию, равное 0, выбирает метод "
"создания выдержки без фрагментов. При значении большем 0 выбирается метод с "
"фрагментами, когда находятся все фрагменты, содержащие как можно больше слов "
"запроса, а затем они сжимаются до слов запроса. Такие фрагменты могут "
"содержать какие-то ключевые слова в середине и ограничиваются двумя искомыми "
"словами. При этом фрагменты могут содержать не больше <literal>MaxWords</"
"literal> слов, а в начале и конце они будут очищены от слов длины "
"<literal>ShortWord</literal> и меньше. Если в документе найдены не все слова "
"запроса, выводится один фрагмент, включающий первые <literal>MinWords</"
"literal> слов в документе."

#: textsearch.xml:1244(para)
msgid ""
"<literal>FragmentDelimiter</literal>: When more than one fragment is "
"displayed, the fragments will be separated by this string."
msgstr ""
"<literal>FragmentDelimiter</literal>: Когда выводятся несколько фрагментов, "
"они будут разделяться этой строкой."

#: textsearch.xml:1253(programlisting)
#, no-wrap
msgid ""
"StartSel=&lt;b&gt;, StopSel=&lt;/b&gt;,\n"
"MaxWords=35, MinWords=15, ShortWord=3, HighlightAll=FALSE,\n"
"MaxFragments=0, FragmentDelimiter=\" ... \""
msgstr ""
"StartSel=&lt;b&gt;, StopSel=&lt;/b&gt;,\n"
"MaxWords=35, MinWords=15, ShortWord=3, HighlightAll=FALSE,\n"
"MaxFragments=0, FragmentDelimiter=\" ... \""

#: textsearch.xml:1192(para)
msgid ""
"If an <replaceable>options</replaceable> string is specified it must consist "
"of a comma-separated list of one or more <replaceable>option</"
"replaceable><literal>=</literal><replaceable>value</replaceable> pairs. The "
"available options are: <placeholder-1/> Any unspecified options receive "
"these defaults: <placeholder-2/>"
msgstr ""
"Если в параметрах передаётся строка <replaceable>options</replaceable>, она "
"должна состоять из списка разделённых запятыми пар <replaceable>параметр</"
"replaceable><literal>=</literal><replaceable>значение</replaceable>. "
"Параметры могут быть следующими: <placeholder-1/> Все явно не определённые "
"параметры получают такие значения по умолчанию: <placeholder-2/>"

#: textsearch.xml:1260(para)
msgid ""
"For example: <screen>\n"
"SELECT ts_headline('english',\n"
"  'The most common type of search\n"
"is to find all documents containing given query terms\n"
"and return them in order of their similarity to the\n"
"query.',\n"
"  to_tsquery('query &amp; similarity'));\n"
"                        ts_headline                         \n"
"------------------------------------------------------------\n"
" containing given &lt;b&gt;query&lt;/b&gt; terms\n"
" and return them in order of their &lt;b&gt;similarity&lt;/b&gt; to the\n"
" &lt;b&gt;query&lt;/b&gt;.\n"
"\n"
"SELECT ts_headline('english',\n"
"  'The most common type of search\n"
"is to find all documents containing given query terms\n"
"and return them in order of their similarity to the\n"
"query.',\n"
"  to_tsquery('query &amp; similarity'),\n"
"  'StartSel = &lt;, StopSel = &gt;');\n"
"                      ts_headline                      \n"
"-------------------------------------------------------\n"
" containing given &lt;query&gt; terms\n"
" and return them in order of their &lt;similarity&gt; to the\n"
" &lt;query&gt;.\n"
"</screen>"
msgstr ""
"Пример использования: <screen>\n"
"SELECT ts_headline('english',\n"
"  'The most common type of search\n"
"is to find all documents containing given query terms\n"
"and return them in order of their similarity to the\n"
"query.',\n"
"  to_tsquery('query &amp; similarity'));\n"
"                        ts_headline                         \n"
"------------------------------------------------------------\n"
" containing given &lt;b&gt;query&lt;/b&gt; terms\n"
" and return them in order of their &lt;b&gt;similarity&lt;/b&gt; to the\n"
" &lt;b&gt;query&lt;/b&gt;.\n"
"\n"
"SELECT ts_headline('english',\n"
"  'The most common type of search\n"
"is to find all documents containing given query terms\n"
"and return them in order of their similarity to the\n"
"query.',\n"
"  to_tsquery('query &amp; similarity'),\n"
"  'StartSel = &lt;, StopSel = &gt;');\n"
"                      ts_headline                      \n"
"-------------------------------------------------------\n"
" containing given &lt;query&gt; terms\n"
" and return them in order of their &lt;similarity&gt; to the\n"
" &lt;query&gt;.\n"
"</screen>"

#: textsearch.xml:1299(programlisting)
#, no-wrap
msgid ""
"SELECT id, ts_headline(body, q), rank\n"
"FROM (SELECT id, body, q, ts_rank_cd(ti, q) AS rank\n"
"      FROM apod, to_tsquery('stars') q\n"
"      WHERE ti @@ q\n"
"      ORDER BY rank DESC\n"
"      LIMIT 10) AS foo;"
msgstr ""
"SELECT id, ts_headline(body, q), rank\n"
"FROM (SELECT id, body, q, ts_rank_cd(ti, q) AS rank\n"
"      FROM apod, to_tsquery('stars') q\n"
"      WHERE ti @@ q\n"
"      ORDER BY rank DESC\n"
"      LIMIT 10) AS foo;"

#: textsearch.xml:1291(para)
msgid ""
"<function>ts_headline</function> uses the original document, not a "
"<type>tsvector</type> summary, so it can be slow and should be used with "
"care. A typical mistake is to call <function>ts_headline</function> for "
"<emphasis>every</emphasis> matching document when only ten documents are to "
"be shown. <acronym>SQL</acronym> subqueries can help; here is an example: "
"<placeholder-1/>"
msgstr ""
"Функция <function>ts_headline</function> работает с оригинальным документом, "
"а не с его сжатым представлением <type>tsvector</type>, так что она может "
"быть медленной и использовать её следует осмотрительно. Типичная ошибка "
"&mdash; вызывать <function>ts_headline</function> для <emphasis>всех</"
"emphasis> подходящих документов, когда показываются только десять. "
"Правильный подход можно реализовать, применив подзапросы <acronym>SQL</"
"acronym>, например так: <placeholder-1/>"

#: textsearch.xml:1314(title)
msgid "Additional Features"
msgstr "Дополнительные возможности"

#: textsearch.xml:1316(para)
msgid ""
"This section describes additional functions and operators that are useful in "
"connection with text search."
msgstr ""
"В этом разделе описываются дополнительные функции и операторы, которые могут "
"быть полезны при поиске текста."

#: textsearch.xml:1322(title)
msgid "Manipulating Documents"
msgstr "Обработка документов"

#: textsearch.xml:1324(para)
msgid ""
"<xref linkend=\"textsearch-parsing-documents\"/> showed how raw textual "
"documents can be converted into <type>tsvector</type> values. "
"<productname>PostgreSQL</productname> also provides functions and operators "
"that can be used to manipulate documents that are already in <type>tsvector</"
"type> form."
msgstr ""
"В <xref remap=\"6\" linkend=\"textsearch-parsing-documents\"/> показывалось, "
"как обычные текстовые документы можно преобразовать в значения "
"<type>tsvector</type>. <productname>PostgreSQL</productname> предлагает "
"также набор функций и операторов для обработки документов, уже "
"представленных в формате <type>tsvector</type>."

#: textsearch.xml:1337(indexterm)
msgid "<primary>tsvector concatenation</primary>"
msgstr "<primary>конкатенация значений tsvector</primary>"

#: textsearch.xml:1341(literal) textsearch.xml:1482(literal)
msgid "<placeholder-1/> || <placeholder-2/>"
msgstr "<placeholder-1/> || <placeholder-2/>"

#: textsearch.xml:1345(para)
msgid ""
"The <type>tsvector</type> concatenation operator returns a vector which "
"combines the lexemes and positional information of the two vectors given as "
"arguments. Positions and weight labels are retained during the "
"concatenation. Positions appearing in the right-hand vector are offset by "
"the largest position mentioned in the left-hand vector, so that the result "
"is nearly equivalent to the result of performing <function>to_tsvector</"
"function> on the concatenation of the two original document strings. (The "
"equivalence is not exact, because any stop-words removed from the end of the "
"left-hand argument will not affect the result, whereas they would have "
"affected the positions of the lexemes in the right-hand argument if textual "
"concatenation were used.)"
msgstr ""
"Оператор конкатенации значений <type>tsvector</type> возвращает вектор, "
"объединяющий лексемы и позиционную информацию двух векторов, переданных ему "
"в аргументах. В полученном результате сохраняются позиции и метки весов. При "
"этом позиции в векторе справа сдвигаются на максимальное значение позиции в "
"векторе слева, что почти равносильно применению <function>to_tsvector</"
"function> к результату конкатенации двух исходных строк документов. (Почти, "
"потому что стоп-слова, исключаемые в конце левого аргумента, при "
"конкатенации исходных строк влияют на позиции лексем в правой части, а при "
"конкатенации <type>tsvector</type> &mdash; нет.)"

#: textsearch.xml:1360(para)
msgid ""
"One advantage of using concatenation in the vector form, rather than "
"concatenating text before applying <function>to_tsvector</function>, is that "
"you can use different configurations to parse different sections of the "
"document. Also, because the <function>setweight</function> function marks "
"all lexemes of the given vector the same way, it is necessary to parse the "
"text and do <function>setweight</function> before concatenating if you want "
"to label different parts of the document with different weights."
msgstr ""
"Преимущество же конкатенации документов в векторной форме по сравнению с "
"конкатенацией текста до вызова <function>to_tsvector</function> заключается "
"в том, что так можно разбирать разные части документа, применяя разные "
"конфигурации. И так как функция <function>setweight</function> помечает все "
"лексемы данного вектора одинаково, разбирать текст и выполнять "
"<function>setweight</function> нужно до объединения разных частей документа "
"с подразумеваемым разным весом."

#: textsearch.xml:1376(indexterm)
msgid "<primary>setweight</primary>"
msgstr "<primary>setweight</primary>"

#: textsearch.xml:1380(replaceable)
msgid "weight"
msgstr "вес"

#: textsearch.xml:1380(type)
msgid "\"char\""
msgstr "\"char\""

#: textsearch.xml:1380(literal)
msgid ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">) returns <placeholder-5/>"
msgstr ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">) returns <placeholder-5/>"

#: textsearch.xml:1384(para)
msgid ""
"<function>setweight</function> returns a copy of the input vector in which "
"every position has been labeled with the given <replaceable>weight</"
"replaceable>, either <literal>A</literal>, <literal>B</literal>, <literal>C</"
"literal>, or <literal>D</literal>. (<literal>D</literal> is the default for "
"new vectors and as such is not displayed on output.) These labels are "
"retained when vectors are concatenated, allowing words from different parts "
"of a document to be weighted differently by ranking functions."
msgstr ""
"<function>setweight</function> возвращает копию входного вектора, помечая в "
"ней каждую позицию заданным <replaceable>весом</replaceable>, меткой "
"<literal>A</literal>, <literal>B</literal>, <literal>C</literal> или "
"<literal>D</literal>. (Метка <literal>D</literal> по умолчанию назначается "
"всем векторам, так что при выводе она опускается.) Эти метки сохраняются при "
"конкатенации векторов, что позволяет придавать разные веса словам из разных "
"частей документа и, как следствие, ранжировать их по-разному."

#: textsearch.xml:1394(para)
msgid ""
"Note that weight labels apply to <emphasis>positions</emphasis>, not "
"<emphasis>lexemes</emphasis>. If the input vector has been stripped of "
"positions then <function>setweight</function> does nothing."
msgstr ""
"Заметьте, что веса назначаются <emphasis>позициям</emphasis>, а не "
"<emphasis>лексемам</emphasis>. Если входной вектор очищен от позиционной "
"информации, <function>setweight</function> не делает ничего."

#: textsearch.xml:1404(indexterm)
msgid "<primary>length(tsvector)</primary>"
msgstr "<primary>length(tsvector)</primary>"

#: textsearch.xml:1408(literal)
msgid "length(<placeholder-1/> <placeholder-2/>) returns <placeholder-3/>"
msgstr "length(<placeholder-1/> <placeholder-2/>) returns <placeholder-3/>"

#: textsearch.xml:1412(para)
msgid "Returns the number of lexemes stored in the vector."
msgstr "Возвращает число лексем, сохранённых в векторе."

#: textsearch.xml:1421(indexterm)
msgid "<primary>strip</primary>"
msgstr "<primary>strip</primary>"

#: textsearch.xml:1425(literal)
msgid "strip(<placeholder-1/> <placeholder-2/>) returns <placeholder-3/>"
msgstr "strip(<placeholder-1/> <placeholder-2/>) returns <placeholder-3/>"

#: textsearch.xml:1429(para)
msgid ""
"Returns a vector that lists the same lexemes as the given vector, but lacks "
"any position or weight information. The result is usually much smaller than "
"an unstripped vector, but it is also less useful. Relevance ranking does not "
"work as well on stripped vectors as unstripped ones. Also, the <literal>&lt;-"
"&gt;</literal> (FOLLOWED BY) <type>tsquery</type> operator will never match "
"stripped input, since it cannot determine the distance between lexeme "
"occurrences."
msgstr ""
"Возвращает вектор с теми же лексемами, что и в данном, но без информации о "
"позиции и весе. Очищенный вектор обычно оказывается намного меньше "
"исходного, но при этом и менее полезным. С очищенными векторами хуже "
"работает ранжирование, а также оператор <literal>&lt;-&gt;</literal> "
"(ПРЕДШЕСТВУЕТ) типа <type>tsquery</type> никогда не найдёт соответствие в "
"них, так как не сможет определить расстояние между вхождениями лексем."

#: textsearch.xml:1445(para)
msgid ""
"A full list of <type>tsvector</type>-related functions is available in <xref "
"linkend=\"textsearch-functions-table\"/>."
msgstr ""
"Полный список связанных с <type>tsvector</type> функций приведён в <xref "
"remap=\"6\" linkend=\"textsearch-functions-table\"/>."

#: textsearch.xml:1453(title)
msgid "Manipulating Queries"
msgstr "Обработка запросов"

#: textsearch.xml:1455(para)
msgid ""
"<xref linkend=\"textsearch-parsing-queries\"/> showed how raw textual "
"queries can be converted into <type>tsquery</type> values. "
"<productname>PostgreSQL</productname> also provides functions and operators "
"that can be used to manipulate queries that are already in <type>tsquery</"
"type> form."
msgstr ""
"В <xref remap=\"6\" linkend=\"textsearch-parsing-queries\"/> показывалось, "
"как обычные текстовые запросы можно преобразовывать в значения "
"<type>tsquery</type>. <productname>PostgreSQL</productname> предлагает также "
"набор функций и операторов для обработки запросов, уже представленных в "
"формате <type>tsquery</type>."

#: textsearch.xml:1468(literal)
msgid "<placeholder-1/> &amp;&amp; <placeholder-2/>"
msgstr "<placeholder-1/> &amp;&amp; <placeholder-2/>"

#: textsearch.xml:1472(para)
msgid "Returns the AND-combination of the two given queries."
msgstr "Возвращает логическое произведение (AND) двух данных запросов."

#: textsearch.xml:1486(para)
msgid "Returns the OR-combination of the two given queries."
msgstr "Возвращает логическое объединение (OR) двух данных запросов."

#: textsearch.xml:1496(literal)
msgid "!! <placeholder-1/>"
msgstr "!! <placeholder-1/>"

#: textsearch.xml:1500(para)
msgid "Returns the negation (NOT) of the given query."
msgstr "Возвращает логическое отрицание (NOT) данного запроса."

#: textsearch.xml:1510(literal)
msgid "<placeholder-1/> &lt;-&gt; <placeholder-2/>"
msgstr "<placeholder-1/> &lt;-&gt; <placeholder-2/>"

#: textsearch.xml:1514(para)
msgid ""
"Returns a query that searches for a match to the first given query "
"immediately followed by a match to the second given query, using the "
"<literal>&lt;-&gt;</literal> (FOLLOWED BY) <type>tsquery</type> operator. "
"For example: <screen>\n"
"SELECT to_tsquery('fat') &lt;-&gt; to_tsquery('cat | rat');\n"
"             ?column?\n"
"-----------------------------------\n"
" 'fat' &lt;-&gt; 'cat' | 'fat' &lt;-&gt; 'rat'\n"
"</screen>"
msgstr ""
"Возвращает запрос, который ищет соответствие первому данному запросу, за "
"которым следует соответствие второму данному запросу, с применением "
"оператора <literal>&lt;-&gt;</literal> (ПРЕДШЕСТВУЕТ) типа <type>tsquery</"
"type>. Например: <screen>\n"
"SELECT to_tsquery('fat') &lt;-&gt; to_tsquery('cat | rat');\n"
"             ?column?\n"
"-----------------------------------\n"
" 'fat' &lt;-&gt; 'cat' | 'fat' &lt;-&gt; 'rat'\n"
"</screen>"

#: textsearch.xml:1534(indexterm)
msgid "<primary>tsquery_phrase</primary>"
msgstr "<primary>tsquery_phrase</primary>"

#: textsearch.xml:1538(replaceable)
msgid "query1"
msgstr "запрос1"

#: textsearch.xml:1538(replaceable)
msgid "query2"
msgstr "запрос2"

#: textsearch.xml:1538(replaceable)
msgid "distance"
msgstr "расстояние"

#: textsearch.xml:1538(literal)
msgid ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/> ]) returns "
"<placeholder-7/>"
msgstr ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/> ]) returns "
"<placeholder-7/>"

#: textsearch.xml:1542(para)
msgid ""
"Returns a query that searches for a match to the first given query followed "
"by a match to the second given query at a distance of at "
"<replaceable>distance</replaceable> lexemes, using the <literal>&lt;"
"<replaceable>N</replaceable>&gt;</literal> <type>tsquery</type> operator. "
"For example: <screen>\n"
"SELECT tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10);\n"
"  tsquery_phrase\n"
"------------------\n"
" 'fat' &lt;10&gt; 'cat'\n"
"</screen>"
msgstr ""
"Возвращает запрос, который ищет соответствие первому данному запросу, за "
"которым следует соответствие второму данному запросу (число лексем между "
"ними задаётся параметром <replaceable>расстояние</replaceable>), с "
"применением оператора <literal>&lt;<replaceable>N</replaceable>&gt;</"
"literal> типа <type>tsquery</type>. Например: <screen>\n"
"SELECT tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10);\n"
"  tsquery_phrase\n"
"------------------\n"
" 'fat' &lt;10&gt; 'cat'\n"
"</screen>"

#: textsearch.xml:1563(indexterm)
msgid "<primary>numnode</primary>"
msgstr "<primary>numnode</primary>"

#: textsearch.xml:1567(literal)
msgid "numnode(<placeholder-1/> <placeholder-2/>) returns <placeholder-3/>"
msgstr "numnode(<placeholder-1/> <placeholder-2/>) returns <placeholder-3/>"

#: textsearch.xml:1571(para)
msgid ""
"Returns the number of nodes (lexemes plus operators) in a <type>tsquery</"
"type>. This function is useful to determine if the <replaceable>query</"
"replaceable> is meaningful (returns &gt; 0), or contains only stop words "
"(returns 0). Examples: <screen>\n"
"SELECT numnode(plainto_tsquery('the any'));\n"
"NOTICE:  query contains only stopword(s) or doesn't contain lexeme(s), "
"ignored\n"
" numnode\n"
"---------\n"
"       0\n"
"\n"
"SELECT numnode('foo &amp; bar'::tsquery);\n"
" numnode\n"
"---------\n"
"       3\n"
"</screen>"
msgstr ""
"Возвращает число узлов (лексем и операторов) в значении <type>tsquery</"
"type>. Эта функция помогает определить, имеет ли смысл <replaceable>запрос</"
"replaceable> (тогда её результат &gt; 0) или он содержит только стоп-слова "
"(тогда она возвращает 0). Примеры: <screen>\n"
" SELECT numnode(plainto_tsquery('the any'));\n"
"ЗАМЕЧАНИЕ:  запрос поиска текста игнорируется, так как содержит\n"
" только стоп-слова или не содержит лексем\n"
" numnode\n"
"---------\n"
"       0\n"
"\n"
"SELECT numnode('foo &amp; bar'::tsquery);\n"
" numnode\n"
"---------\n"
"       3\n"
"</screen>"

#: textsearch.xml:1597(indexterm)
msgid "<primary>querytree</primary>"
msgstr "<primary>querytree</primary>"

#: textsearch.xml:1601(literal)
msgid "querytree(<placeholder-1/> <placeholder-2/>) returns <placeholder-3/>"
msgstr "querytree(<placeholder-1/> <placeholder-2/>) returns <placeholder-3/>"

#: textsearch.xml:1605(para)
msgid ""
"Returns the portion of a <type>tsquery</type> that can be used for searching "
"an index. This function is useful for detecting unindexable queries, for "
"example those containing only stop words or only negated terms. For example: "
"<screen>\n"
"SELECT querytree(to_tsquery('!defined'));\n"
" querytree\n"
"-----------\n"
"\n"
"</screen>"
msgstr ""
"Возвращает часть <type>tsquery</type>, которую можно использовать для поиска "
"по индексу. Эта функция помогает выявить неиндексируемые запросы, например, "
"такие, которые содержат только стоп-слова или условия отрицания. Например: "
"<screen>\n"
"SELECT querytree(to_tsquery('!defined'));\n"
" querytree\n"
"-----------\n"
"\n"
"</screen>"

#: textsearch.xml:1624(title)
msgid "Query Rewriting"
msgstr "Перезапись запросов"

#: textsearch.xml:1626(indexterm)
msgid "<primary>ts_rewrite</primary>"
msgstr "<primary>ts_rewrite</primary>"

#: textsearch.xml:1630(para)
msgid ""
"The <function>ts_rewrite</function> family of functions search a given "
"<type>tsquery</type> for occurrences of a target subquery, and replace each "
"occurrence with a substitute subquery. In essence this operation is a "
"<type>tsquery</type>-specific version of substring replacement. A target and "
"substitute combination can be thought of as a <firstterm>query rewrite rule</"
"firstterm>. A collection of such rewrite rules can be a powerful search aid. "
"For example, you can expand the search using synonyms (e.g., <literal>new "
"york</literal>, <literal>big apple</literal>, <literal>nyc</literal>, "
"<literal>gotham</literal>) or narrow the search to direct the user to some "
"hot topic. There is some overlap in functionality between this feature and "
"thesaurus dictionaries (<xref linkend=\"textsearch-thesaurus\"/>). However, "
"you can modify a set of rewrite rules on-the-fly without reindexing, whereas "
"updating a thesaurus requires reindexing to be effective."
msgstr ""
"Семейство запросов <function>ts_rewrite</function> ищет в данном "
"<type>tsquery</type> вхождения целевого подзапроса и заменяет каждое "
"вхождение указанной подстановкой. По сути эта операция похожа на замену "
"подстроки в строке, только рассчитана на работу с <type>tsquery</type>. "
"Сочетание целевого подзапроса с подстановкой можно считать "
"<firstterm>правилом перезаписи запроса</firstterm>. Набор таких правил "
"перезаписи может быть очень полезен при поиске. Например, вы можете улучшить "
"результаты, добавив синонимы (например, <literal>big apple</literal>, "
"<literal>nyc</literal> и <literal>gotham</literal> для <literal>new york</"
"literal>) или сузить область поиска, чтобы нацелить пользователя на "
"некоторую область. Это в некотором смысле пересекается с функциональностью "
"тезаурусов (<xref linkend=\"textsearch-thesaurus\"/>). Однако, при таком "
"подходе вы можете изменять правила перезаписи &laquo;на лету&raquo;, тогда "
"как при обновлении тезауруса необходима переиндексация."

#: textsearch.xml:1654(replaceable)
msgid "target"
msgstr "цель"

#: textsearch.xml:1654(replaceable)
msgid "substitute"
msgstr "замена"

#: textsearch.xml:1654(literal)
msgid ""
"ts_rewrite (<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>) returns <placeholder-7/>"
msgstr ""
"ts_rewrite (<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>) returns <placeholder-7/>"

#: textsearch.xml:1658(para)
msgid ""
"This form of <function>ts_rewrite</function> simply applies a single rewrite "
"rule: <replaceable class=\"parameter\">target</replaceable> is replaced by "
"<replaceable class=\"parameter\">substitute</replaceable> wherever it "
"appears in <replaceable class=\"parameter\">query</replaceable>. For "
"example: <screen>\n"
"SELECT ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'c'::tsquery);\n"
" ts_rewrite\n"
"------------\n"
" 'b' &amp; 'c'\n"
"</screen>"
msgstr ""
"Эта форма <function>ts_rewrite</function> просто применяет одно правило "
"перезаписи: <replaceable class=\"parameter\">цель</replaceable> заменяется "
"<replaceable class=\"parameter\">подстановкой</replaceable> везде, где она "
"находится в <replaceable class=\"parameter\">запросе</replaceable>. "
"Например: <screen>\n"
"SELECT ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'c'::tsquery);\n"
" ts_rewrite\n"
"------------\n"
" 'b' &amp; 'c'\n"
"</screen>"

#: textsearch.xml:1678(replaceable)
msgid "select"
msgstr "выборка"

#: textsearch.xml:1678(literal)
msgid ""
"ts_rewrite (<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>) returns <placeholder-5/>"
msgstr ""
"ts_rewrite (<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>) returns <placeholder-5/>"

#: textsearch.xml:1682(para)
msgid ""
"This form of <function>ts_rewrite</function> accepts a starting "
"<replaceable>query</replaceable> and a SQL <replaceable>select</replaceable> "
"command, which is given as a text string. The <replaceable>select</"
"replaceable> must yield two columns of <type>tsquery</type> type. For each "
"row of the <replaceable>select</replaceable> result, occurrences of the "
"first column value (the target) are replaced by the second column value (the "
"substitute) within the current <replaceable>query</replaceable> value. For "
"example: <screen>\n"
"CREATE TABLE aliases (t tsquery PRIMARY KEY, s tsquery);\n"
"INSERT INTO aliases VALUES('a', 'c');\n"
"\n"
"SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases');\n"
" ts_rewrite\n"
"------------\n"
" 'b' &amp; 'c'\n"
"</screen>"
msgstr ""
"Эта форма <function>ts_rewrite</function> принимает начальный "
"<replaceable>запрос</replaceable> и SQL-команду <replaceable>select</"
"replaceable>, которая задаётся текстовой строкой. Команда "
"<replaceable>select</replaceable> должна выдавать два столбца типа "
"<type>tsquery</type>. Для каждой строки результата <replaceable>select</"
"replaceable> вхождения первого столбца (цели) заменяются значениями второго "
"столбца (подстановкой) в тексте <replaceable>запроса</replaceable>. "
"Например: <screen>\n"
"CREATE TABLE aliases (t tsquery PRIMARY KEY, s tsquery);\n"
"INSERT INTO aliases VALUES('a', 'c');\n"
"\n"
"SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases');\n"
" ts_rewrite\n"
"------------\n"
" 'b' &amp; 'c'\n"
"</screen>"

#: textsearch.xml:1702(para)
msgid ""
"Note that when multiple rewrite rules are applied in this way, the order of "
"application can be important; so in practice you will want the source query "
"to <literal>ORDER BY</literal> some ordering key."
msgstr ""
"Заметьте, что когда таким способом применяются несколько правил перезаписи, "
"порядок их применения может иметь значение, поэтому в исходном запросе "
"следует добавить <literal>ORDER BY</literal> по какому-либо ключу."

#: textsearch.xml:1712(para)
msgid ""
"Let's consider a real-life astronomical example. We'll expand query "
"<literal>supernovae</literal> using table-driven rewriting rules: <screen>\n"
"CREATE TABLE aliases (t tsquery primary key, s tsquery);\n"
"INSERT INTO aliases VALUES(to_tsquery('supernovae'), to_tsquery('supernovae|"
"sn'));\n"
"\n"
"SELECT ts_rewrite(to_tsquery('supernovae &amp; crab'), 'SELECT * FROM "
"aliases');\n"
"           ts_rewrite            \n"
"---------------------------------\n"
" 'crab' &amp; ( 'supernova' | 'sn' )\n"
"</screen> We can change the rewriting rules just by updating the table: "
"<screen>\n"
"UPDATE aliases\n"
"SET s = to_tsquery('supernovae|sn &amp; !nebulae')\n"
"WHERE t = to_tsquery('supernovae');\n"
"\n"
"SELECT ts_rewrite(to_tsquery('supernovae &amp; crab'), 'SELECT * FROM "
"aliases');\n"
"                 ts_rewrite                  \n"
"---------------------------------------------\n"
" 'crab' &amp; ( 'supernova' | 'sn' &amp; !'nebula' )\n"
"</screen>"
msgstr ""
"Давайте рассмотрим практический пример на тему астрономии. Мы развернём "
"запрос <literal>supernovae</literal>, используя правила перезаписи в "
"таблице: <screen>\n"
"CREATE TABLE aliases (t tsquery primary key, s tsquery);\n"
"INSERT INTO aliases VALUES(to_tsquery('supernovae'),\n"
"  to_tsquery('supernovae|sn'));\n"
"\n"
"SELECT ts_rewrite(to_tsquery('supernovae &amp; crab'), 'SELECT * FROM "
"aliases');\n"
"           ts_rewrite            \n"
"---------------------------------\n"
" 'crab' &amp; ( 'supernova' | 'sn' )\n"
"</screen> Мы можем скорректировать правила перезаписи, просто изменив "
"таблицу: <screen>\n"
"UPDATE aliases\n"
"SET s = to_tsquery('supernovae|sn &amp; !nebulae')\n"
"WHERE t = to_tsquery('supernovae');\n"
"\n"
"SELECT ts_rewrite(to_tsquery('supernovae &amp; crab'), 'SELECT * FROM "
"aliases');\n"
"                 ts_rewrite                  \n"
"---------------------------------------------\n"
" 'crab' &amp; ( 'supernova' | 'sn' &amp; !'nebula' )\n"
"</screen>"

#: textsearch.xml:1740(para)
msgid ""
"Rewriting can be slow when there are many rewriting rules, since it checks "
"every rule for a possible match. To filter out obvious non-candidate rules "
"we can use the containment operators for the <type>tsquery</type> type. In "
"the example below, we select only those rules which might match the original "
"query: <screen>\n"
"SELECT ts_rewrite('a &amp; b'::tsquery,\n"
"                  'SELECT t,s FROM aliases WHERE ''a &amp; b''::tsquery "
"@&gt; t');\n"
" ts_rewrite\n"
"------------\n"
" 'b' &amp; 'c'\n"
"</screen>"
msgstr ""
"Перезапись может быть медленной, когда задано много правил перезаписи, так "
"как соответствия будут проверяться для каждого правила. Чтобы отфильтровать "
"явно неподходящие правила, можно использовать проверки включения для типа "
"<type>tsquery</type>. В следующем примере выбираются только те правила, "
"которые могут соответствовать исходному запросу: <screen>\n"
"SELECT ts_rewrite('a &amp; b'::tsquery,\n"
"                  'SELECT t,s FROM aliases WHERE ''a &amp; b''::tsquery "
"@&gt; t');\n"
" ts_rewrite\n"
"------------\n"
" 'b' &amp; 'c'\n"
"</screen>"

#: textsearch.xml:1761(title)
msgid "Triggers for Automatic Updates"
msgstr "Триггеры для автоматического обновления"

#: textsearch.xml:1763(indexterm)
msgid ""
"<primary>trigger</primary> <secondary>for updating a derived tsvector "
"column</secondary>"
msgstr ""
"<primary>триггер</primary> <secondary>для обновления столбца с производным "
"значением tsvector</secondary>"

#: textsearch.xml:1768(para)
msgid ""
"When using a separate column to store the <type>tsvector</type> "
"representation of your documents, it is necessary to create a trigger to "
"update the <type>tsvector</type> column when the document content columns "
"change. Two built-in trigger functions are available for this, or you can "
"write your own."
msgstr ""
"Когда представление документа в формате <type>tsvector</type> хранится в "
"отдельном столбце, необходимо создать триггер, который будет обновлять его "
"содержимое при изменении столбцов, из которых составляется исходный "
"документ. Для этого можно использовать две встроенные триггерные функции или "
"написать свои собственные."

#: textsearch.xml:1777(replaceable) textsearch.xml:1778(replaceable)
msgid "tsvector_column_name"
msgstr "столбец_tsvector"

#: textsearch.xml:1777(replaceable)
msgid "config_name"
msgstr "имя_конфигурации"

#: textsearch.xml:1777(replaceable) textsearch.xml:1778(replaceable)
msgid "text_column_name"
msgstr "столбец_текста"

#: textsearch.xml:1777(optional) textsearch.xml:1778(optional)
msgid ", ..."
msgstr ", ..."

#: textsearch.xml:1778(replaceable)
msgid "config_column_name"
msgstr "столбец_конфигурации"

#: textsearch.xml:1776(synopsis)
#, no-wrap
msgid ""
"tsvector_update_trigger(<placeholder-1/>, <placeholder-2/>, <placeholder-3/> <placeholder-4/>)\n"
"tsvector_update_trigger_column(<placeholder-5/>, <placeholder-6/>, <placeholder-7/> <placeholder-8/>)"
msgstr ""
"tsvector_update_trigger(<placeholder-1/>, <placeholder-2/>, <placeholder-3/> <placeholder-4/>)\n"
"tsvector_update_trigger_column(<placeholder-5/>, <placeholder-6/>,\n"
"<placeholder-7/> <placeholder-8/>)"

#: textsearch.xml:1781(para)
msgid ""
"These trigger functions automatically compute a <type>tsvector</type> column "
"from one or more textual columns, under the control of parameters specified "
"in the <command>CREATE TRIGGER</command> command. An example of their use "
"is: <screen>\n"
"CREATE TABLE messages (\n"
"    title       text,\n"
"    body        text,\n"
"    tsv         tsvector\n"
");\n"
"\n"
"CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE\n"
"ON messages FOR EACH ROW EXECUTE PROCEDURE\n"
"tsvector_update_trigger(tsv, 'pg_catalog.english', title, body);\n"
"\n"
"INSERT INTO messages VALUES('title here', 'the body text is here');\n"
"\n"
"SELECT * FROM messages;\n"
"   title    |         body          |            tsv             \n"
"------------+-----------------------+----------------------------\n"
" title here | the body text is here | 'bodi':4 'text':5 'titl':1\n"
"\n"
"SELECT title, body FROM messages WHERE tsv @@ to_tsquery('title &amp; "
"body');\n"
"   title    |         body          \n"
"------------+-----------------------\n"
" title here | the body text is here\n"
"</screen> Having created this trigger, any change in <structfield>title</"
"structfield> or <structfield>body</structfield> will automatically be "
"reflected into <structfield>tsv</structfield>, without the application "
"having to worry about it."
msgstr ""
"Эти триггерные функции автоматически вычисляют значение для столбца "
"<type>tsvector</type> из одного или нескольких текстовых столбцов с "
"параметрами, указанными в команде <command>CREATE TRIGGER</command>. Пример "
"их использования: <screen>\n"
"CREATE TABLE messages (\n"
"    title       text,\n"
"    body        text,\n"
"    tsv         tsvector\n"
");\n"
"\n"
"CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE\n"
"ON messages FOR EACH ROW EXECUTE PROCEDURE\n"
"tsvector_update_trigger(tsv, 'pg_catalog.english', title, body);\n"
"\n"
"INSERT INTO messages VALUES('title here', 'the body text is here');\n"
"\n"
"SELECT * FROM messages;\n"
"   title    |         body          |            tsv             \n"
"------------+-----------------------+----------------------------\n"
" title here | the body text is here | 'bodi':4 'text':5 'titl':1\n"
"\n"
"SELECT title, body FROM messages WHERE tsv @@ to_tsquery('title &amp; "
"body');\n"
"   title    |         body          \n"
"------------+-----------------------\n"
" title here | the body text is here\n"
"</screen> С таким триггером любое изменение в полях <structfield>title</"
"structfield> или <structfield>body</structfield> будет автоматически "
"отражаться в содержимом <structfield>tsv</structfield>, так что приложению "
"не придётся заниматься этим."

#: textsearch.xml:1816(para)
msgid ""
"The first trigger argument must be the name of the <type>tsvector</type> "
"column to be updated. The second argument specifies the text search "
"configuration to be used to perform the conversion. For "
"<function>tsvector_update_trigger</function>, the configuration name is "
"simply given as the second trigger argument. It must be schema-qualified as "
"shown above, so that the trigger behavior will not change with changes in "
"<varname>search_path</varname>. For "
"<function>tsvector_update_trigger_column</function>, the second trigger "
"argument is the name of another table column, which must be of type "
"<type>regconfig</type>. This allows a per-row selection of configuration to "
"be made. The remaining argument(s) are the names of textual columns (of type "
"<type>text</type>, <type>varchar</type>, or <type>char</type>). These will "
"be included in the document in the order given. NULL values will be skipped "
"(but the other columns will still be indexed)."
msgstr ""
"Первым аргументом этих функций должно быть имя столбца <type>tsvector</"
"type>, содержимое которого будет обновляться. Ещё один аргумент &mdash; "
"конфигурация текстового поиска, которая будет использоваться для "
"преобразования. Для <function>tsvector_update_trigger</function> имя "
"конфигурации передаётся просто как второй аргумент триггера. Это имя должно "
"быть определено полностью, чтобы поведение триггера не менялось при "
"изменениях в пути поиска (<varname>search_path</varname>). Для "
"<function>tsvector_update_trigger_column</function> во втором аргументе "
"триггера передаётся имя другого столбца таблицы, который должен иметь тип "
"<type>regconfig</type>. Это позволяет использовать разные конфигурации для "
"разных строк. В оставшихся аргументах передаются имена текстовых столбцов "
"(типа <type>text</type>, <type>varchar</type> или <type>char</type>). Их "
"содержимое будет включено в документ в заданном порядке. При этом значения "
"NULL будут пропущены (а другие столбцы будут индексироваться)."

#: textsearch.xml:1840(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION messages_trigger() RETURNS trigger AS $$\n"
"begin\n"
"  new.tsv :=\n"
"     setweight(to_tsvector('pg_catalog.english', coalesce(new.title,'')), 'A') ||\n"
"     setweight(to_tsvector('pg_catalog.english', coalesce(new.body,'')), 'D');\n"
"  return new;\n"
"end\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE\n"
"    ON messages FOR EACH ROW EXECUTE PROCEDURE messages_trigger();"
msgstr ""
"CREATE FUNCTION messages_trigger() RETURNS trigger AS $$\n"
"begin\n"
"  new.tsv :=\n"
"     setweight(to_tsvector('pg_catalog.english', coalesce(new.title,'')),\n"
"       'A') ||\n"
"     setweight(to_tsvector('pg_catalog.english', coalesce(new.body,'')),\n"
"       'D');\n"
"  return new;\n"
"end\n"
"$$ LANGUAGE plpgsql;\n"
"\n"
"CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE\n"
"    ON messages FOR EACH ROW EXECUTE PROCEDURE messages_trigger();"

#: textsearch.xml:1833(para)
msgid ""
"A limitation of these built-in triggers is that they treat all the input "
"columns alike. To process columns differently &mdash; for example, to weight "
"title differently from body &mdash; it is necessary to write a custom "
"trigger. Here is an example using <application>PL/pgSQL</application> as the "
"trigger language: <placeholder-1/>"
msgstr ""
"Ограничение этих встроенных триггеров заключается в том, что они "
"обрабатывают все столбцы одинаково. Чтобы столбцы обрабатывались по-разному, "
"например для текста заголовка задавался не тот же вес, что для тела "
"документа, потребуется разработать свой триггер. К примеру, так это можно "
"сделать на языке <application>PL/pgSQL</application>: <placeholder-1/>"

#: textsearch.xml:1855(para)
msgid ""
"Keep in mind that it is important to specify the configuration name "
"explicitly when creating <type>tsvector</type> values inside triggers, so "
"that the column's contents will not be affected by changes to "
"<varname>default_text_search_config</varname>. Failure to do this is likely "
"to lead to problems such as search results changing after a dump and reload."
msgstr ""
"Помните, что, создавая значения <type>tsvector</type> в триггерах, важно "
"явно указывать имя конфигурации, чтобы содержимое столбца не зависело от "
"изменений <varname>default_text_search_config</varname>. В противном случае "
"могут возникнуть проблемы, например результаты поиска изменятся после "
"выгрузки и восстановления данных."

#: textsearch.xml:1866(title)
msgid "Gathering Document Statistics"
msgstr "Сбор статистики по документу"

#: textsearch.xml:1868(indexterm)
msgid "<primary>ts_stat</primary>"
msgstr "<primary>ts_stat</primary>"

#: textsearch.xml:1872(para)
msgid ""
"The function <function>ts_stat</function> is useful for checking your "
"configuration and for finding stop-word candidates."
msgstr ""
"Функция <function>ts_stat</function> может быть полезна для проверки "
"конфигурации и нахождения возможных стоп-слов."

#: textsearch.xml:1878(replaceable)
msgid "sqlquery"
msgstr "sql_запрос"

#: textsearch.xml:1879(replaceable)
msgctxt "replaceable"
msgid "word"
msgstr "слово"

#: textsearch.xml:1879(replaceable)
msgid "ndoc"
msgstr "число_док"

#: textsearch.xml:1880(replaceable)
msgid "nentry"
msgstr "число_вхожд"

#: textsearch.xml:1880(type) textsearch.xml:3353(type)
#: textsearch.xml:3355(type) textsearch.xml:3384(type)
#: textsearch.xml:3386(type)
msgid "setof record"
msgstr "setof record"

#: textsearch.xml:1877(synopsis)
#, no-wrap
msgid ""
"ts_stat(<placeholder-1/> <placeholder-2/>, <placeholder-3/>\n"
"        OUT <placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>,\n"
"        OUT <placeholder-8/> <placeholder-9/>) returns <placeholder-10/>"
msgstr ""
"ts_stat(<placeholder-1/> <placeholder-2/>, <placeholder-3/>\n"
"        OUT <placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>,\n"
"        OUT <placeholder-8/> <placeholder-9/>) returns <placeholder-10/>"

#: textsearch.xml:1892(para)
msgid ""
"<replaceable>word</replaceable> <type>text</type> &mdash; the value of a "
"lexeme"
msgstr ""
"<replaceable>слово</replaceable> <type>text</type> &mdash; значение лексемы"

#: textsearch.xml:1897(para)
msgid ""
"<replaceable>ndoc</replaceable> <type>integer</type> &mdash; number of "
"documents (<type>tsvector</type>s) the word occurred in"
msgstr ""
"<replaceable>число_док</replaceable> <type>integer</type> &mdash; число "
"документов (значений <type>tsvector</type>), в которых встретилось слово"

#: textsearch.xml:1903(para)
msgid ""
"<replaceable>nentry</replaceable> <type>integer</type> &mdash; total number "
"of occurrences of the word"
msgstr ""
"<replaceable>число_вхожд</replaceable> <type>integer</type> &mdash; общее "
"число вхождений слова"

#: textsearch.xml:1883(para)
msgid ""
"<replaceable>sqlquery</replaceable> is a text value containing an SQL query "
"which must return a single <type>tsvector</type> column. <function>ts_stat</"
"function> executes the query and returns statistics about each distinct "
"lexeme (word) contained in the <type>tsvector</type> data. The columns "
"returned are <placeholder-1/> If <replaceable>weights</replaceable> is "
"supplied, only occurrences having one of those weights are counted."
msgstr ""
"Здесь <replaceable>sql_запрос</replaceable> &mdash; текстовая строка, "
"содержащая SQL-запрос, который должен возвращать один столбец "
"<type>tsvector</type>. Функция <function>ts_stat</function> выполняет запрос "
"и возвращает статистику по каждой отдельной лексеме (слову), содержащейся в "
"данных <type>tsvector</type>. Её результат представляется в столбцах "
"<placeholder-1/> Если передаётся параметр <replaceable>weights</"
"replaceable>, то подсчитываются только вхождения с указанными в нём весами."

#: textsearch.xml:1917(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM ts_stat('SELECT vector FROM apod')\n"
"ORDER BY nentry DESC, ndoc DESC, word\n"
"LIMIT 10;"
msgstr ""
"SELECT * FROM ts_stat('SELECT vector FROM apod')\n"
"ORDER BY nentry DESC, ndoc DESC, word\n"
"LIMIT 10;"

#: textsearch.xml:1926(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM ts_stat('SELECT vector FROM apod', 'ab')\n"
"ORDER BY nentry DESC, ndoc DESC, word\n"
"LIMIT 10;"
msgstr ""
"SELECT * FROM ts_stat('SELECT vector FROM apod', 'ab')\n"
"ORDER BY nentry DESC, ndoc DESC, word\n"
"LIMIT 10;"

#: textsearch.xml:1914(para)
msgid ""
"For example, to find the ten most frequent words in a document collection: "
"<placeholder-1/> The same, but counting only word occurrences with weight "
"<literal>A</literal> or <literal>B</literal>: <placeholder-2/>"
msgstr ""
"Например, найти десять наиболее часто используемых слов в коллекции "
"документов можно так: <placeholder-1/> Следующий запрос возвращает тоже "
"десять слов, но при выборе их учитываются только вхождения с весами "
"<literal>A</literal> или <literal>B</literal>: <placeholder-2/>"

#: textsearch.xml:1938(title)
msgid "Parsers"
msgstr "Анализаторы"

#: textsearch.xml:1940(para)
msgid ""
"Text search parsers are responsible for splitting raw document text into "
"<firstterm>tokens</firstterm> and identifying each token's type, where the "
"set of possible types is defined by the parser itself. Note that a parser "
"does not modify the text at all &mdash; it simply identifies plausible word "
"boundaries. Because of this limited scope, there is less need for "
"application-specific custom parsers than there is for custom dictionaries. "
"At present <productname>PostgreSQL</productname> provides just one built-in "
"parser, which has been found to be useful for a wide range of applications."
msgstr ""
"Задача анализаторов текста &mdash; разделить текст документа на "
"<firstterm>фрагменты</firstterm> и присвоить каждому из них тип из набора, "
"определённого в самом анализаторе. Заметьте, что анализаторы не меняют текст "
"&mdash; они просто выдают позиции предполагаемых слов. Вследствие такой "
"ограниченности их функций, собственные специфические анализаторы бывают "
"нужны гораздо реже, чем собственные словари. В настоящее время в "
"<productname>PostgreSQL</productname> есть только один встроенный "
"анализатор, который может быть полезен для широкого круга приложений."

#: textsearch.xml:1952(para)
msgid ""
"The built-in parser is named <literal>pg_catalog.default</literal>. It "
"recognizes 23 token types, shown in <xref linkend=\"textsearch-default-parser"
"\"/>."
msgstr ""
"Этот встроенный анализатор называется <literal>pg_catalog.default</literal>. "
"Он распознаёт 23 типа фрагментов, перечисленные в <xref remap=\"6\" linkend="
"\"textsearch-default-parser\"/>."

#: textsearch.xml:1958(title)
msgid "Default Parser's Token Types"
msgstr "Типы фрагментов, выделяемых стандартным анализатором"

#: textsearch.xml:1962(entry)
msgid "Alias"
msgstr "Псевдоним"

#: textsearch.xml:1963(entry)
msgid "Description"
msgstr "Описание"

#: textsearch.xml:1964(entry)
msgid "Example"
msgstr "Пример"

#: textsearch.xml:1969(literal)
msgid "asciiword"
msgstr "asciiword"

#: textsearch.xml:1970(entry)
msgid "Word, all ASCII letters"
msgstr "Слово только из букв ASCII"

#: textsearch.xml:1971(literal)
msgid "elephant"
msgstr "elephant"

#: textsearch.xml:1974(literal)
msgctxt "literal"
msgid "word"
msgstr "word"

#: textsearch.xml:1975(entry)
msgid "Word, all letters"
msgstr "Слово из любых букв"

#: textsearch.xml:1976(literal)
msgid "ma&ntilde;ana"
msgstr "ma&ntilde;ana"

#: textsearch.xml:1979(literal)
msgid "numword"
msgstr "numword"

#: textsearch.xml:1980(entry)
msgid "Word, letters and digits"
msgstr "Слово из букв и цифр"

#: textsearch.xml:1981(literal)
msgid "beta1"
msgstr "beta1"

#: textsearch.xml:1984(literal)
msgid "asciihword"
msgstr "asciihword"

#: textsearch.xml:1985(entry)
msgid "Hyphenated word, all ASCII"
msgstr "Слово только из букв ASCII с дефисами"

#: textsearch.xml:1986(literal)
msgid "up-to-date"
msgstr "up-to-date"

#: textsearch.xml:1989(literal)
msgid "hword"
msgstr "hword"

#: textsearch.xml:1990(entry)
msgid "Hyphenated word, all letters"
msgstr "Слово из любых букв с дефисами"

#: textsearch.xml:1991(literal)
msgid "l&oacute;gico-matem&aacute;tica"
msgstr "l&oacute;gico-matem&aacute;tica"

#: textsearch.xml:1994(literal)
msgid "numhword"
msgstr "numhword"

#: textsearch.xml:1995(entry)
msgid "Hyphenated word, letters and digits"
msgstr "Слово из букв и цифр с дефисами"

#: textsearch.xml:1996(literal)
msgid "postgresql-beta1"
msgstr "postgresql-beta1"

#: textsearch.xml:1999(literal)
msgid "hword_asciipart"
msgstr "hword_asciipart"

#: textsearch.xml:2000(entry)
msgid "Hyphenated word part, all ASCII"
msgstr "Часть слова с дефисами, только из букв ASCII"

#: textsearch.xml:2001(entry)
msgid ""
"<literal>postgresql</literal> in the context <literal>postgresql-beta1</"
"literal>"
msgstr ""
"<literal>postgresql</literal> в словосочетании <literal>postgresql-beta1</"
"literal>"

#: textsearch.xml:2004(literal)
msgid "hword_part"
msgstr "hword_part"

#: textsearch.xml:2005(entry)
msgid "Hyphenated word part, all letters"
msgstr "Часть слова с дефисами, из любых букв"

#: textsearch.xml:2006(entry)
msgid ""
"<literal>l&oacute;gico</literal> or <literal>matem&aacute;tica</literal> in "
"the context <literal>l&oacute;gico-matem&aacute;tica</literal>"
msgstr ""
"<literal>l&oacute;gico</literal> или <literal>matem&aacute;tica</literal> в "
"словосочетании <literal>l&oacute;gico-matem&aacute;tica</literal>"

#: textsearch.xml:2010(literal)
msgid "hword_numpart"
msgstr "hword_numpart"

#: textsearch.xml:2011(entry)
msgid "Hyphenated word part, letters and digits"
msgstr "Часть слова с дефисами, из букв и цифр"

#: textsearch.xml:2012(entry)
msgid ""
"<literal>beta1</literal> in the context <literal>postgresql-beta1</literal>"
msgstr ""
"<literal>beta1</literal> в словосочетании <literal>postgresql-beta1</literal>"

#: textsearch.xml:2016(literal)
msgid "email"
msgstr "email"

#: textsearch.xml:2017(entry)
msgid "Email address"
msgstr "Адрес электронной почты"

#: textsearch.xml:2018(literal)
msgid "foo@example.com"
msgstr "foo@example.com"

#: textsearch.xml:2021(literal)
msgid "protocol"
msgstr "protocol"

#: textsearch.xml:2022(entry)
msgid "Protocol head"
msgstr "Префикс протокола"

#: textsearch.xml:2023(literal)
msgid "http://"
msgstr "http://"

#: textsearch.xml:2026(literal)
msgid "url"
msgstr "url"

#: textsearch.xml:2027(entry)
msgid "URL"
msgstr "URL"

#: textsearch.xml:2028(literal)
msgid "example.com/stuff/index.html"
msgstr "example.com/stuff/&zwsp;index.html"

#: textsearch.xml:2031(literal)
msgid "host"
msgstr "host"

#: textsearch.xml:2032(entry)
msgid "Host"
msgstr "Имя узла"

#: textsearch.xml:2033(literal)
msgid "example.com"
msgstr "example.com"

#: textsearch.xml:2036(literal)
msgid "url_path"
msgstr "url_path"

#: textsearch.xml:2037(entry)
msgid "URL path"
msgstr "Путь в адресе URL"

#: textsearch.xml:2038(entry)
msgid "<literal>/stuff/index.html</literal>, in the context of a URL"
msgstr "<literal>/stuff/index.html</literal>, как часть URL"

#: textsearch.xml:2041(literal)
msgid "file"
msgstr "file"

#: textsearch.xml:2042(entry)
msgid "File or path name"
msgstr "Путь или имя файла"

#: textsearch.xml:2043(entry)
msgid "<literal>/usr/local/foo.txt</literal>, if not within a URL"
msgstr "<literal>/usr/local/foo.txt</literal>, если не является частью URL"

#: textsearch.xml:2046(literal)
msgid "sfloat"
msgstr "sfloat"

#: textsearch.xml:2047(entry)
msgid "Scientific notation"
msgstr "Научная запись числа"

#: textsearch.xml:2048(literal)
msgid "-1.234e56"
msgstr "-1.234e56"

#: textsearch.xml:2051(literal)
msgid "float"
msgstr "float"

#: textsearch.xml:2052(entry)
msgid "Decimal notation"
msgstr "Десятичная запись числа"

#: textsearch.xml:2053(literal)
msgid "-1.234"
msgstr "-1.234"

#: textsearch.xml:2056(literal)
msgid "int"
msgstr "int"

#: textsearch.xml:2057(entry)
msgid "Signed integer"
msgstr "Целое со знаком"

#: textsearch.xml:2058(literal)
msgid "-1234"
msgstr "-1234"

#: textsearch.xml:2061(literal)
msgid "uint"
msgstr "uint"

#: textsearch.xml:2062(entry)
msgid "Unsigned integer"
msgstr "Целое без знака"

#: textsearch.xml:2063(literal)
msgid "1234"
msgstr "1234"

#: textsearch.xml:2066(literal)
msgid "version"
msgstr "version"

#: textsearch.xml:2067(entry)
msgid "Version number"
msgstr "Номер версии"

#: textsearch.xml:2068(literal)
msgid "8.3.0"
msgstr "8.3.0"

#: textsearch.xml:2071(literal)
msgid "tag"
msgstr "tag"

#: textsearch.xml:2072(entry)
msgid "XML tag"
msgstr "Тег XML"

#: textsearch.xml:2073(literal)
msgid "&lt;a href=\"dictionaries.html\"&gt;"
msgstr "&lt;a href=&zwsp;\"dictionaries.html\"&gt;"

#: textsearch.xml:2076(literal)
msgid "entity"
msgstr "entity"

#: textsearch.xml:2077(entry)
msgid "XML entity"
msgstr "Сущность XML"

#: textsearch.xml:2078(literal)
msgid "&amp;amp;"
msgstr "&amp;amp;"

#: textsearch.xml:2081(literal)
msgid "blank"
msgstr "blank"

#: textsearch.xml:2082(entry)
msgid "Space symbols"
msgstr "Символы-разделители"

#: textsearch.xml:2083(entry)
msgid "(any whitespace or punctuation not otherwise recognized)"
msgstr ""
"(любые пробельные символы или знаки препинания, не попавшие в другие "
"категории)"

#: textsearch.xml:2090(para)
msgid ""
"The parser's notion of a <quote>letter</quote> is determined by the "
"database's locale setting, specifically <varname>lc_ctype</varname>. Words "
"containing only the basic ASCII letters are reported as a separate token "
"type, since it is sometimes useful to distinguish them. In most European "
"languages, token types <literal>word</literal> and <literal>asciiword</"
"literal> should be treated alike."
msgstr ""
"Понятие <quote>буквы</quote> анализатор определяет исходя из локали, "
"заданной для базы данных, в частности параметра <varname>lc_ctype</varname>. "
"Слова, содержащие только буквы из ASCII (латинские буквы), распознаются как "
"фрагменты отдельного типа, так как иногда бывает полезно выделить их. Для "
"многих европейских языков типы фрагментов <literal>word</literal> и "
"<literal>asciiword</literal> можно воспринимать как синонимы."

#: textsearch.xml:2099(para)
msgid ""
"<literal>email</literal> does not support all valid email characters as "
"defined by RFC 5322. Specifically, the only non-alphanumeric characters "
"supported for email user names are period, dash, and underscore."
msgstr ""
"<literal>email</literal> принимает не все символы, которые считаются "
"допустимыми по стандарту RFC 5322. В частности, имя почтового ящика помимо "
"алфавитно-цифровых символов может содержать только точку, минус и "
"подчёркивание."

#: textsearch.xml:2107(para)
msgid ""
"It is possible for the parser to produce overlapping tokens from the same "
"piece of text. As an example, a hyphenated word will be reported both as the "
"entire word and as each component: <screen>\n"
"SELECT alias, description, token FROM ts_debug('foo-bar-beta1');\n"
"      alias      |               description                |     "
"token     \n"
"-----------------+------------------------------------------"
"+---------------\n"
" numhword        | Hyphenated word, letters and digits      | foo-bar-beta1\n"
" hword_asciipart | Hyphenated word part, all ASCII          | foo\n"
" blank           | Space symbols                            | -\n"
" hword_asciipart | Hyphenated word part, all ASCII          | bar\n"
" blank           | Space symbols                            | -\n"
" hword_numpart   | Hyphenated word part, letters and digits | beta1\n"
"</screen> This behavior is desirable since it allows searches to work for "
"both the whole compound word and for components. Here is another instructive "
"example: <screen>\n"
"SELECT alias, description, token FROM ts_debug('http://example.com/stuff/"
"index.html');\n"
"  alias   |  description  |            token             \n"
"----------+---------------+------------------------------\n"
" protocol | Protocol head | http://\n"
" url      | URL           | example.com/stuff/index.html\n"
" host     | Host          | example.com\n"
" url_path | URL path      | /stuff/index.html\n"
"</screen>"
msgstr ""
"Анализатор может выделить в одном тексте несколько перекрывающихся "
"фрагментов. Например, слово с дефисом будет выдано как целое составное слово "
"и по частям: <screen>\n"
"SELECT alias, description, token FROM ts_debug('foo-bar-beta1');\n"
"      alias      |               description                |     token    \n"
"-----------------+------------------------------------------+--------------\n"
" numhword        | Hyphenated word, letters and digits      | foo-bar-beta1\n"
" hword_asciipart | Hyphenated word part, all ASCII          | foo\n"
" blank           | Space symbols                            | -\n"
" hword_asciipart | Hyphenated word part, all ASCII          | bar\n"
" blank           | Space symbols                            | -\n"
" hword_numpart   | Hyphenated word part, letters and digits | beta1\n"
"</screen> Это поведение считается желательным, так как это позволяет "
"находить при последующем поиске и всё слово целиком, и его части. Ещё один "
"показательный пример: <screen>\n"
"SELECT alias, description, token\n"
"FROM ts_debug('http://example.com/stuff/index.html');\n"
"  alias   |  description  |            token             \n"
"----------+---------------+------------------------------\n"
" protocol | Protocol head | http://\n"
" url      | URL           | example.com/stuff/index.html\n"
" host     | Host          | example.com\n"
" url_path | URL path      | /stuff/index.html\n"
"</screen>"

#: textsearch.xml:2142(title)
msgid "Dictionaries"
msgstr "Словари"

#: textsearch.xml:2144(para)
msgid ""
"Dictionaries are used to eliminate words that should not be considered in a "
"search (<firstterm>stop words</firstterm>), and to <firstterm>normalize</"
"firstterm> words so that different derived forms of the same word will "
"match. A successfully normalized word is called a <firstterm>lexeme</"
"firstterm>. Aside from improving search quality, normalization and removal "
"of stop words reduce the size of the <type>tsvector</type> representation of "
"a document, thereby improving performance. Normalization does not always "
"have linguistic meaning and usually depends on application semantics."
msgstr ""
"Словари полнотекстового поиска предназначены для исключения <firstterm>стоп-"
"слов</firstterm> (слов, которые не должны учитываться при поиске) и "
"<firstterm>нормализации</firstterm> слов, чтобы разные словоформы считались "
"совпадающими. Успешно нормализованное слово называется <firstterm>лексемой</"
"firstterm>. Нормализация и исключение стоп-слов не только улучшает качество "
"поиска, но и уменьшает размер представления документа в формате "
"<type>tsvector</type>, и, как следствие, увеличивает быстродействие. "
"Нормализация не всегда имеет лингвистический смысл, обычно она зависит от "
"требований приложения."

#: textsearch.xml:2161(para)
msgid ""
"Linguistic - Ispell dictionaries try to reduce input words to a normalized "
"form; stemmer dictionaries remove word endings"
msgstr ""
"Лингвистическая нормализация &mdash; словари Ispell пытаются свести слова на "
"входе к нормализованной форме, а стеммеры убирают окончания слов"

#: textsearch.xml:2173(para)
msgid "http://www.pgsql.ru/db/mw/index.html"
msgstr "http://www.pgsql.ru/db/mw/index.html"

#: textsearch.xml:2178(para)
msgid "http://www.pgsql.ru/db/mw/"
msgstr "http://www.pgsql.ru/db/mw/"

#: textsearch.xml:2183(para)
msgid "http://www.pgsql.ru/db/../db/mw/index.html"
msgstr "http://www.pgsql.ru/db/../db/mw/index.html"

#: textsearch.xml:2167(para)
msgid ""
"<acronym>URL</acronym> locations can be canonicalized to make equivalent "
"URLs match: <placeholder-1/>"
msgstr ""
"Адреса <acronym>URL</acronym> могут быть канонизированы, чтобы например "
"следующие адреса считались одинаковыми: <placeholder-1/>"

#: textsearch.xml:2191(para)
msgid ""
"Color names can be replaced by their hexadecimal values, e.g., <literal>red, "
"green, blue, magenta -&gt; FF0000, 00FF00, 0000FF, FF00FF</literal>"
msgstr ""
"Названия цветов могут быть заменены их шестнадцатеричными значениями, "
"например <literal>red, green, blue, magenta -&gt; FF0000, 00FF00, 0000FF, "
"FF00FF</literal>"

#: textsearch.xml:2197(para)
msgid ""
"If indexing numbers, we can remove some fractional digits to reduce the "
"range of possible numbers, so for example <emphasis>3.14</"
"emphasis>159265359, <emphasis>3.14</emphasis>15926, <emphasis>3.14</"
"emphasis> will be the same after normalization if only two digits are kept "
"after the decimal point."
msgstr ""
"При индексировании чисел можно отбросить цифры в дробной части для "
"сокращения множества всевозможных чисел, чтобы например <emphasis>3.14</"
"emphasis>159265359, <emphasis>3.14</emphasis>15926 и <emphasis>3.14</"
"emphasis> стали одинаковыми после нормализации, при которой после точки "
"останутся только две цифры."

#: textsearch.xml:2155(para)
msgid "Some examples of normalization: <placeholder-1/>"
msgstr "Несколько примеров нормализации: <placeholder-1/>"

#: textsearch.xml:2214(para)
msgid ""
"an array of lexemes if the input token is known to the dictionary (notice "
"that one token can produce more than one lexeme)"
msgstr ""
"массив лексем, если входной фрагмент известен в словаре (заметьте, один "
"фрагмент может породить несколько лексем)"

#: textsearch.xml:2220(para)
msgid ""
"a single lexeme with the <literal>TSL_FILTER</literal> flag set, to replace "
"the original token with a new token to be passed to subsequent dictionaries "
"(a dictionary that does this is called a <firstterm>filtering dictionary</"
"firstterm>)"
msgstr ""
"одну лексему с установленным флагом <literal>TSL_FILTER</literal> для замены "
"исходного фрагмента новым, чтобы следующие словари работали с новым "
"вариантом (словарь, который делает это, называется <firstterm>фильтрующим "
"словарём</firstterm>)"

#: textsearch.xml:2228(para)
msgid "an empty array if the dictionary knows the token, but it is a stop word"
msgstr ""
"пустой массив, если словарь воспринимает этот фрагмент, но считает его стоп-"
"словом"

#: textsearch.xml:2233(para)
msgid ""
"<literal>NULL</literal> if the dictionary does not recognize the input token"
msgstr ""
"<literal>NULL</literal>, если словарь не воспринимает полученный фрагмент"

#: textsearch.xml:2209(para)
msgid ""
"A dictionary is a program that accepts a token as input and returns: "
"<placeholder-1/>"
msgstr ""
"Словарь &mdash; это программа, которая принимает на вход фрагмент и "
"возвращает: <placeholder-1/>"

#: textsearch.xml:2240(para)
msgid ""
"<productname>PostgreSQL</productname> provides predefined dictionaries for "
"many languages. There are also several predefined templates that can be used "
"to create new dictionaries with custom parameters. Each predefined "
"dictionary template is described below. If no existing template is suitable, "
"it is possible to create new ones; see the <filename>contrib/</filename> "
"area of the <productname>PostgreSQL</productname> distribution for examples."
msgstr ""
"В <productname>PostgreSQL</productname> встроены стандартные словари для "
"многих языков. Есть также несколько предопределённых шаблонов, на основании "
"которых можно создавать новые словари с изменёнными параметрами. Все эти "
"шаблоны описаны ниже. Если же ни один из них не подходит, можно создать и "
"свои собственные шаблоны. Соответствующие примеры можно найти в каталоге "
"<filename>contrib/</filename> инсталляции <productname>PostgreSQL</"
"productname>."

#: textsearch.xml:2250(para)
msgid ""
"A text search configuration binds a parser together with a set of "
"dictionaries to process the parser's output tokens. For each token type that "
"the parser can return, a separate list of dictionaries is specified by the "
"configuration. When a token of that type is found by the parser, each "
"dictionary in the list is consulted in turn, until some dictionary "
"recognizes it as a known word. If it is identified as a stop word, or if no "
"dictionary recognizes the token, it will be discarded and not indexed or "
"searched for. Normally, the first dictionary that returns a non-"
"<literal>NULL</literal> output determines the result, and any remaining "
"dictionaries are not consulted; but a filtering dictionary can replace the "
"given word with a modified word, which is then passed to subsequent "
"dictionaries."
msgstr ""
"Конфигурация текстового поиска связывает анализатор с набором словарей, "
"которые будут обрабатывать выделенные им фрагменты. Для каждого типа "
"фрагментов, выданных анализатором, в конфигурации задаётся отдельный список "
"словарей. Найденный анализатором фрагмент проходит через все словари по "
"порядку, пока какой-либо словарь не увидит в нём знакомое для него слово. "
"Если он окажется стоп-словом или его не распознает ни один словарь, этот "
"фрагмент не будет учитываться при индексации и поиске. Обычно результат "
"определяет первый же словарь, который возвращает не <literal>NULL</literal>, "
"и остальные словари уже не проверяются; однако фильтрующий словарь может "
"заменить полученное слово другим, которое и будет передано следующим "
"словарям."

#: textsearch.xml:2276(programlisting)
#, no-wrap
msgid ""
"ALTER TEXT SEARCH CONFIGURATION astro_en\n"
"    ADD MAPPING FOR asciiword WITH astrosyn, english_ispell, english_stem;"
msgstr ""
"ALTER TEXT SEARCH CONFIGURATION astro_en\n"
"    ADD MAPPING FOR asciiword WITH astrosyn, english_ispell, english_stem;"

#: textsearch.xml:2265(para)
msgid ""
"The general rule for configuring a list of dictionaries is to place first "
"the most narrow, most specific dictionary, then the more general "
"dictionaries, finishing with a very general dictionary, like a "
"<application>Snowball</application> stemmer or <literal>simple</literal>, "
"which recognizes everything. For example, for an astronomy-specific search "
"(<literal>astro_en</literal> configuration) one could bind token type "
"<type>asciiword</type> (ASCII word) to a synonym dictionary of astronomical "
"terms, a general English dictionary and a <application>Snowball</"
"application> English stemmer: <placeholder-1/>"
msgstr ""
"Общее правило настройки списка словарей заключается в том, чтобы поставить "
"наиболее частные и специфические словари в начале, затем перечислить более "
"общие и закончить самым общим словарём, например стеммером "
"<application>Snowball</application> или словарём <literal>simple</literal>, "
"который распознаёт всё. Например, для поиска по теме астрономии "
"(конфигурация <literal>astro_en</literal>) тип фрагментов <type>asciiword</"
"type> (слово из букв ASCII) можно связать со словарём синонимов "
"астрономических терминов, затем с обычным английским словарём и наконец со "
"стеммером английских окончаний <application>Snowball</application>: "
"<placeholder-1/>"

#: textsearch.xml:2282(para)
msgid ""
"A filtering dictionary can be placed anywhere in the list, except at the end "
"where it'd be useless. Filtering dictionaries are useful to partially "
"normalize words to simplify the task of later dictionaries. For example, a "
"filtering dictionary could be used to remove accents from accented letters, "
"as is done by the <xref linkend=\"unaccent\"/> module."
msgstr ""
"Фильтрующий словарь можно включить в любом месте списка, кроме конца, где он "
"будет бесполезен. Фильтрующие словари бывают полезны для частичной "
"нормализации слов и упрощения задачи следующих словарей. Например, "
"фильтрующий словарь может удалить из текста диакритические знаки, как это "
"делает модуль <xref linkend=\"unaccent\"/>."

#: textsearch.xml:2291(title)
msgid "Stop Words"
msgstr "Стоп-слова"

#: textsearch.xml:2293(para)
msgid ""
"Stop words are words that are very common, appear in almost every document, "
"and have no discrimination value. Therefore, they can be ignored in the "
"context of full text searching. For example, every English text contains "
"words like <literal>a</literal> and <literal>the</literal>, so it is useless "
"to store them in an index. However, stop words do affect the positions in "
"<type>tsvector</type>, which in turn affect ranking: <screen>\n"
"SELECT to_tsvector('english','in the list of stop words');\n"
"        to_tsvector\n"
"----------------------------\n"
" 'list':3 'stop':5 'word':6\n"
"</screen> The missing positions 1,2,4 are because of stop words. Ranks "
"calculated for documents with and without stop words are quite different: "
"<screen>\n"
"SELECT ts_rank_cd (to_tsvector('english','in the list of stop words'), "
"to_tsquery('list &amp; stop'));\n"
" ts_rank_cd\n"
"------------\n"
"       0.05\n"
"\n"
"SELECT ts_rank_cd (to_tsvector('english','list stop words'), "
"to_tsquery('list &amp; stop'));\n"
" ts_rank_cd\n"
"------------\n"
"        0.1\n"
"</screen>"
msgstr ""
"Стоп-словами называются слова, которые встречаются очень часто, практически "
"в каждом документе, и поэтому не имеют различительной ценности. Таким "
"образом, при полнотекстовом поиске их можно игнорировать. Например, в каждом "
"английском тексте содержатся артикли <literal>a</literal> и <literal>the</"
"literal>, так что хранить их в индексе бессмысленно. Однако стоп-слова "
"влияют на позиции лексем в значении <type>tsvector</type>, от чего, в свою "
"очередь, зависит ранжирование: <screen>\n"
"SELECT to_tsvector('english','in the list of stop words');\n"
"        to_tsvector\n"
"----------------------------\n"
" 'list':3 'stop':5 'word':6\n"
"</screen> В результате отсутствуют позиции 1,2,4, потому что фрагменты в "
"этих позициях оказались стоп-словами. Ранги, вычисленные для документов со "
"стоп-словами и без них, могут значительно различаться: <screen>\n"
"SELECT ts_rank_cd (to_tsvector('english','in the list of stop words'),\n"
"  to_tsquery('list &amp; stop'));\n"
" ts_rank_cd\n"
"------------\n"
"       0.05\n"
"\n"
"SELECT ts_rank_cd (to_tsvector('english','list stop words'),\n"
"  to_tsquery('list &amp; stop'));\n"
" ts_rank_cd\n"
"------------\n"
"        0.1\n"
"</screen>"

#: textsearch.xml:2325(para)
msgid ""
"It is up to the specific dictionary how it treats stop words. For example, "
"<literal>ispell</literal> dictionaries first normalize words and then look "
"at the list of stop words, while <literal>Snowball</literal> stemmers first "
"check the list of stop words. The reason for the different behavior is an "
"attempt to decrease noise."
msgstr ""
"Как именно обрабатывать стоп-слова, определяет сам словарь. Например, "
"словари <literal>ispell</literal> сначала нормализуют слова, а затем "
"просматривают список стоп-слов, тогда как стеммеры <literal>Snowball</"
"literal> просматривают свой список стоп-слов в первую очередь. Это различие "
"в поведении объясняется стремлением уменьшить шум."

#: textsearch.xml:2336(title)
msgid "Simple Dictionary"
msgstr "Простой словарь"

#: textsearch.xml:2338(para)
msgid ""
"The <literal>simple</literal> dictionary template operates by converting the "
"input token to lower case and checking it against a file of stop words. If "
"it is found in the file then an empty array is returned, causing the token "
"to be discarded. If not, the lower-cased form of the word is returned as the "
"normalized lexeme. Alternatively, the dictionary can be configured to report "
"non-stop-words as unrecognized, allowing them to be passed on to the next "
"dictionary in the list."
msgstr ""
"Работа шаблона словарей <literal>simple</literal> сводится к преобразованию "
"входного фрагмента в нижний регистр и проверки результата по файлу со "
"списком стоп-слов. Если это слово находится в файле, словарь возвращает "
"пустой массив и фрагмент исключается из дальнейшего рассмотрения. В "
"противном случае словарь возвращает в качестве нормализованной лексемы слово "
"в нижнем регистре. Этот словарь можно настроить и так, чтобы все слова, "
"кроме стоп-слов, считались неопознанными и передавались следующему словарю в "
"списке."

#: textsearch.xml:2352(programlisting)
#, no-wrap
msgid ""
"CREATE TEXT SEARCH DICTIONARY public.simple_dict (\n"
"    TEMPLATE = pg_catalog.simple,\n"
"    STOPWORDS = english\n"
");"
msgstr ""
"CREATE TEXT SEARCH DICTIONARY public.simple_dict (\n"
"    TEMPLATE = pg_catalog.simple,\n"
"    STOPWORDS = english\n"
");"

#: textsearch.xml:2348(para)
msgid ""
"Here is an example of a dictionary definition using the <literal>simple</"
"literal> template: <placeholder-1/> Here, <literal>english</literal> is the "
"base name of a file of stop words. The file's full name will be <filename>"
"$SHAREDIR/tsearch_data/english.stop</filename>, where <literal>$SHAREDIR</"
"literal> means the <productname>PostgreSQL</productname> installation's "
"shared-data directory, often <filename>/usr/local/share/postgresql</"
"filename> (use <command>pg_config --sharedir</command> to determine it if "
"you're not sure). The file format is simply a list of words, one per line. "
"Blank lines and trailing spaces are ignored, and upper case is folded to "
"lower case, but no other processing is done on the file contents."
msgstr ""
"Определить словарь на основе шаблона <literal>simple</literal> можно так: "
"<placeholder-1/> Здесь <literal>english</literal> &mdash; базовое имя файла "
"со стоп-словами. Полным именем файла будет <filename>$SHAREDIR/tsearch_data/"
"english.stop</filename>, где <literal>$SHAREDIR</literal> указывает на "
"каталог с общими данными <productname>PostgreSQL</productname>, часто это "
"<filename>/usr/local/share/postgresql</filename> (точно узнать его можно с "
"помощью команды <command>pg_config --sharedir</command>). Этот текстовый "
"файл должен содержать просто список слов, по одному слову в строке. Пустые "
"строки и окружающие пробелы игнорируются, все символы переводятся в нижний "
"регистр и на этом обработка файла заканчивается."

#: textsearch.xml:2372(para)
msgid ""
"Now we can test our dictionary: <screen>\n"
"SELECT ts_lexize('public.simple_dict','YeS');\n"
" ts_lexize\n"
"-----------\n"
" {yes}\n"
"\n"
"SELECT ts_lexize('public.simple_dict','The');\n"
" ts_lexize\n"
"-----------\n"
" {}\n"
"</screen>"
msgstr ""
"Теперь мы можем проверить наш словарь: <screen>\n"
"SELECT ts_lexize('public.simple_dict','YeS');\n"
" ts_lexize\n"
"-----------\n"
" {yes}\n"
"\n"
"SELECT ts_lexize('public.simple_dict','The');\n"
" ts_lexize\n"
"-----------\n"
" {}\n"
"</screen>"

#: textsearch.xml:2388(para)
msgid ""
"We can also choose to return <literal>NULL</literal>, instead of the lower-"
"cased word, if it is not found in the stop words file. This behavior is "
"selected by setting the dictionary's <literal>Accept</literal> parameter to "
"<literal>false</literal>. Continuing the example: <screen>\n"
"ALTER TEXT SEARCH DICTIONARY public.simple_dict ( Accept = false );\n"
"\n"
"SELECT ts_lexize('public.simple_dict','YeS');\n"
" ts_lexize\n"
"-----------\n"
"\n"
"\n"
"SELECT ts_lexize('public.simple_dict','The');\n"
" ts_lexize\n"
"-----------\n"
" {}\n"
"</screen>"
msgstr ""
"Мы также можем настроить словарь так, чтобы он возвращал <literal>NULL</"
"literal> вместо слова в нижнем регистре, если оно не находится в файле стоп-"
"слов. Для этого нужно присвоить параметру <literal>Accept</literal> значение "
"<literal>false</literal>. Продолжая наш пример: <screen>\n"
"ALTER TEXT SEARCH DICTIONARY public.simple_dict ( Accept = false );\n"
"\n"
"SELECT ts_lexize('public.simple_dict','YeS');\n"
" ts_lexize\n"
"-----------\n"
"\n"
"\n"
"SELECT ts_lexize('public.simple_dict','The');\n"
" ts_lexize\n"
"-----------\n"
" {}\n"
"</screen>"

#: textsearch.xml:2409(para)
msgid ""
"With the default setting of <literal>Accept</literal> = <literal>true</"
"literal>, it is only useful to place a <literal>simple</literal> dictionary "
"at the end of a list of dictionaries, since it will never pass on any token "
"to a following dictionary. Conversely, <literal>Accept</literal> = "
"<literal>false</literal> is only useful when there is at least one following "
"dictionary."
msgstr ""
"Со значением <literal>Accept</literal> = <literal>true</literal> (по "
"умолчанию) словарь <literal>simple</literal> имеет смысл включать только в "
"конце списка словарей, так как он никогда не передаст фрагмент следующему "
"словарю. И напротив, <literal>Accept</literal> = <literal>false</literal> "
"имеет смысл, только если за ним следует ещё минимум один словарь."

#: textsearch.xml:2418(para)
msgid ""
"Most types of dictionaries rely on configuration files, such as files of "
"stop words. These files <emphasis>must</emphasis> be stored in UTF-8 "
"encoding. They will be translated to the actual database encoding, if that "
"is different, when they are read into the server."
msgstr ""
"Большинство словарей работают с дополнительными файлами, например, файлами "
"стоп-слов. Содержимое этих файлов <emphasis>должно</emphasis> иметь "
"кодировку UTF-8. Если база данных работает в другой кодировке, они будут "
"переведены в неё, когда сервер будет загружать их."

#: textsearch.xml:2427(para)
msgid ""
"Normally, a database session will read a dictionary configuration file only "
"once, when it is first used within the session. If you modify a "
"configuration file and want to force existing sessions to pick up the new "
"contents, issue an <command>ALTER TEXT SEARCH DICTIONARY</command> command "
"on the dictionary. This can be a <quote>dummy</quote> update that doesn't "
"actually change any parameter values."
msgstr ""
"Обычно в рамках одного сеанса дополнительный файл словаря загружается только "
"один раз, при первом использовании. Если же вы измените его и захотите, "
"чтобы существующие сеансы работали с новым содержимым, выполните для этого "
"словаря команду <command>ALTER TEXT SEARCH DICTIONARY</command>. Это "
"обновление словаря может быть <quote>фиктивным</quote>, фактически не "
"меняющим значения никаких параметров."

#: textsearch.xml:2440(title)
msgid "Synonym Dictionary"
msgstr "Словарь синонимов"

#: textsearch.xml:2442(para)
msgid ""
"This dictionary template is used to create dictionaries that replace a word "
"with a synonym. Phrases are not supported (use the thesaurus template (<xref "
"linkend=\"textsearch-thesaurus\"/>) for that). A synonym dictionary can be "
"used to overcome linguistic problems, for example, to prevent an English "
"stemmer dictionary from reducing the word <quote>Paris</quote> to "
"<quote>pari</quote>. It is enough to have a <literal>Paris paris</literal> "
"line in the synonym dictionary and put it before the <literal>english_stem</"
"literal> dictionary. For example: <screen>\n"
"SELECT * FROM ts_debug('english', 'Paris');\n"
"   alias   |   description   | token |  dictionaries  |  dictionary  | "
"lexemes \n"
"-----------+-----------------+-------+----------------+--------------"
"+---------\n"
" asciiword | Word, all ASCII | Paris | {english_stem} | english_stem | "
"{pari}\n"
"\n"
"CREATE TEXT SEARCH DICTIONARY my_synonym (\n"
"    TEMPLATE = synonym,\n"
"    SYNONYMS = my_synonyms\n"
");\n"
"\n"
"ALTER TEXT SEARCH CONFIGURATION english\n"
"    ALTER MAPPING FOR asciiword\n"
"    WITH my_synonym, english_stem;\n"
"\n"
"SELECT * FROM ts_debug('english', 'Paris');\n"
"   alias   |   description   | token |       dictionaries        | "
"dictionary | lexemes \n"
"-----------+-----------------+-------+---------------------------"
"+------------+---------\n"
" asciiword | Word, all ASCII | Paris | {my_synonym,english_stem} | "
"my_synonym | {paris}\n"
"</screen>"
msgstr ""
"Этот шаблон словарей используется для создания словарей, заменяющих слова "
"синонимами. Словосочетания такие словари не поддерживают (используйте для "
"этого тезаурус (<xref linkend=\"textsearch-thesaurus\"/>)). Словарь "
"синонимов может помочь в преодолении лингвистических проблем, например, не "
"дать стеммеру английского уменьшить слово <quote>Paris</quote> до "
"<quote>pari</quote>. Для этого достаточно поместить в словарь синонимов "
"строку <literal>Paris paris</literal> и поставить этот словарь перед "
"словарём <literal>english_stem</literal>. Например: <screen>\n"
"SELECT * FROM ts_debug('english', 'Paris');\n"
"   alias  |   description  | token|  dictionaries |  dictionary | lexemes\n"
"----------+----------------+------+---------------+-------------+--------\n"
" asciiword| Word, all ASCII| Paris| {english_stem}| english_stem| {pari}\n"
"\n"
"CREATE TEXT SEARCH DICTIONARY my_synonym (\n"
"    TEMPLATE = synonym,\n"
"    SYNONYMS = my_synonyms\n"
");\n"
"\n"
"ALTER TEXT SEARCH CONFIGURATION english\n"
"    ALTER MAPPING FOR asciiword\n"
"    WITH my_synonym, english_stem;\n"
"\n"
"SELECT * FROM ts_debug('english', 'Paris');\n"
"   alias  |   description  | token| dictionaries | dictionary| lexemes\n"
"----------+----------------+------+--------------+-----------+--------\n"
" asciiword| Word, all ASCII| Paris| {my_synonym, | my_synonym| {paris}\n"
"          |                |      | english_stem}|           |\n"
"</screen>"

#: textsearch.xml:2474(para)
msgid ""
"The only parameter required by the <literal>synonym</literal> template is "
"<literal>SYNONYMS</literal>, which is the base name of its configuration "
"file &mdash; <literal>my_synonyms</literal> in the above example. The file's "
"full name will be <filename>$SHAREDIR/tsearch_data/my_synonyms.syn</"
"filename> (where <literal>$SHAREDIR</literal> means the "
"<productname>PostgreSQL</productname> installation's shared-data directory). "
"The file format is just one line per word to be substituted, with the word "
"followed by its synonym, separated by white space. Blank lines and trailing "
"spaces are ignored."
msgstr ""
"Шаблон <literal>synonym</literal> принимает единственный параметр, "
"<literal>SYNONYMS</literal>, в котором задаётся базовое имя его файла "
"конфигурации &mdash; в данном примере это <literal>my_synonyms</literal>. "
"Полным именем файла будет <filename>$SHAREDIR/tsearch_data/my_synonyms.syn</"
"filename> (где <literal>$SHAREDIR</literal> указывает на каталог общих "
"данных <productname>PostgreSQL</productname>). Содержимое этого файла должны "
"составлять строки с двумя словами в каждой (первое &mdash; заменяемое слово, "
"а второе &mdash; его синоним), разделёнными пробелами. Пустые строки и "
"окружающие пробелы при разборе этого файла игнорируются."

#: textsearch.xml:2487(para)
msgid ""
"The <literal>synonym</literal> template also has an optional parameter "
"<literal>CaseSensitive</literal>, which defaults to <literal>false</"
"literal>. When <literal>CaseSensitive</literal> is <literal>false</literal>, "
"words in the synonym file are folded to lower case, as are input tokens. "
"When it is <literal>true</literal>, words and tokens are not folded to lower "
"case, but are compared as-is."
msgstr ""
"Шаблон <literal>synonym</literal> также принимает необязательный параметр "
"<literal>CaseSensitive</literal>, который по умолчанию имеет значение "
"<literal>false</literal>. Когда <literal>CaseSensitive</literal> равен "
"<literal>false</literal>, слова в файле синонимов переводятся в нижний "
"регистр, вместе с проверяемыми фрагментами. Если же он не равен "
"<literal>true</literal>, регистр слов в файле и проверяемых фрагментов не "
"меняются, они сравниваются &laquo;как есть&raquo;."

#: textsearch.xml:2506(programlisting)
#, no-wrap
msgid ""
"postgres        pgsql\n"
"postgresql      pgsql\n"
"postgre pgsql\n"
"gogle   googl\n"
"indices index*"
msgstr ""
"postgres        pgsql\n"
"postgresql      pgsql\n"
"postgre pgsql\n"
"gogle   googl\n"
"indices index*"

#: textsearch.xml:2496(para)
msgid ""
"An asterisk (<literal>*</literal>) can be placed at the end of a synonym in "
"the configuration file. This indicates that the synonym is a prefix. The "
"asterisk is ignored when the entry is used in <function>to_tsvector()</"
"function>, but when it is used in <function>to_tsquery()</function>, the "
"result will be a query item with the prefix match marker (see <xref linkend="
"\"textsearch-parsing-queries\"/>). For example, suppose we have these "
"entries in <filename>$SHAREDIR/tsearch_data/synonym_sample.syn</filename>: "
"<placeholder-1/> Then we will get these results: <screen>\n"
"mydb=# CREATE TEXT SEARCH DICTIONARY syn (template=synonym, "
"synonyms='synonym_sample');\n"
"mydb=# SELECT ts_lexize('syn','indices');\n"
" ts_lexize\n"
"-----------\n"
" {index}\n"
"(1 row)\n"
"\n"
"mydb=# CREATE TEXT SEARCH CONFIGURATION tst (copy=simple);\n"
"mydb=# ALTER TEXT SEARCH CONFIGURATION tst ALTER MAPPING FOR asciiword WITH "
"syn;\n"
"mydb=# SELECT to_tsvector('tst','indices');\n"
" to_tsvector\n"
"-------------\n"
" 'index':1\n"
"(1 row)\n"
"\n"
"mydb=# SELECT to_tsquery('tst','indices');\n"
" to_tsquery\n"
"------------\n"
" 'index':*\n"
"(1 row)\n"
"\n"
"mydb=# SELECT 'indexes are very useful'::tsvector;\n"
"            tsvector             \n"
"---------------------------------\n"
" 'are' 'indexes' 'useful' 'very'\n"
"(1 row)\n"
"\n"
"mydb=# SELECT 'indexes are very useful'::tsvector @@ "
"to_tsquery('tst','indices');\n"
" ?column?\n"
"----------\n"
" t\n"
"(1 row)\n"
"</screen>"
msgstr ""
"В конце синонима в этом файле можно добавить звёздочку (<literal>*</"
"literal>), тогда этот синоним будет рассматриваться как префикс. Эта "
"звёздочка будет игнорироваться в <function>to_tsvector()</function>, но "
"<function>to_tsquery()</function> изменит результат, добавив в него маркер "
"сопоставления префикса (см. <xref remap=\"4\" linkend=\"textsearch-parsing-"
"queries\"/>). Например, предположим, что файл <filename>$SHAREDIR/"
"tsearch_data/synonym_sample.syn</filename> имеет следующее содержание: "
"<placeholder-1/> С ним мы получим такие результаты: <screen>\n"
"mydb=# CREATE TEXT SEARCH DICTIONARY\n"
"  syn (template=synonym, synonyms='synonym_sample');\n"
"mydb=# SELECT ts_lexize('syn','indices');\n"
" ts_lexize\n"
"-----------\n"
" {index}\n"
"(1 row)\n"
"\n"
"mydb=# CREATE TEXT SEARCH CONFIGURATION tst (copy=simple);\n"
"mydb=# ALTER TEXT SEARCH CONFIGURATION tst ALTER MAPPING FOR asciiword\n"
"  WITH syn;\n"
"mydb=# SELECT to_tsvector('tst','indices');\n"
" to_tsvector\n"
"-------------\n"
" 'index':1\n"
"(1 row)\n"
"\n"
"mydb=# SELECT to_tsquery('tst','indices');\n"
" to_tsquery\n"
"------------\n"
" 'index':*\n"
"(1 row)\n"
"\n"
"mydb=# SELECT 'indexes are very useful'::tsvector;\n"
"            tsvector             \n"
"---------------------------------\n"
" 'are' 'indexes' 'useful' 'very'\n"
"(1 row)\n"
"\n"
"mydb=# SELECT 'indexes are very useful'::tsvector @@\n"
"  to_tsquery('tst','indices');\n"
" ?column?\n"
"----------\n"
" t\n"
"(1 row)\n"
"</screen>"

#: textsearch.xml:2552(title)
msgid "Thesaurus Dictionary"
msgstr "Тезаурус"

#: textsearch.xml:2554(para)
msgid ""
"A thesaurus dictionary (sometimes abbreviated as <acronym>TZ</acronym>) is a "
"collection of words that includes information about the relationships of "
"words and phrases, i.e., broader terms (<acronym>BT</acronym>), narrower "
"terms (<acronym>NT</acronym>), preferred terms, non-preferred terms, related "
"terms, etc."
msgstr ""
"Тезаурус (или сокращённо <acronym>TZ</acronym>) содержит набор слов и "
"информацию о связях слов и словосочетаний, то есть более широкие понятия "
"(Broader Terms, <acronym>BT</acronym>), более узкие понятия (Narrow Terms, "
"<acronym>NT</acronym>), предпочитаемые названия, исключаемые названия, "
"связанные понятия и т. д."

#: textsearch.xml:2570(programlisting)
#, no-wrap
msgid ""
"# this is a comment\n"
"sample word(s) : indexed word(s)\n"
"more sample word(s) : more indexed word(s)\n"
"..."
msgstr ""
"# это комментарий\n"
"образец слов(а) : индексируемые слова\n"
"другой образец слов(а) : другие индексируемые слова\n"
"..."

#: textsearch.xml:2562(para)
msgid ""
"Basically a thesaurus dictionary replaces all non-preferred terms by one "
"preferred term and, optionally, preserves the original terms for indexing as "
"well. <productname>PostgreSQL</productname>'s current implementation of the "
"thesaurus dictionary is an extension of the synonym dictionary with added "
"<firstterm>phrase</firstterm> support. A thesaurus dictionary requires a "
"configuration file of the following format: <placeholder-1/> where the colon "
"(<symbol>:</symbol>) symbol acts as a delimiter between a phrase and its "
"replacement."
msgstr ""
"В основном тезаурус заменяет исключаемые слова и словосочетания "
"предпочитаемыми и может также сохранить исходные слова для индексации. "
"Текущая реализация тезауруса в <productname>PostgreSQL</productname> "
"представляет собой расширение словаря синонимов с поддержкой "
"<firstterm>фраз</firstterm>. Конфигурация тезауруса определяется файлом "
"следующего формата: <placeholder-1/> Здесь двоеточие (<symbol>:</symbol>) "
"служит разделителем между исходной фразой и её заменой."

#: textsearch.xml:2581(para)
msgid ""
"A thesaurus dictionary uses a <firstterm>subdictionary</firstterm> (which is "
"specified in the dictionary's configuration) to normalize the input text "
"before checking for phrase matches. It is only possible to select one "
"subdictionary. An error is reported if the subdictionary fails to recognize "
"a word. In that case, you should remove the use of the word or teach the "
"subdictionary about it. You can place an asterisk (<symbol>*</symbol>) at "
"the beginning of an indexed word to skip applying the subdictionary to it, "
"but all sample words <emphasis>must</emphasis> be known to the subdictionary."
msgstr ""
"Прежде чем проверять соответствие фраз, тезаурус нормализует файл "
"конфигурации, используя <firstterm>внутренний словарь</firstterm> (который "
"указывается в конфигурации словаря-тезауруса). Этот внутренний словарь для "
"тезауруса может быть только одним. Если он не сможет распознать какое-либо "
"слово, произойдёт ошибка. В этом случае необходимо либо исключить это слово, "
"либо добавить его во внутренний словарь. Также можно добавить звёздочку "
"(<symbol>*</symbol>) перед индексируемыми словами, чтобы они не проверялись "
"по внутреннему словарю, но все слова-образцы <emphasis>должны</emphasis> "
"быть известны внутреннему словарю."

#: textsearch.xml:2593(para)
msgid ""
"The thesaurus dictionary chooses the longest match if there are multiple "
"phrases matching the input, and ties are broken by using the last definition."
msgstr ""
"Если входному фрагменту соответствуют несколько фраз в этом списке, тезаурус "
"выберет самое длинное определение, а если таких окажется несколько, самое "
"последнее из них."

#: textsearch.xml:2605(programlisting)
#, no-wrap
msgid "? one ? two : swsw"
msgstr "? one ? two : swsw"

#: textsearch.xml:2599(para)
msgid ""
"Specific stop words recognized by the subdictionary cannot be specified; "
"instead use <literal>?</literal> to mark the location where any stop word "
"can appear. For example, assuming that <literal>a</literal> and "
"<literal>the</literal> are stop words according to the subdictionary: "
"<placeholder-1/> matches <literal>a one the two</literal> and <literal>the "
"one a two</literal>; both would be replaced by <literal>swsw</literal>."
msgstr ""
"Выделить во фразе какие-то стоп-слова нельзя; вместо этого можно вставить "
"<literal>?</literal> в том месте, где может оказаться стоп-слово. Например, "
"в предположении, что <literal>a</literal> и <literal>the</literal> &mdash; "
"стоп-слова по внутреннему словарю: <placeholder-1/> соответствует входным "
"строкам <literal>a one the two</literal> и <literal>the one a two</literal>, "
"так что обе эти строки будут заменены на <literal>swsw</literal>."

#: textsearch.xml:2613(para)
msgid ""
"Since a thesaurus dictionary has the capability to recognize phrases it must "
"remember its state and interact with the parser. A thesaurus dictionary uses "
"these assignments to check if it should handle the next word or stop "
"accumulation. The thesaurus dictionary must be configured carefully. For "
"example, if the thesaurus dictionary is assigned to handle only the "
"<literal>asciiword</literal> token, then a thesaurus dictionary definition "
"like <literal>one 7</literal> will not work since token type <literal>uint</"
"literal> is not assigned to the thesaurus dictionary."
msgstr ""
"Как и обычный словарь, тезаурус должен привязываться к лексемам определённых "
"типов. Так как тезаурус может распознавать фразы, он должен запоминать своё "
"состояние и взаимодействовать с анализатором. Учитывая свои привязки, он "
"может либо обрабатывать следующий фрагмент, либо прекратить накопление "
"фразы. Поэтому настройка тезаурусов в системе требует особого внимания. "
"Например, если привязать тезаурус только к типу фрагментов "
"<literal>asciiword</literal>, тогда определение в тезаурусе <literal>one 7</"
"literal> не будет работать, так как этот тезаурус не связан с типом "
"<literal>uint</literal>."

#: textsearch.xml:2625(para)
msgid ""
"Thesauruses are used during indexing so any change in the thesaurus "
"dictionary's parameters <emphasis>requires</emphasis> reindexing. For most "
"other dictionary types, small changes such as adding or removing stopwords "
"does not force reindexing."
msgstr ""
"Тезаурусы используются при индексации, поэтому при любом изменении "
"параметров или содержимого тезауруса <emphasis>необходима</emphasis> "
"переиндексация. Для большинства других типов словарей при небольших "
"изменениях, таких как удаление и добавление стоп-слов, переиндексация не "
"требуется."

#: textsearch.xml:2634(title)
msgid "Thesaurus Configuration"
msgstr "Конфигурация тезауруса"

#: textsearch.xml:2640(programlisting)
#, no-wrap
msgid ""
"CREATE TEXT SEARCH DICTIONARY thesaurus_simple (\n"
"    TEMPLATE = thesaurus,\n"
"    DictFile = mythesaurus,\n"
"    Dictionary = pg_catalog.english_stem\n"
");"
msgstr ""
"CREATE TEXT SEARCH DICTIONARY thesaurus_simple (\n"
"    TEMPLATE = thesaurus,\n"
"    DictFile = mythesaurus,\n"
"    Dictionary = pg_catalog.english_stem\n"
");"

#: textsearch.xml:2651(para)
msgid "<literal>thesaurus_simple</literal> is the new dictionary's name"
msgstr "<literal>thesaurus_simple</literal> &mdash; имя нового словаря"

#: textsearch.xml:2656(para)
msgid ""
"<literal>mythesaurus</literal> is the base name of the thesaurus "
"configuration file. (Its full name will be <filename>$SHAREDIR/tsearch_data/"
"mythesaurus.ths</filename>, where <literal>$SHAREDIR</literal> means the "
"installation shared-data directory.)"
msgstr ""
"<literal>mythesaurus</literal> &mdash; базовое имя файла конфигурации "
"тезауруса. (Полным путём к файлу будет <filename>$SHAREDIR/tsearch_data/"
"mythesaurus.ths</filename>, где <literal>$SHAREDIR</literal> указывает на "
"каталог общих данных <productname>PostgreSQL</productname>.)"

#: textsearch.xml:2665(para)
msgid ""
"<literal>pg_catalog.english_stem</literal> is the subdictionary (here, a "
"Snowball English stemmer) to use for thesaurus normalization. Notice that "
"the subdictionary will have its own configuration (for example, stop words), "
"which is not shown here."
msgstr ""
"<literal>pg_catalog.english_stem</literal> &mdash; внутренний словарь (в "
"данном случае, это стеммер Snowball для английского) для нормализации "
"тезауруса. Заметьте, что внутренний словарь имеет собственную конфигурацию "
"(например, список стоп-слов), но здесь она не рассматривается."

#: textsearch.xml:2677(programlisting)
#, no-wrap
msgid ""
"ALTER TEXT SEARCH CONFIGURATION russian\n"
"    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart\n"
"    WITH thesaurus_simple;"
msgstr ""
"ALTER TEXT SEARCH CONFIGURATION english\n"
"    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart\n"
"    WITH thesaurus_simple;"

#: textsearch.xml:2636(para)
msgid ""
"To define a new thesaurus dictionary, use the <literal>thesaurus</literal> "
"template. For example: <placeholder-1/> Here: <placeholder-2/> Now it is "
"possible to bind the thesaurus dictionary <literal>thesaurus_simple</"
"literal> to the desired token types in a configuration, for example: "
"<placeholder-3/>"
msgstr ""
"Для создания нового словаря-тезауруса используется шаблон "
"<literal>thesaurus</literal>. Например: <placeholder-1/> Здесь: "
"<placeholder-2/> Теперь тезаурус <literal>thesaurus_simple</literal> можно "
"связать с желаемыми типами фрагментов в конфигурации, например так: "
"<placeholder-3/>"

#: textsearch.xml:2687(title)
msgid "Thesaurus Example"
msgstr "Пример тезауруса"

#: textsearch.xml:2693(programlisting)
#, no-wrap
msgid ""
"supernovae stars : sn\n"
"crab nebulae : crab"
msgstr ""
"supernovae stars : sn\n"
"crab nebulae : crab"

#: textsearch.xml:2701(programlisting)
#, no-wrap
msgid ""
"CREATE TEXT SEARCH DICTIONARY thesaurus_astro (\n"
"    TEMPLATE = thesaurus,\n"
"    DictFile = thesaurus_astro,\n"
"    Dictionary = english_stem\n"
");\n"
"\n"
"ALTER TEXT SEARCH CONFIGURATION russian\n"
"    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart\n"
"    WITH thesaurus_astro, english_stem;"
msgstr ""
"CREATE TEXT SEARCH DICTIONARY thesaurus_astro (\n"
"    TEMPLATE = thesaurus,\n"
"    DictFile = thesaurus_astro,\n"
"    Dictionary = english_stem\n"
");\n"
"\n"
"ALTER TEXT SEARCH CONFIGURATION russian\n"
"    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart\n"
"    WITH thesaurus_astro, english_stem;"

#: textsearch.xml:2689(para)
msgid ""
"Consider a simple astronomical thesaurus <literal>thesaurus_astro</literal>, "
"which contains some astronomical word combinations: <placeholder-1/> Below "
"we create a dictionary and bind some token types to an astronomical "
"thesaurus and English stemmer: <placeholder-2/> Now we can see how it works. "
"<function>ts_lexize</function> is not very useful for testing a thesaurus, "
"because it treats its input as a single token. Instead we can use "
"<function>plainto_tsquery</function> and <function>to_tsvector</function> "
"which will break their input strings into multiple tokens: <screen>\n"
"SELECT plainto_tsquery('supernova star');\n"
" plainto_tsquery\n"
"-----------------\n"
" 'sn'\n"
"\n"
"SELECT to_tsvector('supernova star');\n"
" to_tsvector\n"
"-------------\n"
" 'sn':1\n"
"</screen> In principle, one can use <function>to_tsquery</function> if you "
"quote the argument: <screen>\n"
"SELECT to_tsquery('''supernova star''');\n"
" to_tsquery\n"
"------------\n"
" 'sn'\n"
"</screen> Notice that <literal>supernova star</literal> matches "
"<literal>supernovae stars</literal> in <literal>thesaurus_astro</literal> "
"because we specified the <literal>english_stem</literal> stemmer in the "
"thesaurus definition. The stemmer removed the <literal>e</literal> and "
"<literal>s</literal>."
msgstr ""
"Давайте рассмотрим простой астрономический тезаурус "
"<literal>thesaurus_astro</literal>, содержащий несколько астрономических "
"терминов: <placeholder-1/> Ниже мы создадим словарь и привяжем некоторые "
"типы фрагментов к астрономическому тезаурусу и английскому стеммеру: "
"<placeholder-2/> Теперь можно проверить, как он работает. Функция "
"<function>ts_lexize</function> не очень полезна для проверки тезауруса, так "
"как она обрабатывает входную строку как один фрагмент. Вместо неё мы можем "
"использовать функции <function>plainto_tsquery</function> и "
"<function>to_tsvector</function>, которые разбивают входную строку на "
"несколько фрагментов: <screen>\n"
"SELECT plainto_tsquery('supernova star');\n"
" plainto_tsquery\n"
"-----------------\n"
" 'sn'\n"
"\n"
"SELECT to_tsvector('supernova star');\n"
" to_tsvector\n"
"-------------\n"
" 'sn':1\n"
"</screen> В принципе так же можно использовать <function>to_tsquery</"
"function>, если заключить аргумент в кавычки: <screen>\n"
"SELECT to_tsquery(' ''supernova star''');\n"
" to_tsquery\n"
"------------\n"
" 'sn'\n"
"</screen> Заметьте, что <literal>supernova star</literal> совпадает с "
"<literal>supernovae stars</literal> в <literal>thesaurus_astro</literal>, "
"так как мы подключили стеммер <literal>english_stem</literal> в определении "
"тезауруса. Этот стеммер удалил конечные буквы <literal>e</literal> и "
"<literal>s</literal>."

#: textsearch.xml:2747(para)
msgid ""
"To index the original phrase as well as the substitute, just include it in "
"the right-hand part of the definition: <screen>\n"
"supernovae stars : sn supernovae stars\n"
"\n"
"SELECT plainto_tsquery('supernova star');\n"
"       plainto_tsquery\n"
"-----------------------------\n"
" 'sn' &amp; 'supernova' &amp; 'star'\n"
"</screen>"
msgstr ""
"Чтобы проиндексировать исходную фразу вместе с заменой, её нужно просто "
"добавить в правую часть соответствующего определения: <screen>\n"
"supernovae stars : sn supernovae stars\n"
"\n"
"SELECT plainto_tsquery('supernova star');\n"
"       plainto_tsquery\n"
"-----------------------------\n"
" 'sn' &amp; 'supernova' &amp; 'star'\n"
"</screen>"

#: textsearch.xml:2766(title)
msgid "<application>Ispell</application> Dictionary"
msgstr "Словарь <application>Ispell</application>"

#: textsearch.xml:2768(para)
msgid ""
"The <application>Ispell</application> dictionary template supports "
"<firstterm>morphological dictionaries</firstterm>, which can normalize many "
"different linguistic forms of a word into the same lexeme. For example, an "
"English <application>Ispell</application> dictionary can match all "
"declensions and conjugations of the search term <literal>bank</literal>, e."
"g., <literal>banking</literal>, <literal>banked</literal>, <literal>banks</"
"literal>, <literal>banks'</literal>, and <literal>bank's</literal>."
msgstr ""
"Шаблон словарей <application>Ispell</application> поддерживает "
"<firstterm>морфологические словари</firstterm>, которые могут сводить "
"множество разных лингвистических форм слова к одной лексеме. Например, "
"английский словарь <application>Ispell</application> может связать вместе "
"все склонения и спряжения ключевого слова <literal>bank</literal>: "
"<literal>banking</literal>, <literal>banked</literal>, <literal>banks</"
"literal>, <literal>banks'</literal>,<literal>bank's</literal> и т. п."

#: textsearch.xml:2778(para)
msgid ""
"The standard <productname>PostgreSQL</productname> distribution does not "
"include any <application>Ispell</application> configuration files. "
"Dictionaries for a large number of languages are available from <ulink url="
"\"http://ficus-www.cs.ucla.edu/geoff/ispell.html\">Ispell</ulink>. Also, "
"some more modern dictionary file formats are supported &mdash; <ulink url="
"\"http://en.wikipedia.org/wiki/MySpell\">MySpell</ulink> (OO &lt; 2.0.1) and "
"<ulink url=\"http://sourceforge.net/projects/hunspell/\">Hunspell</ulink> "
"(OO &gt;= 2.0.2). A large list of dictionaries is available on the <ulink "
"url=\"http://wiki.services.openoffice.org/wiki/Dictionaries\">OpenOffice "
"Wiki</ulink>."
msgstr ""
"Стандартный дистрибутив <productname>PostgreSQL</productname> не включает "
"файлы конфигурации <application>Ispell</application>. Загрузить словари для "
"множества языков можно со страницы <ulink url=\"http://ficus-www.cs.ucla.edu/"
"geoff/ispell.html\">Ispell</ulink>. Кроме того, поддерживаются и другие "
"современные форматы словарей: <ulink url=\"http://en.wikipedia.org/wiki/"
"MySpell\">MySpell</ulink> (OO &lt; 2.0.1) и <ulink url=\"http://sourceforge."
"net/projects/hunspell/\">Hunspell</ulink> (OO &gt;= 2.0.2). Большой набор "
"соответствующих словарей можно найти на странице <ulink url=\"http://wiki."
"services.openoffice.org/wiki/Dictionaries\">OpenOffice Wiki</ulink>."

#: textsearch.xml:2791(para)
msgid ""
"To create an <application>Ispell</application> dictionary perform these "
"steps:"
msgstr ""
"Чтобы создать словарь <application>Ispell</application>, выполните следующие "
"действия:"

#: textsearch.xml:2803(programlisting)
#, no-wrap
msgid ""
"iconv -f ISO_8859-1 -t UTF-8 -o nn_no.affix nn_NO.aff\n"
"iconv -f ISO_8859-1 -t UTF-8 -o nn_no.dict nn_NO.dic"
msgstr ""
"iconv -f ISO_8859-1 -t UTF-8 -o nn_no.affix nn_NO.aff\n"
"iconv -f ISO_8859-1 -t UTF-8 -o nn_no.dict nn_NO.dic"

#: textsearch.xml:2796(para)
msgid ""
"download dictionary configuration files. <productname>OpenOffice</"
"productname> extension files have the <filename>.oxt</filename> extension. "
"It is necessary to extract <filename>.aff</filename> and <filename>.dic</"
"filename> files, change extensions to <filename>.affix</filename> and "
"<filename>.dict</filename>. For some dictionary files it is also needed to "
"convert characters to the UTF-8 encoding with commands (for example, for a "
"Norwegian language dictionary): <placeholder-1/>"
msgstr ""
"загрузите файлы конфигурации словаря. Пакет с дополнительным словарём "
"<productname>OpenOffice</productname> имеет расширение <filename>.oxt</"
"filename>. Из него необходимо извлечь файлы <filename>.aff</filename> и "
"<filename>.dic</filename>, и сменить их расширения на <filename>.affix</"
"filename> и <filename>.dict</filename>, соответственно. Для некоторых файлов "
"словарей также необходимо преобразовать символы в кодировку UTF-8 с помощью, "
"например, таких команд (для норвежского языка): <placeholder-1/>"

#: textsearch.xml:2810(para)
msgid "copy files to the <filename>$SHAREDIR/tsearch_data</filename> directory"
msgstr "скопируйте файлы в каталог <filename>$SHAREDIR/tsearch_data</filename>"

#: textsearch.xml:2817(programlisting)
#, no-wrap
msgid ""
"CREATE TEXT SEARCH DICTIONARY english_hunspell (\n"
"    TEMPLATE = ispell,\n"
"    DictFile = en_us,\n"
"    AffFile = en_us,\n"
"    Stopwords = english);"
msgstr ""
"CREATE TEXT SEARCH DICTIONARY english_hunspell (\n"
"    TEMPLATE = ispell,\n"
"    DictFile = en_us,\n"
"    AffFile = en_us,\n"
"    Stopwords = english);"

#: textsearch.xml:2815(para)
msgid "load files into PostgreSQL with the following command: <placeholder-1/>"
msgstr "загрузите эти файлы в PostgreSQL следующей командой: <placeholder-1/>"

#: textsearch.xml:2828(para)
msgid ""
"Here, <literal>DictFile</literal>, <literal>AffFile</literal>, and "
"<literal>StopWords</literal> specify the base names of the dictionary, "
"affixes, and stop-words files. The stop-words file has the same format "
"explained above for the <literal>simple</literal> dictionary type. The "
"format of the other files is not specified here but is available from the "
"above-mentioned web sites."
msgstr ""
"Здесь параметры <literal>DictFile</literal>, <literal>AffFile</literal> и "
"<literal>StopWords</literal> определяют базовые имена файлов словаря, "
"аффиксов и стоп-слов. Файл стоп-слов должен иметь тот же формат, что "
"рассматривался выше в описании словаря <literal>simple</literal>. Формат "
"других файлов здесь не рассматривается, но его можно узнать по вышеуказанным "
"веб-адресам."

#: textsearch.xml:2836(para)
msgid ""
"Ispell dictionaries usually recognize a limited set of words, so they should "
"be followed by another broader dictionary; for example, a Snowball "
"dictionary, which recognizes everything."
msgstr ""
"Словари Ispell обычно воспринимают ограниченный набор слов, так что за ними "
"следует подключить другой, более общий словарь, например, Snowball, который "
"принимает всё."

#: textsearch.xml:2845(programlisting)
#, no-wrap
msgid ""
"prefixes\n"
"flag *A:\n"
"    .           &gt;   RE      # As in enter &gt; reenter\n"
"suffixes\n"
"flag T:\n"
"    E           &gt;   ST      # As in late &gt; latest\n"
"    [^AEIOU]Y   &gt;   -Y,IEST # As in dirty &gt; dirtiest\n"
"    [AEIOU]Y    &gt;   EST     # As in gray &gt; grayest\n"
"    [^EY]       &gt;   EST     # As in small &gt; smallest"
msgstr ""
"prefixes\n"
"flag *A:\n"
"    .           &gt;   RE      # As in enter &gt; reenter\n"
"suffixes\n"
"flag T:\n"
"    E           &gt;   ST      # As in late &gt; latest\n"
"    [^AEIOU]Y   &gt;   -Y,IEST # As in dirty &gt; dirtiest\n"
"    [AEIOU]Y    &gt;   EST     # As in gray &gt; grayest\n"
"    [^EY]       &gt;   EST     # As in small &gt; smallest"

#: textsearch.xml:2842(para)
msgid ""
"The <filename>.affix</filename> file of <application>Ispell</application> "
"has the following structure: <placeholder-1/>"
msgstr ""
"Файл <filename>.affix</filename> для <application>Ispell</application> имеет "
"такую структуру: <placeholder-1/>"

#: textsearch.xml:2859(programlisting)
#, no-wrap
msgid ""
"lapse/ADGRS\n"
"lard/DGRS\n"
"large/PRTY\n"
"lark/MRS"
msgstr ""
"lapse/ADGRS\n"
"lard/DGRS\n"
"large/PRTY\n"
"lark/MRS"

#: textsearch.xml:2857(para)
msgid ""
"And the <filename>.dict</filename> file has the following structure: "
"<placeholder-1/>"
msgstr "А файл <filename>.dict</filename> — такую: <placeholder-1/>"

#: textsearch.xml:2869(programlisting)
#, no-wrap
msgid "basic_form/affix_class_name"
msgstr "basic_form/affix_class_name"

#: textsearch.xml:2867(para)
msgid "Format of the <filename>.dict</filename> file is: <placeholder-1/>"
msgstr "Формат файла <filename>.dict</filename> следующий: <placeholder-1/>"

#: textsearch.xml:2877(programlisting)
#, no-wrap
msgid "condition &gt; [-stripping_letters,] adding_affix"
msgstr "условие &gt; [-отсекаемые_буквы,] добавляемый_аффикс"

#: textsearch.xml:2874(para)
msgid ""
"In the <filename>.affix</filename> file every affix flag is described in the "
"following format: <placeholder-1/>"
msgstr ""
"В файле <filename>.affix</filename> каждый флаг аффиксов описывается в "
"следующем формате: <placeholder-1/>"

#: textsearch.xml:2882(para)
msgid ""
"Here, condition has a format similar to the format of regular expressions. "
"It can use groupings <literal>[...]</literal> and <literal>[^...]</literal>. "
"For example, <literal>[AEIOU]Y</literal> means that the last letter of the "
"word is <literal>\"y\"</literal> and the penultimate letter is <literal>\"a"
"\"</literal>, <literal>\"e\"</literal>, <literal>\"i\"</literal>, <literal>"
"\"o\"</literal> or <literal>\"u\"</literal>. <literal>[^EY]</literal> means "
"that the last letter is neither <literal>\"e\"</literal> nor <literal>\"y\"</"
"literal>."
msgstr ""
"Здесь условие записывается в формате, подобном формату регулярных выражений. "
"В нём возможно описать группы <literal>[...]</literal> и <literal>[^...]</"
"literal>. Например, запись <literal>[AEIOU]Y</literal> означает, что "
"последняя буква слова — <literal>\"y\"</literal>, а предпоследней может быть "
"<literal>\"a\"</literal>, <literal>\"e\"</literal>, <literal>\"i\"</"
"literal>, <literal>\"o\"</literal> или <literal>\"u\"</literal>. Запись "
"<literal>[^EY]</literal> означает, что последняя буква не <literal>\"e\"</"
"literal> и не <literal>\"y\"</literal>."

#: textsearch.xml:2899(programlisting)
#, no-wrap
msgid "compoundwords  controlled z"
msgstr "compoundwords  controlled z"

#: textsearch.xml:2905(programlisting)
#, no-wrap
msgid ""
"SELECT ts_lexize('norwegian_ispell', 'overbuljongterningpakkmesterassistent');\n"
"   {over,buljong,terning,pakk,mester,assistent}\n"
"SELECT ts_lexize('norwegian_ispell', 'sjokoladefabrikk');\n"
"   {sjokoladefabrikk,sjokolade,fabrikk}"
msgstr ""
"SELECT ts_lexize('norwegian_ispell',\n"
"  'overbuljongterningpakkmesterassistent');\n"
"   {over,buljong,terning,pakk,mester,assistent}\n"
"SELECT ts_lexize('norwegian_ispell', 'sjokoladefabrikk');\n"
"   {sjokoladefabrikk,sjokolade,fabrikk}"

#: textsearch.xml:2892(para)
msgid ""
"Ispell dictionaries support splitting compound words; a useful feature. "
"Notice that the affix file should specify a special flag using the "
"<literal>compoundwords controlled</literal> statement that marks dictionary "
"words that can participate in compound formation: <placeholder-1/> Here are "
"some examples for the Norwegian language: <placeholder-2/>"
msgstr ""
"Словари Ispell поддерживают разделение составных слов, что бывает полезно. "
"Заметьте, что для этого в файле аффиксов нужно пометить специальным "
"оператором <literal>compoundwords controlled</literal> слова, которые могут "
"участвовать в составных образованиях: <placeholder-1/> Вот как это работает "
"для норвежского языка: <placeholder-2/>"

#: textsearch.xml:2917(programlisting)
#, no-wrap
msgid ""
"PFX A Y 1\n"
"PFX A   0     re         .\n"
"SFX T N 4\n"
"SFX T   0     st         e\n"
"SFX T   y     iest       [^aeiou]y\n"
"SFX T   0     est        [aeiou]y\n"
"SFX T   0     est        [^ey]"
msgstr ""
"PFX A Y 1\n"
"PFX A   0     re         .\n"
"SFX T N 4\n"
"SFX T   0     st         e\n"
"SFX T   y     iest       [^aeiou]y\n"
"SFX T   0     est        [aeiou]y\n"
"SFX T   0     est        [^ey]"

#: textsearch.xml:2913(para)
msgid ""
"<application>MySpell</application> format is a subset of "
"<application>Hunspell</application>. The <filename>.affix</filename> file of "
"<application>Hunspell</application> has the following structure: "
"<placeholder-1/>"
msgstr ""
"Формат <application>MySpell</application> представляет собой подмножество "
"формата <application>Hunspell</application>. Файл <filename>.affix</"
"filename> словаря <application>Hunspell</application> имеет следующую "
"структуру: <placeholder-1/>"

#: textsearch.xml:2928(para)
msgid ""
"The first line of an affix class is the header. Fields of an affix rules are "
"listed after the header:"
msgstr ""
"Первая строка класса аффиксов &mdash; заголовок. Поля правил аффиксов "
"указываются после заголовка:"

#: textsearch.xml:2934(para)
msgid "parameter name (PFX or SFX)"
msgstr "имя параметра (PFX или SFX)"

#: textsearch.xml:2939(para)
msgid "flag (name of the affix class)"
msgstr "флаг (имя класса аффиксов)"

#: textsearch.xml:2944(para)
msgid ""
"stripping characters from beginning (at prefix) or end (at suffix) of the "
"word"
msgstr ""
"отсекаемые символы в начале (в префиксе) или в конце (в суффиксе) слова"

#: textsearch.xml:2950(para)
msgid "adding affix"
msgstr "добавляемый аффикс"

#: textsearch.xml:2955(para)
msgid ""
"condition that has a format similar to the format of regular expressions."
msgstr "условие в формате, подобном регулярным выражениям."

#: textsearch.xml:2964(programlisting)
#, no-wrap
msgid ""
"larder/M\n"
"lardy/RT\n"
"large/RSPMYT\n"
"largehearted"
msgstr ""
"larder/M\n"
"lardy/RT\n"
"large/RSPMYT\n"
"largehearted"

#: textsearch.xml:2961(para)
msgid ""
"The <filename>.dict</filename> file looks like the <filename>.dict</"
"filename> file of <application>Ispell</application>: <placeholder-1/>"
msgstr ""
"Файл <filename>.dict</filename> подобен файлу <filename>.dict</filename> "
"словаря <application>Ispell</application>: <placeholder-1/>"

#: textsearch.xml:2973(para)
msgid ""
"<application>MySpell</application> does not support compound words. "
"<application>Hunspell</application> has sophisticated support for compound "
"words. At present, <productname>PostgreSQL</productname> implements only the "
"basic compound word operations of Hunspell."
msgstr ""
"Словарь <application>MySpell</application> не поддерживает составные слова. "
"С другой стороны, <application>Hunspell</application> поддерживает множество "
"операции с ними, но в настоящее время <productname>PostgreSQL</productname> "
"использует только самые простые из этого множества."

#: textsearch.xml:2984(title)
msgid "<application>Snowball</application> Dictionary"
msgstr "Словарь <application>Snowball</application>"

#: textsearch.xml:3000(programlisting)
#, no-wrap
msgid ""
"CREATE TEXT SEARCH DICTIONARY english_stem (\n"
"    TEMPLATE = snowball,\n"
"    Language = english,\n"
"    StopWords = english\n"
");"
msgstr ""
"CREATE TEXT SEARCH DICTIONARY english_stem (\n"
"    TEMPLATE = snowball,\n"
"    Language = english,\n"
"    StopWords = english\n"
");"

#: textsearch.xml:2986(para)
msgid ""
"The <application>Snowball</application> dictionary template is based on a "
"project by Martin Porter, inventor of the popular Porter's stemming "
"algorithm for the English language. Snowball now provides stemming "
"algorithms for many languages (see the <ulink url=\"http://snowballstem.org/"
"\">Snowball site</ulink> for more information). Each algorithm understands "
"how to reduce common variant forms of words to a base, or stem, spelling "
"within its language. A Snowball dictionary requires a <literal>language</"
"literal> parameter to identify which stemmer to use, and optionally can "
"specify a <literal>stopword</literal> file name that gives a list of words "
"to eliminate. (<productname>PostgreSQL</productname>'s standard stopword "
"lists are also provided by the Snowball project.) For example, there is a "
"built-in definition equivalent to <placeholder-1/> The stopword file format "
"is the same as already explained."
msgstr ""
"Шаблон словарей <application>Snowball</application> основан на проекте "
"Мартина Потера, изобретателя популярного алгоритма стемминга для английского "
"языка. Сейчас Snowball предлагает алгоритмы и для многих других языков (за "
"подробностями обратитесь на <ulink url=\"http://snowballstem.org\">сайт "
"Snowball</ulink>). Каждый алгоритм знает, как для данного языка свести "
"распространённые словоформы к начальной форме. Для словаря Snowball задаётся "
"обязательный параметр <literal>language</literal>, определяющий, какой "
"именно стеммер использовать, и может задаваться параметр <literal>stopword</"
"literal>, указывающий файл со списком исключаемых слов. (Стандартные списки "
"стоп-слов <productname>PostgreSQL</productname> используется также в и "
"проекте Snowball.) Например, встроенное определение выглядит так "
"<placeholder-1/> Формат файла стоп-слов не отличается от рассмотренного "
"ранее."

#: textsearch.xml:3011(para)
msgid ""
"A <application>Snowball</application> dictionary recognizes everything, "
"whether or not it is able to simplify the word, so it should be placed at "
"the end of the dictionary list. It is useless to have it before any other "
"dictionary because a token will never pass through it to the next dictionary."
msgstr ""
"Словарь <application>Snowball</application> распознаёт любые фрагменты, даже "
"если он не может упростить слова, так что он должен быть самым последним в "
"списке словарей. Помещать его перед другими словарями нет смысла, так как "
"после него никакой фрагмент не будет передан следующему словарю."

#: textsearch.xml:3024(title)
msgid "Configuration Example"
msgstr "Пример конфигурации"

#: textsearch.xml:3026(para)
msgid ""
"A text search configuration specifies all options necessary to transform a "
"document into a <type>tsvector</type>: the parser to use to break text into "
"tokens, and the dictionaries to use to transform each token into a lexeme. "
"Every call of <function>to_tsvector</function> or <function>to_tsquery</"
"function> needs a text search configuration to perform its processing. The "
"configuration parameter <xref linkend=\"guc-default-text-search-config\"/> "
"specifies the name of the default configuration, which is the one used by "
"text search functions if an explicit configuration parameter is omitted. It "
"can be set in <filename>postgresql.conf</filename>, or set for an individual "
"session using the <command>SET</command> command."
msgstr ""
"Конфигурация текстового поиска определяет всё, что необходимо для "
"преобразования документа в формат <type>tsvector</type>: анализатор, который "
"будет разбивать текст на фрагменты, и словари, которые будут преобразовывать "
"фрагменты в лексемы. При каждом вызове <function>to_tsvector</function> или "
"<function>to_tsquery</function> обязательно используется конфигурация "
"текстового поиска. В конфигурации сервера есть параметр <xref linkend=\"guc-"
"default-text-search-config\"/>, задающий имя конфигурации текстового поиска "
"по умолчанию, которая будет использоваться, когда при вызове функций поиска "
"соответствующий аргумент не определён. Этот параметр можно задать в "
"<filename>postgresql.conf</filename> или установить в рамках отдельного "
"сеанса с помощью команды <command>SET</command>."

#: textsearch.xml:3042(para)
msgid ""
"Several predefined text search configurations are available, and you can "
"create custom configurations easily. To facilitate management of text search "
"objects, a set of <acronym>SQL</acronym> commands is available, and there "
"are several <application>psql</application> commands that display "
"information about text search objects (<xref linkend=\"textsearch-psql\"/>)."
msgstr ""
"В системе есть несколько встроенных конфигураций текстового поиска и вы "
"можете легко дополнить их своими. Для удобства управления объектами "
"текстового поиска в <productname>PostgreSQL</productname> реализованы "
"соответствующие <acronym>SQL</acronym>-команды и специальные команды в "
"<application>psql</application>, выводящие информацию об этих объектах "
"(<xref linkend=\"textsearch-psql\"/>)."

#: textsearch.xml:3055(programlisting)
#, no-wrap
msgid "CREATE TEXT SEARCH CONFIGURATION public.pg ( COPY = pg_catalog.english );"
msgstr "CREATE TEXT SEARCH CONFIGURATION public.pg ( COPY = pg_catalog.english );"

#: textsearch.xml:3050(para)
msgid ""
"As an example we will create a configuration <literal>pg</literal>, starting "
"by duplicating the built-in <literal>english</literal> configuration: "
"<placeholder-1/>"
msgstr ""
"В качестве примера использования этих команд мы создадим конфигурацию "
"<literal>pg</literal>, взяв за основу встроенную конфигурацию "
"<literal>english</literal>: <placeholder-1/>"

#: textsearch.xml:3065(programlisting)
#, no-wrap
msgid ""
"postgres    pg\n"
"pgsql       pg\n"
"postgresql  pg"
msgstr ""
"postgres    pg\n"
"pgsql       pg\n"
"postgresql  pg"

#: textsearch.xml:3073(programlisting)
#, no-wrap
msgid ""
"CREATE TEXT SEARCH DICTIONARY pg_dict (\n"
"    TEMPLATE = synonym,\n"
"    SYNONYMS = pg_dict\n"
");"
msgstr ""
"CREATE TEXT SEARCH DICTIONARY pg_dict (\n"
"    TEMPLATE = synonym,\n"
"    SYNONYMS = pg_dict\n"
");"

#: textsearch.xml:3083(programlisting)
#, no-wrap
msgid ""
"CREATE TEXT SEARCH DICTIONARY english_ispell (\n"
"    TEMPLATE = ispell,\n"
"    DictFile = english,\n"
"    AffFile = english,\n"
"    StopWords = english\n"
");"
msgstr ""
"CREATE TEXT SEARCH DICTIONARY english_ispell (\n"
"    TEMPLATE = ispell,\n"
"    DictFile = english,\n"
"    AffFile = english,\n"
"    StopWords = english\n"
");"

#: textsearch.xml:3095(programlisting)
#, no-wrap
msgid ""
"ALTER TEXT SEARCH CONFIGURATION pg\n"
"    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart,\n"
"                      word, hword, hword_part\n"
"    WITH pg_dict, english_ispell, english_stem;"
msgstr ""
"ALTER TEXT SEARCH CONFIGURATION pg\n"
"    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart,\n"
"                      word, hword, hword_part\n"
"    WITH pg_dict, english_ispell, english_stem;"

#: textsearch.xml:3105(programlisting)
#, no-wrap
msgid ""
"ALTER TEXT SEARCH CONFIGURATION pg\n"
"    DROP MAPPING FOR email, url, url_path, sfloat, float;"
msgstr ""
"ALTER TEXT SEARCH CONFIGURATION pg\n"
"    DROP MAPPING FOR email, url, url_path, sfloat, float;"

#: textsearch.xml:3060(para)
msgid ""
"We will use a PostgreSQL-specific synonym list and store it in <filename>"
"$SHAREDIR/tsearch_data/pg_dict.syn</filename>. The file contents look like: "
"<placeholder-1/> We define the synonym dictionary like this: <placeholder-2/"
"> Next we register the <productname>Ispell</productname> dictionary "
"<literal>english_ispell</literal>, which has its own configuration files: "
"<placeholder-3/> Now we can set up the mappings for words in configuration "
"<literal>pg</literal>: <placeholder-4/> We choose not to index or search "
"some token types that the built-in configuration does handle: <placeholder-5/"
">"
msgstr ""
"Мы будем использовать список синонимов, связанных с PostgreSQL, в файле "
"<filename>$SHAREDIR/tsearch_data/pg_dict.syn</filename>. Этот файл содержит "
"строки: <placeholder-1/> Мы определим словарь синонимов следующим образом: "
"<placeholder-2/> Затем мы зарегистрируем словарь <productname>Ispell</"
"productname> <literal>english_ispell</literal>, у которого есть собственные "
"файлы конфигурации: <placeholder-3/> Теперь мы можем настроить сопоставления "
"для слов в конфигурации <literal>pg</literal>: <placeholder-4/> Мы решили не "
"индексировать и не учитывать при поиске некоторые типы фрагментов, которые "
"не обрабатываются встроенной конфигурацией: <placeholder-5/>"

#: textsearch.xml:3114(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM ts_debug('public.pg', '\n"
"PostgreSQL, the highly scalable, SQL compliant, open source object-relational\n"
"database management system, is now undergoing beta testing of the next\n"
"version of our software.\n"
"');"
msgstr ""
"SELECT * FROM ts_debug('public.pg', '\n"
"PostgreSQL, the highly scalable, SQL compliant, open source\n"
"object-relational database management system, is now undergoing\n"
"beta testing of the next version of our software.\n"
"');"

#: textsearch.xml:3111(para)
msgid "Now we can test our configuration: <placeholder-1/>"
msgstr "Теперь мы можем протестировать нашу конфигурацию: <placeholder-1/>"

#: textsearch.xml:3123(para)
msgid ""
"The next step is to set the session to use the new configuration, which was "
"created in the <literal>public</literal> schema: <screen>\n"
"=&gt; \\dF\n"
"   List of text search configurations\n"
" Schema  | Name | Description\n"
"---------+------+-------------\n"
" public  | pg   |\n"
"\n"
"SET default_text_search_config = 'public.pg';\n"
"SET\n"
"\n"
"SHOW default_text_search_config;\n"
" default_text_search_config\n"
"----------------------------\n"
" public.pg\n"
"</screen>"
msgstr ""
"И наконец мы выбираем в текущем сеансе эту конфигурацию, созданную в схеме "
"<literal>public</literal>: <screen>\n"
"=&gt; \\dF\n"
"   List of text search configurations\n"
" Schema  | Name | Description\n"
"---------+------+-------------\n"
" public  | pg   |\n"
"\n"
"SET default_text_search_config = 'public.pg';\n"
"SET\n"
"\n"
"SHOW default_text_search_config;\n"
" default_text_search_config\n"
"----------------------------\n"
" public.pg\n"
"</screen>"

#: textsearch.xml:3147(title)
msgid "Testing and Debugging Text Search"
msgstr "Тестирование и отладка текстового поиска"

#: textsearch.xml:3149(para)
msgid ""
"The behavior of a custom text search configuration can easily become "
"confusing. The functions described in this section are useful for testing "
"text search objects. You can test a complete configuration, or test parsers "
"and dictionaries separately."
msgstr ""
"Поведение нестандартной конфигурации текстового поиска по мере её усложнения "
"может стать непонятным. В этом разделе описаны функции, полезные для "
"тестирования объектов текстового поиска. Вы можете тестировать конфигурацию "
"как целиком, так и по частям, отлаживая анализаторы и словари по отдельности."

#: textsearch.xml:3157(title)
msgid "Configuration Testing"
msgstr "Тестирование конфигурации"

#: textsearch.xml:3159(para)
msgid ""
"The function <function>ts_debug</function> allows easy testing of a text "
"search configuration."
msgstr ""
"Созданную конфигурацию текстового поиска можно легко протестировать с "
"помощью функции <function>ts_debug</function>."

#: textsearch.xml:3164(indexterm)
msgid "<primary>ts_debug</primary>"
msgstr "<primary>ts_debug</primary>"

#: textsearch.xml:3170(replaceable) textsearch.xml:3384(replaceable)
#: textsearch.xml:3386(replaceable)
msgid "alias"
msgstr "псевдоним"

#: textsearch.xml:3171(replaceable) textsearch.xml:3384(replaceable)
#: textsearch.xml:3386(replaceable)
msgid "description"
msgstr "описание"

#: textsearch.xml:3172(replaceable) textsearch.xml:3353(replaceable)
#: textsearch.xml:3355(replaceable) textsearch.xml:3441(replaceable)
msgid "token"
msgstr "фрагмент"

#: textsearch.xml:3173(replaceable)
msgid "dictionaries"
msgstr "словари"

#: textsearch.xml:3173(type)
msgid "regdictionary[]"
msgstr "regdictionary[]"

#: textsearch.xml:3174(replaceable)
msgid "dictionary"
msgstr "словарь"

#: textsearch.xml:3174(type) textsearch.xml:3441(type)
msgid "regdictionary"
msgstr "regdictionary"

#: textsearch.xml:3175(replaceable)
msgid "lexemes"
msgstr "лексемы"

#: textsearch.xml:3175(type) textsearch.xml:3441(type)
msgid "text[]"
msgstr "text[]"

#: textsearch.xml:3168(synopsis)
#, no-wrap
msgid ""
"ts_debug(<placeholder-1/> <placeholder-2/> <placeholder-3/>,\n"
"         OUT <placeholder-4/> <placeholder-5/>,\n"
"         OUT <placeholder-6/> <placeholder-7/>,\n"
"         OUT <placeholder-8/> <placeholder-9/>,\n"
"         OUT <placeholder-10/> <placeholder-11/>,\n"
"         OUT <placeholder-12/> <placeholder-13/>,\n"
"         OUT <placeholder-14/> <placeholder-15/>)\n"
"         returns setof record"
msgstr ""
"ts_debug(<placeholder-1/> <placeholder-2/> <placeholder-3/>,\n"
"         OUT <placeholder-4/> <placeholder-5/>,\n"
"         OUT <placeholder-6/> <placeholder-7/>,\n"
"         OUT <placeholder-8/> <placeholder-9/>,\n"
"         OUT <placeholder-10/> <placeholder-11/>,\n"
"         OUT <placeholder-12/> <placeholder-13/>,\n"
"         OUT <placeholder-14/> <placeholder-15/>)\n"
"         returns setof record"

#: textsearch.xml:3179(para)
msgid ""
"<function>ts_debug</function> displays information about every token of "
"<replaceable class=\"parameter\">document</replaceable> as produced by the "
"parser and processed by the configured dictionaries. It uses the "
"configuration specified by <replaceable class=\"parameter\">config</"
"replaceable>, or <varname>default_text_search_config</varname> if that "
"argument is omitted."
msgstr ""
"<function>ts_debug</function> выводит информацию обо всех фрагментах данного "
"документа, которые были выданы анализатором и обработаны настроенными "
"словарями. Она использует конфигурацию, указанную в аргументе <replaceable "
"class=\"parameter\">config</replaceable>, или "
"<varname>default_text_search_config</varname>, если этот аргумент опущен."

#: textsearch.xml:3195(para)
msgid ""
"<replaceable>alias</replaceable> <type>text</type> &mdash; short name of the "
"token type"
msgstr ""
"<replaceable>синоним</replaceable> <type>text</type> &mdash; краткое имя "
"типа фрагмента"

#: textsearch.xml:3200(para)
msgid ""
"<replaceable>description</replaceable> <type>text</type> &mdash; description "
"of the token type"
msgstr ""
"<replaceable>описание</replaceable> <type>text</type> &mdash; описание типа "
"фрагмента"

#: textsearch.xml:3206(para)
msgid ""
"<replaceable>token</replaceable> <type>text</type> &mdash; text of the token"
msgstr ""
"<replaceable>фрагмент</replaceable> <type>text</type> &mdash; текст фрагмента"

#: textsearch.xml:3211(para)
msgid ""
"<replaceable>dictionaries</replaceable> <type>regdictionary[]</type> &mdash; "
"the dictionaries selected by the configuration for this token type"
msgstr ""
"<replaceable>словари</replaceable> <type>regdictionary[]</type> &mdash; "
"словари, назначенные в конфигурации для фрагментов такого типа"

#: textsearch.xml:3217(para)
msgid ""
"<replaceable>dictionary</replaceable> <type>regdictionary</type> &mdash; the "
"dictionary that recognized the token, or <literal>NULL</literal> if none did"
msgstr ""
"<replaceable>словарь</replaceable> <type>regdictionary</type> &mdash; "
"словарь, распознавший этот фрагмент, или <literal>NULL</literal>, если "
"подходящего словаря не нашлось"

#: textsearch.xml:3223(para)
msgid ""
"<replaceable>lexemes</replaceable> <type>text[]</type> &mdash; the lexeme(s) "
"produced by the dictionary that recognized the token, or <literal>NULL</"
"literal> if none did; an empty array (<literal>{}</literal>) means it was "
"recognized as a stop word"
msgstr ""
"<replaceable>лексемы</replaceable> <type>text[]</type> &mdash; лексемы, "
"выданные словарём, распознавшим фрагмент, или <literal>NULL</literal>, если "
"подходящий словарь не нашёлся; может быть также пустым массивом (<literal>{}"
"</literal>), если фрагмент распознан как стоп-слово"

#: textsearch.xml:3189(para)
msgid ""
"<function>ts_debug</function> returns one row for each token identified in "
"the text by the parser. The columns returned are <placeholder-1/>"
msgstr ""
"<function>ts_debug</function> возвращает по одной строке для каждого "
"фрагмента, найденного в тексте анализатором. Эта строка содержит следующие "
"столбцы: <placeholder-1/>"

#: textsearch.xml:3233(para)
msgid ""
"Here is a simple example: <screen>\n"
"SELECT * FROM ts_debug('english','a fat  cat sat on a mat - it ate a fat "
"rats');\n"
"   alias   |   description   | token |  dictionaries  |  dictionary  | "
"lexemes \n"
"-----------+-----------------+-------+----------------+--------------"
"+---------\n"
" asciiword | Word, all ASCII | a     | {english_stem} | english_stem | {}\n"
" blank     | Space symbols   |       | {}             |              | \n"
" asciiword | Word, all ASCII | fat   | {english_stem} | english_stem | "
"{fat}\n"
" blank     | Space symbols   |       | {}             |              | \n"
" asciiword | Word, all ASCII | cat   | {english_stem} | english_stem | "
"{cat}\n"
" blank     | Space symbols   |       | {}             |              | \n"
" asciiword | Word, all ASCII | sat   | {english_stem} | english_stem | "
"{sat}\n"
" blank     | Space symbols   |       | {}             |              | \n"
" asciiword | Word, all ASCII | on    | {english_stem} | english_stem | {}\n"
" blank     | Space symbols   |       | {}             |              | \n"
" asciiword | Word, all ASCII | a     | {english_stem} | english_stem | {}\n"
" blank     | Space symbols   |       | {}             |              | \n"
" asciiword | Word, all ASCII | mat   | {english_stem} | english_stem | "
"{mat}\n"
" blank     | Space symbols   |       | {}             |              | \n"
" blank     | Space symbols   | -     | {}             |              | \n"
" asciiword | Word, all ASCII | it    | {english_stem} | english_stem | {}\n"
" blank     | Space symbols   |       | {}             |              | \n"
" asciiword | Word, all ASCII | ate   | {english_stem} | english_stem | "
"{ate}\n"
" blank     | Space symbols   |       | {}             |              | \n"
" asciiword | Word, all ASCII | a     | {english_stem} | english_stem | {}\n"
" blank     | Space symbols   |       | {}             |              | \n"
" asciiword | Word, all ASCII | fat   | {english_stem} | english_stem | "
"{fat}\n"
" blank     | Space symbols   |       | {}             |              | \n"
" asciiword | Word, all ASCII | rats  | {english_stem} | english_stem | "
"{rat}\n"
"</screen>"
msgstr ""
"Простой пример: <screen>\n"
"SELECT * FROM ts_debug('english',\n"
"  'a fat  cat sat on a mat - it ate a fat rats');\n"
"   alias  |   description  | token|  dictionaries |  dictionary |lexemes\n"
"----------+----------------+------+---------------+-------------+-------\n"
" asciiword| Word, all ASCII| a    | {english_stem}| english_stem| {}\n"
" blank    | Space symbols  |      | {}            |             | \n"
" asciiword| Word, all ASCII| fat  | {english_stem}| english_stem| {fat}\n"
" blank    | Space symbols  |      | {}            |             | \n"
" asciiword| Word, all ASCII| cat  | {english_stem}| english_stem| {cat}\n"
" blank    | Space symbols  |      | {}            |             | \n"
" asciiword| Word, all ASCII| sat  | {english_stem}| english_stem| {sat}\n"
" blank    | Space symbols  |      | {}            |             | \n"
" asciiword| Word, all ASCII| on   | {english_stem}| english_stem| {}\n"
" blank    | Space symbols  |      | {}            |             | \n"
" asciiword| Word, all ASCII| a    | {english_stem}| english_stem| {}\n"
" blank    | Space symbols  |      | {}            |             | \n"
" asciiword| Word, all ASCII| mat  | {english_stem}| english_stem| {mat}\n"
" blank    | Space symbols  |      | {}            |             | \n"
" blank    | Space symbols  | -    | {}            |             | \n"
" asciiword| Word, all ASCII| it   | {english_stem}| english_stem| {}\n"
" blank    | Space symbols  |      | {}            |             | \n"
" asciiword| Word, all ASCII| ate  | {english_stem}| english_stem| {ate}\n"
" blank    | Space symbols  |      | {}            |             | \n"
" asciiword| Word, all ASCII| a    | {english_stem}| english_stem| {}\n"
" blank    | Space symbols  |      | {}            |             | \n"
" asciiword| Word, all ASCII| fat  | {english_stem}| english_stem| {fat}\n"
" blank    | Space symbols  |      | {}            |             | \n"
" asciiword| Word, all ASCII| rats | {english_stem}| english_stem| {rat}\n"
"</screen>"

#: textsearch.xml:3267(para)
msgid ""
"For a more extensive demonstration, we first create a <literal>public."
"english</literal> configuration and Ispell dictionary for the English "
"language:"
msgstr ""
"Для более полной демонстрации мы сначала создадим конфигурацию "
"<literal>public.english</literal> и словарь Ispell для английского языка:"

#: textsearch.xml:3273(programlisting)
#, no-wrap
msgid ""
"CREATE TEXT SEARCH CONFIGURATION public.english ( COPY = pg_catalog.english );\n"
"\n"
"CREATE TEXT SEARCH DICTIONARY english_ispell (\n"
"    TEMPLATE = ispell,\n"
"    DictFile = english,\n"
"    AffFile = english,\n"
"    StopWords = english\n"
");\n"
"\n"
"ALTER TEXT SEARCH CONFIGURATION public.english\n"
"   ALTER MAPPING FOR asciiword WITH english_ispell, english_stem;"
msgstr ""
"CREATE TEXT SEARCH CONFIGURATION public.english\n"
"  ( COPY = pg_catalog.english );\n"
"\n"
"CREATE TEXT SEARCH DICTIONARY english_ispell (\n"
"    TEMPLATE = ispell,\n"
"    DictFile = english,\n"
"    AffFile = english,\n"
"    StopWords = english\n"
");\n"
"\n"
"ALTER TEXT SEARCH CONFIGURATION public.english\n"
"   ALTER MAPPING FOR asciiword WITH english_ispell, english_stem;"

#: textsearch.xml:3287(screen)
#, no-wrap
msgid ""
"SELECT * FROM ts_debug('public.english','The Brightest supernovaes');\n"
"   alias   |   description   |    token    |         dictionaries          |   dictionary   |   lexemes   \n"
"-----------+-----------------+-------------+-------------------------------+----------------+-------------\n"
" asciiword | Word, all ASCII | The         | {english_ispell,english_stem} | english_ispell | {}\n"
" blank     | Space symbols   |             | {}                            |                | \n"
" asciiword | Word, all ASCII | Brightest   | {english_ispell,english_stem} | english_ispell | {bright}\n"
" blank     | Space symbols   |             | {}                            |                | \n"
" asciiword | Word, all ASCII | supernovaes | {english_ispell,english_stem} | english_stem   | {supernova}"
msgstr ""
"SELECT * FROM ts_debug('public.english','The Brightest supernovaes');\n"
"  alias  | description |   token   |  dictionaries |dictionary| lexemes   \n"
"---------+-------------+-----------+----------- ---+----------+-----------\n"
"asciiword|Word,        |The        |{english_ispell|english_  |{}\n"
"         | all ASCII   |           |,english_stem} |ispell    |\n"
"blank    |Space symbols|           |{}             |          |\n"
"         |             |           |               |          |\n"
"asciiword|Word,        |Brightest  |{english_ispell|english_  |{bright}\n"
"         |all ASCII    |           |,english_stem} |ispell    |\n"
"blank    |Space symbols|           | {}            |          |\n"
"         |             |           |               |          |\n"
"asciiword|Word,        |supernovaes|{english_ispell|english_  |{supernova}\n"
"         |all ASCII    |           |,english_stem} |stem      |"

#: textsearch.xml:3298(para)
msgid ""
"In this example, the word <literal>Brightest</literal> was recognized by the "
"parser as an <literal>ASCII word</literal> (alias <literal>asciiword</"
"literal>). For this token type the dictionary list is "
"<literal>english_ispell</literal> and <literal>english_stem</literal>. The "
"word was recognized by <literal>english_ispell</literal>, which reduced it "
"to the noun <literal>bright</literal>. The word <literal>supernovaes</"
"literal> is unknown to the <literal>english_ispell</literal> dictionary so "
"it was passed to the next dictionary, and, fortunately, was recognized (in "
"fact, <literal>english_stem</literal> is a Snowball dictionary which "
"recognizes everything; that is why it was placed at the end of the "
"dictionary list)."
msgstr ""
"В этом примере слово <literal>Brightest</literal> было воспринято "
"анализатором как фрагмент <literal>ASCII word</literal> (синоним "
"<literal>asciiword</literal>). Для этого типа фрагментов список словарей "
"включает <literal>english_ispell</literal> и <literal>english_stem</"
"literal>. Данное слово было распознано словарём <literal>english_ispell</"
"literal>, который свёл его к <literal>bright</literal>. Слово "
"<literal>supernovaes</literal> оказалось незнакомо словарю "
"<literal>english_ispell</literal>, так что оно было передано следующему "
"словарю, который его благополучно распознал (на самом деле "
"<literal>english_stem</literal> &mdash; это стеммер Snowball, который "
"распознаёт всё, поэтому он включён в список словарей последним)."

#: textsearch.xml:3313(para)
msgid ""
"The word <literal>The</literal> was recognized by the "
"<literal>english_ispell</literal> dictionary as a stop word (<xref linkend="
"\"textsearch-stopwords\"/>) and will not be indexed. The spaces are "
"discarded too, since the configuration provides no dictionaries at all for "
"them."
msgstr ""
"Слово <literal>The</literal> было распознано словарём "
"<literal>english_ispell</literal> как стоп-слово (см. <xref remap=\"4\" "
"linkend=\"textsearch-stopwords\"/>) и поэтому не будет индексироваться. "
"Пробелы тоже отбрасываются, так как в данной конфигурации для них нет "
"словарей."

#: textsearch.xml:3321(para)
msgid ""
"You can reduce the width of the output by explicitly specifying which "
"columns you want to see: <screen>\n"
"SELECT alias, token, dictionary, lexemes\n"
"FROM ts_debug('public.english','The Brightest supernovaes');\n"
"   alias   |    token    |   dictionary   |   lexemes   \n"
"-----------+-------------+----------------+-------------\n"
" asciiword | The         | english_ispell | {}\n"
" blank     |             |                | \n"
" asciiword | Brightest   | english_ispell | {bright}\n"
" blank     |             |                | \n"
" asciiword | supernovaes | english_stem   | {supernova}\n"
"</screen>"
msgstr ""
"Вы можете уменьшить ширину вывода, явно перечислив только те столбцы, "
"которые вы хотите видеть: <screen>\n"
"SELECT alias, token, dictionary, lexemes\n"
"FROM ts_debug('public.english','The Brightest supernovaes');\n"
"   alias   |    token    |   dictionary   |   lexemes   \n"
"-----------+-------------+----------------+-------------\n"
" asciiword | The         | english_ispell | {}\n"
" blank     |             |                | \n"
" asciiword | Brightest   | english_ispell | {bright}\n"
" blank     |             |                | \n"
" asciiword | supernovaes | english_stem   | {supernova}\n"
"</screen>"

#: textsearch.xml:3341(title)
msgid "Parser Testing"
msgstr "Тестирование анализатора"

#: textsearch.xml:3343(para)
msgid "The following functions allow direct testing of a text search parser."
msgstr ""
"Следующие функции позволяют непосредственно протестировать анализатор "
"текстового поиска."

#: textsearch.xml:3347(indexterm)
msgid "<primary>ts_parse</primary>"
msgstr "<primary>ts_parse</primary>"

#: textsearch.xml:3352(replaceable) textsearch.xml:3383(replaceable)
msgid "parser_name"
msgstr "имя_анализатора"

#: textsearch.xml:3353(replaceable) textsearch.xml:3355(replaceable)
#: textsearch.xml:3383(replaceable) textsearch.xml:3385(replaceable)
msgid "tokid"
msgstr "код_фрагмента"

#: textsearch.xml:3354(replaceable) textsearch.xml:3385(replaceable)
msgid "parser_oid"
msgstr "oid_анализатора"

#: textsearch.xml:3354(type) textsearch.xml:3385(type)
msgid "oid"
msgstr "oid"

#: textsearch.xml:3351(synopsis)
#, no-wrap
msgid ""
"ts_parse(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>,\n"
"         OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/> <placeholder-8/>) returns <placeholder-9/>\n"
"ts_parse(<placeholder-10/> <placeholder-11/>, <placeholder-12/> <placeholder-13/>,\n"
"         OUT <placeholder-14/> <placeholder-15/>, OUT <placeholder-16/> <placeholder-17/>) returns <placeholder-18/>"
msgstr ""
"ts_parse(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>,\n"
"         OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/> <placeholder-8/>) returns <placeholder-9/>\n"
"ts_parse(<placeholder-10/> <placeholder-11/>, <placeholder-12/> <placeholder-13/>,\n"
"         OUT <placeholder-14/> <placeholder-15/>, OUT <placeholder-16/> <placeholder-17/>) returns <placeholder-18/>"

#: textsearch.xml:3358(para)
msgid ""
"<function>ts_parse</function> parses the given <replaceable>document</"
"replaceable> and returns a series of records, one for each token produced by "
"parsing. Each record includes a <varname>tokid</varname> showing the "
"assigned token type and a <varname>token</varname> which is the text of the "
"token. For example: <screen>\n"
"SELECT * FROM ts_parse('default', '123 - a number');\n"
" tokid | token\n"
"-------+--------\n"
"    22 | 123\n"
"    12 |\n"
"    12 | -\n"
"     1 | a\n"
"    12 |\n"
"     1 | number\n"
"</screen>"
msgstr ""
"<function>ts_parse</function> разбирает данный документ и возвращает набор "
"записей, по одной для каждого извлечённого фрагмента. Каждая запись содержит "
"<varname>код_фрагмента</varname>, код назначенного типа фрагмента, и "
"<varname>фрагмент</varname>, собственно текст фрагмента. Например: <screen>\n"
"SELECT * FROM ts_parse('default', '123 - a number');\n"
" tokid | token\n"
"-------+--------\n"
"    22 | 123\n"
"    12 |\n"
"    12 | -\n"
"     1 | a\n"
"    12 |\n"
"     1 | number\n"
"</screen>"

#: textsearch.xml:3378(indexterm)
msgid "<primary>ts_token_type</primary>"
msgstr "<primary>ts_token_type</primary>"

#: textsearch.xml:3382(synopsis)
#, no-wrap
msgid ""
"ts_token_type(<placeholder-1/> <placeholder-2/>, OUT <placeholder-3/> <placeholder-4/>,\n"
"              OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/> <placeholder-8/>) returns <placeholder-9/>\n"
"ts_token_type(<placeholder-10/> <placeholder-11/>, OUT <placeholder-12/> <placeholder-13/>,\n"
"              OUT <placeholder-14/> <placeholder-15/>, OUT <placeholder-16/> <placeholder-17/>) returns <placeholder-18/>"
msgstr ""
"ts_token_type(<placeholder-1/> <placeholder-2/>, OUT <placeholder-3/> <placeholder-4/>,\n"
"              OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/> <placeholder-8/>) returns <placeholder-9/>\n"
"ts_token_type(<placeholder-10/> <placeholder-11/>, OUT <placeholder-12/> <placeholder-13/>,\n"
"              OUT <placeholder-14/> <placeholder-15/>, OUT <placeholder-16/> <placeholder-17/>) returns <placeholder-18/>"

#: textsearch.xml:3389(para)
msgid ""
"<function>ts_token_type</function> returns a table which describes each type "
"of token the specified parser can recognize. For each token type, the table "
"gives the integer <varname>tokid</varname> that the parser uses to label a "
"token of that type, the <varname>alias</varname> that names the token type "
"in configuration commands, and a short <varname>description</varname>. For "
"example: <screen>\n"
"SELECT * FROM ts_token_type('default');\n"
" tokid |      alias      |               description                \n"
"-------+-----------------+------------------------------------------\n"
"     1 | asciiword       | Word, all ASCII\n"
"     2 | word            | Word, all letters\n"
"     3 | numword         | Word, letters and digits\n"
"     4 | email           | Email address\n"
"     5 | url             | URL\n"
"     6 | host            | Host\n"
"     7 | sfloat          | Scientific notation\n"
"     8 | version         | Version number\n"
"     9 | hword_numpart   | Hyphenated word part, letters and digits\n"
"    10 | hword_part      | Hyphenated word part, all letters\n"
"    11 | hword_asciipart | Hyphenated word part, all ASCII\n"
"    12 | blank           | Space symbols\n"
"    13 | tag             | XML tag\n"
"    14 | protocol        | Protocol head\n"
"    15 | numhword        | Hyphenated word, letters and digits\n"
"    16 | asciihword      | Hyphenated word, all ASCII\n"
"    17 | hword           | Hyphenated word, all letters\n"
"    18 | url_path        | URL path\n"
"    19 | file            | File or path name\n"
"    20 | float           | Decimal notation\n"
"    21 | int             | Signed integer\n"
"    22 | uint            | Unsigned integer\n"
"    23 | entity          | XML entity\n"
"</screen>"
msgstr ""
"<function>ts_token_type</function> возвращает таблицу, описывающую все типы "
"фрагментов, которые может распознать анализатор. Для каждого типа в этой "
"таблице указывается его целочисленный <varname>код_фрагмента</varname>, "
"<varname>псевдоним </varname>, с которым этот тип фигурирует в командах, и "
"краткое <varname>description</varname>. Например: <screen>\n"
"SELECT * FROM ts_token_type('default');\n"
" tokid |      alias      |               description                \n"
"-------+-----------------+------------------------------------------\n"
"     1 | asciiword       | Word, all ASCII\n"
"     2 | word            | Word, all letters\n"
"     3 | numword         | Word, letters and digits\n"
"     4 | email           | Email address\n"
"     5 | url             | URL\n"
"     6 | host            | Host\n"
"     7 | sfloat          | Scientific notation\n"
"     8 | version         | Version number\n"
"     9 | hword_numpart   | Hyphenated word part, letters and digits\n"
"    10 | hword_part      | Hyphenated word part, all letters\n"
"    11 | hword_asciipart | Hyphenated word part, all ASCII\n"
"    12 | blank           | Space symbols\n"
"    13 | tag             | XML tag\n"
"    14 | protocol        | Protocol head\n"
"    15 | numhword        | Hyphenated word, letters and digits\n"
"    16 | asciihword      | Hyphenated word, all ASCII\n"
"    17 | hword           | Hyphenated word, all letters\n"
"    18 | url_path        | URL path\n"
"    19 | file            | File or path name\n"
"    20 | float           | Decimal notation\n"
"    21 | int             | Signed integer\n"
"    22 | uint            | Unsigned integer\n"
"    23 | entity          | XML entity\n"
"</screen>"

#: textsearch.xml:3430(title)
msgid "Dictionary Testing"
msgstr "Тестирование словаря"

#: textsearch.xml:3432(para)
msgid ""
"The <function>ts_lexize</function> function facilitates dictionary testing."
msgstr ""
"Для тестирования словаря предназначена функция <function>ts_lexize</"
"function>."

#: textsearch.xml:3436(indexterm)
msgid "<primary>ts_lexize</primary>"
msgstr "<primary>ts_lexize</primary>"

#: textsearch.xml:3441(replaceable)
msgid "dict"
msgstr "словарь"

#: textsearch.xml:3440(synopsis)
#, no-wrap
msgid "ts_lexize(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>) returns <placeholder-5/>"
msgstr "ts_lexize(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>) returns <placeholder-5/>"

#: textsearch.xml:3444(para)
msgid ""
"<function>ts_lexize</function> returns an array of lexemes if the input "
"<replaceable>token</replaceable> is known to the dictionary, or an empty "
"array if the token is known to the dictionary but it is a stop word, or "
"<literal>NULL</literal> if it is an unknown word."
msgstr ""
"<function>ts_lexize</function> возвращает массив лексем, если входной "
"<replaceable>фрагмент</replaceable> известен словарю, либо пустой массив, "
"если этот фрагмент считается в словаре стоп-словом, либо <literal>NULL</"
"literal>, если он не был распознан."

#: textsearch.xml:3452(para)
msgid ""
"Examples: <screen>\n"
"SELECT ts_lexize('english_stem', 'stars');\n"
" ts_lexize\n"
"-----------\n"
" {star}\n"
"\n"
"SELECT ts_lexize('english_stem', 'a');\n"
" ts_lexize\n"
"-----------\n"
" {}\n"
"</screen>"
msgstr ""
"Примеры: <screen>\n"
"SELECT ts_lexize('english_stem', 'stars');\n"
" ts_lexize\n"
"-----------\n"
" {star}\n"
"\n"
"SELECT ts_lexize('english_stem', 'a');\n"
" ts_lexize\n"
"-----------\n"
" {}\n"
"</screen>"

#: textsearch.xml:3469(para)
msgid ""
"The <function>ts_lexize</function> function expects a single "
"<emphasis>token</emphasis>, not text. Here is a case where this can be "
"confusing: <screen>\n"
"SELECT ts_lexize('thesaurus_astro','supernovae stars') is null;\n"
" ?column?\n"
"----------\n"
" t\n"
"</screen> The thesaurus dictionary <literal>thesaurus_astro</literal> does "
"know the phrase <literal>supernovae stars</literal>, but "
"<function>ts_lexize</function> fails since it does not parse the input text "
"but treats it as a single token. Use <function>plainto_tsquery</function> or "
"<function>to_tsvector</function> to test thesaurus dictionaries, for "
"example: <screen>\n"
"SELECT plainto_tsquery('supernovae stars');\n"
" plainto_tsquery\n"
"-----------------\n"
" 'sn'\n"
"</screen>"
msgstr ""
"Функция <function>ts_lexize</function> принимает одиночный "
"<emphasis>фрагмент</emphasis>, а не просто текст. Вот пример возможного "
"заблуждения: <screen>\n"
"SELECT ts_lexize('thesaurus_astro','supernovae stars') is null;\n"
" ?column?\n"
"----------\n"
" t\n"
"</screen> Хотя фраза <literal>supernovae stars</literal> есть в тезаурусе "
"<literal>thesaurus_astro</literal>, <function>ts_lexize</function> не "
"работает, так как она не разбирает входной текст, а воспринимает его как "
"один фрагмент. Поэтому для проверки тезаурусов следует использовать функции "
"<function>plainto_tsquery</function> и <function>to_tsvector</function>, "
"например: <screen>\n"
"SELECT plainto_tsquery('supernovae stars');\n"
" plainto_tsquery\n"
"-----------------\n"
" 'sn'\n"
"</screen>"

#: textsearch.xml:3501(title)
msgid "GIN and GiST Index Types"
msgstr "Типы индексов GIN и GiST"

#: textsearch.xml:3503(indexterm)
msgid "<primary>text search</primary> <secondary>indexes</secondary>"
msgstr "<primary>текстовый поиск</primary> <secondary>индексы</secondary>"

#: textsearch.xml:3520(indexterm)
msgid ""
"<primary>index</primary> <secondary>GIN</secondary> <tertiary>text search</"
"tertiary>"
msgstr ""
"<primary>индекс</primary> <secondary>GIN</secondary> <tertiary>текстовый "
"поиск</tertiary>"

#: textsearch.xml:3526(replaceable) textsearch.xml:3546(replaceable)
msgid "name"
msgstr "имя"

#: textsearch.xml:3526(replaceable) textsearch.xml:3546(replaceable)
msgid "table"
msgstr "таблица"

#: textsearch.xml:3526(replaceable) textsearch.xml:3546(replaceable)
msgid "column"
msgstr "столбец"

#: textsearch.xml:3526(literal)
msgid ""
"CREATE INDEX <placeholder-1/> ON <placeholder-2/> USING GIN (<placeholder-3/"
">);"
msgstr ""
"CREATE INDEX <placeholder-1/> ON <placeholder-2/> USING GIN (<placeholder-3/"
">);"

#: textsearch.xml:3530(para)
msgid ""
"Creates a GIN (Generalized Inverted Index)-based index. The "
"<replaceable>column</replaceable> must be of <type>tsvector</type> type."
msgstr ""
"Создаёт индекс на базе GIN (Generalized Inverted Index, Обобщённый "
"Инвертированный Индекс). <replaceable>Столбец</replaceable> должен иметь тип "
"<type>tsvector</type>."

#: textsearch.xml:3540(indexterm)
msgid ""
"<primary>index</primary> <secondary>GiST</secondary> <tertiary>text search</"
"tertiary>"
msgstr ""
"<primary>индекс</primary> <secondary>GiST</secondary> <tertiary>текстовый "
"поиск</tertiary>"

#: textsearch.xml:3546(literal)
msgid ""
"CREATE INDEX <placeholder-1/> ON <placeholder-2/> USING GIST (<placeholder-3/"
">);"
msgstr ""
"CREATE INDEX <placeholder-1/> ON <placeholder-2/> USING GIST (<placeholder-3/"
">);"

#: textsearch.xml:3550(para)
msgid ""
"Creates a GiST (Generalized Search Tree)-based index. The "
"<replaceable>column</replaceable> can be of <type>tsvector</type> or "
"<type>tsquery</type> type."
msgstr ""
"Создаёт индекс на базе GiST (Generalized Search Tree, Обобщённое дерево "
"поиска). Здесь <replaceable>столбец</replaceable> может иметь тип "
"<type>tsvector</type> или <type>tsquery</type>."

#: textsearch.xml:3508(para)
msgid ""
"There are two kinds of indexes that can be used to speed up full text "
"searches. Note that indexes are not mandatory for full text searching, but "
"in cases where a column is searched on a regular basis, an index is usually "
"desirable. <placeholder-1/>"
msgstr ""
"Для ускорения полнотекстового поиска можно использовать индексы двух видов. "
"Заметьте, что эти индексы не требуются для поиска, но если по какому-то "
"столбцу поиск выполняется регулярно, обычно желательно её индексировать. "
"<placeholder-1/>"

#: textsearch.xml:3561(para)
msgid ""
"GIN indexes are the preferred text search index type. As inverted indexes, "
"they contain an index entry for each word (lexeme), with a compressed list "
"of matching locations. Multi-word searches can find the first match, then "
"use the index to remove rows that are lacking additional words. GIN indexes "
"store only the words (lexemes) of <type>tsvector</type> values, and not "
"their weight labels. Thus a table row recheck is needed when using a query "
"that involves weights."
msgstr ""
"Более предпочтительными для текстового поиска являются индексы GIN. Будучи "
"инверсированными индексами, они содержат записи для всех отдельных слов "
"(лексем) с компактным списком мест их вхождений. При поиске нескольких слов "
"можно найти первое, а затем воспользоваться индексом и исключить строки, в "
"которых дополнительные слова отсутствуют. Индексы GIN хранят только слова "
"(лексемы) из значений <type>tsvector</type>, и теряют информацию об их "
"весах. Таким образом для выполнения запроса с весами потребуется "
"перепроверить строки в таблице."

#: textsearch.xml:3571(para)
msgid ""
"A GiST index is <firstterm>lossy</firstterm>, meaning that the index might "
"produce false matches, and it is necessary to check the actual table row to "
"eliminate such false matches. (<productname>PostgreSQL</productname> does "
"this automatically when needed.) GiST indexes are lossy because each "
"document is represented in the index by a fixed-length signature. The "
"signature is generated by hashing each word into a single bit in an n-bit "
"string, with all these bits OR-ed together to produce an n-bit document "
"signature. When two words hash to the same bit position there will be a "
"false match. If all words in the query have matches (real or false) then the "
"table row must be retrieved to see if the match is correct."
msgstr ""
"Индекс GiST допускает <firstterm>неточности</firstterm>, то есть он "
"допускает ложные попадания и поэтому их нужно исключать дополнительно, "
"сверяя результат с фактическими данными таблицы. (<productname>PostgreSQL</"
"productname> делает это автоматически.) Индексы GiST являются неточными, так "
"как все документы в них представляются сигнатурой фиксированной длины. Эта "
"сигнатура создаётся в результате представления присутствия каждого слова как "
"одного бита в строке из n-бит, а затем логического объединения этих битовых "
"строк. Если двум словам будет соответствовать одна битовая позиция, "
"попадание оказывается ложным. Если для всех слов оказались установлены "
"соответствующие биты (в случае фактического или ложного попадания), для "
"проверки правильности предположения о совпадении слов необходимо прочитать "
"строку таблицы."

#: textsearch.xml:3585(para)
msgid ""
"Lossiness causes performance degradation due to unnecessary fetches of table "
"records that turn out to be false matches. Since random access to table "
"records is slow, this limits the usefulness of GiST indexes. The likelihood "
"of false matches depends on several factors, in particular the number of "
"unique words, so using dictionaries to reduce this number is recommended."
msgstr ""
"Неточность индекса приводит к снижению производительности из-за "
"дополнительных обращений к записям таблицы, для которых предположение о "
"совпадении оказывается ложным. Так как произвольный доступ к таблице обычно "
"не бывает быстрым, это ограничивает применимость индексов GiST. Вероятность "
"ложных попаданий зависит от ряда факторов, например от количества уникальных "
"слов, так что его рекомендуется сокращать, применяя словари."

#: textsearch.xml:3594(para)
msgid ""
"Note that <acronym>GIN</acronym> index build time can often be improved by "
"increasing <xref linkend=\"guc-maintenance-work-mem\"/>, while "
"<acronym>GiST</acronym> index build time is not sensitive to that parameter."
msgstr ""
"Заметьте, что построение индекса <acronym>GIN</acronym> часто можно "
"ускорить, увеличив <xref linkend=\"guc-maintenance-work-mem\"/>, тогда как "
"время построения индекса <acronym>GiST</acronym> не зависит от этого "
"параметра."

#: textsearch.xml:3601(para)
msgid ""
"Partitioning of big collections and the proper use of GIN and GiST indexes "
"allows the implementation of very fast searches with online update. "
"Partitioning can be done at the database level using table inheritance, or "
"by distributing documents over servers and collecting search results using "
"the <xref linkend=\"dblink\"/> module. The latter is possible because "
"ranking functions use only local information."
msgstr ""
"Правильно используя индексы GIN и GiST и разделяя большие коллекции "
"документов на секции, можно реализовать очень быстрый поиск с возможностью "
"обновления &laquo;на лету&raquo;. Секционировать данные можно как на уровне "
"базы, с использованием наследования таблиц, так и распределив документы по "
"разным серверам и затем собирая результаты с помощью модуля <xref linkend="
"\"dblink\"/>. Последний вариант возможен благодаря тому, что функции "
"ранжирования используют только локальную информацию."

#: textsearch.xml:3614(title)
msgid "<application>psql</application> Support"
msgstr "Поддержка <application>psql</application>"

#: textsearch.xml:3616(para)
msgid ""
"Information about text search configuration objects can be obtained in "
"<application>psql</application> using a set of commands: <synopsis>\n"
"\\dF{d,p,t}<optional>+</optional> <optional>PATTERN</optional>\n"
"</synopsis> An optional <literal>+</literal> produces more details."
msgstr ""
"Информацию об объектах конфигурации текстового поиска можно получить в "
"<application>psql</application> с помощью следующего набора команд: "
"<synopsis>\n"
"\\dF{d,p,t}<optional>+</optional> <optional>ШАБЛОН</optional>\n"
"</synopsis> Необязательный <literal>+</literal> в этих командах включает "
"более подробный вывод."

#: textsearch.xml:3625(para)
msgid ""
"The optional parameter <replaceable>PATTERN</replaceable> can be the name of "
"a text search object, optionally schema-qualified. If <replaceable>PATTERN</"
"replaceable> is omitted then information about all visible objects will be "
"displayed. <replaceable>PATTERN</replaceable> can be a regular expression "
"and can provide <emphasis>separate</emphasis> patterns for the schema and "
"object names. The following examples illustrate this: <screen>\n"
"=&gt; \\dF *fulltext*\n"
"       List of text search configurations\n"
" Schema |  Name        | Description\n"
"--------+--------------+-------------\n"
" public | fulltext_cfg |\n"
"</screen> <screen>\n"
"=&gt; \\dF *.fulltext*\n"
"       List of text search configurations\n"
" Schema   |  Name        | Description\n"
"----------+----------------------------\n"
" fulltext | fulltext_cfg |\n"
" public   | fulltext_cfg |\n"
"</screen> The available commands are:"
msgstr ""
"В необязательном параметре <replaceable>ШАБЛОН</replaceable> может "
"указываться имя объекта текстового поиска, возможно дополненное именем "
"схемы. Если <replaceable>ШАБЛОН</replaceable> не указан, выводится "
"информация обо всех видимых объектах. <replaceable>ШАБЛОН</replaceable> "
"может содержать регулярное выражение с <emphasis>разными</emphasis> масками "
"для схемы и объекта. Это иллюстрируют следующие примеры: <screen>\n"
"=&gt; \\dF *fulltext*\n"
"       List of text search configurations\n"
" Schema |  Name        | Description\n"
"--------+--------------+-------------\n"
" public | fulltext_cfg |\n"
"</screen> <screen>\n"
"=&gt; \\dF *.fulltext*\n"
"       List of text search configurations\n"
" Schema   |  Name        | Description\n"
"----------+----------------------------\n"
" fulltext | fulltext_cfg |\n"
" public   | fulltext_cfg |\n"
"</screen> Возможны следующие команды:"

#: textsearch.xml:3655(optional) textsearch.xml:3696(optional)
#: textsearch.xml:3727(optional) textsearch.xml:3780(optional)
msgid "+"
msgstr "+"

#: textsearch.xml:3655(optional) textsearch.xml:3696(optional)
#: textsearch.xml:3727(optional) textsearch.xml:3780(optional)
msgid "PATTERN"
msgstr "ШАБЛОН"

#: textsearch.xml:3655(literal)
msgid "\\dF<placeholder-1/> <placeholder-2/>"
msgstr "\\dF<placeholder-1/> <placeholder-2/>"

#: textsearch.xml:3657(para)
msgid ""
"List text search configurations (add <literal>+</literal> for more detail). "
"<screen>\n"
"=&gt; \\dF russian\n"
"            List of text search configurations\n"
"   Schema   |  Name   |            Description             \n"
"------------+---------+------------------------------------\n"
" pg_catalog | russian | configuration for russian language\n"
"\n"
"=&gt; \\dF+ russian\n"
"Text search configuration \"pg_catalog.russian\"\n"
"Parser: \"pg_catalog.default\"\n"
"      Token      | Dictionaries \n"
"-----------------+--------------\n"
" asciihword      | english_stem\n"
" asciiword       | english_stem\n"
" email           | simple\n"
" file            | simple\n"
" float           | simple\n"
" host            | simple\n"
" hword           | russian_stem\n"
" hword_asciipart | english_stem\n"
" hword_numpart   | simple\n"
" hword_part      | russian_stem\n"
" int             | simple\n"
" numhword        | simple\n"
" numword         | simple\n"
" sfloat          | simple\n"
" uint            | simple\n"
" url             | simple\n"
" url_path        | simple\n"
" version         | simple\n"
" word            | russian_stem\n"
"</screen>"
msgstr ""
"Список конфигураций текстового поиска (добавьте <literal>+</literal> для "
"дополнительных сведений). <screen>\n"
"=&gt; \\dF russian\n"
"            List of text search configurations\n"
"   Schema   |  Name   |            Description             \n"
"------------+---------+------------------------------------\n"
" pg_catalog | russian | configuration for russian language\n"
"\n"
"=&gt; \\dF+ russian\n"
"Text search configuration \"pg_catalog.russian\"\n"
"Parser: \"pg_catalog.default\"\n"
"      Token      | Dictionaries \n"
"-----------------+--------------\n"
" asciihword      | english_stem\n"
" asciiword       | english_stem\n"
" email           | simple\n"
" file            | simple\n"
" float           | simple\n"
" host            | simple\n"
" hword           | russian_stem\n"
" hword_asciipart | english_stem\n"
" hword_numpart   | simple\n"
" hword_part      | russian_stem\n"
" int             | simple\n"
" numhword        | simple\n"
" numword         | simple\n"
" sfloat          | simple\n"
" uint            | simple\n"
" url             | simple\n"
" url_path        | simple\n"
" version         | simple\n"
" word            | russian_stem\n"
"</screen>"

#: textsearch.xml:3696(literal)
msgid "\\dFd<placeholder-1/> <placeholder-2/>"
msgstr "\\dFd<placeholder-1/> <placeholder-2/>"

#: textsearch.xml:3698(para)
msgid ""
"List text search dictionaries (add <literal>+</literal> for more detail). "
"<screen>\n"
"=&gt; \\dFd\n"
"                            List of text search dictionaries\n"
"   Schema   |      Name       |                        "
"Description                        \n"
"------------+-----------------"
"+-----------------------------------------------------------\n"
" pg_catalog | danish_stem     | snowball stemmer for danish language\n"
" pg_catalog | dutch_stem      | snowball stemmer for dutch language\n"
" pg_catalog | english_stem    | snowball stemmer for english language\n"
" pg_catalog | finnish_stem    | snowball stemmer for finnish language\n"
" pg_catalog | french_stem     | snowball stemmer for french language\n"
" pg_catalog | german_stem     | snowball stemmer for german language\n"
" pg_catalog | hungarian_stem  | snowball stemmer for hungarian language\n"
" pg_catalog | italian_stem    | snowball stemmer for italian language\n"
" pg_catalog | norwegian_stem  | snowball stemmer for norwegian language\n"
" pg_catalog | portuguese_stem | snowball stemmer for portuguese language\n"
" pg_catalog | romanian_stem   | snowball stemmer for romanian language\n"
" pg_catalog | russian_stem    | snowball stemmer for russian language\n"
" pg_catalog | simple          | simple dictionary: just lower case and check "
"for stopword\n"
" pg_catalog | spanish_stem    | snowball stemmer for spanish language\n"
" pg_catalog | swedish_stem    | snowball stemmer for swedish language\n"
" pg_catalog | turkish_stem    | snowball stemmer for turkish language\n"
"</screen>"
msgstr ""
"Список словарей текстового поиска (добавьте <literal>+</literal> для "
"дополнительных сведений). <screen>\n"
"=&gt; \\dFd\n"
"                            List of text search dictionaries\n"
"  Schema   |     Name       |              Description                  \n"
"-----------+----------------+-------------------------------------------\n"
"pg_catalog | danish_stem    | snowball stemmer for danish language\n"
"pg_catalog | dutch_stem     | snowball stemmer for dutch language\n"
"pg_catalog | english_stem   | snowball stemmer for english language\n"
"pg_catalog | finnish_stem   | snowball stemmer for finnish language\n"
"pg_catalog | french_stem    | snowball stemmer for french language\n"
"pg_catalog | german_stem    | snowball stemmer for german language\n"
"pg_catalog | hungarian_stem | snowball stemmer for hungarian language\n"
"pg_catalog | italian_stem   | snowball stemmer for italian language\n"
"pg_catalog | norwegian_stem | snowball stemmer for norwegian language\n"
"pg_catalog | portuguese_stem| snowball stemmer for portuguese language\n"
"pg_catalog | romanian_stem  | snowball stemmer for romanian language\n"
"pg_catalog | russian_stem   | snowball stemmer for russian language\n"
"pg_catalog | simple         | simple dictionary: just lower case and ...\n"
"pg_catalog | spanish_stem   | snowball stemmer for spanish language\n"
"pg_catalog | swedish_stem   | snowball stemmer for swedish language\n"
"pg_catalog | turkish_stem   | snowball stemmer for turkish language\n"
"</screen>"

#: textsearch.xml:3727(literal)
msgid "\\dFp<placeholder-1/> <placeholder-2/>"
msgstr "\\dFp<placeholder-1/> <placeholder-2/>"

#: textsearch.xml:3729(para)
msgid ""
"List text search parsers (add <literal>+</literal> for more detail). "
"<screen>\n"
"=&gt; \\dFp\n"
"        List of text search parsers\n"
"   Schema   |  Name   |     Description     \n"
"------------+---------+---------------------\n"
" pg_catalog | default | default word parser\n"
"=&gt; \\dFp+\n"
"    Text search parser \"pg_catalog.default\"\n"
"     Method      |    Function    | Description \n"
"-----------------+----------------+-------------\n"
" Start parse     | prsd_start     | \n"
" Get next token  | prsd_nexttoken | \n"
" End parse       | prsd_end       | \n"
" Get headline    | prsd_headline  | \n"
" Get token types | prsd_lextype   | \n"
"\n"
"        Token types for parser \"pg_catalog.default\"\n"
"   Token name    |               Description                \n"
"-----------------+------------------------------------------\n"
" asciihword      | Hyphenated word, all ASCII\n"
" asciiword       | Word, all ASCII\n"
" blank           | Space symbols\n"
" email           | Email address\n"
" entity          | XML entity\n"
" file            | File or path name\n"
" float           | Decimal notation\n"
" host            | Host\n"
" hword           | Hyphenated word, all letters\n"
" hword_asciipart | Hyphenated word part, all ASCII\n"
" hword_numpart   | Hyphenated word part, letters and digits\n"
" hword_part      | Hyphenated word part, all letters\n"
" int             | Signed integer\n"
" numhword        | Hyphenated word, letters and digits\n"
" numword         | Word, letters and digits\n"
" protocol        | Protocol head\n"
" sfloat          | Scientific notation\n"
" tag             | XML tag\n"
" uint            | Unsigned integer\n"
" url             | URL\n"
" url_path        | URL path\n"
" version         | Version number\n"
" word            | Word, all letters\n"
"(23 rows)\n"
"</screen>"
msgstr ""
"Список анализаторов текстового поиска (добавьте <literal>+</literal> для "
"дополнительных сведений). <screen>\n"
"=&gt; \\dFp\n"
"        List of text search parsers\n"
"   Schema   |  Name   |     Description     \n"
"------------+---------+---------------------\n"
" pg_catalog | default | default word parser\n"
"=&gt; \\dFp+\n"
"    Text search parser \"pg_catalog.default\"\n"
"     Method      |    Function    | Description \n"
"-----------------+----------------+-------------\n"
" Start parse     | prsd_start     | \n"
" Get next token  | prsd_nexttoken | \n"
" End parse       | prsd_end       | \n"
" Get headline    | prsd_headline  | \n"
" Get token types | prsd_lextype   | \n"
"\n"
"        Token types for parser \"pg_catalog.default\"\n"
"   Token name    |               Description                \n"
"-----------------+------------------------------------------\n"
" asciihword      | Hyphenated word, all ASCII\n"
" asciiword       | Word, all ASCII\n"
" blank           | Space symbols\n"
" email           | Email address\n"
" entity          | XML entity\n"
" file            | File or path name\n"
" float           | Decimal notation\n"
" host            | Host\n"
" hword           | Hyphenated word, all letters\n"
" hword_asciipart | Hyphenated word part, all ASCII\n"
" hword_numpart   | Hyphenated word part, letters and digits\n"
" hword_part      | Hyphenated word part, all letters\n"
" int             | Signed integer\n"
" numhword        | Hyphenated word, letters and digits\n"
" numword         | Word, letters and digits\n"
" protocol        | Protocol head\n"
" sfloat          | Scientific notation\n"
" tag             | XML tag\n"
" uint            | Unsigned integer\n"
" url             | URL\n"
" url_path        | URL path\n"
" version         | Version number\n"
" word            | Word, all letters\n"
"(23 rows)\n"
"</screen>"

#: textsearch.xml:3780(literal)
msgid "\\dFt<placeholder-1/> <placeholder-2/>"
msgstr "\\dFt<placeholder-1/> <placeholder-2/>"

#: textsearch.xml:3782(para)
msgid ""
"List text search templates (add <literal>+</literal> for more detail). "
"<screen>\n"
"=&gt; \\dFt\n"
"                           List of text search templates\n"
"   Schema   |   Name    |                        "
"Description                        \n"
"------------+-----------"
"+-----------------------------------------------------------\n"
" pg_catalog | ispell    | ispell dictionary\n"
" pg_catalog | simple    | simple dictionary: just lower case and check for "
"stopword\n"
" pg_catalog | snowball  | snowball stemmer\n"
" pg_catalog | synonym   | synonym dictionary: replace word by its synonym\n"
" pg_catalog | thesaurus | thesaurus dictionary: phrase by phrase "
"substitution\n"
"</screen>"
msgstr ""
"Список шаблонов текстового поиска (добавьте <literal>+</literal> для "
"дополнительных сведений). <screen>\n"
"=&gt; \\dFt\n"
"                           List of text search templates\n"
"  Schema  |  Name   |                       Description                  \n"
"----------+---------+----------------------------------------------------\n"
"pg_catalog|ispell   |ispell dictionary\n"
"pg_catalog|simple   |simple dictionary: just lower case and check for ...\n"
"pg_catalog|snowball |snowball stemmer\n"
"pg_catalog|synonym  |synonym dictionary: replace word by its synonym\n"
"pg_catalog|thesaurus|thesaurus dictionary: phrase by phrase substitution\n"
"</screen>"

#: textsearch.xml:3803(title)
msgid "Limitations"
msgstr "Ограничения"

#: textsearch.xml:3810(para)
msgid "The length of each lexeme must be less than 2K bytes"
msgstr "Длина лексемы не может превышать 2 килобайта"

#: textsearch.xml:3813(para)
msgid ""
"The length of a <type>tsvector</type> (lexemes + positions) must be less "
"than 1 megabyte"
msgstr ""
"Длина значения <type>tsvector</type> (лексемы и их позиции) не может "
"превышать 1 мегабайт"

#. TODO: number of lexemes in what?  This is unclear
#: textsearch.xml:3818(para)
msgid "The number of lexemes must be less than 2<superscript>64</superscript>"
msgstr "Число лексем должно быть меньше 2<superscript>64</superscript>"

#: textsearch.xml:3822(para)
msgid ""
"Position values in <type>tsvector</type> must be greater than 0 and no more "
"than 16,383"
msgstr "Значения позиций в <type>tsvector</type> должны быть от 0 до 16383"

#: textsearch.xml:3826(para)
msgid ""
"The match distance in a <literal>&lt;<replaceable>N</replaceable>&gt;</"
"literal> (FOLLOWED BY) <type>tsquery</type> operator cannot be more than "
"16,384"
msgstr ""
"Расстояние в операторе <literal>&lt;<replaceable>N</replaceable>&gt;</"
"literal> (ПРЕДШЕСТВУЕТ) типа <type>tsquery</type> не может быть больше 16384"

#: textsearch.xml:3831(para)
msgid "No more than 256 positions per lexeme"
msgstr "Не больше 256 позиций для одной лексемы"

#: textsearch.xml:3834(para)
msgid ""
"The number of nodes (lexemes + operators) in a <type>tsquery</type> must be "
"less than 32,768"
msgstr ""
"Число узлов (лексемы + операторы) в значении <type>tsquery</type> должно "
"быть меньше 32768"

#: textsearch.xml:3805(para)
msgid ""
"The current limitations of <productname>PostgreSQL</productname>'s text "
"search features are: <placeholder-1/>"
msgstr ""
"Текущая реализация текстового поиска в <productname>PostgreSQL</productname> "
"имеет следующие ограничения: <placeholder-1/>"

#: textsearch.xml:3840(para)
msgid ""
"For comparison, the <productname>PostgreSQL</productname> 8.1 documentation "
"contained 10,441 unique words, a total of 335,420 words, and the most "
"frequent word <quote>postgresql</quote> was mentioned 6,127 times in 655 "
"documents."
msgstr ""
"Для сравнения, документация <productname>PostgreSQL</productname> 8.1 "
"содержала 335&nbsp;420 слов, из них 10&nbsp;441 уникальных, а наиболее часто "
"употребляющееся в ней слово <quote>postgresql</quote> встречается 6&nbsp;127 "
"раз в 655 документах."

#. TODO we need to put a date on these numbers?
#: textsearch.xml:3848(para)
msgid ""
"Another example &mdash; the <productname>PostgreSQL</productname> mailing "
"list archives contained 910,989 unique words with 57,491,343 lexemes in "
"461,020 messages."
msgstr ""
"Другой пример &mdash; архивы списков рассылки <productname>PostgreSQL</"
"productname> содержали 910&nbsp;989 уникальных слов в 57&nbsp;491&nbsp;343 "
"лексемах в 461&nbsp;020 сообщениях."

#: textsearch.xml:3857(title)
msgid "Migration from Pre-8.3 Text Search"
msgstr "Миграция с реализации текстового поиска в версиях до 8.3"

#: textsearch.xml:3859(para)
msgid ""
"Applications that use the <xref linkend=\"tsearch2\"/> module for text "
"searching will need some adjustments to work with the built-in features:"
msgstr ""
"Для работы со встроенными средствами текстового поиска приложения, ранее "
"использовавшие модуль <xref linkend=\"tsearch2\"/>, должны быть изменены с "
"учётом следующих замечаний:"

#: textsearch.xml:3868(para)
msgid ""
"Some functions have been renamed or had small adjustments in their argument "
"lists, and all of them are now in the <literal>pg_catalog</literal> schema, "
"whereas in a previous installation they would have been in <literal>public</"
"literal> or another non-system schema. There is a new version of "
"<application>tsearch2</application> that provides a compatibility layer to "
"solve most problems in this area."
msgstr ""
"Некоторые функции были переименованы, а у других мог измениться список "
"аргументов. Все они сейчас находятся в схеме <literal>pg_catalog</literal>, "
"тогда как раньше они в располагались схеме <literal>public</literal> или "
"другой не системной схеме. Для устранения подобных несоответствий была "
"выпущена новая версия <application>tsearch2</application>, предоставляющая "
"необходимый уровень совместимости."

#: textsearch.xml:3880(para)
msgid ""
"The old <application>tsearch2</application> functions and other objects "
"<emphasis>must</emphasis> be suppressed when loading <application>pg_dump</"
"application> output from a pre-8.3 database. While many of them won't load "
"anyway, a few will and then cause problems. One simple way to deal with this "
"is to load the new <application>tsearch2</application> module before "
"restoring the dump; then it will block the old objects from being loaded."
msgstr ""
"Функции и другие объекты старого модуля <application>tsearch2</application> "
"<emphasis>нужно</emphasis> игнорировать при загрузке в <application>pg_dump</"
"application> базы до версии 8.3. Хотя многие из них всё равно не загрузятся, "
"остальные могут создать проблемы. Есть один простой способ выполнить это "
"требование &mdash; загрузить новый модуль <application>tsearch2</"
"application> прежде чем восстанавливать базу; тогда он предотвратит загрузку "
"старых объектов."

#: textsearch.xml:3891(para)
msgid ""
"Text search configuration setup is completely different now. Instead of "
"manually inserting rows into configuration tables, search is configured "
"through the specialized SQL commands shown earlier in this chapter. There is "
"no automated support for converting an existing custom configuration for "
"8.3; you're on your own here."
msgstr ""
"Настройка конфигурации текстового поиска теперь выполняется совсем по-"
"другому. Вместо того, чтобы вручную вставлять строки в таблицы конфигурации, "
"теперь используются специальные SQL-команды, описанные в этой главе ранее. "
"Нестандартные конфигурации в базах версий до 8.3 не будут автоматически "
"преобразованы в новый формат, вам придётся делать это самостоятельно."

#: textsearch.xml:3909(para)
msgid ""
"Configuration files now must be placed in a single specified directory "
"(<filename>$SHAREDIR/tsearch_data</filename>), and must have a specific "
"extension depending on the type of file, as noted previously in the "
"descriptions of the various dictionary types. This restriction was added to "
"forestall security problems."
msgstr ""
"Файлы конфигурации теперь должны размещаться в одном каталоге (<filename>"
"$SHAREDIR/tsearch_data</filename>) и иметь определённые расширения, в "
"зависимости от типа, как отмечалось ранее в описании различных типов "
"словарей. Это ограничение было добавлено для предупреждения проблем "
"безопасности."

#: textsearch.xml:3919(para)
msgid ""
"Configuration files must be encoded in UTF-8 encoding, regardless of what "
"database encoding is used."
msgstr ""
"Файлы конфигурации должны иметь кодировку UTF-8, вне зависимости от "
"кодировок баз данных."

#: textsearch.xml:3926(para)
msgid ""
"In thesaurus configuration files, stop words must be marked with <literal>?</"
"literal>."
msgstr ""
"В файлах конфигурации тезаурусов стоп-слова должны помечаться знаком "
"<literal>?</literal>."

#: textsearch.xml:3902(para)
msgid ""
"Most types of dictionaries rely on some outside-the-database configuration "
"files. These are largely compatible with pre-8.3 usage, but note the "
"following differences: <placeholder-1/>"
msgstr ""
"Многие типы словарей загружают свои определения и параметры из внешних "
"файлов конфигурации. В основном характер использования этих файлов не "
"изменился в версии 8.3, но есть и следующие различия: <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: textsearch.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#~ msgid ""
#~ "Returns a vector which lists the same lexemes as the given vector, but "
#~ "which lacks any position or weight information. While the returned vector "
#~ "is much less useful than an unstripped vector for relevance ranking, it "
#~ "will usually be much smaller."
#~ msgstr ""
#~ "Возвращает вектор с теми же лексемами, что и в данном, но без информации "
#~ "о позиции и весе. Хотя возвращённый вектор малополезен для ранжирования "
#~ "по релевантности, он обычно имеет гораздо меньший размер, чем полный "
#~ "вектор."
