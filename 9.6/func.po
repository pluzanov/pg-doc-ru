# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-06-27 17:40+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: func.xml:5(title)
msgid "Functions and Operators"
msgstr "Функции и операторы"

#: func.xml:7(indexterm)
msgid "<primary>function</primary>"
msgstr "<primary>функция</primary>"

#: func.xml:11(indexterm)
msgid "<primary>operator</primary>"
msgstr "<primary>оператор</primary>"

#: func.xml:15(para)
msgid ""
"<productname>PostgreSQL</productname> provides a large number of functions "
"and operators for the built-in data types. Users can also define their own "
"functions and operators, as described in <xref linkend=\"server-programming"
"\"/>. The <application>psql</application> commands <command>\\df</command> "
"and <command>\\do</command> can be used to list all available functions and "
"operators, respectively."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет огромное количество "
"функций и операторов для встроенных типов данных. Кроме того, пользователи "
"могут определять свои функции операторы, как описано в <xref remap=\"6\" "
"linkend=\"server-programming\"/>. Просмотреть все существующие функции и "
"операторы можно в <application>psql</application> с помощью команд <command>"
"\\df</command> и <command>\\do</command>, соответственно."

#: func.xml:25(para)
msgid ""
"If you are concerned about portability then note that most of the functions "
"and operators described in this chapter, with the exception of the most "
"trivial arithmetic and comparison operators and some explicitly marked "
"functions, are not specified by the <acronym>SQL</acronym> standard. Some of "
"this extended functionality is present in other <acronym>SQL</acronym> "
"database management systems, and in many cases this functionality is "
"compatible and consistent between the various implementations. This chapter "
"is also not exhaustive; additional functions appear in relevant sections of "
"the manual."
msgstr ""
"Если для вас важна переносимость, учтите, что практически все функции и "
"операторы, описанные в этой главе, за исключением простейших арифметических "
"и операторов сравнения, а также явно отмеченных функций, не описаны в "
"стандарте <acronym>SQL</acronym>. Тем не менее, частично эта расширенная "
"функциональность присутствует и в других СУБД <acronym>SQL</acronym> и во "
"многих случаях различные реализации одинаковых функций оказываются "
"аналогичными и совместимыми. В этой главе не описываются абсолютно все "
"функции; некоторые дополнительные функции рассматриваются в других разделах "
"документации."

#: func.xml:40(title)
msgid "Logical Operators"
msgstr "Логические операторы"

#: func.xml:42(indexterm)
msgid "<primary>operator</primary><secondary>logical</secondary>"
msgstr "<primary>оператор</primary><secondary>логический</secondary>"

#: func.xml:46(indexterm)
msgid ""
"<primary>Boolean</primary><secondary>operators</secondary><see>operators, "
"logical</see>"
msgstr ""
"<primary>Булевы</primary><secondary>операторы</secondary><see>операторы, "
"логические</see>"

#: func.xml:53(indexterm)
msgid "<primary>AND (operator)</primary>"
msgstr "<primary>AND (оператор)</primary>"

#: func.xml:57(indexterm)
msgid "<primary>OR (operator)</primary>"
msgstr "<primary>OR (оператор)</primary>"

#: func.xml:61(indexterm)
msgid "<primary>NOT (operator)</primary>"
msgstr "<primary>NOT (оператор)</primary>"

#: func.xml:65(indexterm)
msgid "<primary>conjunction</primary>"
msgstr "<primary>конъюнкция</primary>"

#: func.xml:69(indexterm)
msgid "<primary>disjunction</primary>"
msgstr "<primary>дизъюнкция</primary>"

#: func.xml:73(indexterm)
msgid "<primary>negation</primary>"
msgstr "<primary>отрицание</primary>"

#: func.xml:78(literal)
msgid "AND"
msgstr "AND"

#: func.xml:79(literal)
msgid "OR"
msgstr "OR"

#: func.xml:80(literal)
msgid "NOT"
msgstr "NOT"

#: func.xml:91(replaceable) func.xml:148(replaceable)
msgctxt "replaceable"
msgid "a"
msgstr "a"

#: func.xml:92(replaceable)
msgctxt "replaceable"
msgid "b"
msgstr "b"

#: func.xml:93(entry)
msgid "<replaceable>a</replaceable> AND <replaceable>b</replaceable>"
msgstr "<replaceable>a</replaceable> AND <replaceable>b</replaceable>"

#: func.xml:94(entry)
msgid "<replaceable>a</replaceable> OR <replaceable>b</replaceable>"
msgstr "<replaceable>a</replaceable> OR <replaceable>b</replaceable>"

#: func.xml:100(entry) func.xml:101(entry) func.xml:102(entry)
#: func.xml:103(entry) func.xml:107(entry) func.xml:110(entry)
#: func.xml:114(entry) func.xml:117(entry) func.xml:155(entry)
#: func.xml:161(entry)
msgid "TRUE"
msgstr "TRUE"

#: func.xml:108(entry) func.xml:109(entry) func.xml:121(entry)
#: func.xml:122(entry) func.xml:123(entry) func.xml:124(entry)
#: func.xml:128(entry) func.xml:130(entry) func.xml:156(entry)
#: func.xml:160(entry)
msgid "FALSE"
msgstr "FALSE"

#: func.xml:115(entry) func.xml:116(entry) func.xml:129(entry)
#: func.xml:131(entry) func.xml:135(entry) func.xml:136(entry)
#: func.xml:137(entry) func.xml:138(entry) func.xml:165(entry)
#: func.xml:166(entry)
msgctxt "entry"
msgid "NULL"
msgstr "NULL"

#: func.xml:149(entry)
msgid "NOT <replaceable>a</replaceable>"
msgstr "NOT <replaceable>a</replaceable>"

#: func.xml:50(para)
msgid ""
"The usual logical operators are available: <placeholder-1/>\n"
"\n"
"    <placeholder-2/>\n"
"\n"
"    <placeholder-3/>\n"
"\n"
"    <placeholder-4/>\n"
"\n"
"    <placeholder-5/>\n"
"\n"
"    <placeholder-6/>\n"
"\n"
"    <placeholder-7/>\n"
"\n"
"    <acronym>SQL</acronym> uses a three-valued logic system with true, "
"false, and <literal>null</literal>, which represents <quote>unknown</quote>. "
"Observe the following truth tables: <placeholder-8/>\n"
"\n"
"    <placeholder-9/>"
msgstr ""
"Набор логических операторов включает обычные: <placeholder-1/>\n"
"\n"
"<placeholder-2/>\n"
"\n"
"<placeholder-3/>\n"
"\n"
"<placeholder-4/>\n"
"\n"
"<placeholder-5/>\n"
"\n"
"<placeholder-6/>\n"
"\n"
"<placeholder-7/>\n"
"\n"
"В <acronym>SQL</acronym> работает логическая система с тремя состояниями: "
"true (истина), false (ложь) и <literal>NULL</literal>, "
"<quote>неопределённое</quote> состояние. Рассмотрите следующие таблицы "
"истинности: <placeholder-8/>\n"
"\n"
"<placeholder-9/>"

#: func.xml:173(para)
msgid ""
"The operators <literal>AND</literal> and <literal>OR</literal> are "
"commutative, that is, you can switch the left and right operand without "
"affecting the result. But see <xref linkend=\"syntax-express-eval\"/> for "
"more information about the order of evaluation of subexpressions."
msgstr ""
"Операторы <literal>AND</literal> и <literal>OR</literal> коммутативны, то "
"есть от перемены мест операндов результат не меняется. Однако значение может "
"иметь порядок вычисления подвыражений. Подробнее это описано в <xref remap="
"\"6\" linkend=\"syntax-express-eval\"/>."

#: func.xml:183(title)
#, fuzzy
msgid "Comparison Functions and Operators"
msgstr "Строковые функции и операторы"

#: func.xml:185(indexterm)
msgid "<primary>comparison</primary><secondary>operators</secondary>"
msgstr "<primary>сравнение</primary><secondary>операторы</secondary>"

#: func.xml:189(para)
#, fuzzy
msgid ""
"The usual comparison operators are available, as shown in <xref linkend="
"\"functions-comparison-op-table\"/>."
msgstr ""
"Набор операторов сравнения включает обычные операторы, перечисленные в "
"таблице <xref remap=\"6\" linkend=\"functions-comparison-table\"/>."

#: func.xml:195(title)
msgid "Comparison Operators"
msgstr "Операторы сравнения"

#: func.xml:199(entry) func.xml:485(entry) func.xml:3565(entry)
#: func.xml:3983(entry) func.xml:6476(entry) func.xml:8030(entry)
#: func.xml:8566(entry) func.xml:8936(entry) func.xml:10335(entry)
#: func.xml:10428(entry) func.xml:11650(entry) func.xml:12125(entry)
msgid "Operator"
msgstr "Оператор"

#: func.xml:200(entry) func.xml:430(entry) func.xml:486(entry)
#: func.xml:643(entry) func.xml:990(entry) func.xml:1044(entry)
#: func.xml:1240(entry) func.xml:1468(entry) func.xml:3246(entry)
#: func.xml:3360(entry) func.xml:3566(entry) func.xml:3984(entry)
#: func.xml:4335(entry) func.xml:4521(entry) func.xml:4735(entry)
#: func.xml:4876(entry) func.xml:4933(entry) func.xml:4989(entry)
#: func.xml:5070(entry) func.xml:5514(entry) func.xml:5619(entry)
#: func.xml:5846(entry) func.xml:6097(entry) func.xml:6251(entry)
#: func.xml:6607(entry) func.xml:7644(entry) func.xml:7926(entry)
#: func.xml:8031(entry) func.xml:8248(entry) func.xml:8351(entry)
#: func.xml:8567(entry) func.xml:8677(entry) func.xml:8877(entry)
#: func.xml:8938(entry) func.xml:9033(entry) func.xml:9374(entry)
#: func.xml:10337(entry) func.xml:10430(entry) func.xml:10557(entry)
#: func.xml:10780(entry) func.xml:11200(entry) func.xml:11651(entry)
#: func.xml:11835(entry) func.xml:12126(entry) func.xml:12324(entry)
#: func.xml:12465(entry) func.xml:12908(entry) func.xml:13318(entry)
#: func.xml:13476(entry) func.xml:13592(entry) func.xml:13689(entry)
#: func.xml:14621(entry) func.xml:14728(entry) func.xml:14872(entry)
#: func.xml:15247(entry) func.xml:15668(entry) func.xml:15925(entry)
#: func.xml:16294(entry) func.xml:16402(entry) func.xml:16492(entry)
#: func.xml:16547(entry) func.xml:16608(entry) func.xml:16648(entry)
#: func.xml:17011(entry) func.xml:17122(entry) func.xml:17257(entry)
#: func.xml:17496(entry) func.xml:17576(entry) func.xml:17667(entry)
#: func.xml:17736(entry) func.xml:18153(entry) func.xml:18403(entry)
#: func.xml:18490(entry) func.xml:18552(entry) func.xml:18672(entry)
#: func.xml:19030(entry) func.xml:19117(entry) func.xml:19250(entry)
msgid "Description"
msgstr "Описание"

#: func.xml:206(literal) func.xml:8573(literal) func.xml:11672(literal)
#: func.xml:12147(literal)
msgid "&lt;"
msgstr "&lt;"

#: func.xml:207(entry) func.xml:11673(entry) func.xml:12148(entry)
msgid "less than"
msgstr "меньше"

#: func.xml:211(literal) func.xml:8593(literal) func.xml:11679(literal)
#: func.xml:12154(literal)
msgid "&gt;"
msgstr "&gt;"

#: func.xml:212(entry) func.xml:11680(entry) func.xml:12155(entry)
msgid "greater than"
msgstr "больше"

#: func.xml:216(literal) func.xml:8578(literal) func.xml:11686(literal)
#: func.xml:12161(literal)
msgid "&lt;="
msgstr "&lt;="

#: func.xml:217(entry)
msgid "less than or equal to"
msgstr "меньше или равно"

#: func.xml:221(literal) func.xml:8588(literal) func.xml:11693(literal)
#: func.xml:12168(literal)
msgid "&gt;="
msgstr "&gt;="

#: func.xml:222(entry)
msgid "greater than or equal to"
msgstr "больше или равно"

#: func.xml:226(literal) func.xml:8583(literal) func.xml:11658(literal)
#: func.xml:12133(literal)
msgid "="
msgstr "="

#: func.xml:227(entry) func.xml:11659(entry) func.xml:12134(entry)
msgid "equal"
msgstr "равно"

#: func.xml:231(entry)
msgid "<literal>&lt;&gt;</literal> or <literal>!=</literal>"
msgstr "<literal>&lt;&gt;</literal> или <literal>!=</literal>"

#: func.xml:232(entry) func.xml:11666(entry) func.xml:12141(entry)
msgid "not equal"
msgstr "не равно"

#: func.xml:239(para)
msgid ""
"The <literal>!=</literal> operator is converted to <literal>&lt;&gt;</"
"literal> in the parser stage. It is not possible to implement <literal>!=</"
"literal> and <literal>&lt;&gt;</literal> operators that do different things."
msgstr ""
"Оператор <literal>!=</literal> преобразуется в <literal>&lt;&gt;</literal> "
"на стадии разбора запроса. Как следствие, реализовать операторы <literal>!=</"
"literal> и <literal>&lt;&gt;</literal> по-разному невозможно."

#: func.xml:247(para)
msgid ""
"Comparison operators are available for all relevant data types. All "
"comparison operators are binary operators that return values of type "
"<type>boolean</type>; expressions like <literal>1 &lt; 2 &lt; 3</literal> "
"are not valid (because there is no <literal>&lt;</literal> operator to "
"compare a Boolean value with <literal>3</literal>)."
msgstr ""
"Операторы сравнения определены для всех типов данных, для которых они имеют "
"смысл. Все операторы сравнения представляют собой бинарные операторы, "
"возвращающие значения типа <type>boolean</type>; при этом выражения вида "
"<literal>1 &lt; 2 &lt; 3</literal> недопустимы (так как не существует "
"оператора <literal>&lt;</literal>, который бы сравнивал булево значение с "
"<literal>3</literal>)."

#: func.xml:257(indexterm)
msgid "<primary>BETWEEN</primary>"
msgstr "<primary>BETWEEN</primary>"

#: func.xml:271(indexterm)
msgid "<primary>BETWEEN SYMMETRIC</primary>"
msgstr "<primary>BETWEEN SYMMETRIC</primary>"

#: func.xml:256(para)
msgid ""
"<placeholder-1/> In addition to the comparison operators, the special "
"<token>BETWEEN</token> construct is available: <synopsis><replaceable>a</"
"replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</"
"replaceable></synopsis> is equivalent to <synopsis><replaceable>a</"
"replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</"
"replaceable> &lt;= <replaceable>y</replaceable></synopsis> Notice that "
"<token>BETWEEN</token> treats the endpoint values as included in the range. "
"<literal>NOT BETWEEN</literal> does the opposite comparison: "
"<synopsis><replaceable>a</replaceable> NOT BETWEEN <replaceable>x</"
"replaceable> AND <replaceable>y</replaceable></synopsis> is equivalent to "
"<synopsis><replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR "
"<replaceable>a</replaceable> &gt; <replaceable>y</replaceable></synopsis>\n"
"    <placeholder-2/>\n"
"    <literal>BETWEEN SYMMETRIC</literal> is the same as <literal>BETWEEN</"
"literal> except there is no requirement that the argument to the left of "
"<literal>AND</literal> be less than or equal to the argument on the right. "
"If it is not, those two arguments are automatically swapped, so that a "
"nonempty range is always implied."
msgstr ""
"<placeholder-1/> Операторы сравнения дополняет специальная конструкция "
"<token>BETWEEN</token>: <synopsis><replaceable>a</replaceable> BETWEEN "
"<replaceable>x</replaceable> AND <replaceable>y</replaceable></synopsis> "
"равнозначно выражению <synopsis><replaceable>a</replaceable> &gt;= "
"<replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= "
"<replaceable>y</replaceable></synopsis> Заметьте, что <token>BETWEEN</token> "
"считает, что границы интервала также включаются в интервал. <literal>NOT "
"BETWEEN</literal> выполняет противоположное сравнение: "
"<synopsis><replaceable>a</replaceable> NOT BETWEEN <replaceable>x</"
"replaceable> AND <replaceable>y</replaceable></synopsis> равнозначно "
"выражению <synopsis><replaceable>a</replaceable> &lt; <replaceable>x</"
"replaceable> OR <replaceable>a</replaceable> &gt; <replaceable>y</"
"replaceable></synopsis>\n"
"<placeholder-2/>\n"
"Конструкция <literal>BETWEEN SYMMETRIC</literal> аналогична "
"<literal>BETWEEN</literal>, за исключением того, что аргумент слева от "
"<literal>AND</literal> не обязательно должен быть меньше или равен аргументу "
"справа. Если это не так, аргументы автоматически меняются местами, то есть "
"интервал всегда будет не пустым."

#: func.xml:282(indexterm)
msgid "<primary>IS NULL</primary>"
msgstr "<primary>IS NULL</primary>"

#: func.xml:285(indexterm)
msgid "<primary>IS NOT NULL</primary>"
msgstr "<primary>IS NOT NULL</primary>"

#: func.xml:288(indexterm)
msgid "<primary>ISNULL</primary>"
msgstr "<primary>ISNULL</primary>"

#: func.xml:291(indexterm)
msgid "<primary>NOTNULL</primary>"
msgstr "<primary>NOTNULL</primary>"

#: func.xml:300(indexterm)
msgid "<primary>null value</primary><secondary>comparing</secondary>"
msgstr "<primary>NULL</primary><secondary>сравнение</secondary>"

#: func.xml:281(para)
msgid ""
"<placeholder-1/>\n"
"    <placeholder-2/>\n"
"    <placeholder-3/>\n"
"    <placeholder-4/> To check whether a value is or is not null, use the "
"constructs: <synopsis><replaceable>expression</replaceable> IS NULL\n"
"<replaceable>expression</replaceable> IS NOT NULL</synopsis> or the "
"equivalent, but nonstandard, constructs: <synopsis><replaceable>expression</"
"replaceable> ISNULL\n"
"<replaceable>expression</replaceable> NOTNULL</synopsis>\n"
"    <placeholder-5/>"
msgstr ""
"<placeholder-1/>\n"
"<placeholder-2/>\n"
"<placeholder-3/>\n"
"<placeholder-4/> Для проверки, содержит ли значение NULL или нет, "
"используются конструкции: <synopsis><replaceable>выражение</replaceable> IS "
"NULL\n"
"<replaceable>выражение</replaceable> IS NOT NULL</synopsis> или равнозначные "
"(но нестандартные) конструкции: <synopsis><replaceable>выражение</"
"replaceable> ISNULL\n"
"<replaceable>выражение</replaceable> NOTNULL</synopsis>\n"
"<placeholder-5/>"

#: func.xml:303(para)
msgid ""
"Do <emphasis>not</emphasis> write <literal><replaceable>expression</"
"replaceable> = NULL</literal> because <literal>NULL</literal> is not "
"<quote>equal to</quote>\n"
"    <literal>NULL</literal>. (The null value represents an unknown value, "
"and it is not known whether two unknown values are equal.) This behavior "
"conforms to the SQL standard."
msgstr ""
"Заметьте, что проверка <literal><replaceable>выражение</replaceable> = NULL</"
"literal> <emphasis>не</emphasis> будет работать, так как <literal>NULL</"
"literal> считается <quote>не равным</quote> <literal>NULL</literal>. "
"(Значение NULL представляет неопределённость и равны ли две "
"неопределённости, тоже не определено.) Это поведение полностью соответствует "
"стандарту SQL."

#: func.xml:313(para)
msgid ""
"Some applications might expect that <literal><replaceable>expression</"
"replaceable> = NULL</literal> returns true if <replaceable>expression</"
"replaceable> evaluates to the null value. It is highly recommended that "
"these applications be modified to comply with the SQL standard. However, if "
"that cannot be done the <xref linkend=\"guc-transform-null-equals\"/> "
"configuration variable is available. If it is enabled, "
"<productname>PostgreSQL</productname> will convert <literal>x = NULL</"
"literal> clauses to <literal>x IS NULL</literal>."
msgstr ""
"Некоторые приложения могут ожидать, что <literal><replaceable>выражение</"
"replaceable> = NULL</literal> вернёт true, если результатом "
"<replaceable>выражения</replaceable> является NULL. Такие приложения "
"настоятельно рекомендуется исправить и привести в соответствие со стандартом "
"SQL. Однако, в случаях, когда это невозможно, это поведение можно изменить с "
"помощью параметра конфигурации <xref linkend=\"guc-transform-null-equals\"/"
">. Когда этот параметр включён, <productname>PostgreSQL</productname> "
"преобразует условие <literal>x = NULL</literal> в <literal>x IS NULL</"
"literal>."

#: func.xml:327(para)
msgid ""
"If the <replaceable>expression</replaceable> is row-valued, then <literal>IS "
"NULL</literal> is true when the row expression itself is null or when all "
"the row's fields are null, while <literal>IS NOT NULL</literal> is true when "
"the row expression itself is non-null and all the row's fields are non-null. "
"Because of this behavior, <literal>IS NULL</literal> and <literal>IS NOT "
"NULL</literal> do not always return inverse results for row-valued "
"expressions, i.e., a row-valued expression that contains both NULL and non-"
"null values will return false for both tests. This definition conforms to "
"the SQL standard, and is a change from the inconsistent behavior exhibited "
"by <productname>PostgreSQL</productname> versions prior to 8.2."
msgstr ""
"Если <replaceable>выражение</replaceable> возвращает табличную строку, тогда "
"условие <literal>IS NULL</literal> будет истинным, когда само выражение "
"равно NULL или все поля строки равны NULL, а <literal>IS NOT NULL</literal> "
"будет истинным, когда выражение не равно NULL и все поля строки также не "
"NULL. Вследствие такого определения, <literal>IS NULL</literal> и "
"<literal>IS NOT NULL</literal> не всегда будут возвращать взаимодополняющие "
"результаты для таких выражений, так как для строк, одни поля которых NULL, а "
"другие не NULL, оба условия будут ложными. Это поведение соответствует "
"стандарту SQL и отличается от того, как это было реализовано в "
"<productname>PostgreSQL</productname> до версии 8.2."

#: func.xml:344(indexterm) func.xml:14303(indexterm)
msgid "<primary>IS DISTINCT FROM</primary>"
msgstr "<primary>IS DISTINCT FROM</primary>"

#: func.xml:347(indexterm) func.xml:14307(indexterm)
msgid "<primary>IS NOT DISTINCT FROM</primary>"
msgstr "<primary>IS NOT DISTINCT FROM</primary>"

#: func.xml:343(para)
msgid ""
"<placeholder-1/>\n"
"    <placeholder-2/> Ordinary comparison operators yield null (signifying "
"<quote>unknown</quote>), not true or false, when either input is null. For "
"example, <literal>7 = NULL</literal> yields null, as does <literal>7 &lt;"
"&gt; NULL</literal>. When this behavior is not suitable, use the <literal>IS "
"<optional> NOT </optional> DISTINCT FROM</literal> constructs: "
"<synopsis><replaceable>expression</replaceable> IS DISTINCT FROM "
"<replaceable>expression</replaceable>\n"
"<replaceable>expression</replaceable> IS NOT DISTINCT FROM "
"<replaceable>expression</replaceable></synopsis> For non-null inputs, "
"<literal>IS DISTINCT FROM</literal> is the same as the <literal>&lt;&gt;</"
"literal> operator. However, if both inputs are null it returns false, and if "
"only one input is null it returns true. Similarly, <literal>IS NOT DISTINCT "
"FROM</literal> is identical to <literal>=</literal> for non-null inputs, but "
"it returns true when both inputs are null, and false when only one input is "
"null. Thus, these constructs effectively act as though null were a normal "
"data value, rather than <quote>unknown</quote>."
msgstr ""
"<placeholder-1/>\n"
"<placeholder-2/> Обычные операторы сравнения выдают NULL (что означает "
"<quote>неопределённость</quote>), а не true или false, когда любое из "
"сравниваемых значений NULL. Например, <literal>7 = NULL</literal> выдаёт "
"NULL, так же, как и <literal>7 &lt;&gt; NULL</literal>. Когда это поведение "
"нежелательно, можно использовать конструкции <literal>IS <optional> NOT </"
"optional> DISTINCT FROM</literal>: <synopsis><replaceable>выражение</"
"replaceable> IS DISTINCT FROM <replaceable>выражение</replaceable>\n"
"<replaceable>выражение</replaceable> IS NOT DISTINCT FROM "
"<replaceable>выражение</replaceable></synopsis> Для значений не NULL условие "
"<literal>IS DISTINCT FROM</literal> работает так же, как оператор "
"<literal>&lt;&gt;</literal>. Однако, если оба сравниваемых значения NULL, "
"результат будет false, и только если одно из значений NULL, возвращается "
"true. Аналогично, условие <literal>IS NOT DISTINCT FROM</literal> "
"равносильно <literal>=</literal> для значений не NULL, но возвращает true, "
"если оба сравниваемых значения NULL и false в противном случае. Таким "
"образом, эти конструкции по сути работают с NULL, как с обычным значением, а "
"не с <quote>неопределённостью</quote>."

#: func.xml:368(indexterm)
msgid "<primary>IS TRUE</primary>"
msgstr "<primary>IS TRUE</primary>"

#: func.xml:371(indexterm)
msgid "<primary>IS NOT TRUE</primary>"
msgstr "<primary>IS NOT TRUE</primary>"

#: func.xml:374(indexterm)
msgid "<primary>IS FALSE</primary>"
msgstr "<primary>IS FALSE</primary>"

#: func.xml:377(indexterm)
msgid "<primary>IS NOT FALSE</primary>"
msgstr "<primary>IS NOT FALSE</primary>"

#: func.xml:380(indexterm)
msgid "<primary>IS UNKNOWN</primary>"
msgstr "<primary>IS UNKNOWN</primary>"

#: func.xml:383(indexterm)
msgid "<primary>IS NOT UNKNOWN</primary>"
msgstr "<primary>IS NOT UNKNOWN</primary>"

#: func.xml:367(para)
msgid ""
"<placeholder-1/>\n"
"    <placeholder-2/>\n"
"    <placeholder-3/>\n"
"    <placeholder-4/>\n"
"    <placeholder-5/>\n"
"    <placeholder-6/> Boolean values can also be tested using the constructs "
"<synopsis><replaceable>expression</replaceable> IS TRUE\n"
"<replaceable>expression</replaceable> IS NOT TRUE\n"
"<replaceable>expression</replaceable> IS FALSE\n"
"<replaceable>expression</replaceable> IS NOT FALSE\n"
"<replaceable>expression</replaceable> IS UNKNOWN\n"
"<replaceable>expression</replaceable> IS NOT UNKNOWN</synopsis> These will "
"always return true or false, never a null value, even when the operand is "
"null. A null input is treated as the logical value <quote>unknown</quote>. "
"Notice that <literal>IS UNKNOWN</literal> and <literal>IS NOT UNKNOWN</"
"literal> are effectively the same as <literal>IS NULL</literal> and "
"<literal>IS NOT NULL</literal>, respectively, except that the input "
"expression must be of Boolean type."
msgstr ""
"<placeholder-1/>\n"
"<placeholder-2/>\n"
"<placeholder-3/>\n"
"<placeholder-4/>\n"
"<placeholder-5/>\n"
"<placeholder-6/> Логические значения можно также проверить с помощью условий "
"<synopsis><replaceable>выражение</replaceable> IS TRUE\n"
"<replaceable>выражение</replaceable> IS NOT TRUE\n"
"<replaceable>выражение</replaceable> IS FALSE\n"
"<replaceable>выражение</replaceable> IS NOT FALSE\n"
"<replaceable>выражение</replaceable> IS UNKNOWN\n"
"<replaceable>выражение</replaceable> IS NOT UNKNOWN</synopsis> Они всегда "
"возвращают true или false и никогда NULL, даже если какой-любо операнд NULL. "
"Они интерпретируют значение NULL как <quote>неизвестное</quote> логическое "
"состояние. Заметьте, что <literal>IS UNKNOWN</literal> и <literal>IS NOT "
"UNKNOWN</literal> по сути равнозначны <literal>IS NULL</literal> и "
"<literal>IS NOT NULL</literal>, соответственно, за исключением того, что "
"выражение может быть только булевого типа."

#. IS OF does not conform to the ISO SQL behavior, so it is undocumented here
#.    <para>
#.     <indexterm>
#.      <primary>IS OF</primary>
#.     </indexterm>
#.     <indexterm>
#.      <primary>IS NOT OF</primary>
#.     </indexterm>
#.     It is possible to check the data type of an expression using the
#.     constructs
#. <synopsis><replaceable>expression</replaceable> IS OF (typename, ...)
#. <replaceable>expression</replaceable> IS NOT OF (typename, ...)</synopsis>
#.     They return a boolean value based on whether the expression's data
#.     type is one of the listed data types.
#.    </para>
#: func.xml:419(para)
#, fuzzy
msgid ""
"Some comparison-related functions are also available, as shown in <xref "
"linkend=\"functions-comparison-func-table\"/>."
msgstr ""
"Набор операторов сравнения включает обычные операторы, перечисленные в "
"таблице <xref remap=\"6\" linkend=\"functions-comparison-table\"/>."

#: func.xml:425(title)
#, fuzzy
msgid "Comparison Functions"
msgstr "Главные функции"

#: func.xml:429(entry) func.xml:641(entry) func.xml:988(entry)
#: func.xml:1238(entry) func.xml:1466(entry) func.xml:3244(entry)
#: func.xml:3358(entry) func.xml:5512(entry) func.xml:6605(entry)
#: func.xml:7925(entry) func.xml:8246(entry) func.xml:8349(entry)
#: func.xml:8675(entry) func.xml:8875(entry) func.xml:9031(entry)
#: func.xml:9372(entry) func.xml:10556(entry) func.xml:10778(entry)
#: func.xml:11200(entry) func.xml:11833(entry) func.xml:12322(entry)
#: func.xml:12461(entry) func.xml:12904(entry) func.xml:13313(entry)
#: func.xml:13471(entry) func.xml:13590(entry) func.xml:13687(entry)
#: func.xml:14618(entry) func.xml:14726(entry) func.xml:17734(entry)
msgid "Function"
msgstr "Функция"

#: func.xml:431(entry) func.xml:487(entry) func.xml:644(entry)
#: func.xml:1241(entry) func.xml:1469(entry) func.xml:3247(entry)
#: func.xml:3361(entry) func.xml:3567(entry) func.xml:3985(entry)
#: func.xml:5515(entry) func.xml:5847(entry) func.xml:6252(entry)
#: func.xml:6477(entry) func.xml:6608(entry) func.xml:7927(entry)
#: func.xml:8032(entry) func.xml:8249(entry) func.xml:8352(entry)
#: func.xml:8568(entry) func.xml:8678(entry) func.xml:8878(entry)
#: func.xml:8939(entry) func.xml:9034(entry) func.xml:9375(entry)
#: func.xml:10338(entry) func.xml:10431(entry) func.xml:10558(entry)
#: func.xml:10781(entry) func.xml:11652(entry) func.xml:11836(entry)
#: func.xml:12127(entry) func.xml:12325(entry)
msgid "Example"
msgstr "Пример"

#: func.xml:432(entry) func.xml:7928(entry) func.xml:10339(entry)
#: func.xml:10559(entry) func.xml:10782(entry)
msgid "Example Result"
msgstr "Результат примера"

#: func.xml:438(indexterm)
#, fuzzy
msgid "<primary>num_nonnulls</primary>"
msgstr "<primary>enum_last</primary>"

#: func.xml:441(literal)
#, fuzzy
msgid "num_nonnulls(VARIADIC \"any\")"
msgstr "json_build_array(VARIADIC \"any\")"

#: func.xml:443(entry)
#, fuzzy
msgid "returns the number of non-NULL arguments"
msgstr "возвращает число размерностей массива"

#: func.xml:444(literal)
msgid "num_nonnulls(1, NULL, 2)"
msgstr ""

#: func.xml:445(literal) func.xml:518(literal) func.xml:609(literal)
#: func.xml:726(literal) func.xml:778(literal) func.xml:884(literal)
#: func.xml:971(literal) func.xml:2118(literal) func.xml:10370(literal)
#: func.xml:11872(literal) func.xml:11931(literal)
msgctxt "literal"
msgid "2"
msgstr "2"

#: func.xml:449(indexterm)
#, fuzzy
msgid "<primary>num_nulls</primary>"
msgstr "<primary>enum_last</primary>"

#: func.xml:452(literal)
#, fuzzy
msgid "num_nulls(VARIADIC \"any\")"
msgstr "json_build_array(VARIADIC \"any\")"

#: func.xml:454(entry)
#, fuzzy
msgid "returns the number of NULL arguments"
msgstr "возвращает число размерностей массива"

#: func.xml:455(literal)
msgid "num_nulls(1, NULL, 2)"
msgstr ""

#: func.xml:456(literal) func.xml:525(literal) func.xml:801(literal)
#: func.xml:3434(literal)
msgctxt "literal"
msgid "1"
msgstr "1"

#: func.xml:465(title)
msgid "Mathematical Functions and Operators"
msgstr "Математические функции и операторы"

#: func.xml:467(para)
msgid ""
"Mathematical operators are provided for many <productname>PostgreSQL</"
"productname> types. For types without standard mathematical conventions (e."
"g., date/time types) we describe the actual behavior in subsequent sections."
msgstr ""
"Математические операторы определены для множества типов "
"<productname>PostgreSQL</productname>. Как работают эти операции с типами, "
"для которых нет стандартных соглашений о математических действиях (например, "
"с типами даты/времени), мы опишем в последующих разделах."

#: func.xml:475(para)
msgid ""
"<xref linkend=\"functions-math-op-table\"/> shows the available mathematical "
"operators."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-math-op-table\"/> перечислены все "
"доступные математические операторы."

#: func.xml:480(title)
msgid "Mathematical Operators"
msgstr "Математические операторы"

#: func.xml:488(entry) func.xml:645(entry) func.xml:1242(entry)
#: func.xml:1470(entry) func.xml:3248(entry) func.xml:3362(entry)
#: func.xml:3568(entry) func.xml:6286(entry) func.xml:6478(entry)
#: func.xml:6609(entry) func.xml:8679(entry) func.xml:8879(entry)
#: func.xml:8940(entry) func.xml:9035(entry) func.xml:9376(entry)
#: func.xml:11653(entry) func.xml:11837(entry) func.xml:12128(entry)
#: func.xml:12326(entry)
msgid "Result"
msgstr "Результат"

#: func.xml:494(literal) func.xml:4428(literal) func.xml:6484(literal)
#: func.xml:6490(literal) func.xml:6496(literal) func.xml:6502(literal)
#: func.xml:6508(literal) func.xml:6514(literal) func.xml:8037(literal)
#: func.xml:8643(literal) func.xml:12245(literal)
msgid "+"
msgstr "+"

#: func.xml:495(entry) func.xml:8644(entry)
msgid "addition"
msgstr "сложение"

#: func.xml:496(literal)
msgid "2 + 3"
msgstr "2 + 3"

#: func.xml:497(literal) func.xml:539(literal) func.xml:567(literal)
#: func.xml:3277(literal) func.xml:3470(literal) func.xml:9085(literal)
#: func.xml:10795(literal)
msgctxt "literal"
msgid "5"
msgstr "5"

#: func.xml:501(literal) func.xml:6520(literal) func.xml:6526(literal)
#: func.xml:6532(literal) func.xml:6538(literal) func.xml:6544(literal)
#: func.xml:6550(literal) func.xml:6556(literal) func.xml:6562(literal)
#: func.xml:6568(literal) func.xml:8042(literal) func.xml:8648(literal)
#: func.xml:8653(literal) func.xml:10477(literal) func.xml:10485(literal)
#: func.xml:12259(literal)
msgid "-"
msgstr "-"

#: func.xml:502(entry) func.xml:8649(entry) func.xml:8654(entry)
msgid "subtraction"
msgstr "вычитание"

#: func.xml:503(literal)
msgid "2 - 3"
msgstr "2 - 3"

#: func.xml:504(literal) func.xml:897(literal)
msgid "-1"
msgstr "-1"

#: func.xml:508(literal) func.xml:4423(literal) func.xml:6574(literal)
#: func.xml:6580(literal) func.xml:6586(literal) func.xml:8047(literal)
#: func.xml:12252(literal)
msgid "*"
msgstr "*"

#: func.xml:509(entry)
msgid "multiplication"
msgstr "умножение"

#: func.xml:510(literal)
msgid "2 * 3"
msgstr "2 * 3"

#: func.xml:511(literal) func.xml:8725(literal)
msgid "6"
msgstr "6"

#: func.xml:515(literal) func.xml:6592(literal) func.xml:8052(literal)
msgid "/"
msgstr "/"

#: func.xml:516(entry)
msgid "division (integer division truncates the result)"
msgstr "деление (при целочисленном делении остаток отбрасывается)"

#: func.xml:517(literal)
msgid "4 / 2"
msgstr "4 / 2"

#: func.xml:522(literal)
msgid "%"
msgstr "%"

#: func.xml:523(entry)
msgid "modulo (remainder)"
msgstr "остаток от деления"

#: func.xml:524(literal)
msgid "5 % 4"
msgstr "5 % 4"

#: func.xml:529(literal) func.xml:4527(literal)
msgid "^"
msgstr "^"

#: func.xml:530(entry)
msgid "exponentiation (associates left to right)"
msgstr "возведение в степень (вычисляется слева направо)"

#: func.xml:531(literal)
msgid "2.0 ^ 3.0"
msgstr "2.0 ^ 3.0"

#: func.xml:532(literal)
msgid "8"
msgstr "8"

#: func.xml:536(literal)
msgid "|/"
msgstr "|/"

#: func.xml:537(entry) func.xml:908(entry)
msgid "square root"
msgstr "квадратный корень"

#: func.xml:538(literal)
msgid "|/ 25.0"
msgstr "|/ 25.0"

#: func.xml:543(literal)
msgid "||/"
msgstr "||/"

#: func.xml:544(entry) func.xml:671(entry)
msgid "cube root"
msgstr "кубический корень"

#: func.xml:545(literal)
msgid "||/ 27.0"
msgstr "||/ 27.0"

#: func.xml:546(literal) func.xml:673(literal) func.xml:947(literal)
#: func.xml:959(literal) func.xml:1362(literal) func.xml:3305(literal)
#: func.xml:6718(literal) func.xml:6766(literal) func.xml:9073(literal)
#: func.xml:10363(literal) func.xml:10384(literal) func.xml:11907(literal)
msgctxt "literal"
msgid "3"
msgstr "3"

#: func.xml:550(literal)
msgid "!"
msgstr "!"

#: func.xml:551(entry)
msgid "factorial"
msgstr "факториал"

#: func.xml:552(literal)
msgid "5 !"
msgstr "5 !"

#: func.xml:553(literal) func.xml:560(literal) func.xml:1490(literal)
msgid "120"
msgstr "120"

#: func.xml:557(literal) func.xml:8980(literal)
msgid "!!"
msgstr "!!"

#: func.xml:558(entry)
msgid "factorial (prefix operator)"
msgstr "факториал (префиксная форма)"

#: func.xml:559(literal)
msgid "!! 5"
msgstr "!! 5"

#: func.xml:564(literal)
msgid "@"
msgstr "@"

#: func.xml:565(entry) func.xml:658(entry)
msgid "absolute value"
msgstr "модуль числа (абсолютное значение)"

#: func.xml:566(literal)
msgid "@ -5.0"
msgstr "@ -5.0"

#: func.xml:571(literal) func.xml:3581(literal) func.xml:8633(literal)
msgid "&amp;"
msgstr "&amp;"

#: func.xml:572(entry) func.xml:3582(entry) func.xml:8634(entry)
msgid "bitwise AND"
msgstr "битовый AND"

#: func.xml:573(literal)
msgid "91 &amp; 15"
msgstr "91 &amp; 15"

#: func.xml:574(literal)
msgid "11"
msgstr "11"

#: func.xml:578(literal) func.xml:3588(literal) func.xml:8638(literal)
msgid "|"
msgstr "|"

#: func.xml:579(entry) func.xml:3589(entry) func.xml:8639(entry)
msgid "bitwise OR"
msgstr "битовый OR"

#: func.xml:580(literal)
msgid "32 | 3"
msgstr "32 | 3"

#: func.xml:581(literal)
msgid "35"
msgstr "35"

#: func.xml:585(literal) func.xml:3595(literal) func.xml:8057(literal)
#: func.xml:8062(literal)
msgid "#"
msgstr "#"

#: func.xml:586(entry) func.xml:3596(entry)
msgid "bitwise XOR"
msgstr "битовый XOR"

#: func.xml:587(literal)
msgid "17 # 5"
msgstr "17 # 5"

#: func.xml:588(literal) func.xml:6708(literal) func.xml:6756(literal)
msgctxt "literal"
msgid "20"
msgstr "20"

#: func.xml:592(literal) func.xml:3602(literal) func.xml:3991(literal)
#: func.xml:8628(literal)
msgid "~"
msgstr "~"

#: func.xml:593(entry) func.xml:3603(entry) func.xml:8629(entry)
msgid "bitwise NOT"
msgstr "битовый NOT"

#: func.xml:594(literal)
msgid "~1"
msgstr "~1"

#: func.xml:595(literal)
msgid "-2"
msgstr "-2"

#: func.xml:599(literal) func.xml:3609(literal) func.xml:8092(literal)
#: func.xml:8603(literal) func.xml:12210(literal)
msgid "&lt;&lt;"
msgstr "&lt;&lt;"

#: func.xml:600(entry) func.xml:3610(entry)
msgid "bitwise shift left"
msgstr "битовый сдвиг влево"

#: func.xml:601(literal)
msgid "1 &lt;&lt; 4"
msgstr "1 &lt;&lt; 4"

#: func.xml:602(literal)
msgctxt "literal"
msgid "16"
msgstr "16"

#: func.xml:606(literal) func.xml:3616(literal) func.xml:8097(literal)
#: func.xml:8613(literal) func.xml:12217(literal)
msgid "&gt;&gt;"
msgstr "&gt;&gt;"

#: func.xml:607(entry) func.xml:3617(entry)
msgid "bitwise shift right"
msgstr "битовый сдвиг вправо"

#: func.xml:608(literal)
msgid "8 &gt;&gt; 2"
msgstr "8 &gt;&gt; 2"

#: func.xml:616(para)
msgid ""
"The bitwise operators work only on integral data types, whereas the others "
"are available for all numeric data types. The bitwise operators are also "
"available for the bit string types <type>bit</type> and <type>bit varying</"
"type>, as shown in <xref linkend=\"functions-bit-string-op-table\"/>."
msgstr ""
"Битовые операторы работают только с целостными типами данных, тогда как "
"другие и работают и с остальными числовыми типами. Битовые операции также "
"работают с битовыми строками <type>bit</type> и <type>bit varying</type>, "
"как показано в <xref remap=\"6\" linkend=\"functions-bit-string-op-table\"/>."

#: func.xml:624(para)
msgid ""
"<xref linkend=\"functions-math-func-table\"/> shows the available "
"mathematical functions. In the table, <literal>dp</literal> indicates "
"<type>double precision</type>. Many of these functions are provided in "
"multiple forms with different argument types. Except where noted, any given "
"form of a function returns the same data type as its argument. The functions "
"working with <type>double precision</type> data are mostly implemented on "
"top of the host system's C library; accuracy and behavior in boundary cases "
"can therefore vary depending on the host system."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-math-func-table\"/> перечислены все "
"существующие математические функции. Сокращение <literal>dp</literal> в ней "
"обозначает тип <type>double precision</type> (плавающее с двойной "
"точностью). Многие из этих функций имеют несколько форм с разными типами "
"аргументов. За исключением случаев, где это указано явно, любая форма "
"функции возвращает результат того же типа, что и аргумент. Функции, "
"работающие с данными <type>double precision</type>, в массе своей используют "
"реализации из системных библиотек сервера, поэтому точность и поведение в "
"граничных случаях может зависеть от системы сервера."

#: func.xml:637(title)
msgid "Mathematical Functions"
msgstr "Математические функции"

#: func.xml:642(entry) func.xml:989(entry) func.xml:1239(entry)
#: func.xml:1467(entry) func.xml:3245(entry) func.xml:3359(entry)
#: func.xml:5513(entry) func.xml:6606(entry) func.xml:7643(entry)
#: func.xml:8247(entry) func.xml:8350(entry) func.xml:8676(entry)
#: func.xml:8876(entry) func.xml:8937(entry) func.xml:9032(entry)
#: func.xml:9373(entry) func.xml:10779(entry) func.xml:11200(entry)
#: func.xml:11834(entry) func.xml:12323(entry) func.xml:12463(entry)
#: func.xml:12906(entry) func.xml:13316(entry) func.xml:13474(entry)
#: func.xml:13591(entry) func.xml:13688(entry) func.xml:14620(entry)
#: func.xml:14727(entry) func.xml:14872(entry) func.xml:15247(entry)
#: func.xml:15668(entry) func.xml:15925(entry) func.xml:16294(entry)
#: func.xml:16402(entry) func.xml:16492(entry) func.xml:16608(entry)
#: func.xml:16648(entry) func.xml:17011(entry) func.xml:17122(entry)
#: func.xml:17257(entry) func.xml:17496(entry) func.xml:17576(entry)
#: func.xml:17667(entry) func.xml:17735(entry) func.xml:18153(entry)
#: func.xml:18403(entry) func.xml:18490(entry) func.xml:18552(entry)
#: func.xml:18672(entry) func.xml:19250(entry)
msgid "Return Type"
msgstr "Тип результата"

#: func.xml:652(indexterm)
msgid "<primary>abs</primary>"
msgstr "<primary>abs</primary>"

#: func.xml:655(replaceable) func.xml:1053(replaceable)
#: func.xml:1058(replaceable) func.xml:1068(replaceable)
#: func.xml:1074(replaceable) func.xml:1084(replaceable)
#: func.xml:1090(replaceable) func.xml:1101(replaceable)
#: func.xml:1108(replaceable) func.xml:1119(replaceable)
#: func.xml:1125(replaceable) func.xml:1135(replaceable)
#: func.xml:1141(replaceable) func.xml:1151(replaceable)
#: func.xml:1157(replaceable) func.xml:1167(replaceable)
#: func.xml:1173(replaceable) func.xml:4390(replaceable)
msgctxt "replaceable"
msgid "x"
msgstr "x"

#: func.xml:655(function)
msgid "abs(<placeholder-1/>)"
msgstr "abs(<placeholder-1/>)"

#: func.xml:657(entry) func.xml:683(entry) func.xml:696(entry)
#: func.xml:736(entry) func.xml:749(entry) func.xml:762(entry)
#: func.xml:775(entry) func.xml:860(entry) func.xml:894(entry)
#: func.xml:907(entry) func.xml:920(entry)
msgid "(same as input)"
msgstr "тип аргумента"

#: func.xml:659(literal)
msgid "abs(-17.4)"
msgstr "abs(-17.4)"

#: func.xml:660(literal)
msgid "17.4"
msgstr "17.4"

#: func.xml:665(indexterm)
msgid "<primary>cbrt</primary>"
msgstr "<primary>cbrt</primary>"

#: func.xml:668(type) func.xml:670(type) func.xml:681(type) func.xml:694(type)
#: func.xml:707(type) func.xml:709(type) func.xml:734(type) func.xml:747(type)
#: func.xml:760(type) func.xml:773(type) func.xml:811(type) func.xml:822(type)
#: func.xml:823(type) func.xml:825(type) func.xml:845(type) func.xml:847(type)
#: func.xml:858(type) func.xml:892(type) func.xml:905(type) func.xml:918(type)
#: func.xml:939(type) func.xml:1001(type) func.xml:1010(type)
msgid "dp"
msgstr "dp"

#: func.xml:668(function)
msgid "cbrt(<placeholder-1/>)"
msgstr "cbrt(<placeholder-1/>)"

#: func.xml:672(literal)
msgid "cbrt(27.0)"
msgstr "cbrt(27.0)"

#: func.xml:678(indexterm)
msgid "<primary>ceil</primary>"
msgstr "<primary>ceil</primary>"

#: func.xml:681(type) func.xml:694(type) func.xml:720(type) func.xml:721(type)
#: func.xml:723(type) func.xml:734(type) func.xml:747(type) func.xml:760(type)
#: func.xml:773(type) func.xml:782(type) func.xml:783(type) func.xml:784(type)
#: func.xml:832(type) func.xml:833(type) func.xml:834(type) func.xml:858(type)
#: func.xml:867(type) func.xml:868(type) func.xml:879(type) func.xml:881(type)
#: func.xml:892(type) func.xml:905(type) func.xml:918(type) func.xml:927(type)
#: func.xml:928(type) func.xml:951(type) func.xml:5550(type)
#: func.xml:5573(type) func.xml:17350(type) func.xml:18227(type)
msgid "numeric"
msgstr "numeric"

#: func.xml:681(function)
msgid "ceil(<placeholder-1/> or <placeholder-2/>)"
msgstr "ceil(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:684(entry)
#, fuzzy
msgid "nearest integer greater than or equal to argument"
msgstr "наибольшее целое не больше аргумента"

#: func.xml:685(literal)
msgid "ceil(-42.8)"
msgstr "ceil(-42.8)"

#: func.xml:686(literal)
msgid "-42"
msgstr "-42"

#: func.xml:691(indexterm)
msgid "<primary>ceiling</primary>"
msgstr "<primary>ceiling</primary>"

#: func.xml:694(function)
msgid "ceiling(<placeholder-1/> or <placeholder-2/>)"
msgstr "ceiling(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:697(entry)
#, fuzzy
msgid ""
"nearest integer greater than or equal to argument (same as <function>ceil</"
"function>)"
msgstr ""
"наименьшее целое не меньше аргумента (синоним <function>ceil</function>)"

#: func.xml:698(literal)
msgid "ceiling(-95.3)"
msgstr "ceiling(-95.3)"

#: func.xml:699(literal)
msgid "-95"
msgstr "-95"

#: func.xml:704(indexterm)
msgid "<primary>degrees</primary>"
msgstr "<primary>degrees</primary>"

#: func.xml:707(function)
msgid "degrees(<placeholder-1/>)"
msgstr "degrees(<placeholder-1/>)"

#: func.xml:710(entry)
msgid "radians to degrees"
msgstr "преобразование радианов в градусы"

#: func.xml:711(literal)
msgid "degrees(0.5)"
msgstr "degrees(0.5)"

#: func.xml:712(literal)
msgid "28.6478897565412"
msgstr "28.6478897565&zwsp;412"

#: func.xml:717(indexterm)
msgid "<primary>div</primary>"
msgstr "<primary>div</primary>"

#: func.xml:720(parameter) func.xml:795(parameter)
msgctxt "parameter"
msgid "y"
msgstr "y"

#: func.xml:721(parameter) func.xml:783(parameter) func.xml:796(parameter)
msgctxt "parameter"
msgid "x"
msgstr "x"

#: func.xml:720(function)
msgid ""
"div(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"div(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:724(entry)
msgid "integer quotient of <parameter>y</parameter>/<parameter>x</parameter>"
msgstr ""
"целочисленный результат <parameter>y</parameter>/<parameter>x</parameter>"

#: func.xml:725(literal)
msgid "div(9,4)"
msgstr "div(9,4)"

#: func.xml:731(indexterm)
msgid "<primary>exp</primary>"
msgstr "<primary>exp</primary>"

#: func.xml:734(function)
msgid "exp(<placeholder-1/> or <placeholder-2/>)"
msgstr "exp(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:737(entry)
msgid "exponential"
msgstr "экспонента"

#: func.xml:738(literal)
msgid "exp(1.0)"
msgstr "exp(1.0)"

#: func.xml:739(literal)
msgid "2.71828182845905"
msgstr "2.7182818284&zwsp;5905"

#: func.xml:744(indexterm)
msgid "<primary>floor</primary>"
msgstr "<primary>floor</primary>"

#: func.xml:747(function)
msgid "floor(<placeholder-1/> or <placeholder-2/>)"
msgstr "floor(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:750(entry)
#, fuzzy
msgid "nearest integer less than or equal to argument"
msgstr "наименьшее целое не меньше аргумента"

#: func.xml:751(literal)
msgid "floor(-42.8)"
msgstr "floor(-42.8)"

#: func.xml:752(literal)
msgid "-43"
msgstr "-43"

#: func.xml:757(indexterm)
msgid "<primary>ln</primary>"
msgstr "<primary>ln</primary>"

#: func.xml:760(function)
msgid "ln(<placeholder-1/> or <placeholder-2/>)"
msgstr "ln(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:763(entry)
msgid "natural logarithm"
msgstr "натуральный логарифм"

#: func.xml:764(literal)
msgid "ln(2.0)"
msgstr "ln(2.0)"

#: func.xml:765(literal)
msgid "0.693147180559945"
msgstr "0.6931471805&zwsp;59945"

#: func.xml:770(indexterm)
msgid "<primary>log</primary>"
msgstr "<primary>log</primary>"

#: func.xml:773(function)
msgid "log(<placeholder-1/> or <placeholder-2/>)"
msgstr "log(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:776(entry)
msgid "base 10 logarithm"
msgstr "логарифм по основанию 10"

#: func.xml:777(literal)
msgid "log(100.0)"
msgstr "log(100.0)"

#: func.xml:782(parameter) func.xml:823(parameter) func.xml:833(parameter)
msgctxt "parameter"
msgid "b"
msgstr "b"

#: func.xml:782(function)
msgid ""
"log(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"log(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:785(entry)
msgid "logarithm to base <parameter>b</parameter>"
msgstr "логарифм по основанию <parameter>b</parameter>"

#: func.xml:786(literal)
msgid "log(2.0, 64.0)"
msgstr "log(2.0, 64.0)"

#: func.xml:787(literal)
msgid "6.0000000000"
msgstr "6.0000000000"

#: func.xml:792(indexterm)
msgid "<primary>mod</primary>"
msgstr "<primary>mod</primary>"

#: func.xml:795(function)
msgid "mod(<placeholder-1/>, <placeholder-2/>)"
msgstr "mod(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:798(entry)
msgid "(same as argument types)"
msgstr "зависит от типов аргументов"

#: func.xml:799(entry)
msgid "remainder of <parameter>y</parameter>/<parameter>x</parameter>"
msgstr "остаток от деления <parameter>y</parameter>/<parameter>x</parameter>"

#: func.xml:800(literal)
msgid "mod(9,4)"
msgstr "mod(9,4)"

#: func.xml:806(indexterm)
msgid "<primary>pi</primary>"
msgstr "<primary>pi</primary>"

#: func.xml:809(function)
msgctxt "function"
msgid "pi()"
msgstr "pi()"

#: func.xml:812(entry)
msgid "<quote>&pi;</quote> constant"
msgstr "константа <quote>&pi;</quote>"

#: func.xml:813(literal)
msgctxt "literal"
msgid "pi()"
msgstr "pi()"

#: func.xml:814(literal)
msgid "3.14159265358979"
msgstr "3.1415926535&zwsp;8979"

#: func.xml:819(indexterm)
msgid "<primary>power</primary>"
msgstr "<primary>power</primary>"

#: func.xml:822(parameter) func.xml:832(parameter)
msgctxt "parameter"
msgid "a"
msgstr "a"

#: func.xml:822(function) func.xml:832(function)
msgid ""
"power(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"power(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:826(entry) func.xml:835(entry)
msgid ""
"<parameter>a</parameter> raised to the power of <parameter>b</parameter>"
msgstr "<parameter>a</parameter> возводится в степень <parameter>b</parameter>"

#: func.xml:827(literal) func.xml:836(literal)
msgid "power(9.0, 3.0)"
msgstr "power(9.0, 3.0)"

#: func.xml:828(literal) func.xml:837(literal)
msgid "729"
msgstr "729"

#: func.xml:842(indexterm)
msgid "<primary>radians</primary>"
msgstr "<primary>radians</primary>"

#: func.xml:845(function)
msgid "radians(<placeholder-1/>)"
msgstr "radians(<placeholder-1/>)"

#: func.xml:848(entry)
msgid "degrees to radians"
msgstr "преобразование градусов в радианы"

#: func.xml:849(literal)
msgid "radians(45.0)"
msgstr "radians(45.0)"

#: func.xml:850(literal)
msgid "0.785398163397448"
msgstr "0.7853981633&zwsp;97448"

#: func.xml:855(indexterm)
msgid "<primary>round</primary>"
msgstr "<primary>round</primary>"

#: func.xml:858(function)
msgid "round(<placeholder-1/> or <placeholder-2/>)"
msgstr "round(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:861(entry)
msgid "round to nearest integer"
msgstr "округление до ближайшего целого"

#: func.xml:862(literal)
msgid "round(42.4)"
msgstr "round(42.4)"

#: func.xml:863(literal) func.xml:923(literal)
msgid "42"
msgstr "42"

#: func.xml:867(parameter) func.xml:927(parameter)
msgid "v"
msgstr "v"

#: func.xml:867(parameter) func.xml:927(parameter)
msgctxt "parameter"
msgid "s"
msgstr "s"

#: func.xml:867(type) func.xml:927(type) func.xml:939(type) func.xml:940(type)
#: func.xml:951(type) func.xml:952(type) func.xml:964(type) func.xml:1284(type)
#: func.xml:1297(type) func.xml:1331(type) func.xml:1342(type)
#: func.xml:1359(type) func.xml:1370(type) func.xml:1482(type)
#: func.xml:1516(type) func.xml:1701(type) func.xml:1719(type)
#: func.xml:1730(type) func.xml:1746(type) func.xml:1989(type)
#: func.xml:2036(type) func.xml:2053(type) func.xml:2093(type)
#: func.xml:2110(type) func.xml:2160(type) func.xml:3274(type)
#: func.xml:3285(type) func.xml:3302(type) func.xml:3313(type)
#: func.xml:3429(type) func.xml:3444(type) func.xml:3459(type)
#: func.xml:5537(type) func.xml:6874(type) func.xml:6875(type)
#: func.xml:6876(type) func.xml:6895(type) func.xml:6896(type)
#: func.xml:6897(type) func.xml:6898(type) func.xml:6899(type)
#: func.xml:6900(type) func.xml:6921(type) func.xml:6922(type)
#: func.xml:6942(type) func.xml:6943(type) func.xml:6944(type)
#: func.xml:6945(type) func.xml:6946(type) func.xml:6966(type)
#: func.xml:6967(type) func.xml:6968(type) func.xml:6969(type)
#: func.xml:6970(type) func.xml:8297(type) func.xml:8303(type)
#: func.xml:8721(type) func.xml:8758(type) func.xml:8792(type)
#: func.xml:8800(type) func.xml:10345(type) func.xml:10360(type)
#: func.xml:10790(type) func.xml:11869(type) func.xml:11901(type)
#: func.xml:11904(type) func.xml:11912(type) func.xml:11915(type)
#: func.xml:11923(type) func.xml:11926(type) func.xml:11995(type)
#: func.xml:11998(type) func.xml:12009(type) func.xml:14921(type)
#: func.xml:14933(type) func.xml:14940(type) func.xml:14947(type)
#: func.xml:14990(type) func.xml:17129(type) func.xml:17154(type)
#: func.xml:17804(type) func.xml:17829(type) func.xml:17847(type)
#: func.xml:17864(type) func.xml:18160(type) func.xml:18686(type)
#: func.xml:18700(type) func.xml:18714(type) func.xml:18735(type)
#: func.xml:18749(type) func.xml:18763(type) func.xml:18777(type)
#: func.xml:18791(type) func.xml:18805(type) func.xml:18819(type)
#: func.xml:19268(type)
msgid "int"
msgstr "int"

#: func.xml:867(function)
msgid ""
"round(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"round(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:869(entry)
msgid "round to <parameter>s</parameter> decimal places"
msgstr ""
"округление <parameter>v</parameter> до <parameter>s</parameter> десятичных "
"знаков"

#: func.xml:870(literal)
msgid "round(42.4382, 2)"
msgstr "round(42.4382, 2)"

#: func.xml:871(literal)
msgid "42.44"
msgstr "42.44"

#: func.xml:876(indexterm)
#, fuzzy
msgid "<primary>scale</primary>"
msgstr "<primary>локаль</primary>"

#: func.xml:879(function)
#, fuzzy
msgid "scale(<placeholder-1/>)"
msgstr "age(<placeholder-1/>)"

#: func.xml:882(entry)
msgid ""
"scale of the argument (the number of decimal digits in the fractional part)"
msgstr ""

#: func.xml:883(literal)
#, fuzzy
msgid "scale(8.41)"
msgstr "scale"

#: func.xml:889(indexterm)
msgid "<primary>sign</primary>"
msgstr "<primary>sign</primary>"

#: func.xml:892(function)
msgid "sign(<placeholder-1/> or <placeholder-2/>)"
msgstr "sign(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:895(entry)
msgid "sign of the argument (-1, 0, +1)"
msgstr "знак аргумента (-1, 0, +1)"

#: func.xml:896(literal)
msgid "sign(-8.4)"
msgstr "sign(-8.4)"

#: func.xml:902(indexterm)
msgid "<primary>sqrt</primary>"
msgstr "<primary>sqrt</primary>"

#: func.xml:905(function)
msgid "sqrt(<placeholder-1/> or <placeholder-2/>)"
msgstr "sqrt(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:909(literal)
msgid "sqrt(2.0)"
msgstr "sqrt(2.0)"

#: func.xml:910(literal)
msgid "1.4142135623731"
msgstr "1.4142135623&zwsp;731"

#: func.xml:915(indexterm) func.xml:8885(indexterm)
msgid "<primary>trunc</primary>"
msgstr "<primary>trunc</primary>"

#: func.xml:918(function)
msgid "trunc(<placeholder-1/> or <placeholder-2/>)"
msgstr "trunc(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:921(entry)
msgid "truncate toward zero"
msgstr "округление к нулю"

#: func.xml:922(literal)
msgid "trunc(42.8)"
msgstr "trunc(42.8)"

#: func.xml:927(function)
msgid ""
"trunc(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"trunc(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:929(entry)
msgid "truncate to <parameter>s</parameter> decimal places"
msgstr "округление к 0 до <parameter>s</parameter> десятичных знаков"

#: func.xml:930(literal)
msgid "trunc(42.4382, 2)"
msgstr "trunc(42.4382, 2)"

#: func.xml:931(literal)
msgid "42.43"
msgstr "42.43"

#: func.xml:936(indexterm)
msgid "<primary>width_bucket</primary>"
msgstr "<primary>width_bucket</primary>"

#: func.xml:939(parameter) func.xml:951(parameter) func.xml:963(parameter)
msgid "operand"
msgstr "operand"

#: func.xml:939(parameter) func.xml:951(parameter)
msgid "b1"
msgstr "b1"

#: func.xml:939(parameter) func.xml:951(parameter)
msgid "b2"
msgstr "b2"

#: func.xml:939(parameter) func.xml:951(parameter) func.xml:2126(parameter)
msgid "count"
msgstr "count"

#: func.xml:939(function) func.xml:951(function)
msgid ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>)"
msgstr ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>)"

#: func.xml:941(entry) func.xml:953(entry)
msgid ""
"return the bucket number to which <parameter>operand</parameter> would be "
"assigned in a histogram having <parameter>count</parameter> equal-width "
"buckets spanning the range <parameter>b1</parameter> to <parameter>b2</"
"parameter>; returns <literal>0</literal> or <literal><parameter>count</"
"parameter>+1</literal> for an input outside the range"
msgstr ""
"возвращает номер группы, в которую попадёт <parameter>operand</parameter> в "
"гистограмме с числом групп <parameter>count</parameter> равного размера, в "
"диапазоне от <parameter>b1</parameter> до <parameter>b2</parameter>; "
"возвращает <literal>0</literal> или <literal><parameter>count</parameter>+1</"
"literal>, если операнд лежит вне диапазона"

#: func.xml:946(literal) func.xml:958(literal)
msgid "width_bucket(5.35, 0.024, 10.06, 5)"
msgstr "width_bucket(5.35, 0.024, 10.06, 5)"

#: func.xml:963(type) func.xml:1876(type) func.xml:1906(type)
#: func.xml:10878(type) func.xml:11844(type) func.xml:11888(type)
#: func.xml:11923(type) func.xml:11936(type) func.xml:11949(type)
#: func.xml:11960(type) func.xml:11972(type) func.xml:13779(type)
#: func.xml:13781(type) func.xml:13808(type) func.xml:13810(type)
msgid "anyelement"
msgstr "anyelement"

#: func.xml:963(parameter)
msgid "thresholds"
msgstr "thresholds"

#: func.xml:963(type) func.xml:11844(type) func.xml:11847(type)
#: func.xml:11855(type) func.xml:11858(type) func.xml:11866(type)
#: func.xml:11877(type) func.xml:11892(type) func.xml:11901(type)
#: func.xml:11912(type) func.xml:11923(type) func.xml:11936(type)
#: func.xml:11949(type) func.xml:11952(type) func.xml:11960(type)
#: func.xml:11963(type) func.xml:11972(type) func.xml:11975(type)
#: func.xml:11983(type) func.xml:11995(type) func.xml:12006(type)
#: func.xml:12029(type) func.xml:12041(type)
msgid "anyarray"
msgstr "anyarray"

#: func.xml:963(function)
msgid ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:965(entry)
msgid ""
"return the bucket number to which <parameter>operand</parameter> would be "
"assigned given an array listing the lower bounds of the buckets; returns "
"<literal>0</literal> for an input less than the first lower bound; the "
"<parameter>thresholds</parameter> array <emphasis>must be sorted</emphasis>, "
"smallest first, or unexpected results will be obtained"
msgstr ""
"возвращает номер группы, в которую попадёт <parameter>operand</parameter> "
"(группы определяются нижними границами, передаваемыми в "
"<parameter>thresholds</parameter>); возвращает 0, если операнд оказывается "
"левее нижней границы; массив <parameter>thresholds</parameter> "
"<emphasis>должен быть отсортирован</emphasis> по возрастанию, иначе будут "
"получены неожиданные результаты"

#: func.xml:970(literal)
msgid ""
"width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])"
msgstr ""
"width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])"

#: func.xml:977(para)
msgid ""
"<xref linkend=\"functions-math-random-table\"/> shows functions for "
"generating random numbers."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-math-random-table\"/> перечислены "
"все функции для генерации случайных чисел."

#: func.xml:983(title)
msgid "Random Functions"
msgstr "Случайные функции"

#: func.xml:996(indexterm)
msgid "<primary>random</primary>"
msgstr "<primary>random</primary>"

#: func.xml:999(function)
msgid "random()"
msgstr "random()"

#: func.xml:1002(entry)
msgid "random value in the range 0.0 &lt;= x &lt; 1.0"
msgstr "случайное число в диапазоне 0.0 &lt;= x &lt; 1.0"

#: func.xml:1007(indexterm)
msgid "<primary>setseed</primary>"
msgstr "<primary>setseed</primary>"

#: func.xml:1010(function)
msgid "setseed(<placeholder-1/>)"
msgstr "setseed(<placeholder-1/>)"

#: func.xml:1012(type) func.xml:17593(type) func.xml:17601(type)
#: func.xml:17771(type) func.xml:18681(type) func.xml:18688(type)
#: func.xml:18695(type) func.xml:18702(type) func.xml:18723(type)
#: func.xml:18744(type) func.xml:18751(type) func.xml:18758(type)
#: func.xml:18765(type)
msgctxt "type"
msgid "void"
msgstr "void"

#: func.xml:1013(entry)
msgid ""
"set seed for subsequent <literal>random()</literal> calls (value between "
"-1.0 and 1.0, inclusive)"
msgstr ""
"задаёт отправную точку для последующих вызовов <literal>random()</literal> "
"(значение между -1.0 и 1.0, включая границы)"

#: func.xml:1020(para)
msgid ""
"The characteristics of the values returned by <literal><function>random()</"
"function></literal> depend on the system implementation. It is not suitable "
"for cryptographic applications; see <xref linkend=\"pgcrypto\"/> module for "
"an alternative."
msgstr ""
"Характеристики значений, возвращаемых функцией <literal><function>random()</"
"function></literal> зависят от системы. Для применения в криптографии они "
"непригодны; альтернативы описаны в <xref remap=\"6\" linkend=\"pgcrypto\"/>."

#: func.xml:1027(para)
#, fuzzy
msgid ""
"Finally, <xref linkend=\"functions-math-trig-table\"/> shows the available "
"trigonometric functions. All trigonometric functions take arguments and "
"return values of type <type>double precision</type>. Each of the "
"trigonometric functions comes in two variants, one that measures angles in "
"radians and one that measures angles in degrees."
msgstr ""
"Наконец, в <xref remap=\"6\" linkend=\"functions-math-trig-table\"/> "
"перечислены все тригонометрические функции. Все эти функции принимают "
"аргументы и возвращают значения типа <type>double precision</type>. "
"Аргументы тригонометрических функций выражаются в радианах. Также в радианах "
"выражаются результаты обратных функций. Для преобразования единиц могут быть "
"полезны упомянутые выше функции <literal><function>radians()</function></"
"literal> и <literal><function>degrees()</function></literal>."

#: func.xml:1037(title)
msgid "Trigonometric Functions"
msgstr "Тригонометрические функции"

#: func.xml:1042(entry)
#, fuzzy
msgid "Function (radians)"
msgstr "Перегрузка функций"

#: func.xml:1043(entry)
#, fuzzy
msgid "Function (degrees)"
msgstr "Имена функций"

#: func.xml:1051(indexterm)
msgid "<primary>acos</primary>"
msgstr "<primary>acos</primary>"

#: func.xml:1053(function)
msgid "acos(<placeholder-1/>)"
msgstr "acos(<placeholder-1/>)"

#: func.xml:1056(indexterm)
#, fuzzy
msgid "<primary>acosd</primary>"
msgstr "<primary>acos</primary>"

#: func.xml:1058(function)
#, fuzzy
msgid "acosd(<placeholder-1/>)"
msgstr "acos(<placeholder-1/>)"

#: func.xml:1060(entry)
msgid "inverse cosine"
msgstr "арккосинус"

#: func.xml:1065(indexterm)
msgid "<primary>asin</primary>"
msgstr "<primary>asin</primary>"

#: func.xml:1068(function)
msgid "asin(<placeholder-1/>)"
msgstr "asin(<placeholder-1/>)"

#: func.xml:1071(indexterm)
#, fuzzy
msgid "<primary>asind</primary>"
msgstr "<primary>asin</primary>"

#: func.xml:1074(function)
#, fuzzy
msgid "asind(<placeholder-1/>)"
msgstr "asin(<placeholder-1/>)"

#: func.xml:1076(entry)
msgid "inverse sine"
msgstr "арксинус"

#: func.xml:1081(indexterm)
msgid "<primary>atan</primary>"
msgstr "<primary>atan</primary>"

#: func.xml:1084(function)
msgid "atan(<placeholder-1/>)"
msgstr "atan(<placeholder-1/>)"

#: func.xml:1087(indexterm)
#, fuzzy
msgid "<primary>atand</primary>"
msgstr "<primary>atan</primary>"

#: func.xml:1090(function)
#, fuzzy
msgid "atand(<placeholder-1/>)"
msgstr "atan(<placeholder-1/>)"

#: func.xml:1092(entry)
msgid "inverse tangent"
msgstr "арктангенс"

#: func.xml:1097(indexterm)
msgid "<primary>atan2</primary>"
msgstr "<primary>atan2</primary>"

#: func.xml:1100(replaceable) func.xml:1107(replaceable)
msgctxt "replaceable"
msgid "y"
msgstr "y"

#: func.xml:1100(function)
msgid "atan2(<placeholder-1/>, <placeholder-2/>)"
msgstr "atan2(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:1104(indexterm)
#, fuzzy
msgid "<primary>atan2d</primary>"
msgstr "<primary>atan2</primary>"

#: func.xml:1107(function)
#, fuzzy
msgid "atan2d(<placeholder-1/>, <placeholder-2/>)"
msgstr "atan2(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:1110(entry)
msgid ""
"inverse tangent of <literal><replaceable>y</replaceable>/<replaceable>x</"
"replaceable></literal>"
msgstr ""
"арктангенс <literal><replaceable>y</replaceable>/<replaceable>x</"
"replaceable></literal>"

#: func.xml:1116(indexterm)
msgid "<primary>cos</primary>"
msgstr "<primary>cos</primary>"

#: func.xml:1119(function)
msgid "cos(<placeholder-1/>)"
msgstr "cos(<placeholder-1/>)"

#: func.xml:1122(indexterm)
#, fuzzy
msgid "<primary>cosd</primary>"
msgstr "<primary>cos</primary>"

#: func.xml:1125(function)
#, fuzzy
msgid "cosd(<placeholder-1/>)"
msgstr "cos(<placeholder-1/>)"

#: func.xml:1127(entry)
msgid "cosine"
msgstr "косинус"

#: func.xml:1132(indexterm)
msgid "<primary>cot</primary>"
msgstr "<primary>cot</primary>"

#: func.xml:1135(function)
msgid "cot(<placeholder-1/>)"
msgstr "cot(<placeholder-1/>)"

#: func.xml:1138(indexterm)
#, fuzzy
msgid "<primary>cotd</primary>"
msgstr "<primary>cot</primary>"

#: func.xml:1141(function)
#, fuzzy
msgid "cotd(<placeholder-1/>)"
msgstr "cot(<placeholder-1/>)"

#: func.xml:1143(entry)
msgid "cotangent"
msgstr "котангенс"

#: func.xml:1148(indexterm)
msgid "<primary>sin</primary>"
msgstr "<primary>sin</primary>"

#: func.xml:1151(function)
msgid "sin(<placeholder-1/>)"
msgstr "sin(<placeholder-1/>)"

#: func.xml:1154(indexterm)
#, fuzzy
msgid "<primary>sind</primary>"
msgstr "<primary>sin</primary>"

#: func.xml:1157(function)
#, fuzzy
msgid "sind(<placeholder-1/>)"
msgstr "sin(<placeholder-1/>)"

#: func.xml:1159(entry)
msgid "sine"
msgstr "синус"

#: func.xml:1164(indexterm)
msgid "<primary>tan</primary>"
msgstr "<primary>tan</primary>"

#: func.xml:1167(function)
msgid "tan(<placeholder-1/>)"
msgstr "tan(<placeholder-1/>)"

#: func.xml:1170(indexterm)
#, fuzzy
msgid "<primary>tand</primary>"
msgstr "<primary>tan</primary>"

#: func.xml:1173(function)
#, fuzzy
msgid "tand(<placeholder-1/>)"
msgstr "tan(<placeholder-1/>)"

#: func.xml:1175(entry)
msgid "tangent"
msgstr "тангенс"

#: func.xml:1182(para)
msgid ""
"Another way to work with angles measured in degrees is to use the unit "
"transformation functions <literal><function>radians()</function></literal> "
"and <literal><function>degrees()</function></literal> shown earlier. "
"However, using the degree-based trigonometric functions is preferred, as "
"that way avoids roundoff error for special cases such as <literal>sind(30)</"
"literal>."
msgstr ""

#: func.xml:1196(title)
msgid "String Functions and Operators"
msgstr "Строковые функции и операторы"

#: func.xml:1198(para)
msgid ""
"This section describes functions and operators for examining and "
"manipulating string values. Strings in this context include values of the "
"types <type>character</type>, <type>character varying</type>, and "
"<type>text</type>. Unless otherwise noted, all of the functions listed below "
"work on all of these types, but be wary of potential effects of automatic "
"space-padding when using the <type>character</type> type. Some functions "
"also exist natively for the bit-string types."
msgstr ""
"В этом разделе описаны функции и операторы для работы с текстовыми строками. "
"Под строками в данном контексте подразумеваются значения типов "
"<type>character</type>, <type>character varying</type> и <type>text</type>. "
"Если не отмечено обратное, все нижеперечисленные функции работают со всеми "
"этими типами, хотя с типом <type>character</type> следует учитывать "
"возможные эффекты автоматического дополнения строк пробелами. Некоторые из "
"этих функций также поддерживают битовые строки."

#: func.xml:1209(para)
msgid ""
"<acronym>SQL</acronym> defines some string functions that use key words, "
"rather than commas, to separate arguments. Details are in <xref linkend="
"\"functions-string-sql\"/>. <productname>PostgreSQL</productname> also "
"provides versions of these functions that use the regular function "
"invocation syntax (see <xref linkend=\"functions-string-other\"/>)."
msgstr ""
"В <acronym>SQL</acronym> определены несколько строковых функций, в которых "
"аргументы разделяются не запятыми, а ключевыми словами. Они перечислены в "
"<xref remap=\"6\" linkend=\"functions-string-sql\"/>. "
"<productname>PostgreSQL</productname> также предоставляет варианты этих "
"функций с синтаксисом, обычным для функций (см. <xref remap=\"4\" linkend="
"\"functions-string-other\"/>)."

#: func.xml:1220(para)
msgid ""
"Before <productname>PostgreSQL</productname> 8.3, these functions would "
"silently accept values of several non-string data types as well, due to the "
"presence of implicit coercions from those data types to <type>text</type>. "
"Those coercions have been removed because they frequently caused surprising "
"behaviors. However, the string concatenation operator (<literal>||</"
"literal>) still accepts non-string input, so long as at least one input is "
"of a string type, as shown in <xref linkend=\"functions-string-sql\"/>. For "
"other cases, insert an explicit coercion to <type>text</type> if you need to "
"duplicate the previous behavior."
msgstr ""
"До версии 8.3 в <productname>PostgreSQL</productname> эти функции также "
"прозрачно принимали значения некоторых не строковых типов, неявно приводя "
"эти значения к типу <type>text</type>. Сейчас такие приведения исключены, "
"так как они часто приводили к неожиданным результатам. Однако оператор "
"конкатенации строк (<literal>||</literal>) по-прежнему принимает не только "
"строковые данные, если хотя бы один аргумент имеет строковый тип, как "
"показано в <xref remap=\"6\" linkend=\"functions-string-sql\"/>. Во всех "
"остальных случаях для повторения предыдущего поведения потребуется добавить "
"явное преобразование в <type>text</type>."

#: func.xml:1234(title)
msgid "<acronym>SQL</acronym> String Functions and Operators"
msgstr "Строковые функции и операторы языка <acronym>SQL</acronym>"

#: func.xml:1248(parameter) func.xml:1249(parameter) func.xml:1282(parameter)
#: func.xml:1316(parameter) func.xml:1329(parameter) func.xml:1342(parameter)
#: func.xml:1357(parameter) func.xml:1370(parameter) func.xml:1381(parameter)
#: func.xml:1393(parameter) func.xml:1411(parameter) func.xml:1427(parameter)
#: func.xml:1444(parameter) func.xml:1480(parameter) func.xml:1498(parameter)
#: func.xml:1570(parameter) func.xml:1594(parameter) func.xml:1612(parameter)
#: func.xml:1628(parameter) func.xml:1683(parameter) func.xml:1717(parameter)
#: func.xml:1728(parameter) func.xml:1745(parameter) func.xml:1767(parameter)
#: func.xml:1785(parameter) func.xml:1839(parameter) func.xml:1859(parameter)
#: func.xml:1891(parameter) func.xml:1922(parameter) func.xml:1939(parameter)
#: func.xml:1955(parameter) func.xml:1972(parameter) func.xml:1989(parameter)
#: func.xml:2003(parameter) func.xml:2052(parameter) func.xml:2073(parameter)
#: func.xml:2091(parameter) func.xml:2108(parameter) func.xml:2126(parameter)
#: func.xml:2142(parameter) func.xml:2176(parameter) func.xml:3254(parameter)
#: func.xml:3255(parameter) func.xml:3272(parameter) func.xml:3285(parameter)
#: func.xml:3300(parameter) func.xml:3313(parameter) func.xml:3330(parameter)
#: func.xml:3372(parameter) func.xml:3390(parameter) func.xml:3427(parameter)
#: func.xml:3442(parameter) func.xml:3457(parameter) func.xml:3478(parameter)
#: func.xml:3494(parameter) func.xml:3510(parameter)
msgctxt "parameter"
msgid "string"
msgstr "string"

#: func.xml:1248(literal) func.xml:3254(literal) func.xml:3574(literal)
#: func.xml:8959(literal) func.xml:8973(literal) func.xml:10471(literal)
#: func.xml:11721(literal) func.xml:11728(literal) func.xml:11735(literal)
#: func.xml:11742(literal)
msgid "||"
msgstr "||"

#: func.xml:1250(type) func.xml:1269(type) func.xml:1318(type)
#: func.xml:1344(type) func.xml:1372(type) func.xml:1382(type)
#: func.xml:1394(type) func.xml:1413(type) func.xml:1431(type)
#: func.xml:1446(type) func.xml:1498(type) func.xml:1499(type)
#: func.xml:1501(type) func.xml:1518(type) func.xml:1538(type)
#: func.xml:1552(type) func.xml:1556(type) func.xml:1597(type)
#: func.xml:1612(type) func.xml:1628(type) func.xml:1629(type)
#: func.xml:1646(type) func.xml:1648(type) func.xml:1665(type)
#: func.xml:1668(type) func.xml:1685(type) func.xml:1700(type)
#: func.xml:1703(type) func.xml:1745(type) func.xml:1747(type)
#: func.xml:1749(type) func.xml:1767(type) func.xml:1768(type)
#: func.xml:1770(type) func.xml:1787(type) func.xml:1801(type)
#: func.xml:1839(type) func.xml:1841(type) func.xml:1859(type)
#: func.xml:1861(type) func.xml:1877(type) func.xml:1891(type)
#: func.xml:1893(type) func.xml:1907(type) func.xml:1922(type)
#: func.xml:1939(type) func.xml:1941(type) func.xml:1955(type)
#: func.xml:1972(type) func.xml:1989(type) func.xml:1991(type)
#: func.xml:2003(type) func.xml:2004(type) func.xml:2005(type)
#: func.xml:2007(type) func.xml:2022(type) func.xml:2035(type)
#: func.xml:2038(type) func.xml:2052(type) func.xml:2054(type)
#: func.xml:2056(type) func.xml:2073(type) func.xml:2074(type)
#: func.xml:2076(type) func.xml:2091(type) func.xml:2092(type)
#: func.xml:2095(type) func.xml:2128(type) func.xml:2142(type)
#: func.xml:2143(type) func.xml:2145(type) func.xml:2163(type)
#: func.xml:2176(type) func.xml:2177(type) func.xml:2178(type)
#: func.xml:2180(type) func.xml:3390(type) func.xml:3391(type)
#: func.xml:3408(type) func.xml:3410(type) func.xml:3480(type)
#: func.xml:5524(type) func.xml:5526(type) func.xml:5531(type)
#: func.xml:5532(type) func.xml:5537(type) func.xml:5538(type)
#: func.xml:5544(type) func.xml:5545(type) func.xml:5550(type)
#: func.xml:5551(type) func.xml:5560(type) func.xml:5571(type)
#: func.xml:5582(type) func.xml:6701(type) func.xml:6712(type)
#: func.xml:6726(type) func.xml:6736(type) func.xml:6972(type)
#: func.xml:7023(type) func.xml:8690(type) func.xml:8697(type)
#: func.xml:8734(type) func.xml:8813(type) func.xml:9092(type)
#: func.xml:9104(type) func.xml:9119(type) func.xml:9165(type)
#: func.xml:9177(type) func.xml:9189(type) func.xml:9223(type)
#: func.xml:9225(type) func.xml:9268(type) func.xml:9339(type)
#: func.xml:9385(type) func.xml:9397(type) func.xml:9409(type)
#: func.xml:9417(type) func.xml:9428(type) func.xml:9436(type)
#: func.xml:9447(type) func.xml:10353(type) func.xml:10367(type)
#: func.xml:10451(type) func.xml:10478(type) func.xml:10849(type)
#: func.xml:10949(type) func.xml:11068(type) func.xml:11880(type)
#: func.xml:11983(type) func.xml:11986(type) func.xml:12017(type)
#: func.xml:14890(type) func.xml:15009(type) func.xml:15931(type)
#: func.xml:15936(type) func.xml:15941(type) func.xml:15946(type)
#: func.xml:15952(type) func.xml:15958(type) func.xml:15963(type)
#: func.xml:15968(type) func.xml:15973(type) func.xml:15978(type)
#: func.xml:15983(type) func.xml:15995(type) func.xml:16000(type)
#: func.xml:16005(type) func.xml:16011(type) func.xml:16016(type)
#: func.xml:16026(type) func.xml:16031(type) func.xml:16036(type)
#: func.xml:16041(type) func.xml:16046(type) func.xml:16063(type)
#: func.xml:16073(type) func.xml:16300(type) func.xml:16314(type)
#: func.xml:16408(type) func.xml:16413(type) func.xml:16418(type)
#: func.xml:16423(type) func.xml:16734(type) func.xml:16754(type)
#: func.xml:17022(type) func.xml:17034(type) func.xml:17264(type)
#: func.xml:17292(type) func.xml:17336(type) func.xml:17676(type)
#: func.xml:17883(type) func.xml:17899(type) func.xml:17915(type)
#: func.xml:17931(type) func.xml:18033(type) func.xml:18052(type)
#: func.xml:18070(type) func.xml:18089(type) func.xml:18188(type)
#: func.xml:18208(type) func.xml:18219(type) func.xml:18229(type)
#: func.xml:18421(type) func.xml:18559(type) func.xml:18568(type)
#: func.xml:18570(type) func.xml:18577(type) func.xml:18586(type)
#: func.xml:19052(type) func.xml:19057(type) func.xml:19062(type)
#: func.xml:19070(type) func.xml:19159(type) func.xml:19164(type)
#: func.xml:19172(type) func.xml:19181(type)
msgctxt "type"
msgid "text"
msgstr "text"

#: func.xml:1253(indexterm)
msgid "<primary>character string</primary><secondary>concatenation</secondary>"
msgstr ""
"<primary>символьная строка</primary><secondary>конкатенация</secondary>"

#: func.xml:1251(entry) func.xml:3257(entry)
msgid "String concatenation <placeholder-1/>"
msgstr "Конкатенация строк <placeholder-1/>"

#: func.xml:1257(literal)
msgid "'Post' || 'greSQL'"
msgstr "'Post' || 'greSQL'"

#: func.xml:1258(literal)
msgid "PostgreSQL"
msgstr "PostgreSQL"

#: func.xml:1262(entry)
msgid ""
"<literal><parameter>string</parameter> <literal>||</literal>\n"
"        <parameter>non-string</parameter></literal> or "
"<literal><parameter>non-string</parameter> <literal>||</literal>\n"
"        <parameter>string</parameter></literal>"
msgstr ""
"<literal><parameter>string</parameter> <literal>||</literal>\n"
"        <parameter>не string</parameter></literal> или "
"<literal><parameter>не string</parameter> <literal>||</literal>\n"
"        <parameter>string</parameter></literal>"

#: func.xml:1270(entry)
msgid "String concatenation with one non-string input"
msgstr "Конкатенация строк с одним не строковым операндом"

#: func.xml:1273(literal)
msgid "'Value: ' || 42"
msgstr "'Value: ' || 42"

#: func.xml:1274(literal)
msgid "Value: 42"
msgstr "Value: 42"

#: func.xml:1279(indexterm)
msgid "<primary>bit_length</primary>"
msgstr "<primary>bit_length</primary>"

#: func.xml:1282(function)
msgid "bit_length(<placeholder-1/>)"
msgstr "bit_length(<placeholder-1/>)"

#: func.xml:1285(entry)
msgid "Number of bits in string"
msgstr "Число бит в строке"

#: func.xml:1286(literal)
msgid "bit_length('jose')"
msgstr "bit_length('jose')"

#: func.xml:1287(literal)
msgid "32"
msgstr "32"

#: func.xml:1292(indexterm)
msgid "<primary>char_length</primary>"
msgstr "<primary>char_length</primary>"

#: func.xml:1291(entry)
msgid ""
"<placeholder-1/>\n"
"        <literal><function>char_length(<parameter>string</parameter>)</"
"function></literal> or "
"<literal><function>character_length(<parameter>string</parameter>)</"
"function></literal>"
msgstr ""
"<placeholder-1/>\n"
"        <literal><function>char_length(<parameter>string</parameter>)</"
"function></literal> или "
"<literal><function>character_length(<parameter>string</parameter>)</"
"function></literal>"

#: func.xml:1300(indexterm)
msgid "<primary>character string</primary><secondary>length</secondary>"
msgstr "<primary>строка символов</primary><secondary>длина</secondary>"

#: func.xml:1303(indexterm)
msgid ""
"<primary>length</primary><secondary sortas=\"character string\">of a "
"character string</secondary><see>character string, length</see>"
msgstr ""
"<primary>длина</primary><secondary sortas=\"символьная строка\">строки "
"символов</secondary><see>строка символов, длина</see>"

#: func.xml:1298(entry)
msgid ""
"Number of characters in string <placeholder-1/>\n"
"        <placeholder-2/>"
msgstr ""
"Число символов в строке <placeholder-1/>\n"
"    <placeholder-2/>"

#: func.xml:1307(literal)
msgid "char_length('jose')"
msgstr "char_length('jose')"

#: func.xml:1308(literal) func.xml:1334(literal) func.xml:1724(literal)
#: func.xml:1737(literal) func.xml:12001(literal) func.xml:12012(literal)
msgctxt "literal"
msgid "4"
msgstr "4"

#: func.xml:1313(indexterm) func.xml:12295(indexterm)
msgid "<primary>lower</primary>"
msgstr "<primary>lower</primary>"

#: func.xml:1316(function)
msgid "lower(<placeholder-1/>)"
msgstr "lower(<placeholder-1/>)"

#: func.xml:1319(entry)
msgid "Convert string to lower case"
msgstr "Переводит символы строки в нижний регистр"

#: func.xml:1320(literal)
msgid "lower('TOM')"
msgstr "lower('TOM')"

#: func.xml:1321(literal)
msgid "tom"
msgstr "tom"

#: func.xml:1326(indexterm) func.xml:3269(indexterm)
msgid "<primary>octet_length</primary>"
msgstr "<primary>octet_length</primary>"

#: func.xml:1329(function) func.xml:3272(function)
msgid "octet_length(<placeholder-1/>)"
msgstr "octet_length(<placeholder-1/>)"

#: func.xml:1332(entry)
msgid "Number of bytes in string"
msgstr "Число байт в строке"

#: func.xml:1333(literal)
msgid "octet_length('jose')"
msgstr "octet_length('jose')"

#: func.xml:1339(indexterm) func.xml:3282(indexterm)
msgid "<primary>overlay</primary>"
msgstr "<primary>overlay</primary>"

#: func.xml:1342(optional) func.xml:1370(optional) func.xml:3285(optional)
#: func.xml:3313(optional)
msgid "for <placeholder-1/>"
msgstr "for <placeholder-1/>"

#: func.xml:1342(function) func.xml:3285(function)
msgid ""
"overlay(<placeholder-1/> placing <placeholder-2/> from <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"overlay(<placeholder-1/> placing <placeholder-2/> from <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:1345(entry) func.xml:3288(entry)
msgid "Replace substring"
msgstr "Заменяет подстроку"

#: func.xml:1348(literal)
msgid "overlay('Txxxxas' placing 'hom' from 2 for 4)"
msgstr "overlay('Txxxxas' placing 'hom' from 2 for 4)"

#: func.xml:1349(literal)
msgid "Thomas"
msgstr "Thomas"

#: func.xml:1354(indexterm) func.xml:3297(indexterm)
msgid "<primary>position</primary>"
msgstr "<primary>position</primary>"

#: func.xml:1357(parameter) func.xml:2108(parameter) func.xml:3300(parameter)
msgid "substring"
msgstr "substring"

#: func.xml:1357(function) func.xml:3300(function)
msgid "position(<placeholder-1/> in <placeholder-2/>)"
msgstr "position(<placeholder-1/> in <placeholder-2/>)"

#: func.xml:1360(entry) func.xml:3303(entry)
msgid "Location of specified substring"
msgstr "Положение указанной подстроки"

#: func.xml:1361(literal)
msgid "position('om' in 'Thomas')"
msgstr "position('om' in 'Thomas')"

#: func.xml:1367(indexterm) func.xml:3310(indexterm) func.xml:3817(indexterm)
#: func.xml:3956(indexterm)
msgid "<primary>substring</primary>"
msgstr "<primary>substring</primary>"

#: func.xml:1370(optional) func.xml:3313(optional)
msgid "from <placeholder-1/>"
msgstr "from <placeholder-1/>"

#: func.xml:1370(function) func.xml:3313(function)
msgid "substring(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "substring(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:1373(entry) func.xml:3316(entry)
msgid "Extract substring"
msgstr "Извлекает подстроку"

#: func.xml:1376(literal)
msgid "substring('Thomas' from 2 for 3)"
msgstr "substring('Thomas' from 2 for 3)"

#: func.xml:1377(literal)
msgid "hom"
msgstr "hom"

#: func.xml:1381(replaceable) func.xml:1393(replaceable)
#: func.xml:3724(replaceable) func.xml:3725(replaceable)
#: func.xml:3821(replaceable) func.xml:3822(replaceable)
msgctxt "replaceable"
msgid "pattern"
msgstr "шаблон"

#: func.xml:1381(function)
msgid "substring(<placeholder-1/> from <placeholder-2/>)"
msgstr "substring(<placeholder-1/> from <placeholder-2/>)"

#: func.xml:1383(entry)
msgid ""
"Extract substring matching POSIX regular expression. See <xref linkend="
"\"functions-matching\"/> for more information on pattern matching."
msgstr ""
"Извлекает подстроку, соответствующую регулярному выражению в стиле POSIX. "
"Подробно шаблоны описаны в <xref remap=\"6\" linkend=\"functions-matching\"/"
">."

#: func.xml:1388(literal)
msgid "substring('Thomas' from '...$')"
msgstr "substring('Thomas' from '...$')"

#: func.xml:1389(literal)
msgid "mas"
msgstr "mas"

#: func.xml:1393(replaceable)
msgid "escape"
msgstr "спецсимвол"

#: func.xml:1393(function)
msgid "substring(<placeholder-1/> from <placeholder-2/> for <placeholder-3/>)"
msgstr "substring(<placeholder-1/> from <placeholder-2/> for <placeholder-3/>)"

#: func.xml:1395(entry)
msgid ""
"Extract substring matching <acronym>SQL</acronym> regular expression. See "
"<xref linkend=\"functions-matching\"/> for more information on pattern "
"matching."
msgstr ""
"Извлекает подстроку, соответствующую регулярному выражению в стиле "
"<acronym>SQL</acronym>. Подробно шаблоны описаны в <xref remap=\"6\" linkend="
"\"functions-matching\"/>."

#: func.xml:1400(literal)
msgid "substring('Thomas' from '%#\"o_a#\"_' for '#')"
msgstr "substring('Thomas' from '%#\"o_a#\"_' for '#')"

#: func.xml:1401(literal)
msgid "oma"
msgstr "oma"

#: func.xml:1406(indexterm) func.xml:3325(indexterm)
msgid "<primary>trim</primary>"
msgstr "<primary>trim</primary>"

#: func.xml:1409(optional) func.xml:1425(optional)
msgid "leading | trailing | both"
msgstr "leading | trailing | both"

#: func.xml:1410(parameter) func.xml:1499(parameter) func.xml:1768(parameter)
#: func.xml:2074(parameter)
msgid "characters"
msgstr "characters"

#: func.xml:1409(function)
msgid ""
"trim(<placeholder-1/>\n"
"        <optional><placeholder-2/></optional> from <placeholder-3/>)"
msgstr ""
"trim(<placeholder-1/>\n"
"        <optional><placeholder-2/></optional> from <placeholder-3/>)"

#: func.xml:1414(entry)
msgid ""
"Remove the longest string containing only the <parameter>characters</"
"parameter> (a space by default) from the start/end/both ends of the "
"<parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, содержащую только символы "
"<parameter>characters</parameter> (по умолчанию пробелы), с начала, с конца "
"или с обеих сторон строки <parameter>string</parameter>"

#: func.xml:1419(literal)
msgid "trim(both 'x' from 'xTomxx')"
msgstr "trim(both 'x' from 'xTomxx')"

#: func.xml:1420(literal) func.xml:1436(literal) func.xml:3339(literal)
msgid "Tom"
msgstr "Tom"

#: func.xml:1426(optional)
msgctxt "optional"
msgid "from"
msgstr "from"

#: func.xml:1428(parameter)
msgid ", characters"
msgstr ", characters"

#: func.xml:1425(function)
msgid ""
"trim(<placeholder-1/> <placeholder-2/>\n"
"        <placeholder-3/>\n"
"        <optional><placeholder-4/></optional> )"
msgstr ""
"trim(<placeholder-1/> <placeholder-2/>\n"
"        <placeholder-3/>\n"
"        <optional><placeholder-4/></optional> )"

#: func.xml:1432(entry)
msgid "Non-standard version of <function>trim()</function>"
msgstr "Нестандартная версия <function>trim()</function>"

#: func.xml:1435(literal)
msgid "trim(both from 'xTomxx', 'x')"
msgstr "trim(both from 'xTomxx', 'x')"

#: func.xml:1441(indexterm) func.xml:12298(indexterm)
msgid "<primary>upper</primary>"
msgstr "<primary>upper</primary>"

#: func.xml:1444(function)
msgid "upper(<placeholder-1/>)"
msgstr "upper(<placeholder-1/>)"

#: func.xml:1447(entry)
msgid "Convert string to upper case"
msgstr "Переводит символы строки в верхний регистр"

#: func.xml:1448(literal)
msgid "upper('tom')"
msgstr "upper('tom')"

#: func.xml:1449(literal)
msgid "TOM"
msgstr "TOM"

#: func.xml:1455(para)
msgid ""
"Additional string manipulation functions are available and are listed in "
"<xref linkend=\"functions-string-other\"/>. Some of them are used internally "
"to implement the <acronym>SQL</acronym>-standard string functions listed in "
"<xref linkend=\"functions-string-sql\"/>."
msgstr ""
"Кроме этого, в <productname>PostgreSQL</productname> есть и другие функции "
"для работы со строками, перечисленные в <xref remap=\"6\" linkend="
"\"functions-string-other\"/>. Некоторые из них используются в качестве "
"внутренней реализации стандартных строковых функций <acronym>SQL</acronym>, "
"приведённых в <xref remap=\"6\" linkend=\"functions-string-sql\"/>."

#: func.xml:1462(title)
msgid "Other String Functions"
msgstr "Другие строковые функции"

#: func.xml:1477(indexterm)
msgid "<primary>ascii</primary>"
msgstr "<primary>ascii</primary>"

#: func.xml:1480(function)
msgid "ascii(<placeholder-1/>)"
msgstr "ascii(<placeholder-1/>)"

#: func.xml:1483(entry)
msgid ""
"<acronym>ASCII</acronym> code of the first character of the argument. For "
"<acronym>UTF8</acronym> returns the Unicode code point of the character. For "
"other multibyte encodings, the argument must be an <acronym>ASCII</acronym> "
"character."
msgstr ""
"Возвращает <acronym>ASCII</acronym>-код первого символа аргумента. Для "
"<acronym>UTF8</acronym> возвращает код символа в Unicode. Для других "
"многобайтных кодировок аргумент должен быть <acronym>ASCII</acronym>-"
"символом."

#: func.xml:1489(literal)
msgid "ascii('x')"
msgstr "ascii('x')"

#: func.xml:1495(indexterm) func.xml:3369(indexterm)
msgid "<primary>btrim</primary>"
msgstr "<primary>btrim</primary>"

#: func.xml:1499(optional) func.xml:1747(optional) func.xml:1768(optional)
#: func.xml:2054(optional) func.xml:2074(optional) func.xml:2143(optional)
#: func.xml:9223(optional) func.xml:9235(optional) func.xml:9247(optional)
#: func.xml:11010(optional) func.xml:17292(optional) func.xml:17745(optional)
msgid ", <placeholder-1/> <placeholder-2/>"
msgstr ", <placeholder-1/> <placeholder-2/>"

#: func.xml:1498(function)
msgid ""
"btrim(<placeholder-1/> <placeholder-2/>\n"
"        <placeholder-3/>)"
msgstr ""
"btrim(<placeholder-1/> <placeholder-2/>\n"
"        <placeholder-3/>)"

#: func.xml:1502(entry)
msgid ""
"Remove the longest string consisting only of characters in "
"<parameter>characters</parameter> (a space by default) from the start and "
"end of <parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, состоящую только из символов "
"<parameter>characters</parameter> (по умолчанию пробелов), с начала и с "
"конца строки <parameter>string</parameter>"

#: func.xml:1507(literal)
msgid "btrim('xyxtrimyyx', 'xy')"
msgstr "btrim('xyxtrimyyx', 'xy')"

#: func.xml:1508(literal) func.xml:1777(literal) func.xml:2083(literal)
#: func.xml:3382(literal)
msgid "trim"
msgstr "trim"

#: func.xml:1513(indexterm)
msgid "<primary>chr</primary>"
msgstr "<primary>chr</primary>"

#: func.xml:1516(function)
msgid "chr(<placeholder-1/>)"
msgstr "chr(<placeholder-1/>)"

#: func.xml:1519(entry)
msgid ""
"Character with the given code. For <acronym>UTF8</acronym> the argument is "
"treated as a Unicode code point. For other multibyte encodings the argument "
"must designate an <acronym>ASCII</acronym> character. The NULL (0) character "
"is not allowed because text data types cannot store such bytes."
msgstr ""
"Возвращает символ с данным кодом. Для <acronym>UTF8</acronym> аргумент "
"воспринимается как код символа Unicode, а для других кодировок он должен "
"указывать на <acronym>ASCII</acronym>-символ. Код 0 (NULL) не допускается, "
"так как байты с нулевым кодом в текстовых строках сохранить нельзя."

#: func.xml:1526(literal)
msgid "chr(65)"
msgstr "chr(65)"

#: func.xml:1527(literal)
msgid "A"
msgstr "A"

#: func.xml:1532(indexterm)
msgid "<primary>concat</primary>"
msgstr "<primary>concat</primary>"

#: func.xml:1535(parameter) func.xml:1536(parameter) func.xml:1553(parameter)
#: func.xml:1554(parameter) func.xml:1700(parameter) func.xml:2020(parameter)
#: func.xml:2035(parameter)
msgid "str"
msgstr "str"

#: func.xml:1535(type) func.xml:1536(type) func.xml:1553(type)
#: func.xml:1554(type) func.xml:1666(type) func.xml:13490(type)
#: func.xml:13493(type) func.xml:13512(type) func.xml:13515(type)
#: func.xml:13534(type) func.xml:13537(type) func.xml:13556(type)
#: func.xml:13559(type)
msgid "\"any\""
msgstr "\"any\""

#: func.xml:1535(function)
msgid ""
"concat(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/"
"> [, ...] ])"
msgstr ""
"concat(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/"
"> [, ...] ])"

#: func.xml:1539(entry)
msgid ""
"Concatenate the text representations of all the arguments. NULL arguments "
"are ignored."
msgstr "Соединяет текстовые представления всех аргументов, игнорируя NULL."

#: func.xml:1543(literal)
msgid "concat('abcde', 2, NULL, 22)"
msgstr "concat('abcde', 2, NULL, 22)"

#: func.xml:1544(literal)
msgid "abcde222"
msgstr "abcde222"

#: func.xml:1549(indexterm)
msgid "<primary>concat_ws</primary>"
msgstr "<primary>concat_ws</primary>"

#: func.xml:1552(parameter)
msgid "sep"
msgstr "sep"

#: func.xml:1552(function)
msgid ""
"concat_ws(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
"> [, <placeholder-5/> <placeholder-6/> [, ...] ])"
msgstr ""
"concat_ws(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
"> [, <placeholder-5/> <placeholder-6/> [, ...] ])"

#: func.xml:1557(entry)
msgid ""
"Concatenate all but the first argument with separators. The first argument "
"is used as the separator string. NULL arguments are ignored."
msgstr ""
"Соединяет все аргументы, кроме первого, через разделитель, игнорируя "
"аргументы NULL. Разделитель указывается в первом аргументе."

#: func.xml:1561(literal)
msgid "concat_ws(',', 'abcde', 2, NULL, 22)"
msgstr "concat_ws(',', 'abcde', 2, NULL, 22)"

#: func.xml:1562(literal)
msgid "abcde,2,22"
msgstr "abcde,2,22"

#: func.xml:1567(indexterm)
msgid "<primary>convert</primary>"
msgstr "<primary>convert</primary>"

#: func.xml:1570(type) func.xml:1574(type) func.xml:1594(type)
#: func.xml:1615(type) func.xml:1631(type) func.xml:1645(type)
#: func.xml:1728(type) func.xml:3256(type) func.xml:3287(type)
#: func.xml:3315(type) func.xml:3332(type) func.xml:3373(type)
#: func.xml:3375(type) func.xml:3393(type) func.xml:3407(type)
#: func.xml:3497(type) func.xml:3513(type) func.xml:18089(type)
#: func.xml:18579(type)
msgid "bytea"
msgstr "bytea"

#: func.xml:1571(parameter) func.xml:1595(parameter)
msgid "src_encoding"
msgstr "src_encoding"

#: func.xml:1571(type) func.xml:1572(type) func.xml:1595(type)
#: func.xml:1613(type) func.xml:1729(type) func.xml:1826(type)
#: func.xml:14878(type) func.xml:14884(type) func.xml:14897(type)
#: func.xml:14909(type) func.xml:14997(type) func.xml:15003(type)
#: func.xml:16021(type) func.xml:17745(type) func.xml:17768(type)
#: func.xml:17785(type) func.xml:17804(type) func.xml:17829(type)
#: func.xml:17847(type) func.xml:17864(type) func.xml:18172(type)
#: func.xml:18254(type)
msgctxt "type"
msgid "name"
msgstr "name"

#: func.xml:1572(parameter) func.xml:1613(parameter)
msgid "dest_encoding"
msgstr "dest_encoding"

#: func.xml:1570(function)
msgid ""
"convert(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"convert(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:1575(entry)
msgid ""
"Convert string to <parameter>dest_encoding</parameter>. The original "
"encoding is specified by <parameter>src_encoding</parameter>. The "
"<parameter>string</parameter> must be valid in this encoding. Conversions "
"can be defined by <command>CREATE CONVERSION</command>. Also there are some "
"predefined conversions. See <xref linkend=\"conversion-names\"/> for "
"available conversions."
msgstr ""
"Преобразует строку <parameter>string</parameter> из кодировки "
"<parameter>src_encoding</parameter> в <parameter>dest_encoding</parameter>. "
"Переданная строка должна быть допустимой для исходной кодировки. "
"Преобразования могут быть определены с помощью <command>CREATE CONVERSION</"
"command>. Все встроенные преобразования перечислены в <xref remap=\"6\" "
"linkend=\"conversion-names\"/>."

#: func.xml:1584(literal)
msgid "convert('text_in_utf8', 'UTF8', 'LATIN1')"
msgstr "convert('text_in_utf8'&zwsp;, 'UTF8', 'LATIN1')"

#: func.xml:1585(entry)
msgid ""
"<literal>text_in_utf8</literal> represented in Latin-1 encoding (ISO 8859-1)"
msgstr ""
"строка <literal>text_in_utf8</literal>, представленная в кодировке Latin-1 "
"(ISO 8859-1)"

#: func.xml:1591(indexterm)
msgid "<primary>convert_from</primary>"
msgstr "<primary>convert_from</primary>"

#: func.xml:1594(function)
msgid ""
"convert_from(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"convert_from(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:1598(entry)
msgid ""
"Convert string to the database encoding. The original encoding is specified "
"by <parameter>src_encoding</parameter>. The <parameter>string</parameter> "
"must be valid in this encoding."
msgstr ""
"Преобразует строку <parameter>string</parameter> из кодировки "
"<parameter>src_encoding</parameter> в кодировку базы данных. Переданная "
"строка должна быть допустимой для исходной кодировки."

#: func.xml:1603(literal)
msgid "convert_from('text_in_utf8', 'UTF8')"
msgstr "convert_from('text_in_utf8'&zwsp;, 'UTF8')"

#: func.xml:1604(entry)
msgid ""
"<literal>text_in_utf8</literal> represented in the current database encoding"
msgstr ""
"строка <literal>text_in_utf8</literal>, представленная в кодировке текущей "
"базы данных"

#: func.xml:1609(indexterm)
msgid "<primary>convert_to</primary>"
msgstr "<primary>convert_to</primary>"

#: func.xml:1612(function)
msgid ""
"convert_to(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"convert_to(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:1616(entry)
msgid "Convert string to <parameter>dest_encoding</parameter>."
msgstr "Преобразует строку в кодировку <parameter>dest_encoding</parameter>."

#: func.xml:1619(literal)
msgid "convert_to('some text', 'UTF8')"
msgstr "convert_to('некоторый текст', 'UTF8')"

#: func.xml:1620(entry)
msgid "<literal>some text</literal> represented in the UTF8 encoding"
msgstr "<literal>некоторый текст</literal>, представленный в кодировке UTF8"

#: func.xml:1625(indexterm) func.xml:3387(indexterm)
msgid "<primary>decode</primary>"
msgstr "<primary>decode</primary>"

#: func.xml:1629(parameter) func.xml:1646(parameter) func.xml:3391(parameter)
#: func.xml:3408(parameter)
msgctxt "parameter"
msgid "format"
msgstr "format"

#: func.xml:1628(function) func.xml:3390(function)
msgid ""
"decode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"decode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:1632(entry) func.xml:3394(entry)
msgid ""
"Decode binary data from textual representation in <parameter>string</"
"parameter>. Options for <parameter>format</parameter> are same as in "
"<function>encode</function>."
msgstr ""
"Получает двоичные данные из текстового представления в <parameter>string</"
"parameter>. Значения параметра <parameter>format</parameter> те же, что и "
"для функции <function>encode</function>."

#: func.xml:1636(literal)
msgid "decode('MTIzAAE=', 'base64')"
msgstr "decode('MTIzAAE=', 'base64')"

#: func.xml:1637(literal)
msgid "\\x3132330001"
msgstr "\\x3132330001"

#: func.xml:1642(indexterm) func.xml:3404(indexterm)
msgid "<primary>encode</primary>"
msgstr "<primary>encode</primary>"

#: func.xml:1645(parameter) func.xml:3407(parameter)
msgid "data"
msgstr "data"

#: func.xml:1645(function) func.xml:3407(function)
msgid ""
"encode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"encode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:1649(entry) func.xml:3411(entry)
msgid ""
"Encode binary data into a textual representation. Supported formats are: "
"<literal>base64</literal>, <literal>hex</literal>, <literal>escape</"
"literal>. <literal>escape</literal> converts zero bytes and high-bit-set "
"bytes to octal sequences (<literal>\\</literal><replaceable>nnn</"
"replaceable>) and doubles backslashes."
msgstr ""
"Переводит двоичные данные в текстовое представление в одном из форматов: "
"<literal>base64</literal>, <literal>hex</literal>, <literal>escape</"
"literal>. Формат <literal>escape</literal> преобразует нулевые байты и байты "
"с 1 в старшем бите в восьмеричные последовательности <literal>\\nnn</"
"literal> и дублирует обратную косую черту."

#: func.xml:1656(literal)
msgid "encode(E'123\\\\000\\\\001', 'base64')"
msgstr "encode(E'123&zwsp;\\\\000&zwsp;\\\\001', 'base64')"

#: func.xml:1657(literal)
msgid "MTIzAAE="
msgstr "MTIzAAE="

#: func.xml:1662(indexterm) func.xml:3012(indexterm)
msgid "<primary>format</primary>"
msgstr "<primary>format</primary>"

#: func.xml:1665(function) func.xml:3010(function)
msgctxt "function"
msgid "format"
msgstr "format"

#: func.xml:1665(parameter)
msgid "formatstr"
msgstr "formatstr"

#: func.xml:1666(parameter)
msgid "formatarg"
msgstr "formatarg"

#: func.xml:1665(literal)
msgid ""
"<placeholder-1/>(<placeholder-2/> <placeholder-3/> [, <placeholder-4/> "
"<placeholder-5/> [, ...] ])"
msgstr ""
"<placeholder-1/>(<placeholder-2/> <placeholder-3/> [, <placeholder-4/> "
"<placeholder-5/> [, ...] ])"

#: func.xml:1669(entry)
msgid ""
"Format arguments according to a format string. This function is similar to "
"the C function <function>sprintf</function>. See <xref linkend=\"functions-"
"string-format\"/>."
msgstr ""
"Форматирует аргумент в соответствии со строкой формата. Эта функция работает "
"подобно <function>sprintf</function> в языке C. См. <xref remap=\"4\" "
"linkend=\"functions-string-format\"/>."

#: func.xml:1674(literal)
msgid "format('Hello %s, %1$s', 'World')"
msgstr "format('Hello %s, %1$s', 'World')"

#: func.xml:1675(literal)
msgid "Hello World, World"
msgstr "Hello World, World"

#: func.xml:1680(indexterm)
msgid "<primary>initcap</primary>"
msgstr "<primary>initcap</primary>"

#: func.xml:1683(function)
msgid "initcap(<placeholder-1/>)"
msgstr "initcap(<placeholder-1/>)"

#: func.xml:1686(entry)
msgid ""
"Convert the first letter of each word to upper case and the rest to lower "
"case. Words are sequences of alphanumeric characters separated by non-"
"alphanumeric characters."
msgstr ""
"Переводит первую букву каждого слова в строке в верхний регистр, а остальные "
"&mdash; в нижний. Словами считаются последовательности алфавитно-цифровых "
"символов, разделённые любыми другими символами."

#: func.xml:1691(literal)
msgid "initcap('hi THOMAS')"
msgstr "initcap('hi THOMAS')"

#: func.xml:1692(literal)
msgid "Hi Thomas"
msgstr "Hi Thomas"

#: func.xml:1697(indexterm)
msgid "<primary>left</primary>"
msgstr "<primary>left</primary>"

#: func.xml:1701(parameter) func.xml:2036(parameter)
msgctxt "parameter"
msgid "n"
msgstr "n"

#: func.xml:1700(function)
msgid ""
"left(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"left(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:1704(entry)
msgid ""
"Return first <replaceable>n</replaceable> characters in the string. When "
"<replaceable>n</replaceable> is negative, return all but last |"
"<replaceable>n</replaceable>| characters."
msgstr ""
"Возвращает первые <replaceable>n</replaceable> символов в строке. Когда "
"<replaceable>n</replaceable> меньше нуля, возвращаются все символы слева, "
"кроме последних |<replaceable>n</replaceable>|."

#: func.xml:1708(literal)
msgid "left('abcde', 2)"
msgstr "left('abcde', 2)"

#: func.xml:1709(literal)
msgid "ab"
msgstr "ab"

#: func.xml:1714(indexterm) func.xml:3454(indexterm) func.xml:8222(indexterm)
#: func.xml:9065(indexterm)
msgid "<primary>length</primary>"
msgstr "<primary>length</primary>"

#: func.xml:1717(function) func.xml:3457(function) func.xml:8290(function)
#: func.xml:9068(function)
msgid "length(<placeholder-1/>)"
msgstr "length(<placeholder-1/>)"

#: func.xml:1720(entry)
msgid "Number of characters in <parameter>string</parameter>"
msgstr "Число символов в строке <parameter>string</parameter>"

#: func.xml:1723(literal)
msgid "length('jose')"
msgstr "length('jose')"

#: func.xml:1729(parameter) func.xml:2143(parameter)
msgid "encoding"
msgstr "encoding"

#: func.xml:1728(function)
msgid ""
"length(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> )"
msgstr ""
"length(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> )"

#: func.xml:1731(entry)
msgid ""
"Number of characters in <parameter>string</parameter> in the given "
"<parameter>encoding</parameter>. The <parameter>string</parameter> must be "
"valid in this encoding."
msgstr ""
"Число символов, которые содержит строка <parameter>string</parameter> в "
"заданной кодировке <parameter>encoding</parameter>. Переданная строка должна "
"быть допустимой в этой кодировке."

#: func.xml:1736(literal)
msgid "length('jose', 'UTF8')"
msgstr "length('jose', 'UTF8')"

#: func.xml:1742(indexterm)
msgid "<primary>lpad</primary>"
msgstr "<primary>lpad</primary>"

#: func.xml:1746(parameter) func.xml:2053(parameter) func.xml:18568(parameter)
#: func.xml:18577(parameter)
msgctxt "parameter"
msgid "length"
msgstr "length"

#: func.xml:1747(parameter) func.xml:2054(parameter)
msgid "fill"
msgstr "fill"

#: func.xml:1745(function)
msgid ""
"lpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>\n"
"        <placeholder-5/>)"
msgstr ""
"lpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>\n"
"        <placeholder-5/>)"

#: func.xml:1750(entry)
msgid ""
"Fill up the <parameter>string</parameter> to length <parameter>length</"
"parameter> by prepending the characters <parameter>fill</parameter> (a space "
"by default). If the <parameter>string</parameter> is already longer than "
"<parameter>length</parameter> then it is truncated (on the right)."
msgstr ""
"Дополняет строку <parameter>string</parameter> слева до длины "
"<parameter>length</parameter> символами <parameter>fill</parameter> (по "
"умолчанию пробелами). Если длина строки уже больше заданной, она обрезается "
"справа."

#: func.xml:1758(literal)
msgid "lpad('hi', 5, 'xy')"
msgstr "lpad('hi', 5, 'xy')"

#: func.xml:1759(literal)
msgid "xyxhi"
msgstr "xyxhi"

#: func.xml:1764(indexterm)
msgid "<primary>ltrim</primary>"
msgstr "<primary>ltrim</primary>"

#: func.xml:1767(function)
msgid ""
"ltrim(<placeholder-1/> <placeholder-2/>\n"
"        <placeholder-3/>)"
msgstr ""
"ltrim(<placeholder-1/> <placeholder-2/>\n"
"        <placeholder-3/>)"

#: func.xml:1771(entry)
msgid ""
"Remove the longest string containing only characters from "
"<parameter>characters</parameter> (a space by default) from the start of "
"<parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, содержащую только символы "
"<parameter>characters</parameter> (по умолчанию пробелы), с начала строки "
"<parameter>string</parameter>"

#: func.xml:1776(literal)
msgid "ltrim('zzzytrim', 'xyz')"
msgstr "ltrim('zzzytrim', 'xyz')"

#: func.xml:1782(indexterm) func.xml:3475(indexterm)
msgid "<primary>md5</primary>"
msgstr "<primary>md5</primary>"

#: func.xml:1785(function) func.xml:3478(function)
msgid "md5(<placeholder-1/>)"
msgstr "md5(<placeholder-1/>)"

#: func.xml:1788(entry) func.xml:3481(entry)
msgid ""
"Calculates the MD5 hash of <parameter>string</parameter>, returning the "
"result in hexadecimal"
msgstr ""
"Вычисляет MD5-хеш строки <parameter>string</parameter> и возвращает "
"результат в 16-ричном виде"

#: func.xml:1792(literal)
msgid "md5('abc')"
msgstr "md5('abc')"

#: func.xml:1793(literal)
msgid "900150983cd24fb0 d6963f7d28e17f72"
msgstr "90015098&zwsp;3cd24fb0 d6963f7d&zwsp;28e17f72"

#: func.xml:1798(indexterm)
#, fuzzy
msgid "<primary>parse_ident</primary>"
msgstr "<primary>ident</primary>"

#: func.xml:1801(parameter)
#, fuzzy
msgid "qualified_identifier"
msgstr "sql_identifier"

#: func.xml:1802(parameter)
#, fuzzy
msgid "strictmode"
msgstr "строго выше"

#: func.xml:1802(type) func.xml:6776(type) func.xml:6784(type)
#: func.xml:6792(type) func.xml:8279(type) func.xml:8285(type)
#: func.xml:8825(type) func.xml:8946(type) func.xml:8953(type)
#: func.xml:8995(type) func.xml:9002(type) func.xml:11010(type)
#: func.xml:11035(type) func.xml:11227(type) func.xml:12358(type)
#: func.xml:12369(type) func.xml:12380(type) func.xml:12391(type)
#: func.xml:12402(type) func.xml:14902(type) func.xml:14966(type)
#: func.xml:15256(type) func.xml:15263(type) func.xml:15272(type)
#: func.xml:15280(type) func.xml:15288(type) func.xml:15295(type)
#: func.xml:15303(type) func.xml:15310(type) func.xml:15318(type)
#: func.xml:15325(type) func.xml:15333(type) func.xml:15340(type)
#: func.xml:15348(type) func.xml:15355(type) func.xml:15363(type)
#: func.xml:15370(type) func.xml:15378(type) func.xml:15385(type)
#: func.xml:15393(type) func.xml:15400(type) func.xml:15408(type)
#: func.xml:15415(type) func.xml:15423(type) func.xml:15430(type)
#: func.xml:15436(type) func.xml:15675(type) func.xml:15681(type)
#: func.xml:15687(type) func.xml:15693(type) func.xml:15699(type)
#: func.xml:15705(type) func.xml:15711(type) func.xml:15717(type)
#: func.xml:15723(type) func.xml:15729(type) func.xml:15735(type)
#: func.xml:15741(type) func.xml:16523(type) func.xml:16749(type)
#: func.xml:16921(type) func.xml:16926(type) func.xml:16931(type)
#: func.xml:16982(type) func.xml:17131(type) func.xml:17142(type)
#: func.xml:17149(type) func.xml:17156(type) func.xml:17292(type)
#: func.xml:17306(type) func.xml:17745(type) func.xml:18559(type)
#: func.xml:18568(type) func.xml:18577(type) func.xml:18586(type)
#: func.xml:18709(type) func.xml:18716(type) func.xml:18730(type)
#: func.xml:18737(type) func.xml:18772(type) func.xml:18779(type)
#: func.xml:18786(type) func.xml:18793(type) func.xml:18800(type)
#: func.xml:18807(type) func.xml:18814(type) func.xml:18821(type)
msgid "boolean"
msgstr "boolean"

#: func.xml:1801(function)
#, fuzzy
msgid ""
"parse_ident(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/> DEFAULT true ] )"
msgstr ""
"repeat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:1804(type) func.xml:1957(type) func.xml:9044(type)
#: func.xml:9141(type) func.xml:9199(type) func.xml:9305(type)
#: func.xml:9385(type) func.xml:9399(type) func.xml:10374(type)
#: func.xml:10381(type) func.xml:10458(type) func.xml:10465(type)
#: func.xml:10494(type) func.xml:12020(type) func.xml:16314(type)
#: func.xml:17804(type) func.xml:17829(type) func.xml:17847(type)
#: func.xml:17864(type) func.xml:19189(type) func.xml:19200(type)
msgid "text[]"
msgstr "text[]"

#: func.xml:1805(entry)
msgid ""
"Split <parameter>qualified_identifier</parameter> into an array of "
"identifiers, removing any quoting of individual identifiers. By default, "
"extra characters after the last identifier are considered an error; but if "
"the second parameter is <literal>false</literal>, then such extra characters "
"are ignored. (This behavior is useful for parsing names for objects like "
"functions.) Note that this function does not truncate over-length "
"identifiers. If you want truncation you can cast the result to <type>name[]</"
"type>."
msgstr ""

#: func.xml:1815(literal)
msgid "parse_ident('\"SomeSchema\".someTable')"
msgstr ""

#: func.xml:1816(literal)
msgid "{SomeSchema,sometable}"
msgstr ""

#: func.xml:1821(indexterm)
msgid "<primary>pg_client_encoding</primary>"
msgstr "<primary>pg_client_encoding</primary>"

#: func.xml:1824(function)
msgctxt "function"
msgid "pg_client_encoding()"
msgstr "pg_client_encoding()"

#: func.xml:1827(entry)
msgid "Current client encoding name"
msgstr "Возвращает имя текущей клиентской кодировки"

#: func.xml:1830(literal)
msgctxt "literal"
msgid "pg_client_encoding()"
msgstr "pg_client_encoding()"

#: func.xml:1831(literal) func.xml:2239(literal) func.xml:2245(literal)
#: func.xml:2522(literal) func.xml:2648(literal)
msgid "SQL_ASCII"
msgstr "SQL_ASCII"

#: func.xml:1836(indexterm)
msgid "<primary>quote_ident</primary>"
msgstr "<primary>quote_ident</primary>"

#: func.xml:1839(function)
msgid "quote_ident(<placeholder-1/> <placeholder-2/>)"
msgstr "quote_ident(<placeholder-1/> <placeholder-2/>)"

#: func.xml:1842(entry)
msgid ""
"Return the given string suitably quoted to be used as an identifier in an "
"<acronym>SQL</acronym> statement string. Quotes are added only if necessary "
"(i.e., if the string contains non-identifier characters or would be case-"
"folded). Embedded quotes are properly doubled. See also <xref linkend="
"\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Переданная строка оформляется для использования в качестве идентификатора в "
"<acronym>SQL</acronym> -операторе. При необходимости идентификатор "
"заключается в кавычки (например, если он содержит символы, недопустимые в "
"открытом виде, или буквы в разном регистре). Если переданная строка содержит "
"кавычки, они дублируются. См. также <xref remap=\"4\" linkend=\"plpgsql-"
"quote-literal-example\"/>."

#: func.xml:1850(literal)
msgid "quote_ident('Foo bar')"
msgstr "quote_ident('Foo bar')"

#: func.xml:1851(literal)
msgid "\"Foo bar\""
msgstr "\"Foo bar\""

#: func.xml:1856(indexterm)
msgid "<primary>quote_literal</primary>"
msgstr "<primary>quote_literal</primary>"

#: func.xml:1859(function) func.xml:1876(function)
msgid "quote_literal(<placeholder-1/> <placeholder-2/>)"
msgstr "quote_literal(<placeholder-1/> <placeholder-2/>)"

#: func.xml:1862(entry)
msgid ""
"Return the given string suitably quoted to be used as a string literal in an "
"<acronym>SQL</acronym> statement string. Embedded single-quotes and "
"backslashes are properly doubled. Note that <function>quote_literal</"
"function> returns null on null input; if the argument might be null, "
"<function>quote_nullable</function> is often more suitable. See also <xref "
"linkend=\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Переданная строка оформляется для использования в качестве текстовой строки "
"в <acronym>SQL</acronym>-операторе. Включённые символы апостроф и обратная "
"косая черта при этом дублируются. Заметьте, что <function>quote_literal</"
"function> возвращает NULL, когда на вход ей передаётся строка NULL; если же "
"нужно получить представление и такого аргумента, лучше использовать "
"<function>quote_nullable</function>. См. также <xref remap=\"4\" linkend="
"\"plpgsql-quote-literal-example\"/>."

#: func.xml:1871(literal)
msgid "quote_literal(E'O\\'Reilly')"
msgstr "quote_literal(E'O\\'Reilly')"

#: func.xml:1872(literal)
msgid "'O''Reilly'"
msgstr "'O''Reilly'"

#: func.xml:1876(parameter) func.xml:1906(parameter)
msgctxt "parameter"
msgid "value"
msgstr "value"

#: func.xml:1878(entry)
msgid ""
"Coerce the given value to text and then quote it as a literal. Embedded "
"single-quotes and backslashes are properly doubled."
msgstr ""
"Переводит данное значение в текстовый вид и заключает в апострофы как "
"текстовую строку. Символы апостроф и обратная косая черта при этом "
"дублируются."

#: func.xml:1882(literal)
msgid "quote_literal(42.5)"
msgstr "quote_literal(42.5)"

#: func.xml:1883(literal) func.xml:1914(literal)
msgid "'42.5'"
msgstr "'42.5'"

#: func.xml:1888(indexterm)
msgid "<primary>quote_nullable</primary>"
msgstr "<primary>quote_nullable</primary>"

#: func.xml:1891(function) func.xml:1906(function)
msgid "quote_nullable(<placeholder-1/> <placeholder-2/>)"
msgstr "quote_nullable(<placeholder-1/> <placeholder-2/>)"

#: func.xml:1894(entry)
msgid ""
"Return the given string suitably quoted to be used as a string literal in an "
"<acronym>SQL</acronym> statement string; or, if the argument is null, return "
"<literal>NULL</literal>. Embedded single-quotes and backslashes are properly "
"doubled. See also <xref linkend=\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Переданная строка оформляется для использования в качестве текстовой строки "
"в <acronym>SQL</acronym>-операторе; при этом для аргумента NULL возвращается "
"строка <literal>NULL</literal>. Символы апостроф и обратная косая черта "
"дублируются должным образом. См. также <xref remap=\"4\" linkend=\"plpgsql-"
"quote-literal-example\"/>."

#: func.xml:1901(literal)
msgid "quote_nullable(NULL)"
msgstr "quote_nullable(NULL)"

#: func.xml:1902(literal)
msgctxt "literal"
msgid "NULL"
msgstr "NULL"

#: func.xml:1908(entry)
msgid ""
"Coerce the given value to text and then quote it as a literal; or, if the "
"argument is null, return <literal>NULL</literal>. Embedded single-quotes and "
"backslashes are properly doubled."
msgstr ""
"Переводит данное значение в текстовый вид и заключает в апострофы как "
"текстовую строку, при этом для аргумента NULL возвращается строка "
"<literal>NULL</literal>. Символы апостроф и обратная косая черта дублируются "
"должным образом."

#: func.xml:1913(literal)
msgid "quote_nullable(42.5)"
msgstr "quote_nullable(42.5)"

#: func.xml:1919(indexterm) func.xml:3962(indexterm)
msgid "<primary>regexp_matches</primary>"
msgstr "<primary>regexp_matches</primary>"

#: func.xml:1922(parameter) func.xml:1939(parameter) func.xml:1955(parameter)
#: func.xml:1972(parameter)
msgctxt "parameter"
msgid "pattern"
msgstr "pattern"

#: func.xml:1922(parameter) func.xml:1939(parameter) func.xml:1955(parameter)
#: func.xml:1972(parameter)
msgid "flags"
msgstr "flags"

#: func.xml:1922(function)
msgid ""
"regexp_matches(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"
msgstr ""
"regexp_matches&zwsp;(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"

#: func.xml:1924(type)
msgid "setof text[]"
msgstr "setof text[]"

#: func.xml:1925(entry)
msgid ""
"Return all captured substrings resulting from matching a POSIX regular "
"expression against the <parameter>string</parameter>. See <xref linkend="
"\"functions-posix-regexp\"/> for more information."
msgstr ""
"Возвращает все подходящие подстроки, полученные в результате применения "
"регулярного выражения в стиле POSIX к <parameter>string</parameter>. "
"Подробности описаны в <xref remap=\"6\" linkend=\"functions-posix-regexp\"/>."

#: func.xml:1930(literal)
msgid "regexp_matches('foobarbequebaz', '(bar)(beque)')"
msgstr "regexp_matches&zwsp;('foobar&zwsp;bequebaz', '(bar)(beque)')"

#: func.xml:1931(literal)
msgid "{bar,beque}"
msgstr "{bar,beque}"

#: func.xml:1936(indexterm) func.xml:3959(indexterm)
msgid "<primary>regexp_replace</primary>"
msgstr "<primary>regexp_replace</primary>"

#: func.xml:1939(parameter)
msgid "replacement"
msgstr "replacement"

#: func.xml:1939(function)
msgid ""
"regexp_replace(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>])"
msgstr ""
"regexp_replace&zwsp;(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>])"

#: func.xml:1942(entry)
msgid ""
"Replace substring(s) matching a POSIX regular expression. See <xref linkend="
"\"functions-posix-regexp\"/> for more information."
msgstr ""
"Заменяет подстроки, соответствующие заданному регулярному выражению в стиле "
"POSIX. Подробности описаны в <xref remap=\"6\" linkend=\"functions-posix-"
"regexp\"/>."

#: func.xml:1946(literal)
msgid "regexp_replace('Thomas', '.[mN]a.', 'M')"
msgstr "regexp_replace('Thomas', '.[mN]a.', 'M')"

#: func.xml:1947(literal)
msgid "ThM"
msgstr "ThM"

#: func.xml:1952(indexterm) func.xml:3968(indexterm)
msgid "<primary>regexp_split_to_array</primary>"
msgstr "<primary>regexp_split_to_array</primary>"

#: func.xml:1955(function)
msgid ""
"regexp_split_to_array(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/> ])"
msgstr ""
"regexp_split_to_array(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/> ])"

#: func.xml:1958(entry) func.xml:1975(entry)
msgid ""
"Split <parameter>string</parameter> using a POSIX regular expression as the "
"delimiter. See <xref linkend=\"functions-posix-regexp\"/> for more "
"information."
msgstr ""
"Разделяет содержимое <parameter>string</parameter> на элементы, используя в "
"качестве разделителя регулярное выражение POSIX. Подробности описаны в <xref "
"remap=\"6\" linkend=\"functions-posix-regexp\"/>."

#: func.xml:1963(literal)
msgid "regexp_split_to_array('hello world', E'\\\\s+')"
msgstr "regexp_split_to_array('hello world', E'\\\\s+')"

#: func.xml:1964(literal)
msgid "{hello,world}"
msgstr "{hello,world}"

#: func.xml:1969(indexterm) func.xml:3965(indexterm)
msgid "<primary>regexp_split_to_table</primary>"
msgstr "<primary>regexp_split&zwsp;_to_table</primary>"

#: func.xml:1972(function)
msgid ""
"regexp_split_to_table(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"
msgstr ""
"regexp_split_to_table(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"

#: func.xml:1974(type) func.xml:10862(type) func.xml:10933(type)
#: func.xml:14972(type) func.xml:18561(type)
msgid "setof text"
msgstr "setof text"

#: func.xml:1980(literal)
msgid "regexp_split_to_table('hello world', E'\\\\s+')"
msgstr "regexp_split_to_table('hello world', E'\\\\s+')"

#: func.xml:1981(literal)
msgid "world"
msgstr "world"

#: func.xml:1981(entry)
msgid "<literal>hello</literal><placeholder-1/> (2 rows)"
msgstr "<literal>hello</literal> <placeholder-1/> (2 строки)"

#: func.xml:1986(indexterm)
msgid "<primary>repeat</primary>"
msgstr "<primary>repeat</primary>"

#: func.xml:1989(parameter) func.xml:2160(parameter)
msgctxt "parameter"
msgid "number"
msgstr "number"

#: func.xml:1989(function)
msgid ""
"repeat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"repeat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:1992(entry)
msgid ""
"Repeat <parameter>string</parameter> the specified <parameter>number</"
"parameter> of times"
msgstr ""
"Повторяет содержимое <parameter>string</parameter> указанное число "
"(<parameter>number</parameter>) раз"

#: func.xml:1994(literal)
msgid "repeat('Pg', 4)"
msgstr "repeat('Pg', 4)"

#: func.xml:1995(literal)
msgid "PgPgPgPg"
msgstr "PgPgPgPg"

#: func.xml:2000(indexterm)
msgid "<primary>replace</primary>"
msgstr "<primary>replace</primary>"

#: func.xml:2004(parameter) func.xml:2126(parameter) func.xml:2177(parameter)
msgctxt "parameter"
msgid "from"
msgstr "from"

#: func.xml:2005(parameter) func.xml:2178(parameter)
msgid "to"
msgstr "to"

#: func.xml:2003(function)
msgid ""
"replace(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"replace(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:2008(entry)
msgid ""
"Replace all occurrences in <parameter>string</parameter> of substring "
"<parameter>from</parameter> with substring <parameter>to</parameter>"
msgstr ""
"Заменяет все вхождения в <parameter>string</parameter> подстроки "
"<parameter>from</parameter> подстрокой <parameter>to</parameter>"

#: func.xml:2011(literal)
msgid "replace('abcdefabcdef', 'cd', 'XX')"
msgstr "replace('abcdefabcdef', 'cd', 'XX')"

#: func.xml:2012(literal)
msgid "abXXefabXXef"
msgstr "abXXefabXXef"

#: func.xml:2017(indexterm)
msgid "<primary>reverse</primary>"
msgstr "<primary>reverse</primary>"

#: func.xml:2020(function)
msgid "reverse(<placeholder-1/>)"
msgstr "reverse(<placeholder-1/>)"

#: func.xml:2023(entry)
msgid "Return reversed string."
msgstr "Возвращает перевёрнутую строку"

#: func.xml:2026(literal)
msgid "reverse('abcde')"
msgstr "reverse('abcde')"

#: func.xml:2027(literal)
msgid "edcba"
msgstr "edcba"

#: func.xml:2032(indexterm)
msgid "<primary>right</primary>"
msgstr "<primary>right</primary>"

#: func.xml:2035(function)
msgid ""
"right(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"right(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:2039(entry)
msgid ""
"Return last <replaceable>n</replaceable> characters in the string. When "
"<replaceable>n</replaceable> is negative, return all but first |"
"<replaceable>n</replaceable>| characters."
msgstr ""
"Возвращает последние <replaceable>n</replaceable> символов в строке. Когда "
"<replaceable>n</replaceable> меньше нуля, возвращаются все символы справа, "
"кроме первых |<replaceable>n</replaceable>|."

#: func.xml:2043(literal)
msgid "right('abcde', 2)"
msgstr "right('abcde', 2)"

#: func.xml:2044(literal)
msgid "de"
msgstr "de"

#: func.xml:2049(indexterm)
msgid "<primary>rpad</primary>"
msgstr "<primary>rpad</primary>"

#: func.xml:2052(function)
msgid ""
"rpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>\n"
"        <placeholder-5/>)"
msgstr ""
"rpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>\n"
"        <placeholder-5/>)"

#: func.xml:2057(entry)
msgid ""
"Fill up the <parameter>string</parameter> to length <parameter>length</"
"parameter> by appending the characters <parameter>fill</parameter> (a space "
"by default). If the <parameter>string</parameter> is already longer than "
"<parameter>length</parameter> then it is truncated."
msgstr ""
"Дополняет строку <parameter>string</parameter> справа до длины "
"<parameter>length</parameter> символами <parameter>fill</parameter> (по "
"умолчанию пробелами). Если длина строки уже больше заданной, она обрезается."

#: func.xml:2064(literal)
msgid "rpad('hi', 5, 'xy')"
msgstr "rpad('hi', 5, 'xy')"

#: func.xml:2065(literal)
msgid "hixyx"
msgstr "hixyx"

#: func.xml:2070(indexterm)
msgid "<primary>rtrim</primary>"
msgstr "<primary>rtrim</primary>"

#: func.xml:2073(function)
msgid ""
"rtrim(<placeholder-1/> <placeholder-2/>\n"
"         <placeholder-3/>)"
msgstr ""
"rtrim(<placeholder-1/> <placeholder-2/>\n"
"         <placeholder-3/>)"

#: func.xml:2077(entry)
msgid ""
"Remove the longest string containing only characters from "
"<parameter>characters</parameter> (a space by default) from the end of "
"<parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, содержащую только символы "
"<parameter>characters</parameter> (по умолчанию пробелы), с конца строки "
"<parameter>string</parameter>"

#: func.xml:2082(literal)
msgid "rtrim('trimxxxx', 'x')"
msgstr "rtrim('trimxxxx', 'x')"

#: func.xml:2088(indexterm)
msgid "<primary>split_part</primary>"
msgstr "<primary>split_part</primary>"

#: func.xml:2092(parameter)
msgctxt "parameter"
msgid "delimiter"
msgstr "delimiter"

#: func.xml:2093(parameter) func.xml:6749(parameter) func.xml:6760(parameter)
msgctxt "parameter"
msgid "field"
msgstr "field"

#: func.xml:2091(function)
msgid ""
"split_part(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"split_part(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:2096(entry)
msgid ""
"Split <parameter>string</parameter> on <parameter>delimiter</parameter> and "
"return the given field (counting from one)"
msgstr ""
"Разделяет строку <parameter>string</parameter> по символу "
"<parameter>delimiter</parameter> и возвращает элемент по заданному номеру "
"(считая с 1)"

#: func.xml:2099(literal)
msgid "split_part('abc~@~def~@~ghi', '~@~', 2)"
msgstr "split_part('abc~@~def&zwsp;~@~ghi', '~@~', 2)"

#: func.xml:2100(literal)
msgid "def"
msgstr "def"

#: func.xml:2105(indexterm)
msgid "<primary>strpos</primary>"
msgstr "<primary>strpos</primary>"

#: func.xml:2108(function)
msgid "strpos(<placeholder-1/>, <placeholder-2/>)"
msgstr "strpos(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:2111(entry)
msgid ""
"Location of specified substring (same as "
"<literal>position(<parameter>substring</parameter> in <parameter>string</"
"parameter>)</literal>, but note the reversed argument order)"
msgstr ""
"Возвращает положение указанной подстроки (подобно "
"<literal>position(<parameter>substring</parameter> in <parameter>string</"
"parameter>)</literal>, но с другим порядком аргументов)"

#: func.xml:2117(literal)
msgid "strpos('high', 'ig')"
msgstr "strpos('high', 'ig')"

#: func.xml:2123(indexterm)
msgid "<primary>substr</primary>"
msgstr "<primary>substr</primary>"

#: func.xml:2126(optional) func.xml:9723(optional) func.xml:9990(optional)
#: func.xml:10049(optional) func.xml:11889(optional) func.xml:11923(optional)
#: func.xml:11983(optional) func.xml:12017(optional)
msgid ", <placeholder-1/>"
msgstr ", <placeholder-1/>"

#: func.xml:2126(function)
msgid "substr(<placeholder-1/>, <placeholder-2/> <placeholder-3/>)"
msgstr "substr(<placeholder-1/>, <placeholder-2/> <placeholder-3/>)"

#: func.xml:2129(entry)
msgid ""
"Extract substring (same as <literal>substring(<parameter>string</parameter> "
"from <parameter>from</parameter> for <parameter>count</parameter>)</literal>)"
msgstr ""
"Извлекает подстроку (подобно <literal>substring(<parameter>string</"
"parameter> from <parameter>from</parameter> for <parameter>count</"
"parameter>)</literal>)"

#: func.xml:2133(literal)
msgid "substr('alphabet', 3, 2)"
msgstr "substr('alphabet', 3, 2)"

#: func.xml:2134(literal)
msgid "ph"
msgstr "ph"

#: func.xml:2139(indexterm)
msgid "<primary>to_ascii</primary>"
msgstr "<primary>to_ascii</primary>"

#: func.xml:2142(function)
msgid ""
"to_ascii(<placeholder-1/> <placeholder-2/>\n"
"        <placeholder-3/>)"
msgstr ""
"to_ascii(<placeholder-1/> <placeholder-2/>\n"
"        <placeholder-3/>)"

#: func.xml:2146(entry)
msgid ""
"Convert <parameter>string</parameter> to <acronym>ASCII</acronym> from "
"another encoding (only supports conversion from <literal>LATIN1</literal>, "
"<literal>LATIN2</literal>, <literal>LATIN9</literal>, and <literal>WIN1250</"
"literal> encodings)"
msgstr ""
"Преобразует <parameter>string</parameter> в <acronym>ASCII</acronym> из "
"кодировки <parameter>encoding</parameter> (поддерживаются только "
"<literal>LATIN1</literal>, <literal>LATIN2</literal>, <literal>LATIN9</"
"literal> и <literal>WIN1250</literal>)"

#: func.xml:2151(literal)
msgid "to_ascii('Karel')"
msgstr "to_ascii('Karel')"

#: func.xml:2152(literal)
msgid "Karel"
msgstr "Karel"

#: func.xml:2157(indexterm)
msgid "<primary>to_hex</primary>"
msgstr "<primary>to_hex</primary>"

#: func.xml:2161(type) func.xml:11206(type) func.xml:11212(type)
#: func.xml:11218(type) func.xml:11222(type) func.xml:11223(type)
#: func.xml:11227(type) func.xml:11228(type) func.xml:12605(type)
#: func.xml:12613(type) func.xml:13021(type) func.xml:13496(type)
#: func.xml:13518(type) func.xml:13702(type) func.xml:13715(type)
#: func.xml:13728(type) func.xml:16498(type) func.xml:16513(type)
#: func.xml:16518(type) func.xml:16845(type) func.xml:18167(type)
#: func.xml:18174(type) func.xml:18181(type) func.xml:18190(type)
#: func.xml:18201(type) func.xml:18210(type) func.xml:18217(type)
#: func.xml:18239(type) func.xml:18249(type) func.xml:18256(type)
#: func.xml:18263(type) func.xml:18505(type) func.xml:18568(type)
#: func.xml:18577(type) func.xml:18679(type) func.xml:18693(type)
#: func.xml:18707(type) func.xml:18728(type) func.xml:18742(type)
#: func.xml:18756(type) func.xml:18770(type) func.xml:18784(type)
#: func.xml:18798(type) func.xml:18812(type)
msgctxt "type"
msgid "bigint"
msgstr "bigint"

#: func.xml:2160(function)
msgid "to_hex(<placeholder-1/> <placeholder-2/> or <placeholder-3/>)"
msgstr "to_hex(<placeholder-1/> <placeholder-2/> или <placeholder-3/>)"

#: func.xml:2164(entry)
msgid ""
"Convert <parameter>number</parameter> to its equivalent hexadecimal "
"representation"
msgstr "Преобразует число <parameter>number</parameter> в 16-ричный вид"

#: func.xml:2167(literal)
msgid "to_hex(2147483647)"
msgstr "to_hex(2147483647)"

#: func.xml:2168(literal)
msgid "7fffffff"
msgstr "7fffffff"

#: func.xml:2173(indexterm)
msgid "<primary>translate</primary>"
msgstr "<primary>translate</primary>"

#: func.xml:2176(function)
msgid ""
"translate(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"translate(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:2181(entry)
msgid ""
"Any character in <parameter>string</parameter> that matches a character in "
"the <parameter>from</parameter> set is replaced by the corresponding "
"character in the <parameter>to</parameter> set. If <parameter>from</"
"parameter> is longer than <parameter>to</parameter>, occurrences of the "
"extra characters in <parameter>from</parameter> are removed."
msgstr ""
"Заменяет символы в <parameter>string</parameter>, найденные в наборе "
"<parameter>from</parameter>, на соответствующие символы в множестве "
"<parameter>to</parameter>. Если строка <parameter>from</parameter> длиннее "
"<parameter>to</parameter>, найденные в исходной строке лишние символы "
"<parameter>from</parameter> удаляются."

#: func.xml:2189(literal)
msgid "translate('12345', '143', 'ax')"
msgstr "translate('12345', '143', 'ax')"

#: func.xml:2190(literal)
msgid "a2x5"
msgstr "a2x5"

#: func.xml:2197(para)
msgid ""
"The <function>concat</function>, <function>concat_ws</function> and "
"<function>format</function> functions are variadic, so it is possible to "
"pass the values to be concatenated or formatted as an array marked with the "
"<literal>VARIADIC</literal> keyword (see <xref linkend=\"xfunc-sql-variadic-"
"functions\"/>). The array's elements are treated as if they were separate "
"ordinary arguments to the function. If the variadic array argument is NULL, "
"<function>concat</function> and <function>concat_ws</function> return NULL, "
"but <function>format</function> treats a NULL as a zero-element array."
msgstr ""
"Функции <function>concat</function>, <function>concat_ws</function> и "
"<function>format</function> принимают переменное число аргументов, так что "
"им для объединения или форматирования можно передавать значения в виде "
"массива, помеченного ключевым словом <literal>VARIADIC</literal> (см. <xref "
"remap=\"4\" linkend=\"xfunc-sql-variadic-functions\"/>). Элементы такого "
"массива обрабатываются, как если бы они были обычными аргументами функции. "
"Если вместо массива в соответствующем аргументе передаётся NULL, функции "
"<function>concat</function> и <function>concat_ws</function> возвращают "
"NULL, а <function>format</function> воспринимает NULL как массив нулевого "
"размера."

#: func.xml:2209(para)
msgid ""
"See also the aggregate function <function>string_agg</function> in <xref "
"linkend=\"functions-aggregate\"/>."
msgstr ""
"См. также агрегатную функцию <function>string_agg</function> в <xref remap="
"\"6\" linkend=\"functions-aggregate\"/>."

#: func.xml:2215(title)
msgid "Built-in Conversions"
msgstr "Встроенные преобразования"

#: func.xml:2221(para)
msgid ""
"The conversion names follow a standard naming scheme: The official name of "
"the source encoding with all non-alphanumeric characters replaced by "
"underscores, followed by <literal>_to_</literal>, followed by the similarly "
"processed destination encoding name. Therefore, the names might deviate from "
"the customary encoding names."
msgstr ""
"Имена преобразований следуют стандартной схеме именования. К официальному "
"названию исходной кодировки, в котором все не алфавитно-цифровые символы "
"заменяются подчёркиваниями, добавляется <literal>_to_</literal>, а за ним "
"аналогично подготовленное имя целевой кодировки. Таким образом, имена "
"кодировок могут не совпадать буквально с общепринятыми названиями."

#: func.xml:2219(entry)
msgid "Conversion Name <placeholder-1/>"
msgstr "Имя преобразования <placeholder-1/>"

#: func.xml:2231(entry)
msgid "Source Encoding"
msgstr "Исходная кодировка"

#: func.xml:2232(entry)
msgid "Destination Encoding"
msgstr "Целевая кодировка"

#: func.xml:2238(literal)
msgid "ascii_to_mic"
msgstr "ascii_to_mic"

#: func.xml:2240(literal) func.xml:2258(literal) func.xml:2270(literal)
#: func.xml:2282(literal) func.xml:2300(literal) func.xml:2318(literal)
#: func.xml:2372(literal) func.xml:2384(literal) func.xml:2402(literal)
#: func.xml:2414(literal) func.xml:2432(literal) func.xml:2492(literal)
#: func.xml:2521(literal) func.xml:2527(literal) func.xml:2533(literal)
#: func.xml:2539(literal) func.xml:2545(literal) func.xml:2551(literal)
#: func.xml:2557(literal) func.xml:2563(literal) func.xml:2569(literal)
#: func.xml:2575(literal) func.xml:2581(literal) func.xml:2587(literal)
#: func.xml:2593(literal) func.xml:2599(literal) func.xml:2605(literal)
#: func.xml:2611(literal) func.xml:2624(literal) func.xml:2882(literal)
#: func.xml:2906(literal) func.xml:2948(literal)
msgid "MULE_INTERNAL"
msgstr "MULE_INTERNAL"

#: func.xml:2244(literal)
msgid "ascii_to_utf8"
msgstr "ascii_to_utf8"

#: func.xml:2246(literal) func.xml:2264(literal) func.xml:2276(literal)
#: func.xml:2294(literal) func.xml:2306(literal) func.xml:2324(literal)
#: func.xml:2330(literal) func.xml:2336(literal) func.xml:2342(literal)
#: func.xml:2348(literal) func.xml:2354(literal) func.xml:2360(literal)
#: func.xml:2366(literal) func.xml:2378(literal) func.xml:2390(literal)
#: func.xml:2408(literal) func.xml:2420(literal) func.xml:2438(literal)
#: func.xml:2456(literal) func.xml:2462(literal) func.xml:2468(literal)
#: func.xml:2474(literal) func.xml:2480(literal) func.xml:2498(literal)
#: func.xml:2516(literal) func.xml:2630(literal) func.xml:2636(literal)
#: func.xml:2642(literal) func.xml:2647(literal) func.xml:2653(literal)
#: func.xml:2659(literal) func.xml:2665(literal) func.xml:2671(literal)
#: func.xml:2677(literal) func.xml:2683(literal) func.xml:2689(literal)
#: func.xml:2695(literal) func.xml:2701(literal) func.xml:2707(literal)
#: func.xml:2713(literal) func.xml:2719(literal) func.xml:2725(literal)
#: func.xml:2731(literal) func.xml:2737(literal) func.xml:2743(literal)
#: func.xml:2749(literal) func.xml:2755(literal) func.xml:2761(literal)
#: func.xml:2767(literal) func.xml:2773(literal) func.xml:2779(literal)
#: func.xml:2785(literal) func.xml:2791(literal) func.xml:2797(literal)
#: func.xml:2803(literal) func.xml:2809(literal) func.xml:2815(literal)
#: func.xml:2821(literal) func.xml:2827(literal) func.xml:2833(literal)
#: func.xml:2839(literal) func.xml:2845(literal) func.xml:2851(literal)
#: func.xml:2857(literal) func.xml:2863(literal) func.xml:2869(literal)
#: func.xml:2888(literal) func.xml:2912(literal) func.xml:2924(literal)
#: func.xml:2930(literal) func.xml:2954(literal) func.xml:2966(literal)
#: func.xml:2972(literal) func.xml:2977(literal) func.xml:2984(literal)
#: func.xml:2989(literal)
msgid "UTF8"
msgstr "UTF8"

#: func.xml:2250(literal)
msgid "big5_to_euc_tw"
msgstr "big5_to_euc_tw"

#: func.xml:2251(literal) func.xml:2257(literal) func.xml:2263(literal)
#: func.xml:2312(literal) func.xml:2528(literal) func.xml:2654(literal)
msgid "BIG5"
msgstr "BIG5"

#: func.xml:2252(literal) func.xml:2311(literal) func.xml:2317(literal)
#: func.xml:2323(literal) func.xml:2552(literal) func.xml:2678(literal)
msgid "EUC_TW"
msgstr "EUC_TW"

#: func.xml:2256(literal)
msgid "big5_to_mic"
msgstr "big5_to_mic"

#: func.xml:2262(literal)
msgid "big5_to_utf8"
msgstr "big5_to_utf8"

#: func.xml:2268(literal)
msgid "euc_cn_to_mic"
msgstr "euc_cn_to_mic"

#: func.xml:2269(literal) func.xml:2275(literal) func.xml:2534(literal)
#: func.xml:2660(literal)
msgid "EUC_CN"
msgstr "EUC_CN"

#: func.xml:2274(literal)
msgid "euc_cn_to_utf8"
msgstr "euc_cn_to_utf8"

#: func.xml:2280(literal)
msgid "euc_jp_to_mic"
msgstr "euc_jp_to_mic"

#: func.xml:2281(literal) func.xml:2287(literal) func.xml:2293(literal)
#: func.xml:2540(literal) func.xml:2618(literal) func.xml:2666(literal)
msgid "EUC_JP"
msgstr "EUC_JP"

#: func.xml:2286(literal)
msgid "euc_jp_to_sjis"
msgstr "euc_jp_to_sjis"

#: func.xml:2288(literal) func.xml:2594(literal) func.xml:2617(literal)
#: func.xml:2623(literal) func.xml:2629(literal) func.xml:2798(literal)
msgid "SJIS"
msgstr "SJIS"

#: func.xml:2292(literal)
msgid "euc_jp_to_utf8"
msgstr "euc_jp_to_utf8"

#: func.xml:2298(literal)
msgid "euc_kr_to_mic"
msgstr "euc_kr_to_mic"

#: func.xml:2299(literal) func.xml:2305(literal) func.xml:2546(literal)
#: func.xml:2672(literal)
msgid "EUC_KR"
msgstr "EUC_KR"

#: func.xml:2304(literal)
msgid "euc_kr_to_utf8"
msgstr "euc_kr_to_utf8"

#: func.xml:2310(literal)
msgid "euc_tw_to_big5"
msgstr "euc_tw_to_big5"

#: func.xml:2316(literal)
msgid "euc_tw_to_mic"
msgstr "euc_tw_to_mic"

#: func.xml:2322(literal)
msgid "euc_tw_to_utf8"
msgstr "euc_tw_to_utf8"

#: func.xml:2328(literal)
msgid "gb18030_to_utf8"
msgstr "gb18030_to_utf8"

#: func.xml:2329(literal) func.xml:2684(literal)
msgid "GB18030"
msgstr "GB18030"

#: func.xml:2334(literal)
msgid "gbk_to_utf8"
msgstr "gbk_to_utf8"

#: func.xml:2335(literal) func.xml:2690(literal)
msgid "GBK"
msgstr "GBK"

#: func.xml:2340(literal)
msgid "iso_8859_10_to_utf8"
msgstr "iso_8859_10_to_utf8"

#: func.xml:2341(literal) func.xml:2702(literal)
msgid "LATIN6"
msgstr "LATIN6"

#: func.xml:2346(literal)
msgid "iso_8859_13_to_utf8"
msgstr "iso_8859_13_to_utf8"

#: func.xml:2347(literal) func.xml:2708(literal)
msgid "LATIN7"
msgstr "LATIN7"

#: func.xml:2352(literal)
msgid "iso_8859_14_to_utf8"
msgstr "iso_8859_14_to_utf8"

#: func.xml:2353(literal) func.xml:2714(literal)
msgid "LATIN8"
msgstr "LATIN8"

#: func.xml:2358(literal)
msgid "iso_8859_15_to_utf8"
msgstr "iso_8859_15_to_utf8"

#: func.xml:2359(literal) func.xml:2720(literal)
msgid "LATIN9"
msgstr "LATIN9"

#: func.xml:2364(literal)
msgid "iso_8859_16_to_utf8"
msgstr "iso_8859_16_to_utf8"

#: func.xml:2365(literal) func.xml:2726(literal)
msgid "LATIN10"
msgstr "LATIN10"

#: func.xml:2370(literal)
msgid "iso_8859_1_to_mic"
msgstr "iso_8859_1_to_mic"

#: func.xml:2371(literal) func.xml:2377(literal) func.xml:2558(literal)
#: func.xml:2696(literal)
msgid "LATIN1"
msgstr "LATIN1"

#: func.xml:2376(literal)
msgid "iso_8859_1_to_utf8"
msgstr "iso_8859_1_to_utf8"

#: func.xml:2382(literal)
msgid "iso_8859_2_to_mic"
msgstr "iso_8859_2_to_mic"

#: func.xml:2383(literal) func.xml:2389(literal) func.xml:2395(literal)
#: func.xml:2564(literal) func.xml:2732(literal) func.xml:2876(literal)
msgid "LATIN2"
msgstr "LATIN2"

#: func.xml:2388(literal)
msgid "iso_8859_2_to_utf8"
msgstr "iso_8859_2_to_utf8"

#: func.xml:2394(literal)
msgid "iso_8859_2_to_windows_1250"
msgstr "iso_8859_2_to_windows_1250"

#: func.xml:2396(literal) func.xml:2600(literal) func.xml:2816(literal)
#: func.xml:2875(literal) func.xml:2881(literal) func.xml:2887(literal)
msgid "WIN1250"
msgstr "WIN1250"

#: func.xml:2400(literal)
msgid "iso_8859_3_to_mic"
msgstr "iso_8859_3_to_mic"

#: func.xml:2401(literal) func.xml:2407(literal) func.xml:2570(literal)
#: func.xml:2738(literal)
msgid "LATIN3"
msgstr "LATIN3"

#: func.xml:2406(literal)
msgid "iso_8859_3_to_utf8"
msgstr "iso_8859_3_to_utf8"

#: func.xml:2412(literal)
msgid "iso_8859_4_to_mic"
msgstr "iso_8859_4_to_mic"

#: func.xml:2413(literal) func.xml:2419(literal) func.xml:2576(literal)
#: func.xml:2744(literal)
msgid "LATIN4"
msgstr "LATIN4"

#: func.xml:2418(literal)
msgid "iso_8859_4_to_utf8"
msgstr "iso_8859_4_to_utf8"

#: func.xml:2424(literal)
msgid "iso_8859_5_to_koi8_r"
msgstr "iso_8859_5_to_koi8_r"

#: func.xml:2425(literal) func.xml:2431(literal) func.xml:2437(literal)
#: func.xml:2443(literal) func.xml:2449(literal) func.xml:2486(literal)
#: func.xml:2582(literal) func.xml:2750(literal) func.xml:2894(literal)
#: func.xml:2936(literal)
msgid "ISO_8859_5"
msgstr "ISO_8859_5"

#: func.xml:2426(literal) func.xml:2485(literal) func.xml:2491(literal)
#: func.xml:2497(literal) func.xml:2503(literal) func.xml:2509(literal)
#: func.xml:2588(literal) func.xml:2786(literal) func.xml:2900(literal)
#: func.xml:2942(literal)
msgid "KOI8R"
msgstr "KOI8R"

#: func.xml:2430(literal)
msgid "iso_8859_5_to_mic"
msgstr "iso_8859_5_to_mic"

#: func.xml:2436(literal)
msgid "iso_8859_5_to_utf8"
msgstr "iso_8859_5_to_utf8"

#: func.xml:2442(literal)
msgid "iso_8859_5_to_windows_1251"
msgstr "iso_8859_5_to_windows_1251"

#: func.xml:2444(literal) func.xml:2504(literal) func.xml:2606(literal)
#: func.xml:2822(literal) func.xml:2893(literal) func.xml:2899(literal)
#: func.xml:2905(literal) func.xml:2911(literal) func.xml:2917(literal)
msgid "WIN1251"
msgstr "WIN1251"

#: func.xml:2448(literal)
msgid "iso_8859_5_to_windows_866"
msgstr "iso_8859_5_to_windows_866"

#: func.xml:2450(literal) func.xml:2510(literal) func.xml:2612(literal)
#: func.xml:2864(literal) func.xml:2918(literal) func.xml:2935(literal)
#: func.xml:2941(literal) func.xml:2947(literal) func.xml:2953(literal)
#: func.xml:2959(literal)
msgid "WIN866"
msgstr "WIN866"

#: func.xml:2454(literal)
msgid "iso_8859_6_to_utf8"
msgstr "iso_8859_6_to_utf8"

#: func.xml:2455(literal) func.xml:2756(literal)
msgid "ISO_8859_6"
msgstr "ISO_8859_6"

#: func.xml:2460(literal)
msgid "iso_8859_7_to_utf8"
msgstr "iso_8859_7_to_utf8"

#: func.xml:2461(literal) func.xml:2762(literal)
msgid "ISO_8859_7"
msgstr "ISO_8859_7"

#: func.xml:2466(literal)
msgid "iso_8859_8_to_utf8"
msgstr "iso_8859_8_to_utf8"

#: func.xml:2467(literal) func.xml:2768(literal)
msgid "ISO_8859_8"
msgstr "ISO_8859_8"

#: func.xml:2472(literal)
msgid "iso_8859_9_to_utf8"
msgstr "iso_8859_9_to_utf8"

#: func.xml:2473(literal) func.xml:2774(literal)
msgid "LATIN5"
msgstr "LATIN5"

#: func.xml:2478(literal)
msgid "johab_to_utf8"
msgstr "johab_to_utf8"

#: func.xml:2479(literal) func.xml:2780(literal)
msgid "JOHAB"
msgstr "JOHAB"

#: func.xml:2484(literal)
msgid "koi8_r_to_iso_8859_5"
msgstr "koi8_r_to_iso_8859_5"

#: func.xml:2490(literal)
msgid "koi8_r_to_mic"
msgstr "koi8_r_to_mic"

#: func.xml:2496(literal)
msgid "koi8_r_to_utf8"
msgstr "koi8_r_to_utf8"

#: func.xml:2502(literal)
msgid "koi8_r_to_windows_1251"
msgstr "koi8_r_to_windows_1251"

#: func.xml:2508(literal)
msgid "koi8_r_to_windows_866"
msgstr "koi8_r_to_windows_866"

#: func.xml:2514(literal)
msgid "koi8_u_to_utf8"
msgstr "koi8_u_to_utf8"

#: func.xml:2515(literal) func.xml:2792(literal)
msgid "KOI8U"
msgstr "KOI8U"

#: func.xml:2520(literal)
msgid "mic_to_ascii"
msgstr "mic_to_ascii"

#: func.xml:2526(literal)
msgid "mic_to_big5"
msgstr "mic_to_big5"

#: func.xml:2532(literal)
msgid "mic_to_euc_cn"
msgstr "mic_to_euc_cn"

#: func.xml:2538(literal)
msgid "mic_to_euc_jp"
msgstr "mic_to_euc_jp"

#: func.xml:2544(literal)
msgid "mic_to_euc_kr"
msgstr "mic_to_euc_kr"

#: func.xml:2550(literal)
msgid "mic_to_euc_tw"
msgstr "mic_to_euc_tw"

#: func.xml:2556(literal)
msgid "mic_to_iso_8859_1"
msgstr "mic_to_iso_8859_1"

#: func.xml:2562(literal)
msgid "mic_to_iso_8859_2"
msgstr "mic_to_iso_8859_2"

#: func.xml:2568(literal)
msgid "mic_to_iso_8859_3"
msgstr "mic_to_iso_8859_3"

#: func.xml:2574(literal)
msgid "mic_to_iso_8859_4"
msgstr "mic_to_iso_8859_4"

#: func.xml:2580(literal)
msgid "mic_to_iso_8859_5"
msgstr "mic_to_iso_8859_5"

#: func.xml:2586(literal)
msgid "mic_to_koi8_r"
msgstr "mic_to_koi8_r"

#: func.xml:2592(literal)
msgid "mic_to_sjis"
msgstr "mic_to_sjis"

#: func.xml:2598(literal)
msgid "mic_to_windows_1250"
msgstr "mic_to_windows_1250"

#: func.xml:2604(literal)
msgid "mic_to_windows_1251"
msgstr "mic_to_windows_1251"

#: func.xml:2610(literal)
msgid "mic_to_windows_866"
msgstr "mic_to_windows_866"

#: func.xml:2616(literal)
msgid "sjis_to_euc_jp"
msgstr "sjis_to_euc_jp"

#: func.xml:2622(literal)
msgid "sjis_to_mic"
msgstr "sjis_to_mic"

#: func.xml:2628(literal)
msgid "sjis_to_utf8"
msgstr "sjis_to_utf8"

#: func.xml:2634(literal)
msgid "tcvn_to_utf8"
msgstr "tcvn_to_utf8"

#: func.xml:2635(literal) func.xml:2804(literal)
msgid "WIN1258"
msgstr "WIN1258"

#: func.xml:2640(literal)
msgid "uhc_to_utf8"
msgstr "uhc_to_utf8"

#: func.xml:2641(literal) func.xml:2810(literal)
msgid "UHC"
msgstr "UHC"

#: func.xml:2646(literal)
msgid "utf8_to_ascii"
msgstr "utf8_to_ascii"

#: func.xml:2652(literal)
msgid "utf8_to_big5"
msgstr "utf8_to_big5"

#: func.xml:2658(literal)
msgid "utf8_to_euc_cn"
msgstr "utf8_to_euc_cn"

#: func.xml:2664(literal)
msgid "utf8_to_euc_jp"
msgstr "utf8_to_euc_jp"

#: func.xml:2670(literal)
msgid "utf8_to_euc_kr"
msgstr "utf8_to_euc_kr"

#: func.xml:2676(literal)
msgid "utf8_to_euc_tw"
msgstr "utf8_to_euc_tw"

#: func.xml:2682(literal)
msgid "utf8_to_gb18030"
msgstr "utf8_to_gb18030"

#: func.xml:2688(literal)
msgid "utf8_to_gbk"
msgstr "utf8_to_gbk"

#: func.xml:2694(literal)
msgid "utf8_to_iso_8859_1"
msgstr "utf8_to_iso_8859_1"

#: func.xml:2700(literal)
msgid "utf8_to_iso_8859_10"
msgstr "utf8_to_iso_8859_10"

#: func.xml:2706(literal)
msgid "utf8_to_iso_8859_13"
msgstr "utf8_to_iso_8859_13"

#: func.xml:2712(literal)
msgid "utf8_to_iso_8859_14"
msgstr "utf8_to_iso_8859_14"

#: func.xml:2718(literal)
msgid "utf8_to_iso_8859_15"
msgstr "utf8_to_iso_8859_15"

#: func.xml:2724(literal)
msgid "utf8_to_iso_8859_16"
msgstr "utf8_to_iso_8859_16"

#: func.xml:2730(literal)
msgid "utf8_to_iso_8859_2"
msgstr "utf8_to_iso_8859_2"

#: func.xml:2736(literal)
msgid "utf8_to_iso_8859_3"
msgstr "utf8_to_iso_8859_3"

#: func.xml:2742(literal)
msgid "utf8_to_iso_8859_4"
msgstr "utf8_to_iso_8859_4"

#: func.xml:2748(literal)
msgid "utf8_to_iso_8859_5"
msgstr "utf8_to_iso_8859_5"

#: func.xml:2754(literal)
msgid "utf8_to_iso_8859_6"
msgstr "utf8_to_iso_8859_6"

#: func.xml:2760(literal)
msgid "utf8_to_iso_8859_7"
msgstr "utf8_to_iso_8859_7"

#: func.xml:2766(literal)
msgid "utf8_to_iso_8859_8"
msgstr "utf8_to_iso_8859_8"

#: func.xml:2772(literal)
msgid "utf8_to_iso_8859_9"
msgstr "utf8_to_iso_8859_9"

#: func.xml:2778(literal)
msgid "utf8_to_johab"
msgstr "utf8_to_johab"

#: func.xml:2784(literal)
msgid "utf8_to_koi8_r"
msgstr "utf8_to_koi8_r"

#: func.xml:2790(literal)
msgid "utf8_to_koi8_u"
msgstr "utf8_to_koi8_u"

#: func.xml:2796(literal)
msgid "utf8_to_sjis"
msgstr "utf8_to_sjis"

#: func.xml:2802(literal)
msgid "utf8_to_tcvn"
msgstr "utf8_to_tcvn"

#: func.xml:2808(literal)
msgid "utf8_to_uhc"
msgstr "utf8_to_uhc"

#: func.xml:2814(literal)
msgid "utf8_to_windows_1250"
msgstr "utf8_to_windows_1250"

#: func.xml:2820(literal)
msgid "utf8_to_windows_1251"
msgstr "utf8_to_windows_1251"

#: func.xml:2826(literal)
msgid "utf8_to_windows_1252"
msgstr "utf8_to_windows_1252"

#: func.xml:2828(literal) func.xml:2923(literal)
msgid "WIN1252"
msgstr "WIN1252"

#: func.xml:2832(literal)
msgid "utf8_to_windows_1253"
msgstr "utf8_to_windows_1253"

#: func.xml:2834(literal)
msgid "WIN1253"
msgstr "WIN1253"

#: func.xml:2838(literal)
msgid "utf8_to_windows_1254"
msgstr "utf8_to_windows_1254"

#: func.xml:2840(literal)
msgid "WIN1254"
msgstr "WIN1254"

#: func.xml:2844(literal)
msgid "utf8_to_windows_1255"
msgstr "utf8_to_windows_1255"

#: func.xml:2846(literal)
msgid "WIN1255"
msgstr "WIN1255"

#: func.xml:2850(literal)
msgid "utf8_to_windows_1256"
msgstr "utf8_to_windows_1256"

#: func.xml:2852(literal) func.xml:2929(literal)
msgid "WIN1256"
msgstr "WIN1256"

#: func.xml:2856(literal)
msgid "utf8_to_windows_1257"
msgstr "utf8_to_windows_1257"

#: func.xml:2858(literal)
msgid "WIN1257"
msgstr "WIN1257"

#: func.xml:2862(literal)
msgid "utf8_to_windows_866"
msgstr "utf8_to_windows_866"

#: func.xml:2868(literal)
msgid "utf8_to_windows_874"
msgstr "utf8_to_windows_874"

#: func.xml:2870(literal) func.xml:2965(literal)
msgid "WIN874"
msgstr "WIN874"

#: func.xml:2874(literal)
msgid "windows_1250_to_iso_8859_2"
msgstr "windows_1250_to_iso_8859_2"

#: func.xml:2880(literal)
msgid "windows_1250_to_mic"
msgstr "windows_1250_to_mic"

#: func.xml:2886(literal)
msgid "windows_1250_to_utf8"
msgstr "windows_1250_to_utf8"

#: func.xml:2892(literal)
msgid "windows_1251_to_iso_8859_5"
msgstr "windows_1251_to_iso_8859_5"

#: func.xml:2898(literal)
msgid "windows_1251_to_koi8_r"
msgstr "windows_1251_to_koi8_r"

#: func.xml:2904(literal)
msgid "windows_1251_to_mic"
msgstr "windows_1251_to_mic"

#: func.xml:2910(literal)
msgid "windows_1251_to_utf8"
msgstr "windows_1251_to_utf8"

#: func.xml:2916(literal)
msgid "windows_1251_to_windows_866"
msgstr "windows_1251_to_windows_866"

#: func.xml:2922(literal)
msgid "windows_1252_to_utf8"
msgstr "windows_1252_to_utf8"

#: func.xml:2928(literal)
msgid "windows_1256_to_utf8"
msgstr "windows_1256_to_utf8"

#: func.xml:2934(literal)
msgid "windows_866_to_iso_8859_5"
msgstr "windows_866_to_iso_8859_5"

#: func.xml:2940(literal)
msgid "windows_866_to_koi8_r"
msgstr "windows_866_to_koi8_r"

#: func.xml:2946(literal)
msgid "windows_866_to_mic"
msgstr "windows_866_to_mic"

#: func.xml:2952(literal)
msgid "windows_866_to_utf8"
msgstr "windows_866_to_utf8"

#: func.xml:2958(literal)
msgid "windows_866_to_windows_1251"
msgstr "windows_866_to_windows_1251"

#: func.xml:2960(literal)
msgid "WIN"
msgstr "WIN"

#: func.xml:2964(literal)
msgid "windows_874_to_utf8"
msgstr "windows_874_to_utf8"

#: func.xml:2970(literal)
msgid "euc_jis_2004_to_utf8"
msgstr "euc_jis_2004_to_utf8"

#: func.xml:2971(literal) func.xml:2978(literal) func.xml:2995(literal)
#: func.xml:3002(literal)
msgid "EUC_JIS_2004"
msgstr "EUC_JIS_2004"

#: func.xml:2976(literal)
msgid "utf8_to_euc_jis_2004"
msgstr "utf8_to_euc_jis_2004"

#: func.xml:2982(literal)
msgid "shift_jis_2004_to_utf8"
msgstr "shift_jis_2004_to_utf8"

#: func.xml:2983(literal) func.xml:2990(literal) func.xml:2996(literal)
#: func.xml:3001(literal)
msgid "SHIFT_JIS_2004"
msgstr "SHIFT_JIS_2004"

#: func.xml:2988(literal)
msgid "utf8_to_shift_jis_2004"
msgstr "utf8_to_shift_jis_2004"

#: func.xml:2994(literal)
msgid "euc_jis_2004_to_shift_jis_2004"
msgstr "euc_jis_2004_to_shift_jis_2004"

#: func.xml:3000(literal)
msgid "shift_jis_2004_to_euc_jis_2004"
msgstr "shift_jis_2004_to_euc_jis_2004"

#: func.xml:3016(para)
msgid ""
"The function <function>format</function> produces output formatted according "
"to a format string, in a style similar to the C function <function>sprintf</"
"function>."
msgstr ""
"Функция <function>format</function> выдаёт текст, отформатированный в "
"соответствии со строкой формата, подобно функции <function>sprintf</"
"function> в C."

#: func.xml:3022(para)
msgid ""
"<synopsis><function>format</function>(<parameter>formatstr</parameter> "
"<type>text</type> [, <parameter>formatarg</parameter> <type>\"any\"</type> "
"[, ...] ])</synopsis>\n"
"     <replaceable>formatstr</replaceable> is a format string that specifies "
"how the result should be formatted. Text in the format string is copied "
"directly to the result, except where <firstterm>format specifiers</"
"firstterm> are used. Format specifiers act as placeholders in the string, "
"defining how subsequent function arguments should be formatted and inserted "
"into the result. Each <replaceable>formatarg</replaceable> argument is "
"converted to text according to the usual output rules for its data type, and "
"then formatted and inserted into the result string according to the format "
"specifier(s)."
msgstr ""
"<synopsis><function>format</function>(<parameter>formatstr</parameter> "
"<type>text</type> [, <parameter>formatarg</parameter> <type>\"any\"</type> "
"[, ...] ])</synopsis>\n"
"     <replaceable>formatstr</replaceable> &mdash; строка, определяющая, как "
"будет форматироваться результат. Обычный текст в строке формата "
"непосредственно копируется в результат, за исключением "
"<firstterm>спецификаторов формата</firstterm>. Спецификаторы формата "
"представляют собой местозаполнители, определяющие, как должны "
"форматироваться и выводиться в результате аргументы функции. Каждый аргумент "
"<replaceable>formatarg</replaceable> преобразуется в текст по правилам "
"выводам своего типа данных, а затем форматируется и вставляется в "
"результирующую строку согласно спецификаторам формата."

#: func.xml:3042(term)
msgid "<replaceable>position</replaceable> (optional)"
msgstr "<replaceable>позиция</replaceable> (необязателен)"

#: func.xml:3044(para)
msgid ""
"A string of the form <literal><replaceable>n</replaceable>$</literal> where "
"<replaceable>n</replaceable> is the index of the argument to print. Index 1 "
"means the first argument after <replaceable>formatstr</replaceable>. If the "
"<replaceable>position</replaceable> is omitted, the default is to use the "
"next argument in sequence."
msgstr ""
"Строка вида <literal><replaceable>n</replaceable>$</literal>, где "
"<replaceable>n</replaceable> &mdash; индекс выводимого аргумента. Индекс, "
"равный 1, выбирает первый аргумент после <replaceable>formatstr</"
"replaceable>. Если <replaceable>позиция</replaceable> опускается, по "
"умолчанию используется следующий аргумент по порядку."

#: func.xml:3055(term)
msgid "<replaceable>flags</replaceable> (optional)"
msgstr "<replaceable>флаги</replaceable> (необязателен)"

#: func.xml:3057(para)
msgid ""
"Additional options controlling how the format specifier's output is "
"formatted. Currently the only supported flag is a minus sign (<literal>-</"
"literal>) which will cause the format specifier's output to be left-"
"justified. This has no effect unless the <replaceable>width</replaceable> "
"field is also specified."
msgstr ""
"Дополнительные параметры, управляющие форматированием данного спецификатора. "
"В настоящее время поддерживается только знак минус (<literal>-</literal>), "
"который выравнивает результата спецификатора по левому краю. Он работает, "
"только если также определена <replaceable>ширина</replaceable>."

#: func.xml:3068(term)
msgid "<replaceable>width</replaceable> (optional)"
msgstr "<replaceable>ширина</replaceable> (необязателен)"

#: func.xml:3070(para)
msgid ""
"Specifies the <emphasis>minimum</emphasis> number of characters to use to "
"display the format specifier's output. The output is padded on the left or "
"right (depending on the <literal>-</literal> flag) with spaces as needed to "
"fill the width. A too-small width does not cause truncation of the output, "
"but is simply ignored. The width may be specified using any of the "
"following: a positive integer; an asterisk (<literal>*</literal>) to use the "
"next function argument as the width; or a string of the form "
"<literal>*<replaceable>n</replaceable>$</literal> to use the <replaceable>n</"
"replaceable>th function argument as the width."
msgstr ""
"Задаёт <emphasis>минимальное</emphasis> число символов, которое будет "
"занимать результат данного спецификатора. Выводимое значение выравнивается "
"по правой или левой стороне (в зависимости от флага <literal>-</literal>) с "
"дополнением необходимым числом пробелов. Если ширина слишком мала, она "
"просто игнорируется, т. е. результат не усекается. Ширину можно обозначить "
"положительным целым, звёздочкой (<literal>*</literal>), тогда ширина будет "
"получена из следующего аргумента функции, или строкой вида "
"<literal>*<replaceable>n</replaceable>$</literal>, тогда ширина будет "
"задаваться в <replaceable>n</replaceable>-ом аргументе функции."

#: func.xml:3082(para)
msgid ""
"If the width comes from a function argument, that argument is consumed "
"before the argument that is used for the format specifier's value. If the "
"width argument is negative, the result is left aligned (as if the <literal>-"
"</literal> flag had been specified) within a field of length <function>abs</"
"function>(<replaceable>width</replaceable>)."
msgstr ""
"Если ширина передаётся в аргументе функции, этот аргумент выбирается до "
"аргумента, используемого для спецификатора. Если аргумент ширины "
"отрицательный, результат выравнивается по левой стороне (как если бы был "
"указан флаг <literal>-</literal>) в рамках поля длины <function>abs</"
"function>(<replaceable>ширина</replaceable>)."

#: func.xml:3093(term)
msgid "<replaceable>type</replaceable> (required)"
msgstr "<replaceable>тип</replaceable> (обязателен)"

#: func.xml:3100(para)
msgid ""
"<literal>s</literal> formats the argument value as a simple string. A null "
"value is treated as an empty string."
msgstr ""
"<literal>s</literal> форматирует значение аргумента как простую строку. "
"Значение NULL представляется пустой строкой."

#: func.xml:3106(para)
msgid ""
"<literal>I</literal> treats the argument value as an SQL identifier, double-"
"quoting it if necessary. It is an error for the value to be null (equivalent "
"to <function>quote_ident</function>)."
msgstr ""
"<literal>I</literal> обрабатывает значение аргумента как SQL-идентификатор, "
"при необходимости заключая его в кавычки. Значение NULL для такого "
"преобразования считается ошибочным (так же, как и для <function>quote_ident</"
"function>)."

#: func.xml:3114(para)
msgid ""
"<literal>L</literal> quotes the argument value as an SQL literal. A null "
"value is displayed as the string <literal>NULL</literal>, without quotes "
"(equivalent to <function>quote_nullable</function>)."
msgstr ""
"<literal>L</literal> заключает значение аргумента в апострофы, как строку "
"SQL. Значение NULL выводится буквально, как <literal>NULL</literal>, без "
"кавычек (так же, как и с <function>quote_nullable</function>)."

#: func.xml:3095(para)
msgid ""
"The type of format conversion to use to produce the format specifier's "
"output. The following types are supported: <placeholder-1/>"
msgstr ""
"Тип спецификатора определяет преобразование соответствующего выводимого "
"значения. Поддерживаются следующие типы: <placeholder-1/>"

#: func.xml:3034(para)
msgid ""
"Format specifiers are introduced by a <literal>%</literal> character and "
"have the form <synopsis>%[<replaceable>position</replaceable>]"
"[<replaceable>flags</replaceable>][<replaceable>width</"
"replaceable>]<replaceable>type</replaceable></synopsis> where the component "
"fields are: <placeholder-1/>"
msgstr ""
"Спецификаторы формата предваряются символом <literal>%</literal> и имеют "
"форму <synopsis>%[<replaceable>позиция</replaceable>][<replaceable>флаги</"
"replaceable>][<replaceable>ширина</replaceable>]<replaceable>тип</"
"replaceable></synopsis> Здесь: <placeholder-1/>"

#: func.xml:3127(para)
msgid ""
"In addition to the format specifiers described above, the special sequence "
"<literal>%%</literal> may be used to output a literal <literal>%</literal> "
"character."
msgstr ""
"В дополнение к спецификаторам, описанным выше, можно использовать "
"спецпоследовательность <literal>%%</literal>, которая просто выведет символ "
"<literal>%</literal>."

#: func.xml:3132(para)
msgid ""
"Here are some examples of the basic format conversions: <screen>SELECT "
"format('Hello %s', 'World');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Hello World</"
"computeroutput>\n"
"\n"
"SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Testing one, two, "
"three, %</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\\'Reilly');\n"
"<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO \"Foo "
"bar\" VALUES('O''Reilly')</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'locations', E'C:\\\\Program "
"Files');\n"
"<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO "
"locations VALUES(E'C:\\\\Program Files')</computeroutput></screen>"
msgstr ""
"Несколько пример простых преобразований формата: <screen>SELECT "
"format('Hello %s', 'World');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Hello World</"
"computeroutput>\n"
"\n"
"SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Testing one, "
"two, three, %</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\\'Reilly');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>INSERT INTO "
"\"Foo bar\" VALUES('O''Reilly')</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'locations', E'C:\\\\Program "
"Files');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>INSERT INTO "
"locations VALUES(E'C:\\\\Program Files')</computeroutput></screen>"

#: func.xml:3148(para)
msgid ""
"Here are examples using <replaceable>width</replaceable> fields and the "
"<literal>-</literal> flag: <screen>SELECT format('|%10s|', 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%-10s|', 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', 10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', -10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', 10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', -10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput></screen>"
msgstr ""
"Следующие примеры иллюстрируют использование поля <replaceable>ширина</"
"replaceable> и флага <literal>-</literal>: <screen>SELECT format('|%10s|', "
"'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%-10s|', 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', 10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', -10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', 10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', -10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput></screen>"

#: func.xml:3171(para)
msgid ""
"These examples show use of <replaceable>position</replaceable> fields: "
"<screen>SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, "
"one</computeroutput>\n"
"\n"
"SELECT format('|%*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       bar|</"
"computeroutput>\n"
"\n"
"SELECT format('|%1$*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       foo|</"
"computeroutput></screen>"
msgstr ""
"Эти примеры показывают применение полей <replaceable>позиция</replaceable>: "
"<screen>SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Testing three, "
"two, one</computeroutput>\n"
"\n"
"SELECT format('|%*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       bar|</"
"computeroutput>\n"
"\n"
"SELECT format('|%1$*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</"
"computeroutput></screen>"

#: func.xml:3184(para)
msgid ""
"Unlike the standard C function <function>sprintf</function>, "
"<productname>PostgreSQL</productname>'s <function>format</function> function "
"allows format specifiers with and without <replaceable>position</"
"replaceable> fields to be mixed in the same format string. A format "
"specifier without a <replaceable>position</replaceable> field always uses "
"the next argument after the last argument consumed. In addition, the "
"<function>format</function> function does not require all function arguments "
"to be used in the format string. For example: <screen>SELECT format('Testing "
"%3$s, %2$s, %s', 'one', 'two', 'three');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, "
"three</computeroutput></screen>"
msgstr ""
"В отличие от стандартной функции C <function>sprintf</function>, функция "
"<function>format</function> в <productname>PostgreSQL</productname> "
"позволяет комбинировать в одной строке спецификаторы с полями "
"<replaceable>позиция</replaceable> и без них. Спецификатор формата без поля "
"<replaceable>позиция</replaceable> всегда использует следующий аргумент "
"после последнего выбранного. Кроме того, функция <function>format</function> "
"не требует, чтобы в строке формата использовались все аргументы функции. "
"Пример этого поведения: <screen>SELECT format('Testing %3$s, %2$s, %s', "
"'one', 'two', 'three');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Testing three, "
"two, three</computeroutput></screen>"

#: func.xml:3199(para)
msgid ""
"The <literal>%I</literal> and <literal>%L</literal> format specifiers are "
"particularly useful for safely constructing dynamic SQL statements. See "
"<xref linkend=\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Спецификаторы формата <literal>%I</literal> и <literal>%L</literal> особенно "
"полезны для безопасного составления динамических операторов SQL. См. <xref "
"remap=\"4\" linkend=\"plpgsql-quote-literal-example\"/>."

#: func.xml:3210(title)
msgid "Binary String Functions and Operators"
msgstr "Функции и операторы двоичных строк"

#: func.xml:3212(indexterm)
msgid "<primary>binary data</primary><secondary>functions</secondary>"
msgstr "<primary>двоичные данные</primary><secondary>функции</secondary>"

#: func.xml:3216(para)
msgid ""
"This section describes functions and operators for examining and "
"manipulating values of type <type>bytea</type>."
msgstr ""
"В этом разделе описываются функции и операторы для работы с данными типа "
"<type>bytea</type>."

#: func.xml:3221(para)
msgid ""
"<acronym>SQL</acronym> defines some string functions that use key words, "
"rather than commas, to separate arguments. Details are in <xref linkend="
"\"functions-binarystring-sql\"/>. <productname>PostgreSQL</productname> also "
"provides versions of these functions that use the regular function "
"invocation syntax (see <xref linkend=\"functions-binarystring-other\"/>)."
msgstr ""
"В <acronym>SQL</acronym> определены несколько строковых функций, в которых "
"аргументы разделяются не запятыми, а ключевыми словами. Подробнее это "
"описано в <xref remap=\"6\" linkend=\"functions-binarystring-sql\"/>. "
"<productname>PostgreSQL</productname> также предоставляет варианты этих "
"функций с синтаксисом, обычным для функций (см. <xref remap=\"4\" linkend="
"\"functions-binarystring-other\"/>)."

#: func.xml:3232(para)
msgid ""
"The sample results shown on this page assume that the server parameter <link "
"linkend=\"guc-bytea-output\"><varname>bytea_output</varname></link> is set "
"to <literal>escape</literal> (the traditional PostgreSQL format)."
msgstr ""
"В примерах, приведённых на этой странице, подразумевается, что параметр "
"сервера <link linkend=\"guc-bytea-output\"><varname>bytea_output</varname></"
"link> равен <literal>escape</literal> (выбран традиционный формат "
"PostgreSQL)."

#: func.xml:3240(title)
msgid "<acronym>SQL</acronym> Binary String Functions and Operators"
msgstr ""
"<acronym>SQL</acronym>-функции и операторы для работы с двоичными строками"

#: func.xml:3259(indexterm)
msgid "<primary>binary string</primary><secondary>concatenation</secondary>"
msgstr "<primary>двоичные строки</primary><secondary>конкатенация</secondary>"

#: func.xml:3263(literal)
msgid "E'\\\\\\\\Post'::bytea || E'\\\\047gres\\\\000'::bytea"
msgstr "E'\\\\\\\\Post'::bytea || E'\\\\047gres&zwsp;\\\\000'::bytea"

#: func.xml:3264(literal)
msgid "\\\\Post'gres\\000"
msgstr "\\\\Post'gres&zwsp;\\000"

#: func.xml:3275(entry)
msgid "Number of bytes in binary string"
msgstr "Число байт в двоичной строке"

#: func.xml:3276(literal)
msgid "octet_length(E'jo\\\\000se'::bytea)"
msgstr "octet_length(E'jo\\\\000se'::bytea)"

#: func.xml:3291(literal)
msgid ""
"overlay(E'Th\\\\000omas'::bytea placing E'\\\\002\\\\003'::bytea from 2 for "
"3)"
msgstr ""
"overlay(E'Th\\\\000&zwsp;omas'::bytea placing E'\\\\002\\\\003'::bytea from "
"2 for 3)"

#: func.xml:3292(literal)
msgid "T\\\\002\\\\003mas"
msgstr "T\\\\002&zwsp;\\\\003&zwsp;mas"

#: func.xml:3304(literal)
msgid "position(E'\\\\000om'::bytea in E'Th\\\\000omas'::bytea)"
msgstr "position(E'\\\\000om'::bytea in E'Th\\\\000&zwsp;omas'::bytea)"

#: func.xml:3319(literal)
msgid "substring(E'Th\\\\000omas'::bytea from 2 for 3)"
msgstr "substring(E'Th\\\\000&zwsp;omas'::bytea from 2 for 3)"

#: func.xml:3320(literal)
msgid "h\\000o"
msgstr "h\\000o"

#: func.xml:3328(optional)
msgid "both"
msgstr "both"

#: func.xml:3329(parameter) func.xml:3373(parameter)
msgid "bytes"
msgstr "bytes"

#: func.xml:3328(function)
msgid ""
"trim(<placeholder-1/>\n"
"        <placeholder-2/> from <placeholder-3/>)"
msgstr ""
"trim(<placeholder-1/>\n"
"        <placeholder-2/> from <placeholder-3/>)"

#: func.xml:3333(entry)
msgid ""
"Remove the longest string containing only the bytes in <parameter>bytes</"
"parameter> from the start and end of <parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, содержащую только байты <parameter>bytes</"
"parameter>, с начала и с конца строки <parameter>string</parameter>"

#: func.xml:3338(literal)
msgid "trim(E'\\\\000'::bytea from E'\\\\000Tom\\\\000'::bytea)"
msgstr "trim(E'\\\\000'::bytea from E'\\\\000Tom&zwsp;\\\\000'::bytea)"

#: func.xml:3345(para)
msgid ""
"Additional binary string manipulation functions are available and are listed "
"in <xref linkend=\"functions-binarystring-other\"/>. Some of them are used "
"internally to implement the <acronym>SQL</acronym>-standard string functions "
"listed in <xref linkend=\"functions-binarystring-sql\"/>."
msgstr ""
"В <productname>PostgreSQL</productname> есть и другие функции для работы с "
"двоичными строками, перечисленные в <xref remap=\"6\" linkend=\"functions-"
"binarystring-other\"/>. Некоторые из них используются в качестве внутренней "
"реализации стандартных функций <acronym>SQL</acronym>, приведённых в <xref "
"remap=\"6\" linkend=\"functions-binarystring-sql\"/>."

#: func.xml:3354(title)
msgid "Other Binary String Functions"
msgstr "Другие функции для работы с двоичными строками"

#: func.xml:3372(function)
msgid ""
"btrim(<placeholder-1/>\n"
"        <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"btrim(<placeholder-1/>\n"
"        <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:3376(entry)
msgid ""
"Remove the longest string consisting only of bytes in <parameter>bytes</"
"parameter> from the start and end of <parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, состоящую только из байт <parameter>bytes</"
"parameter>, с начала и с конца строки <parameter>string</parameter>"

#: func.xml:3381(literal)
msgid "btrim(E'\\\\000trim\\\\000'::bytea, E'\\\\000'::bytea)"
msgstr "btrim(E'\\\\000trim&zwsp;\\\\000'::bytea, E'\\\\000'::bytea)"

#: func.xml:3398(literal)
msgid "decode(E'123\\\\000456', 'escape')"
msgstr "decode(E'123&zwsp;\\\\000456', 'escape')"

#: func.xml:3399(literal) func.xml:3419(literal)
msgid "123\\000456"
msgstr "123\\000456"

#: func.xml:3418(literal)
msgid "encode(E'123\\\\000456'::bytea, 'escape')"
msgstr "encode(E'123&zwsp;\\\\000456'::bytea, 'escape')"

#: func.xml:3424(indexterm)
msgid "<primary>get_bit</primary>"
msgstr "<primary>get_bit</primary>"

#: func.xml:3427(parameter) func.xml:3442(parameter) func.xml:3495(parameter)
#: func.xml:3511(parameter) func.xml:18568(parameter) func.xml:18577(parameter)
msgctxt "parameter"
msgid "offset"
msgstr "offset"

#: func.xml:3427(function)
msgid "get_bit(<placeholder-1/>, <placeholder-2/>)"
msgstr "get_bit(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:3430(entry)
msgid "Extract bit from string"
msgstr "Извлекает бит из строки"

#: func.xml:3433(literal)
msgid "get_bit(E'Th\\\\000omas'::bytea, 45)"
msgstr "get_bit(E'Th\\\\000&zwsp;omas'::bytea, 45)"

#: func.xml:3439(indexterm)
msgid "<primary>get_byte</primary>"
msgstr "<primary>get_byte</primary>"

#: func.xml:3442(function)
msgid "get_byte(<placeholder-1/>, <placeholder-2/>)"
msgstr "get_byte(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:3445(entry)
msgid "Extract byte from string"
msgstr "Извлекает байт из строки"

#: func.xml:3448(literal)
msgid "get_byte(E'Th\\\\000omas'::bytea, 4)"
msgstr "get_byte(E'Th\\\\000&zwsp;omas'::bytea, 4)"

#: func.xml:3449(literal)
msgid "109"
msgstr "109"

#: func.xml:3462(indexterm)
msgid "<primary>binary string</primary><secondary>length</secondary>"
msgstr "<primary>двоичная строка</primary><secondary>длина</secondary>"

#: func.xml:3465(indexterm)
msgid ""
"<primary>length</primary><secondary sortas=\"binary string\">of a binary "
"string</secondary><see>binary strings, length</see>"
msgstr ""
"<primary>длина</primary><secondary sortas=\"двоичная строка\">двоичной "
"строки</secondary><see>двоичные строки, длина</see>"

#: func.xml:3460(entry)
msgid ""
"Length of binary string <placeholder-1/>\n"
"       <placeholder-2/>"
msgstr ""
"Длина двоичной строки <placeholder-1/>\n"
"       <placeholder-2/>"

#: func.xml:3469(literal)
msgid "length(E'jo\\\\000se'::bytea)"
msgstr "length(E'jo\\\\000se'::bytea)"

#: func.xml:3485(literal)
msgid "md5(E'Th\\\\000omas'::bytea)"
msgstr "md5(E'Th\\\\000&zwsp;omas'::bytea)"

#: func.xml:3486(literal)
msgid "8ab2d3c9689aaf18 b4958c334c82d8b1"
msgstr "8ab2d3c9&zwsp;689aaf18 b4958c33&zwsp;4c82d8b1"

#: func.xml:3491(indexterm)
msgid "<primary>set_bit</primary>"
msgstr "<primary>set_bit</primary>"

#: func.xml:3495(parameter) func.xml:3511(parameter)
msgid "newvalue"
msgstr "newvalue"

#: func.xml:3494(function)
msgid "set_bit(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "set_bit(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:3498(entry)
msgid "Set bit in string"
msgstr "Устанавливает значение бита в строке"

#: func.xml:3501(literal)
msgid "set_bit(E'Th\\\\000omas'::bytea, 45, 0)"
msgstr "set_bit(E'Th\\\\000&zwsp;omas'::bytea, 45, 0)"

#: func.xml:3502(literal)
msgid "Th\\000omAs"
msgstr "Th\\000omAs"

#: func.xml:3507(indexterm)
msgid "<primary>set_byte</primary>"
msgstr "<primary>set_byte</primary>"

#: func.xml:3510(function)
msgid "set_byte(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "set_byte(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:3514(entry)
msgid "Set byte in string"
msgstr "Устанавливает значение байта в строке"

#: func.xml:3517(literal)
msgid "set_byte(E'Th\\\\000omas'::bytea, 4, 64)"
msgstr "set_byte(E'Th\\\\000&zwsp;omas'::bytea, 4, 64)"

#: func.xml:3518(literal)
msgid "Th\\000o@as"
msgstr "Th\\000o@as"

#: func.xml:3524(para)
msgid ""
"<function>get_byte</function> and <function>set_byte</function> number the "
"first byte of a binary string as byte 0. <function>get_bit</function> and "
"<function>set_bit</function> number bits from the right within each byte; "
"for example bit 0 is the least significant bit of the first byte, and bit 15 "
"is the most significant bit of the second byte."
msgstr ""
"Для функций <function>get_byte</function> и <function>set_byte</function> "
"байты нумеруется с 0. Функции <function>get_bit</function> и "
"<function>set_bit</function> нумеруют биты справа налево; например, бит 0 "
"будет меньшим значащим битом первого байта, а бит 15 &mdash; большим "
"значащим битом второго байта."

#: func.xml:3532(para)
msgid ""
"See also the aggregate function <function>string_agg</function> in <xref "
"linkend=\"functions-aggregate\"/> and the large object functions in <xref "
"linkend=\"lo-funcs\"/>."
msgstr ""
"См. также агрегатную функцию <function>string_agg</function> в <xref remap="
"\"6\" linkend=\"functions-aggregate\"/> и функции для работы с большими "
"объектами в <xref remap=\"6\" linkend=\"lo-funcs\"/>."

#: func.xml:3541(title)
msgid "Bit String Functions and Operators"
msgstr "Функции и операторы для работы с битовыми строками"

#: func.xml:3543(indexterm)
msgid "<primary>bit strings</primary><secondary>functions</secondary>"
msgstr "<primary>битовые строки</primary><secondary>функции</secondary>"

#: func.xml:3547(para)
msgid ""
"This section describes functions and operators for examining and "
"manipulating bit strings, that is values of the types <type>bit</type> and "
"<type>bit varying</type>. Aside from the usual comparison operators, the "
"operators shown in <xref linkend=\"functions-bit-string-op-table\"/> can be "
"used. Bit string operands of <literal>&amp;</literal>, <literal>|</literal>, "
"and <literal>#</literal> must be of equal length. When bit shifting, the "
"original length of the string is preserved, as shown in the examples."
msgstr ""
"В этом разделе описываются функции и операторы, предназначенные для работы с "
"битовыми строками, то есть с данными типов <type>bit</type> и <type>bit "
"varying</type>. Помимо обычных операторов сравнения, с такими данными можно "
"использовать операторы, перечисленные в <xref remap=\"6\" linkend="
"\"functions-bit-string-op-table\"/>. Заметьте, что операторы <literal>&amp;</"
"literal>, <literal>|</literal> и <literal>#</literal> работают только с "
"двоичными строками одинаковой длины. Операторы побитового сдвига сохраняют "
"длины исходных строк, как показано в примерах."

#: func.xml:3560(title)
msgid "Bit String Operators"
msgstr "Операторы для работы с битовыми строками"

#: func.xml:3575(entry)
msgid "concatenation"
msgstr "конкатенация"

#: func.xml:3576(literal)
msgid "B'10001' || B'011'"
msgstr "B'10001' || B'011'"

#: func.xml:3577(literal)
msgid "10001011"
msgstr "10001011"

#: func.xml:3583(literal)
msgid "B'10001' &amp; B'01101'"
msgstr "B'10001' &amp; B'01101'"

#: func.xml:3584(literal)
msgid "00001"
msgstr "00001"

#: func.xml:3590(literal)
msgid "B'10001' | B'01101'"
msgstr "B'10001' | B'01101'"

#: func.xml:3591(literal)
msgid "11101"
msgstr "11101"

#: func.xml:3597(literal)
msgid "B'10001' # B'01101'"
msgstr "B'10001' # B'01101'"

#: func.xml:3598(literal)
msgid "11100"
msgstr "11100"

#: func.xml:3604(literal)
msgid "~ B'10001'"
msgstr "~ B'10001'"

#: func.xml:3605(literal)
msgid "01110"
msgstr "01110"

#: func.xml:3611(literal)
msgid "B'10001' &lt;&lt; 3"
msgstr "B'10001' &lt;&lt; 3"

#: func.xml:3612(literal)
msgid "01000"
msgstr "01000"

#: func.xml:3618(literal)
msgid "B'10001' &gt;&gt; 2"
msgstr "B'10001' &gt;&gt; 2"

#: func.xml:3619(literal)
msgid "00100"
msgstr "00100"

#: func.xml:3625(para)
msgid ""
"The following <acronym>SQL</acronym>-standard functions work on bit strings "
"as well as character strings: <literal><function>length</function></"
"literal>, <literal><function>bit_length</function></literal>, "
"<literal><function>octet_length</function></literal>, "
"<literal><function>position</function></literal>, "
"<literal><function>substring</function></literal>, "
"<literal><function>overlay</function></literal>."
msgstr ""
"Следующие функции языка <acronym>SQL</acronym> работают как с символьными, "
"так и с битовыми строками: <literal><function>length</function></literal>, "
"<literal><function>bit_length</function></literal>, "
"<literal><function>octet_length</function></literal>, "
"<literal><function>position</function></literal>, "
"<literal><function>substring</function></literal>, "
"<literal><function>overlay</function></literal>."

#: func.xml:3636(para)
msgid ""
"The following functions work on bit strings as well as binary strings: "
"<literal><function>get_bit</function></literal>, <literal><function>set_bit</"
"function></literal>. When working with a bit string, these functions number "
"the first (leftmost) bit of the string as bit 0."
msgstr ""
"С битовыми и двоичными строками работают функции <literal><function>get_bit</"
"function></literal> и <literal><function>set_bit</function></literal>. При "
"работе с битовыми строками эти функции нумеруют биты слева направо и самый "
"левый бит считается нулевым."

#: func.xml:3649(programlisting)
#, no-wrap
msgid ""
"44::bit(10)                    <lineannotation>0000101100</lineannotation>\n"
"44::bit(3)                     <lineannotation>100</lineannotation>\n"
"cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>\n"
"'1110'::bit(4)::integer        <lineannotation>14</lineannotation>"
msgstr ""
"44::bit(10)                    <lineannotation>0000101100</lineannotation>\n"
"44::bit(3)                     <lineannotation>100</lineannotation>\n"
"cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>\n"
"'1110'::bit(4)::integer        <lineannotation>14</lineannotation>"

#: func.xml:3645(para)
msgid ""
"In addition, it is possible to cast integral values to and from type "
"<type>bit</type>. Some examples: <placeholder-1/> Note that casting to just "
"<quote>bit</quote> means casting to <literal>bit(1)</literal>, and so will "
"deliver only the least significant bit of the integer."
msgstr ""
"Кроме того, целые значения можно преобразовать в тип <type>bit</type> и "
"обратно. Например: <placeholder-1/> Заметьте, что приведение к типу "
"<quote>bit</quote> без длины будет означать приведение к <literal>bit(1)</"
"literal>, и в результате будет получен только один менее значащий бит числа."

#: func.xml:3659(para)
msgid ""
"Casting an integer to <type>bit(n)</type> copies the rightmost <literal>n</"
"literal> bits. Casting an integer to a bit string width wider than the "
"integer itself will sign-extend on the left."
msgstr ""
"Приведение целого числа к типу <type>bit(n)</type> копирует правые "
"<literal>n</literal> бит числа. Если же целое преобразуется в битовую строку "
"большей длины, чем требуется для этого числа, она дополняется слева битами "
"знака числа."

#: func.xml:3670(title)
msgid "Pattern Matching"
msgstr "Поиск по шаблону"

#: func.xml:3672(indexterm)
msgid "<primary>pattern matching</primary>"
msgstr "<primary>поиск по шаблону</primary>"

#: func.xml:3676(para)
msgid ""
"There are three separate approaches to pattern matching provided by "
"<productname>PostgreSQL</productname>: the traditional <acronym>SQL</"
"acronym> <function>LIKE</function> operator, the more recent "
"<function>SIMILAR TO</function> operator (added in SQL:1999), and "
"<acronym>POSIX</acronym>-style regular expressions. Aside from the basic "
"<quote>does this string match this pattern?</quote> operators, functions are "
"available to extract or replace matching substrings and to split a string at "
"matching locations."
msgstr ""
"<productname>PostgreSQL</productname> предлагает три разных способа поиска "
"текста по шаблону: традиционный оператор <function>LIKE</function> языка "
"<acronym>SQL</acronym>, более современный <function>SIMILAR TO</function> "
"(добавленный в SQL:1999) и регулярные выражения в стиле <acronym>POSIX</"
"acronym>. Помимо простых операторов, отвечающих на вопрос "
"<quote>соответствует ли строка этому шаблону?</quote>, в "
"<productname>PostgreSQL</productname> есть функции для извлечения или замены "
"соответствующих подстрок и для разделения строки по заданному шаблону."

#: func.xml:3689(para)
msgid ""
"If you have pattern matching needs that go beyond this, consider writing a "
"user-defined function in Perl or Tcl."
msgstr ""
"Если этих встроенных возможностей оказывается недостаточно, вы можете "
"написать собственные функции на языке Perl или Tcl."

#: func.xml:3696(para)
msgid ""
"While most regular-expression searches can be executed very quickly, regular "
"expressions can be contrived that take arbitrary amounts of time and memory "
"to process. Be wary of accepting regular-expression search patterns from "
"hostile sources. If you must do so, it is advisable to impose a statement "
"timeout."
msgstr ""
"Хотя чаще всего поиск по регулярному выражению бывает очень быстрым, "
"регулярные выражения бывают и настолько сложными, что их обработка может "
"занять приличное время и объём памяти. Поэтому опасайтесь шаблонов "
"регулярных выражений, поступающих из недоверенных источников. Если у вас нет "
"другого выхода, рекомендуется ввести таймаут для операторов."

#: func.xml:3704(para)
msgid ""
"Searches using <function>SIMILAR TO</function> patterns have the same "
"security hazards, since <function>SIMILAR TO</function> provides many of the "
"same capabilities as <acronym>POSIX</acronym>-style regular expressions."
msgstr ""
"Поиск с шаблонами <function>SIMILAR TO</function> несёт те же риски "
"безопасности, так как конструкция <function>SIMILAR TO</function> "
"предоставляет во многом те же возможности, что и регулярные выражения в "
"стиле <acronym>POSIX</acronym>."

#: func.xml:3711(para)
msgid ""
"<function>LIKE</function> searches, being much simpler than the other two "
"options, are safer to use with possibly-hostile pattern sources."
msgstr ""
"Поиск с <function>LIKE</function> гораздо проще, чем два другие варианта, "
"поэтому его безопаснее использовать с недоверенными источниками шаблонов "
"поиска."

#: func.xml:3718(function)
msgid "LIKE"
msgstr "LIKE"

#: func.xml:3720(indexterm)
msgid "<primary>LIKE</primary>"
msgstr "<primary>LIKE</primary>"

#: func.xml:3724(replaceable) func.xml:3725(replaceable)
#: func.xml:3821(replaceable) func.xml:3822(replaceable)
msgctxt "replaceable"
msgid "string"
msgstr "строка"

#: func.xml:3724(replaceable) func.xml:3725(replaceable)
#: func.xml:3821(replaceable) func.xml:3822(replaceable)
msgid "escape-character"
msgstr "спецсимвол"

#: func.xml:3724(optional) func.xml:3725(optional) func.xml:3821(optional)
#: func.xml:3822(optional)
msgid "ESCAPE <placeholder-1/>"
msgstr "ESCAPE <placeholder-1/>"

#: func.xml:3724(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> LIKE <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT LIKE <placeholder-5/> <placeholder-6/>"
msgstr ""
"<placeholder-1/> LIKE <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT LIKE <placeholder-5/> <placeholder-6/>"

#: func.xml:3727(para)
msgid ""
"The <function>LIKE</function> expression returns true if the "
"<replaceable>string</replaceable> matches the supplied <replaceable>pattern</"
"replaceable>. (As expected, the <function>NOT LIKE</function> expression "
"returns false if <function>LIKE</function> returns true, and vice versa. An "
"equivalent expression is <literal>NOT (<replaceable>string</replaceable> "
"LIKE <replaceable>pattern</replaceable>)</literal>.)"
msgstr ""
"Выражение <function>LIKE</function> возвращает true, если "
"<replaceable>строка</replaceable> соответствует заданному "
"<replaceable>шаблону</replaceable>. (Как можно было ожидать, выражение "
"<function>NOT LIKE</function> возвращает false, когда <function>LIKE</"
"function> возвращает true, и наоборот. Этому выражению равносильно выражение "
"<literal>NOT (<replaceable>строка</replaceable> LIKE <replaceable>шаблон</"
"replaceable>)</literal>.)"

#: func.xml:3738(para)
msgid ""
"If <replaceable>pattern</replaceable> does not contain percent signs or "
"underscores, then the pattern only represents the string itself; in that "
"case <function>LIKE</function> acts like the equals operator. An underscore "
"(<literal>_</literal>) in <replaceable>pattern</replaceable> stands for "
"(matches) any single character; a percent sign (<literal>%</literal>) "
"matches any sequence of zero or more characters."
msgstr ""
"Если <replaceable>шаблон</replaceable> не содержит знаков процента и "
"подчёркиваний, тогда шаблон представляет в точности строку и <function>LIKE</"
"function> работает как оператор сравнения. Подчёркивание (<literal>_</"
"literal>) в <replaceable>шаблоне</replaceable> подменяет (вместо него "
"подходит) любой символ; а знак процента (<literal>%</literal>) подменяет "
"любую (в том числе и пустую) последовательность символов."

#: func.xml:3750(programlisting)
#, no-wrap
msgid ""
"'abc' LIKE 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'a%'     <lineannotation>true</lineannotation>\n"
"'abc' LIKE '_b_'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'c'      <lineannotation>false</lineannotation>"
msgstr ""
"'abc' LIKE 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'a%'     <lineannotation>true</lineannotation>\n"
"'abc' LIKE '_b_'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'c'      <lineannotation>false</lineannotation>"

#: func.xml:3748(para) func.xml:3919(para) func.xml:4041(para)
#: func.xml:4071(para) func.xml:4105(para) func.xml:4141(para)
#: func.xml:4196(para)
msgid "Some examples: <placeholder-1/>"
msgstr "Несколько примеров: <placeholder-1/>"

#: func.xml:3756(para)
msgid ""
"<function>LIKE</function> pattern matching always covers the entire string. "
"Therefore, if it's desired to match a sequence anywhere within a string, the "
"pattern must start and end with a percent sign."
msgstr ""
"При проверке по шаблону <function>LIKE</function> всегда рассматривается вся "
"строка. Поэтому, если нужно найти последовательность символов где-то в "
"середине строки, шаблон должен начинаться и заканчиваться знаками процента."

#: func.xml:3762(para)
msgid ""
"To match a literal underscore or percent sign without matching other "
"characters, the respective character in <replaceable>pattern</replaceable> "
"must be preceded by the escape character. The default escape character is "
"the backslash but a different one can be selected by using the "
"<literal>ESCAPE</literal> clause. To match the escape character itself, "
"write two escape characters."
msgstr ""
"Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, "
"перед соответствующим символом в <replaceable>шаблоне</replaceable> нужно "
"добавить спецсимвол. По умолчанию в качестве спецсимвола выбрана обратная "
"косая черта, но с помощью предложения <literal>ESCAPE</literal> можно "
"выбрать и другой. Чтобы включить спецсимвол в шаблон поиска, продублируйте "
"его."

#: func.xml:3773(para) func.xml:4403(para)
msgid ""
"If you have <xref linkend=\"guc-standard-conforming-strings\"/> turned off, "
"any backslashes you write in literal string constants will need to be "
"doubled. See <xref linkend=\"sql-syntax-strings\"/> for more information."
msgstr ""
"Если параметр <xref linkend=\"guc-standard-conforming-strings\"/> выключен, "
"каждый символ обратной косой черты, записываемый в текстовой константе, "
"нужно дублировать. Подробнее это описано в <xref remap=\"6\" linkend=\"sql-"
"syntax-strings\"/>."

#: func.xml:3780(para)
msgid ""
"It's also possible to select no escape character by writing <literal>ESCAPE "
"''</literal>. This effectively disables the escape mechanism, which makes it "
"impossible to turn off the special meaning of underscore and percent signs "
"in the pattern."
msgstr ""
"Также можно отказаться от спецсимвола, написав <literal>ESCAPE ''</literal>. "
"При этом механизм спецпоследовательностей фактически отключается и "
"использовать знаки процента и подчёркивания буквально в шаблоне нельзя."

#: func.xml:3787(para)
msgid ""
"The key word <token>ILIKE</token> can be used instead of <token>LIKE</token> "
"to make the match case-insensitive according to the active locale. This is "
"not in the <acronym>SQL</acronym> standard but is a <productname>PostgreSQL</"
"productname> extension."
msgstr ""
"Вместо <token>LIKE</token> можно использовать ключевое слово <token>ILIKE</"
"token>, чтобы поиск был регистр-независимым с учётом текущей языковой среды. "
"Этот оператор не описан в стандарте <acronym>SQL</acronym>; это расширение "
"<productname>PostgreSQL</productname>."

#: func.xml:3794(para)
msgid ""
"The operator <literal>~~</literal> is equivalent to <function>LIKE</"
"function>, and <literal>~~*</literal> corresponds to <function>ILIKE</"
"function>. There are also <literal>!~~</literal> and <literal>!~~*</literal> "
"operators that represent <function>NOT LIKE</function> and <function>NOT "
"ILIKE</function>, respectively. All of these operators are "
"<productname>PostgreSQL</productname>-specific."
msgstr ""
"Кроме того, в <productname>PostgreSQL</productname> есть оператор "
"<literal>~~</literal>, равнозначный <function>LIKE</function>, и "
"<literal>~~*</literal>, соответствующий <function>ILIKE</function>. Есть "
"также два оператора <literal>!~~</literal> и <literal>!~~*</literal>, "
"представляющие <function>NOT LIKE</function> и <function>NOT ILIKE</"
"function>, соответственно. Все эти операторы можно отнести к особенностям "
"<productname>PostgreSQL</productname>."

#: func.xml:3807(title)
msgid "<function>SIMILAR TO</function> Regular Expressions"
msgstr "Регулярные выражения <function>SIMILAR TO</function>"

#: func.xml:3809(indexterm)
msgid "<primary>regular expression</primary>"
msgstr "<primary>регулярное выражение</primary>"

#: func.xml:3814(indexterm)
msgid "<primary>SIMILAR TO</primary>"
msgstr "<primary>SIMILAR TO</primary>"

#: func.xml:3821(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> SIMILAR TO <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT SIMILAR TO <placeholder-5/> <placeholder-6/>"
msgstr ""
"<placeholder-1/> SIMILAR TO <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT SIMILAR TO <placeholder-5/> <placeholder-6/>"

#: func.xml:3824(para)
msgid ""
"The <function>SIMILAR TO</function> operator returns true or false depending "
"on whether its pattern matches the given string. It is similar to "
"<function>LIKE</function>, except that it interprets the pattern using the "
"SQL standard's definition of a regular expression. SQL regular expressions "
"are a curious cross between <function>LIKE</function> notation and common "
"regular expression notation."
msgstr ""
"Оператор <function>SIMILAR TO</function> возвращает true или false в "
"зависимости от того, соответствует ли данная строка шаблону или нет. Он "
"работает подобно оператору <function>LIKE</function>, только его шаблоны "
"соответствуют определению регулярных выражений в стандарте SQL. Регулярные "
"выражения SQL представляют собой любопытный гибрид синтаксиса "
"<function>LIKE</function> с синтаксисом обычных регулярных выражений."

#: func.xml:3834(para)
msgid ""
"Like <function>LIKE</function>, the <function>SIMILAR TO</function> operator "
"succeeds only if its pattern matches the entire string; this is unlike "
"common regular expression behavior where the pattern can match any part of "
"the string. Also like <function>LIKE</function>, <function>SIMILAR TO</"
"function> uses <literal>_</literal> and <literal>%</literal> as wildcard "
"characters denoting any single character and any string, respectively (these "
"are comparable to <literal>.</literal> and <literal>.*</literal> in POSIX "
"regular expressions)."
msgstr ""
"Как и <function>LIKE</function>, условие <function>SIMILAR TO</function> "
"истинно, только если шаблон соответствует всей строке; это отличается от "
"условий с регулярными выражениями, в которых шаблон может соответствовать "
"любой части строки. Также подобно <function>LIKE</function>, "
"<function>SIMILAR TO</function> воспринимает символы <literal>_</literal> и "
"<literal>%</literal> как знаки подстановки, подменяющие любой один символ "
"или любую подстроку, соответственно (в регулярных выражениях POSIX им "
"аналогичны символы <literal>.</literal> и <literal>.*</literal>)."

#: func.xml:3854(para)
msgid "<literal>|</literal> denotes alternation (either of two alternatives)."
msgstr "<literal>|</literal> означает выбор (одного из двух вариантов)."

#: func.xml:3859(para)
msgid ""
"<literal>*</literal> denotes repetition of the previous item zero or more "
"times."
msgstr ""
"<literal>*</literal> означает повторение предыдущего элемента 0 и более раз."

#: func.xml:3865(para)
msgid ""
"<literal>+</literal> denotes repetition of the previous item one or more "
"times."
msgstr ""
"<literal>+</literal> означает повторение предыдущего элемента 1 и более раз."

#: func.xml:3871(para)
msgid ""
"<literal>?</literal> denotes repetition of the previous item zero or one "
"time."
msgstr ""
"<literal>?</literal> означает вхождение предыдущего элемента 0 или 1 раз."

#: func.xml:3877(para)
msgid ""
"<literal>{</literal><replaceable>m</replaceable><literal>}</literal> denotes "
"repetition of the previous item exactly <replaceable>m</replaceable> times."
msgstr ""
"<literal>{</literal><replaceable>m</replaceable><literal>}</literal> "
"означает повторяет предыдущего элемента ровно <replaceable>m</replaceable> "
"раз."

#: func.xml:3883(para)
msgid ""
"<literal>{</literal><replaceable>m</replaceable><literal>,}</literal> "
"denotes repetition of the previous item <replaceable>m</replaceable> or more "
"times."
msgstr ""
"<literal>{</literal><replaceable>m</replaceable><literal>,}</literal> "
"означает повторение предыдущего элемента <replaceable>m</replaceable> или "
"более раз."

#: func.xml:3889(para)
msgid ""
"<literal>{</literal><replaceable>m</replaceable><literal>,</"
"literal><replaceable>n</replaceable><literal>}</literal> denotes repetition "
"of the previous item at least <replaceable>m</replaceable> and not more than "
"<replaceable>n</replaceable> times."
msgstr ""
"<literal>{</literal><replaceable>m</replaceable><literal>,</"
"literal><replaceable>n</replaceable><literal>}</literal> означает повторение "
"предыдущего элемента не менее чем <replaceable>m</replaceable> и не более "
"чем <replaceable>n</replaceable> раз."

#: func.xml:3896(para)
msgid ""
"Parentheses <literal>()</literal> can be used to group items into a single "
"logical item."
msgstr ""
"Скобки <literal>()</literal> объединяют несколько элементов в одну "
"логическую группу."

#: func.xml:3902(para)
msgid ""
"A bracket expression <literal>[...]</literal> specifies a character class, "
"just as in POSIX regular expressions."
msgstr ""
"Квадратные скобки <literal>[...]</literal> обозначают класс символов так же, "
"как и в регулярных выражениях POSIX."

#: func.xml:3847(para)
msgid ""
"In addition to these facilities borrowed from <function>LIKE</function>, "
"<function>SIMILAR TO</function> supports these pattern-matching "
"metacharacters borrowed from POSIX regular expressions: <placeholder-1/> "
"Notice that the period (<literal>.</literal>) is not a metacharacter for "
"<function>SIMILAR TO</function>."
msgstr ""
"Помимо средств описания шаблонов, позаимствованных от <function>LIKE</"
"function>, <function>SIMILAR TO</function> поддерживает следующие "
"метасимволы, унаследованные от регулярных выражений POSIX: <placeholder-1/> "
"Обратите внимание, точка (<literal>.</literal>) не является метасимволом для "
"оператора <function>SIMILAR TO</function>."

#: func.xml:3913(para)
msgid ""
"As with <function>LIKE</function>, a backslash disables the special meaning "
"of any of these metacharacters; or a different escape character can be "
"specified with <literal>ESCAPE</literal>."
msgstr ""
"Как и с <function>LIKE</function>, обратная косая черта отменяет специальное "
"значение любого из этих метасимволов, а предложение <literal>ESCAPE</"
"literal> позволяет выбрать другой спецсимвол."

#: func.xml:3921(programlisting)
#, no-wrap
msgid ""
"'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>\n"
"'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation>"
msgstr ""
"'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>\n"
"'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation>"

#: func.xml:3927(para)
msgid ""
"The <function>substring</function> function with three parameters, "
"<function>substring(<replaceable>string</replaceable> from "
"<replaceable>pattern</replaceable> for <replaceable>escape-character</"
"replaceable>)</function>, provides extraction of a substring that matches an "
"SQL regular expression pattern. As with <literal>SIMILAR TO</literal>, the "
"specified pattern must match the entire data string, or else the function "
"fails and returns null. To indicate the part of the pattern that should be "
"returned on success, the pattern must contain two occurrences of the escape "
"character followed by a double quote (<literal>\"</literal>). The text "
"matching the portion of the pattern between these markers is returned."
msgstr ""
"Функция <function>substring</function> с тремя параметрами, "
"<function>substring(<replaceable>строка</replaceable> from "
"<replaceable>шаблон</replaceable> for <replaceable>спецсимвол</"
"replaceable>)</function> извлекает подстроку, соответствующую шаблону "
"регулярного выражения SQL. Как и с <literal>SIMILAR TO</literal>, указанному "
"шаблону должна соответствовать вся строка, в противном случае функция не "
"найдёт ничего и вернёт NULL. Для обозначения части шаблона, которая должна "
"быть возвращена в случае успеха, шаблон должен содержать два спецсимвола и "
"кавычки (<literal>\"</literal>) после каждого. Эта функция возвращает часть "
"шаблона между двумя такими маркерами."

#: func.xml:3945(programlisting)
#, no-wrap
msgid ""
"substring('foobar' from '%#\"o_b#\"%' for '#')   <lineannotation>oob</lineannotation>\n"
"substring('foobar' from '#\"o_b#\"%' for '#')    <lineannotation>NULL</lineannotation>"
msgstr ""
"substring('foobar' from '%#\"o_b#\"%' for '#')   <lineannotation>oob</lineannotation>\n"
"substring('foobar' from '#\"o_b#\"%' for '#')    <lineannotation>NULL</lineannotation>"

#: func.xml:3943(para)
msgid ""
"Some examples, with <literal>#\"</literal> delimiting the return string: "
"<placeholder-1/>"
msgstr ""
"Несколько примеров с маркерами <literal>#\"</literal>, выделяющими "
"возвращаемую строку: <placeholder-1/>"

#: func.xml:3951(title)
msgid "<acronym>POSIX</acronym> Regular Expressions"
msgstr "Регулярные выражения <acronym>POSIX</acronym>"

#: func.xml:3953(indexterm)
msgid ""
"<primary>regular expression</primary><seealso>pattern matching</seealso>"
msgstr ""
"<primary>регулярное выражение</primary><seealso>поиск по шаблону</seealso>"

#: func.xml:3972(para)
msgid ""
"<xref linkend=\"functions-posix-table\"/> lists the available operators for "
"pattern matching using POSIX regular expressions."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-posix-table\"/> перечислены все "
"существующие операторы для проверки строк регулярными выражениями POSIX."

#: func.xml:3978(title)
msgid "Regular Expression Match Operators"
msgstr "Операторы регулярных выражений"

#: func.xml:3992(entry)
msgid "Matches regular expression, case sensitive"
msgstr "Проверяет соответствие регулярному выражению с учётом регистра"

#: func.xml:3993(literal)
msgid "'thomas' ~ '.*thomas.*'"
msgstr "'thomas' ~ '.*thomas.*'"

#: func.xml:3997(literal)
msgid "~*"
msgstr "~*"

#: func.xml:3998(entry)
msgid "Matches regular expression, case insensitive"
msgstr "Проверяет соответствие регулярному выражению без учёта регистра"

#: func.xml:3999(literal)
msgid "'thomas' ~* '.*Thomas.*'"
msgstr "'thomas' ~* '.*Thomas.*'"

#: func.xml:4003(literal)
msgid "!~"
msgstr "!~"

#: func.xml:4004(entry)
msgid "Does not match regular expression, case sensitive"
msgstr "Проверяет несоответствие регулярному выражению с учётом регистра"

#: func.xml:4005(literal)
msgid "'thomas' !~ '.*Thomas.*'"
msgstr "'thomas' !~ '.*Thomas.*'"

#: func.xml:4009(literal)
msgid "!~*"
msgstr "!~*"

#: func.xml:4010(entry)
msgid "Does not match regular expression, case insensitive"
msgstr "Проверяет несоответствие регулярному выражению без учёта регистра"

#: func.xml:4011(literal)
msgid "'thomas' !~* '.*vadim.*'"
msgstr "'thomas' !~* '.*vadim.*'"

#: func.xml:4017(para)
msgid ""
"<acronym>POSIX</acronym> regular expressions provide a more powerful means "
"for pattern matching than the <function>LIKE</function> and "
"<function>SIMILAR TO</function> operators. Many Unix tools such as "
"<command>egrep</command>, <command>sed</command>, or <command>awk</command> "
"use a pattern matching language that is similar to the one described here."
msgstr ""
"Регулярные выражения <acronym>POSIX</acronym> предоставляют более мощные "
"средства поиска по шаблонам, чем операторы <function>LIKE</function> и "
"<function>SIMILAR TO</function>. Во многих командах Unix, таких как "
"<command>egrep</command>, <command>sed</command> и <command>awk</command> "
"используется язык шаблонов, похожий на описанный здесь."

#: func.xml:4026(para)
msgid ""
"A regular expression is a character sequence that is an abbreviated "
"definition of a set of strings (a <firstterm>regular set</firstterm>). A "
"string is said to match a regular expression if it is a member of the "
"regular set described by the regular expression. As with <function>LIKE</"
"function>, pattern characters match string characters exactly unless they "
"are special characters in the regular expression language &mdash; but "
"regular expressions use different special characters than <function>LIKE</"
"function> does. Unlike <function>LIKE</function> patterns, a regular "
"expression is allowed to match anywhere within a string, unless the regular "
"expression is explicitly anchored to the beginning or end of the string."
msgstr ""
"Регулярное выражение &mdash; это последовательность символов, представляющая "
"собой краткое определение набора строк (<firstterm>регулярное множество</"
"firstterm>). Строка считается соответствующей регулярному выражению, если "
"она является членом регулярного множества, описываемого регулярным "
"выражением. Как и для <function>LIKE</function>, символы шаблона "
"непосредственно соответствуют символам строки, за исключением специальных "
"символов языка регулярных выражений. При этом спецсимволы регулярных "
"выражений отличается от спецсимволов <function>LIKE</function>. В отличие от "
"шаблонов <function>LIKE</function>, регулярное выражение может совпадать с "
"любой частью строки, если только оно не привязано явно к началу и/или концу "
"строки."

#: func.xml:4043(programlisting)
#, no-wrap
msgid ""
"'abc' ~ 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' ~ '^a'     <lineannotation>true</lineannotation>\n"
"'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>\n"
"'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>"
msgstr ""
"'abc' ~ 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' ~ '^a'     <lineannotation>true</lineannotation>\n"
"'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>\n"
"'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>"

#: func.xml:4049(para)
msgid ""
"The <acronym>POSIX</acronym> pattern language is described in much greater "
"detail below."
msgstr ""
"Более подробно язык шаблонов в стиле <acronym>POSIX</acronym> описан ниже."

#: func.xml:4054(para)
msgid ""
"The <function>substring</function> function with two parameters, "
"<function>substring(<replaceable>string</replaceable> from "
"<replaceable>pattern</replaceable>)</function>, provides extraction of a "
"substring that matches a POSIX regular expression pattern. It returns null "
"if there is no match, otherwise the portion of the text that matched the "
"pattern. But if the pattern contains any parentheses, the portion of the "
"text that matched the first parenthesized subexpression (the one whose left "
"parenthesis comes first) is returned. You can put parentheses around the "
"whole expression if you want to use parentheses within it without triggering "
"this exception. If you need parentheses in the pattern before the "
"subexpression you want to extract, see the non-capturing parentheses "
"described below."
msgstr ""
"Функция <function>substring</function> с двумя параметрами, "
"<function>substring(<replaceable>строка</replaceable> from "
"<replaceable>шаблон</replaceable>)</function>, извлекает подстроку, "
"соответствующую шаблону регулярного выражения POSIX. Она возвращает фрагмент "
"текста, подходящий шаблону, если таковой находится в строке, либо NULL в "
"противном случае. Но если шаблон содержит скобки, она возвращает первое "
"подвыражение, заключённое в скобки (то, которое начинается с самой первой "
"открывающей скобки). Если вы хотите использовать скобки, но не в таком "
"особом режиме, можно просто заключить в них всё выражение. Если же вам нужно "
"включить скобки в шаблон до подвыражения, которое вы хотите извлечь, это "
"можно сделать, используя группы без захвата, которые будут описаны ниже."

#: func.xml:4073(programlisting)
#, no-wrap
msgid ""
"substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>\n"
"substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>"
msgstr ""
"substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>\n"
"substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>"

#: func.xml:4077(para)
msgid ""
"The <function>regexp_replace</function> function provides substitution of "
"new text for substrings that match POSIX regular expression patterns. It has "
"the syntax <function>regexp_replace</function>(<replaceable>source</"
"replaceable>, <replaceable>pattern</replaceable>, <replaceable>replacement</"
"replaceable>\n"
"     <optional>, <replaceable>flags</replaceable></optional>). The "
"<replaceable>source</replaceable> string is returned unchanged if there is "
"no match to the <replaceable>pattern</replaceable>. If there is a match, the "
"<replaceable>source</replaceable> string is returned with the "
"<replaceable>replacement</replaceable> string substituted for the matching "
"substring. The <replaceable>replacement</replaceable> string can contain "
"<literal>\\</literal><replaceable>n</replaceable>, where <replaceable>n</"
"replaceable> is 1 through 9, to indicate that the source substring matching "
"the <replaceable>n</replaceable>'th parenthesized subexpression of the "
"pattern should be inserted, and it can contain <literal>\\&amp;</literal> to "
"indicate that the substring matching the entire pattern should be inserted. "
"Write <literal>\\\\</literal> if you need to put a literal backslash in the "
"replacement text. The <replaceable>flags</replaceable> parameter is an "
"optional text string containing zero or more single-letter flags that change "
"the function's behavior. Flag <literal>i</literal> specifies case-"
"insensitive matching, while flag <literal>g</literal> specifies replacement "
"of each matching substring rather than only the first one. Supported flags "
"(though not <literal>g</literal>) are described in <xref linkend=\"posix-"
"embedded-options-table\"/>."
msgstr ""
"Функция <function>regexp_replace</function> подставляет другой текст вместо "
"подстрок, соответствующих шаблонам регулярных выражений POSIX. Она имеет "
"синтаксис <function>regexp_replace</function>(<replaceable>исходная_строка</"
"replaceable>, <replaceable>шаблон</replaceable>, <replaceable>замена</"
"replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Если "
"<replaceable>исходная_строка</replaceable> не содержит фрагмента, "
"подходящего под <replaceable>шаблон</replaceable>, она возвращается "
"неизменной. Если же соответствие находится, возвращается "
"<replaceable>исходная_строка</replaceable>, в которой вместо "
"соответствующего фрагмента подставляется <replaceable>замена</replaceable>. "
"Строка <replaceable>замена</replaceable> может содержать <literal>\\</"
"literal><replaceable>n</replaceable>, где <replaceable>n</replaceable> "
"&mdash; число от 1 до 9, указывающее на исходный фрагмент, соответствующий "
"<replaceable>n</replaceable>-ому подвыражению в скобках, и может содержать "
"обозначение <literal>\\&amp;</literal>, указывающее, что будет вставлен "
"фрагмент, соответствующий всему шаблону. Если же в текст замены нужно "
"включить обратную косую черту буквально, следует написать <literal>\\\\</"
"literal>. В необязательном параметре <replaceable>флаги</replaceable> "
"передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, "
"меняющих поведение функции. Флаг <literal>i</literal> включает поиск без "
"учёта регистра, а флаг <literal>g</literal> указывает, что заменяться должны "
"все подходящие подстроки, а не только первая из них. Допустимые флаги (кроме "
"<literal>g</literal>) описаны в <xref remap=\"6\" linkend=\"posix-embedded-"
"options-table\"/>."

#: func.xml:4107(programlisting)
#, no-wrap
msgid ""
"regexp_replace('foobarbaz', 'b..', 'X')\n"
"                                   <lineannotation>fooXbaz</lineannotation>\n"
"regexp_replace('foobarbaz', 'b..', 'X', 'g')\n"
"                                   <lineannotation>fooXX</lineannotation>\n"
"regexp_replace('foobarbaz', 'b(..)', E'X\\\\1Y', 'g')\n"
"                                   <lineannotation>fooXarYXazY</lineannotation>"
msgstr ""
"regexp_replace('foobarbaz', 'b..', 'X')\n"
"                                   <lineannotation>fooXbaz</lineannotation>\n"
"regexp_replace('foobarbaz', 'b..', 'X', 'g')\n"
"                                   <lineannotation>fooXX</lineannotation>\n"
"regexp_replace('foobarbaz', 'b(..)', E'X\\\\1Y', 'g')\n"
"                                   <lineannotation>fooXarYXazY</lineannotation>"

#: func.xml:4115(para)
msgid ""
"The <function>regexp_matches</function> function returns a text array of all "
"of the captured substrings resulting from matching a POSIX regular "
"expression pattern. It has the syntax <function>regexp_matches</"
"function>(<replaceable>string</replaceable>, <replaceable>pattern</"
"replaceable>\n"
"     <optional>, <replaceable>flags</replaceable></optional>). The function "
"can return no rows, one row, or multiple rows (see the <literal>g</literal> "
"flag below). If the <replaceable>pattern</replaceable> does not match, the "
"function returns no rows. If the pattern contains no parenthesized "
"subexpressions, then each row returned is a single-element text array "
"containing the substring matching the whole pattern. If the pattern contains "
"parenthesized subexpressions, the function returns a text array whose "
"<replaceable>n</replaceable>'th element is the substring matching the "
"<replaceable>n</replaceable>'th parenthesized subexpression of the pattern "
"(not counting <quote>non-capturing</quote> parentheses; see below for "
"details). The <replaceable>flags</replaceable> parameter is an optional text "
"string containing zero or more single-letter flags that change the "
"function's behavior. Flag <literal>g</literal> causes the function to find "
"each match in the string, not only the first one, and return a row for each "
"such match. Supported flags (though not <literal>g</literal>) are described "
"in <xref linkend=\"posix-embedded-options-table\"/>."
msgstr ""
"Функция <function>regexp_matches</function> возвращает текстовый массив из "
"всех подходящих подстрок, полученных в результате применения регулярного "
"выражения POSIX. Она имеет синтаксис <function>regexp_matches</"
"function>(<replaceable>строка</replaceable>, <replaceable>шаблон</"
"replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Эта "
"функция может вовсе не вернуть строк или вернуть одну или несколько строк "
"(см. описание флага <literal>g</literal> ниже). Если <replaceable>шаблон</"
"replaceable> не находится в строке, функция не возвращает строк. Если шаблон "
"не содержит подвыражений в скобках, тогда для каждой строки возвращается "
"массив с одним элементом, содержащим подстроку, соответствующую всему "
"шаблону. Если же шаблон содержит подвыражения в скобках, функция возвращает "
"массив элементов, в котором <replaceable>n</replaceable>-эй элемент "
"соответствует <replaceable>n</replaceable>-ому подвыражению в скобках (не "
"считая скобки <quote>без захвата</quote>; подробнее об этом ниже). В "
"необязательном параметре <replaceable>флаги</replaceable> передаётся "
"текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих "
"поведение функции. Флаг <literal>g</literal> указывает, что функция должна "
"находить в строке не только первое, а все соответствия шаблону, и возвращать "
"строку для каждого соответствия. Допустимые флаги (кроме <literal>g</"
"literal>) описаны в <xref remap=\"6\" linkend=\"posix-embedded-options-table"
"\"/>."

#: func.xml:4143(programlisting)
#, no-wrap
msgid ""
"SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
"(1 row)\n"
"\n"
"SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
" {bazil,barf}\n"
"(2 rows)\n"
"\n"
"SELECT regexp_matches('foobarbequebaz', 'barbeque');\n"
" regexp_matches \n"
"----------------\n"
" {barbeque}\n"
"(1 row)"
msgstr ""
"SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
"(1 row)\n"
"\n"
"SELECT regexp_matches(\n"
" 'foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
" {bazil,barf}\n"
"(2 rows)\n"
"\n"
"SELECT regexp_matches('foobarbequebaz', 'barbeque');\n"
" regexp_matches \n"
"----------------\n"
" {barbeque}\n"
"(1 row)"

#: func.xml:4168(programlisting)
#, no-wrap
msgid "SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;"
msgstr "SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;"

#: func.xml:4163(para)
msgid ""
"It is possible to force <function>regexp_matches()</function> to always "
"return one row by using a sub-select; this is particularly useful in a "
"<literal>SELECT</literal> target list when you want all rows returned, even "
"non-matching ones: <placeholder-1/>"
msgstr ""
"Добиться, чтобы функция <function>regexp_matches()</function> всегда "
"возвращала одну строку, можно с помощью вложенного подзапроса; это особенно "
"полезно в списке выборки <literal>SELECT</literal>, когда нужно получить все "
"строки, в том числе и не соответствующие шаблону: <placeholder-1/>"

#: func.xml:4171(para)
msgid ""
"The <function>regexp_split_to_table</function> function splits a string "
"using a POSIX regular expression pattern as a delimiter. It has the syntax "
"<function>regexp_split_to_table</function>(<replaceable>string</"
"replaceable>, <replaceable>pattern</replaceable>\n"
"     <optional>, <replaceable>flags</replaceable></optional>). If there is "
"no match to the <replaceable>pattern</replaceable>, the function returns the "
"<replaceable>string</replaceable>. If there is at least one match, for each "
"match it returns the text from the end of the last match (or the beginning "
"of the string) to the beginning of the match. When there are no more "
"matches, it returns the text from the end of the last match to the end of "
"the string. The <replaceable>flags</replaceable> parameter is an optional "
"text string containing zero or more single-letter flags that change the "
"function's behavior. <function>regexp_split_to_table</function> supports the "
"flags described in <xref linkend=\"posix-embedded-options-table\"/>."
msgstr ""
"Функция <function>regexp_split_to_table</function> разделяет строку, "
"используя в качестве разделителя шаблон регулярного выражения POSIX. Она "
"имеет синтаксис <function>regexp_split_to_table</"
"function>(<replaceable>строка</replaceable>, <replaceable>шаблон</"
"replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Если "
"<replaceable>шаблон</replaceable> не находится в переданной строке, "
"возвращается вся <replaceable>строка</replaceable> целиком. Если находится "
"минимум одно вхождение, для каждого такого вхождения возвращается текст от "
"конца предыдущего вхождения (или начала строки) до начала вхождения. После "
"последнего найденного вхождения возвращается фрагмент от его конца до конца "
"строки. В необязательном параметре <replaceable>флаги</replaceable> "
"передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, "
"меняющих поведение функции. Флаги, которые поддерживает "
"<function>regexp_split_to_table</function>, описаны в <xref remap=\"6\" "
"linkend=\"posix-embedded-options-table\"/>."

#: func.xml:4187(para)
msgid ""
"The <function>regexp_split_to_array</function> function behaves the same as "
"<function>regexp_split_to_table</function>, except that "
"<function>regexp_split_to_array</function> returns its result as an array of "
"<type>text</type>. It has the syntax <function>regexp_split_to_array</"
"function>(<replaceable>string</replaceable>, <replaceable>pattern</"
"replaceable>\n"
"     <optional>, <replaceable>flags</replaceable></optional>). The "
"parameters are the same as for <function>regexp_split_to_table</function>."
msgstr ""
"Функция <function>regexp_split_to_array</function> ведёт себя подобно "
"<function>regexp_split_to_table</function>, за исключением того, что "
"<function>regexp_split_to_array</function> возвращает результат в массиве "
"элементов типа <type>text</type>. Она имеет синтаксис "
"<function>regexp_split_to_array</function>(<replaceable>строка</"
"replaceable>, <replaceable>шаблон</replaceable> <optional>, "
"<replaceable>флаги</replaceable></optional>). Параметры у этой функции те "
"же, что и у <function>regexp_split_to_table</function>."

#: func.xml:4198(programlisting)
#, no-wrap
msgid ""
"\n"
"SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\\\s+') AS foo;\n"
"  foo   \n"
"-------\n"
" the    \n"
" quick  \n"
" brown  \n"
" fox    \n"
" jumps \n"
" over   \n"
" the    \n"
" lazy   \n"
" dog    \n"
"(9 rows)\n"
"\n"
"SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\\\s+');\n"
"              regexp_split_to_array             \n"
"-----------------------------------------------\n"
" {the,quick,brown,fox,jumps,over,the,lazy,dog}\n"
"(1 row)\n"
"\n"
"SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\\\s*') AS foo;\n"
" foo \n"
"-----\n"
" t         \n"
" h         \n"
" e         \n"
" q         \n"
" u         \n"
" i         \n"
" c         \n"
" k         \n"
" b         \n"
" r         \n"
" o         \n"
" w         \n"
" n         \n"
" f         \n"
" o         \n"
" x         \n"
"(16 rows)"
msgstr ""
"\n"
"SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\\\s+') AS foo;\n"
"  foo   \n"
"-------\n"
" the    \n"
" quick  \n"
" brown  \n"
" fox    \n"
" jumps \n"
" over   \n"
" the    \n"
" lazy   \n"
" dog    \n"
"(9 rows)\n"
"\n"
"SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\\\s+');\n"
"              regexp_split_to_array             \n"
"-----------------------------------------------\n"
" {the,quick,brown,fox,jumps,over,the,lazy,dog}\n"
"(1 row)\n"
"\n"
"SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\\\s*') AS foo;\n"
" foo \n"
"-----\n"
" t         \n"
" h         \n"
" e         \n"
" q         \n"
" u         \n"
" i         \n"
" c         \n"
" k         \n"
" b         \n"
" r         \n"
" o         \n"
" w         \n"
" n         \n"
" f         \n"
" o         \n"
" x         \n"
"(16 rows)"

#: func.xml:4241(para)
msgid ""
"As the last example demonstrates, the regexp split functions ignore zero-"
"length matches that occur at the start or end of the string or immediately "
"after a previous match. This is contrary to the strict definition of regexp "
"matching that is implemented by <function>regexp_matches</function>, but is "
"usually the most convenient behavior in practice. Other software systems "
"such as Perl use similar definitions."
msgstr ""
"Как показывает последний пример, функции разделения по регулярным выражениям "
"игнорируют вхождения нулевой длины, идущие в начале и в конце строки, а "
"также непосредственно за предыдущим вхождением. Это поведение противоречит "
"строгому определению поиска по регулярным выражениям, который реализует "
"<function>regexp_matches</function>, но обычно более удобно на практике. "
"Подобное поведение наблюдается и в других программных средах, например в "
"Perl."

#: func.xml:4253(title)
msgid "Regular Expression Details"
msgstr "Подробное описание регулярных выражений"

#: func.xml:4255(para)
msgid ""
"<productname>PostgreSQL</productname>'s regular expressions are implemented "
"using a software package written by Henry Spencer. Much of the description "
"of regular expressions below is copied verbatim from his manual."
msgstr ""
"Регулярные выражения в <productname>PostgreSQL</productname> реализованы с "
"использованием программного пакета, который разработал Генри Спенсер (Henry "
"Spencer). Практически всё следующее описание регулярных выражений дословно "
"скопировано из его руководства."

#: func.xml:4262(para)
msgid ""
"Regular expressions (<acronym>RE</acronym>s), as defined in <acronym>POSIX</"
"acronym> 1003.2, come in two forms: <firstterm>extended</firstterm> "
"<acronym>RE</acronym>s or <acronym>ERE</acronym>s (roughly those of "
"<command>egrep</command>), and <firstterm>basic</firstterm> <acronym>RE</"
"acronym>s or <acronym>BRE</acronym>s (roughly those of <command>ed</"
"command>). <productname>PostgreSQL</productname> supports both forms, and "
"also implements some extensions that are not in the POSIX standard, but have "
"become widely used due to their availability in programming languages such "
"as Perl and Tcl. <acronym>RE</acronym>s using these non-POSIX extensions are "
"called <firstterm>advanced</firstterm> <acronym>RE</acronym>s or "
"<acronym>ARE</acronym>s in this documentation. AREs are almost an exact "
"superset of EREs, but BREs have several notational incompatibilities (as "
"well as being much more limited). We first describe the ARE and ERE forms, "
"noting features that apply only to AREs, and then describe how BREs differ."
msgstr ""
"Регулярное выражение (Regular expression, <acronym>RE</acronym>), согласно "
"определению в <acronym>POSIX</acronym> 1003.2, может иметь две формы: "
"<firstterm>расширенное</firstterm> <acronym>RE</acronym> или <acronym>ERE</"
"acronym> (грубо говоря, это выражения которые понимает <command>egrep</"
"command>) и <firstterm>простое</firstterm> <acronym>RE</acronym> или "
"<acronym>BRE</acronym> (грубо говоря, это выражения для <command>ed</"
"command>). <productname>PostgreSQL</productname> поддерживает обе формы, а "
"кроме того реализует некоторые расширения, не предусмотренные стандартом "
"POSIX, но широко используемые вследствие их доступности в некоторых языках "
"программирования, например в Perl и Tcl. Регулярные выражения, использующие "
"эти несовместимые с POSIX расширения, здесь называются "
"<firstterm>усовершенствованными</firstterm> <acronym>RE</acronym> или "
"<acronym>ARE</acronym>. ARE практически представляют собой надмножество ERE, "
"тогда как BRE отличаются некоторой несовместимостью в записи (помимо того, "
"что они гораздо более ограничены). Сначала мы опишем формы ARE и ERE, "
"отметив особенности, присущие только ARE, а затем расскажем, чем от них "
"отличаются BRE."

#: func.xml:4283(para)
msgid ""
"<productname>PostgreSQL</productname> always initially presumes that a "
"regular expression follows the ARE rules. However, the more limited ERE or "
"BRE rules can be chosen by prepending an <firstterm>embedded option</"
"firstterm> to the RE pattern, as described in <xref linkend=\"posix-"
"metasyntax\"/>. This can be useful for compatibility with applications that "
"expect exactly the <acronym>POSIX</acronym> 1003.2 rules."
msgstr ""
"<productname>PostgreSQL</productname> изначально всегда предполагает, что "
"регулярное выражение следует правилам ARE. Однако можно переключиться на "
"более ограниченные правила ERE или BRE, добавив в шаблон RE "
"<firstterm>встроенный параметр</firstterm>, как описано в <xref remap=\"6\" "
"linkend=\"posix-metasyntax\"/>. Это может быть полезно для совместимости с "
"приложениями, ожидающими от СУБД строгого следования правилам "
"<acronym>POSIX</acronym> 1003.2."

#: func.xml:4293(para)
msgid ""
"A regular expression is defined as one or more <firstterm>branches</"
"firstterm>, separated by <literal>|</literal>. It matches anything that "
"matches one of the branches."
msgstr ""
"Регулярное выражение определяется как одна или более <firstterm>ветвей</"
"firstterm>, разделённых символами <literal>|</literal>. Оно считается "
"соответствующим всему, что соответствует одной из этих ветвей."

#: func.xml:4300(para)
msgid ""
"A branch is zero or more <firstterm>quantified atoms</firstterm> or "
"<firstterm>constraints</firstterm>, concatenated. It matches a match for the "
"first, followed by a match for the second, etc; an empty branch matches the "
"empty string."
msgstr ""
"Ветвь &mdash; это ноль или несколько <firstterm>количественных атомов</"
"firstterm> или <firstterm>ограничений</firstterm>, соединённых вместе. "
"Соответствие ветви в целом образуется из соответствия первой части, за "
"которым следует соответствие второй части и т. д.; пустой ветви "
"соответствует пустая строка."

#: func.xml:4307(para)
msgid ""
"A quantified atom is an <firstterm>atom</firstterm> possibly followed by a "
"single <firstterm>quantifier</firstterm>. Without a quantifier, it matches a "
"match for the atom. With a quantifier, it can match some number of matches "
"of the atom. An <firstterm>atom</firstterm> can be any of the possibilities "
"shown in <xref linkend=\"posix-atoms-table\"/>. The possible quantifiers and "
"their meanings are shown in <xref linkend=\"posix-quantifiers-table\"/>."
msgstr ""
"Количественный атом &mdash; это <firstterm>атом</firstterm>, за которым "
"может следовать <firstterm>определитель количества</firstterm>. Без этого "
"определителя ему соответствует одно вхождение атома. С определителем "
"количества ему может соответствовать некоторое число вхождений этого атома. "
"Все возможные <firstterm>атомы</firstterm> перечислены в <xref remap=\"6\" "
"linkend=\"posix-atoms-table\"/>. Варианты определителей количества и их "
"значения перечислены в <xref remap=\"6\" linkend=\"posix-quantifiers-table\"/"
">."

#: func.xml:4318(para)
msgid ""
"A <firstterm>constraint</firstterm> matches an empty string, but matches "
"only when specific conditions are met. A constraint can be used where an "
"atom could be used, except it cannot be followed by a quantifier. The simple "
"constraints are shown in <xref linkend=\"posix-constraints-table\"/>; some "
"more constraints are described later."
msgstr ""
"<firstterm>Ограничению</firstterm> соответствует пустая строка, но это "
"соответствие возможно только при выполнении определённых условий. "
"Ограничения могут использоваться там же, где и атомы, за исключением того, "
"что их нельзя дополнять определителями количества. Простые ограничения "
"показаны в <xref remap=\"6\" linkend=\"posix-constraints-table\"/>; "
"некоторые дополнительные ограничения описаны ниже."

#: func.xml:4329(title)
msgid "Regular Expression Atoms"
msgstr "Атомы регулярных выражений"

#: func.xml:4334(entry)
msgid "Atom"
msgstr "Атом"

#: func.xml:4341(literal)
msgid "("
msgstr "("

#: func.xml:4341(replaceable) func.xml:4348(replaceable)
#: func.xml:4537(replaceable) func.xml:4544(replaceable)
#: func.xml:4551(replaceable) func.xml:4558(replaceable)
msgid "re"
msgstr "re"

#: func.xml:4341(literal) func.xml:4348(literal) func.xml:4537(literal)
#: func.xml:4544(literal) func.xml:4551(literal) func.xml:4558(literal)
msgid ")"
msgstr ")"

#: func.xml:4342(entry)
msgid ""
"(where <replaceable>re</replaceable> is any regular expression) matches a "
"match for <replaceable>re</replaceable>, with the match noted for possible "
"reporting"
msgstr ""
"(где <replaceable>re</replaceable> &mdash; любое регулярное выражение) "
"описывает соответствие <replaceable>re</replaceable>, при этом данное "
"соответствие захватывается для последующей обработки"

#: func.xml:4348(literal)
msgid "(?:"
msgstr "(?:"

#: func.xml:4349(entry)
msgid ""
"as above, but the match is not noted for reporting (a <quote>non-capturing</"
"quote> set of parentheses) (AREs only)"
msgstr ""
"подобно предыдущему, но соответствие не захватывается (т. е. это набор "
"скобок <quote>без захвата</quote>) (применимо только к ARE)"

#: func.xml:4355(literal)
msgid "."
msgstr "."

#: func.xml:4356(entry)
msgid "matches any single character"
msgstr "соответствует любому символу"

#: func.xml:4360(literal)
msgid "["
msgstr "["

#: func.xml:4360(replaceable)
msgid "chars"
msgstr "символы"

#: func.xml:4360(literal)
msgid "]"
msgstr "]"

#: func.xml:4361(entry)
msgid ""
"a <firstterm>bracket expression</firstterm>, matching any one of the "
"<replaceable>chars</replaceable> (see <xref linkend=\"posix-bracket-"
"expressions\"/> for more detail)"
msgstr ""
"<firstterm>выражение в квадратных скобках</firstterm>, соответствует любому "
"из <replaceable>символов</replaceable> (подробнее это описано в <xref remap="
"\"6\" linkend=\"posix-bracket-expressions\"/>)"

#: func.xml:4367(literal) func.xml:4374(literal) func.xml:4828(literal)
#: func.xml:4836(literal) func.xml:4995(literal) func.xml:5001(literal)
msgid "\\"
msgstr "\\"

#: func.xml:4367(replaceable)
msgid "k"
msgstr "k"

#: func.xml:4368(entry)
msgid ""
"(where <replaceable>k</replaceable> is a non-alphanumeric character) matches "
"that character taken as an ordinary character, e.g., <literal>\\\\</literal> "
"matches a backslash character"
msgstr ""
"(где <replaceable>k</replaceable> &mdash; не алфавитно-цифровой символ) "
"соответствует обычному символу буквально, т. е. <literal>\\\\</literal> "
"соответствует обратной косой черте"

#: func.xml:4374(replaceable)
msgctxt "replaceable"
msgid "c"
msgstr "c"

#: func.xml:4375(entry)
msgid ""
"where <replaceable>c</replaceable> is alphanumeric (possibly followed by "
"other characters) is an <firstterm>escape</firstterm>, see <xref linkend="
"\"posix-escape-sequences\"/> (AREs only; in EREs and BREs, this matches "
"<replaceable>c</replaceable>)"
msgstr ""
"где <replaceable>c</replaceable> &mdash; алфавитно-цифровой символ (за "
"которым могут следовать другие символы), это <firstterm>спецсимвол</"
"firstterm>, см. <xref remap=\"4\" linkend=\"posix-escape-sequences\"/> "
"(применим только к ARE; в ERE и BRE этому атому соответствует "
"<replaceable>c</replaceable>)"

#: func.xml:4382(literal) func.xml:4438(literal) func.xml:4443(literal)
#: func.xml:4449(literal) func.xml:4471(literal) func.xml:4476(literal)
#: func.xml:4482(literal)
msgid "{"
msgstr "{"

#: func.xml:4383(entry)
msgid ""
"when followed by a character other than a digit, matches the left-brace "
"character <literal>{</literal>; when followed by a digit, it is the "
"beginning of a <replaceable>bound</replaceable> (see below)"
msgstr ""
"когда за этим символом следует любой символ, кроме цифры, этот атом "
"соответствует левой фигурной скобке (<literal>{</literal>), если же за ним "
"следует цифра, это обозначает начало <replaceable>границы</replaceable> (см. "
"ниже)"

#: func.xml:4391(entry)
msgid ""
"where <replaceable>x</replaceable> is a single character with no other "
"significance, matches that character"
msgstr ""
"(где <replaceable>x</replaceable> &mdash; один символ, не имеющий "
"специального значения) соответствует этому символу"

#: func.xml:4398(para)
msgid "An RE cannot end with a backslash (<literal>\\</literal>)."
msgstr ""
"Выражение RE не может заканчиваться обратной косой чертой (<literal>\\</"
"literal>)."

#: func.xml:4411(title)
msgid "Regular Expression Quantifiers"
msgstr "Определители количества в регулярных выражениях"

#: func.xml:4416(entry)
msgid "Quantifier"
msgstr "Определитель"

#: func.xml:4417(entry)
msgid "Matches"
msgstr "Соответствует"

#: func.xml:4424(entry)
msgid "a sequence of 0 or more matches of the atom"
msgstr "0 или более вхождений атома"

#: func.xml:4429(entry)
msgid "a sequence of 1 or more matches of the atom"
msgstr "1 или более вхождений атома"

#: func.xml:4433(literal) func.xml:10450(literal)
msgid "?"
msgstr "?"

#: func.xml:4434(entry)
msgid "a sequence of 0 or 1 matches of the atom"
msgstr "0 или 1 вхождение атома"

#: func.xml:4438(replaceable) func.xml:4443(replaceable)
#: func.xml:4449(replaceable) func.xml:4471(replaceable)
#: func.xml:4476(replaceable) func.xml:4482(replaceable)
#: func.xml:4995(replaceable)
msgctxt "replaceable"
msgid "m"
msgstr "m"

#: func.xml:4438(literal) func.xml:4449(literal)
msgid "}"
msgstr "}"

#: func.xml:4439(entry)
msgid "a sequence of exactly <replaceable>m</replaceable> matches of the atom"
msgstr "ровно <replaceable>m</replaceable> вхождений атома"

#: func.xml:4443(literal)
msgid ",}"
msgstr ",}"

#: func.xml:4444(entry)
msgid "a sequence of <replaceable>m</replaceable> or more matches of the atom"
msgstr "<replaceable>m</replaceable> или более вхождений атома"

#: func.xml:4449(literal) func.xml:4482(literal)
msgid ","
msgstr ","

#: func.xml:4449(replaceable) func.xml:4482(replaceable)
msgctxt "replaceable"
msgid "n"
msgstr "n"

#: func.xml:4450(entry)
msgid ""
"a sequence of <replaceable>m</replaceable> through <replaceable>n</"
"replaceable> (inclusive) matches of the atom; <replaceable>m</replaceable> "
"cannot exceed <replaceable>n</replaceable>"
msgstr ""
"от <replaceable>m</replaceable> до <replaceable>n</replaceable> (включая "
"границы) вхождений атома; <replaceable>m</replaceable> не может быть больше "
"<replaceable>n</replaceable>"

#: func.xml:4456(literal)
msgid "*?"
msgstr "*?"

#: func.xml:4457(entry)
msgid "non-greedy version of <literal>*</literal>"
msgstr "не жадная версия <literal>*</literal>"

#: func.xml:4461(literal)
msgid "+?"
msgstr "+?"

#: func.xml:4462(entry)
msgid "non-greedy version of <literal>+</literal>"
msgstr "не жадная версия <literal>+</literal>"

#: func.xml:4466(literal)
msgid "??"
msgstr "??"

#: func.xml:4467(entry)
msgid "non-greedy version of <literal>?</literal>"
msgstr "не жадная версия <literal>?</literal>"

#: func.xml:4471(literal) func.xml:4482(literal)
msgid "}?"
msgstr "}?"

#: func.xml:4472(entry)
msgid ""
"non-greedy version of <literal>{</literal><replaceable>m</"
"replaceable><literal>}</literal>"
msgstr ""
"не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>}</"
"literal>"

#: func.xml:4476(literal)
msgid ",}?"
msgstr ",}?"

#: func.xml:4477(entry)
msgid ""
"non-greedy version of <literal>{</literal><replaceable>m</"
"replaceable><literal>,}</literal>"
msgstr ""
"не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>,}"
"</literal>"

#: func.xml:4483(entry)
msgid ""
"non-greedy version of <literal>{</literal><replaceable>m</"
"replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</"
"literal>"
msgstr ""
"не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>,</"
"literal><replaceable>n</replaceable><literal>}</literal>"

#: func.xml:4489(para)
msgid ""
"The forms using <literal>{</literal><replaceable>...</replaceable><literal>}"
"</literal> are known as <firstterm>bounds</firstterm>. The numbers "
"<replaceable>m</replaceable> and <replaceable>n</replaceable> within a bound "
"are unsigned decimal integers with permissible values from 0 to 255 "
"inclusive."
msgstr ""
"В формах с <literal>{</literal><replaceable>...</replaceable><literal>}</"
"literal> числа <replaceable>m</replaceable> и <replaceable>n</replaceable> "
"определяют так называемые <firstterm>границы</firstterm> количества. Эти "
"числа должны быть беззнаковыми десятичными целыми в диапазоне от 0 до 255 "
"включительно."

#: func.xml:4496(para)
msgid ""
"<firstterm>Non-greedy</firstterm> quantifiers (available in AREs only) match "
"the same possibilities as their corresponding normal (<firstterm>greedy</"
"firstterm>) counterparts, but prefer the smallest number rather than the "
"largest number of matches. See <xref linkend=\"posix-matching-rules\"/> for "
"more detail."
msgstr ""
"<firstterm>Не жадные</firstterm> определители (допустимые только в ARE) "
"описывают те же возможные соответствия, что и аналогичные им обычные (&laquo;"
"<firstterm>жадные</firstterm>&raquo;), но предпочитают выбирать наименьшее, "
"а не наибольшее количество вхождений. Подробнее это описано в <xref remap="
"\"6\" linkend=\"posix-matching-rules\"/>."

#: func.xml:4505(para)
msgid ""
"A quantifier cannot immediately follow another quantifier, e.g., "
"<literal>**</literal> is invalid. A quantifier cannot begin an expression or "
"subexpression or follow <literal>^</literal> or <literal>|</literal>."
msgstr ""
"Определители количества не могут следовать один за другим, например запись "
"<literal>**</literal> будет ошибочной. Кроме того, определители не могут "
"стоять в начале выражения или подвыражения и идти сразу после <literal>^</"
"literal> или <literal>|</literal>."

#: func.xml:4515(title)
msgid "Regular Expression Constraints"
msgstr "Ограничения в регулярных выражениях"

# #-#-#-#-#  -  #-#-#-#-#
# refragment
#: func.xml:4520(entry)
msgid "Constraint"
msgstr "Ограничение"

#: func.xml:4528(entry)
msgid "matches at the beginning of the string"
msgstr "соответствует началу строки"

#: func.xml:4532(literal)
msgid "$"
msgstr "$"

#: func.xml:4533(entry)
msgid "matches at the end of the string"
msgstr "соответствует концу строки"

#: func.xml:4537(literal)
msgid "(?="
msgstr "(?="

#: func.xml:4538(entry)
msgid ""
"<firstterm>positive lookahead</firstterm> matches at any point where a "
"substring matching <replaceable>re</replaceable> begins (AREs only)"
msgstr ""
"<firstterm>позитивный предпросмотр</firstterm> находит соответствие в точке, "
"где начинается подстрока, соответствующая <replaceable>re</replaceable> "
"(только для ARE)"

#: func.xml:4544(literal)
msgid "(?!"
msgstr "(?!"

#: func.xml:4545(entry)
msgid ""
"<firstterm>negative lookahead</firstterm> matches at any point where no "
"substring matching <replaceable>re</replaceable> begins (AREs only)"
msgstr ""
"<firstterm>негативный предпросмотр</firstterm> находит соответствие там, где "
"не начинается подстрока, соответствующая <replaceable>re</replaceable> "
"(только для ARE)"

#: func.xml:4551(literal)
#, fuzzy
msgid "(?&lt;="
msgstr "&lt;="

#: func.xml:4552(entry)
#, fuzzy
msgid ""
"<firstterm>positive lookbehind</firstterm> matches at any point where a "
"substring matching <replaceable>re</replaceable> ends (AREs only)"
msgstr ""
"<firstterm>позитивный предпросмотр</firstterm> находит соответствие в точке, "
"где начинается подстрока, соответствующая <replaceable>re</replaceable> "
"(только для ARE)"

#: func.xml:4558(literal)
#, fuzzy
msgid "(?&lt;!"
msgstr "?&lt;@"

#: func.xml:4559(entry)
#, fuzzy
msgid ""
"<firstterm>negative lookbehind</firstterm> matches at any point where no "
"substring matching <replaceable>re</replaceable> ends (AREs only)"
msgstr ""
"<firstterm>негативный предпросмотр</firstterm> находит соответствие там, где "
"не начинается подстрока, соответствующая <replaceable>re</replaceable> "
"(только для ARE)"

#: func.xml:4567(para)
#, fuzzy
msgid ""
"Lookahead and lookbehind constraints cannot contain <firstterm>back "
"references</firstterm> (see <xref linkend=\"posix-escape-sequences\"/>), and "
"all parentheses within them are considered non-capturing."
msgstr ""
"Ограничения предпросмотра не могут содержать <firstterm>ссылки назад</"
"firstterm> (см. <xref remap=\"4\" linkend=\"posix-escape-sequences\"/>) и "
"все скобки в них считаются &laquo;скобками без захвата&raquo;."

#: func.xml:4575(title)
msgid "Bracket Expressions"
msgstr "Выражения в квадратных скобках"

#: func.xml:4577(para)
msgid ""
"A <firstterm>bracket expression</firstterm> is a list of characters enclosed "
"in <literal>[]</literal>. It normally matches any single character from the "
"list (but see below). If the list begins with <literal>^</literal>, it "
"matches any single character <emphasis>not</emphasis> from the rest of the "
"list. If two characters in the list are separated by <literal>-</literal>, "
"this is shorthand for the full range of characters between those two "
"(inclusive) in the collating sequence, e.g., <literal>[0-9]</literal> in "
"<acronym>ASCII</acronym> matches any decimal digit. It is illegal for two "
"ranges to share an endpoint, e.g., <literal>a-c-e</literal>. Ranges are very "
"collating-sequence-dependent, so portable programs should avoid relying on "
"them."
msgstr ""
"<firstterm>Выражение в квадратных скобках</firstterm> содержит список "
"символов, заключённый в <literal>[]</literal>. Обычно ему соответствует "
"любой символ из списка (об исключении написано ниже). Если список начинается "
"с <literal>^</literal>, ему соответствует любой символ, который "
"<emphasis>не</emphasis> перечисляется далее в этом списке. Если два символа "
"в списке разделяются знаком <literal>-</literal>, это воспринимается как "
"краткая запись полного интервала символов между двумя заданными (и включая "
"их) в порядке сортировки; например выражению <literal>[0-9]</literal> в "
"<acronym>ASCII</acronym> соответствует любая десятичная цифра. Два интервала "
"не могут разделять одну границу, т. е. выражение <literal>a-c-e</literal> "
"недопустимо. Интервалы зависят от порядка сортировки, который может "
"меняться, поэтому в переносимых программах их лучше не использовать."

#: func.xml:4594(para)
msgid ""
"To include a literal <literal>]</literal> in the list, make it the first "
"character (after <literal>^</literal>, if that is used). To include a "
"literal <literal>-</literal>, make it the first or last character, or the "
"second endpoint of a range. To use a literal <literal>-</literal> as the "
"first endpoint of a range, enclose it in <literal>[.</literal> and "
"<literal>.]</literal> to make it a collating element (see below). With the "
"exception of these characters, some combinations using <literal>[</literal> "
"(see next paragraphs), and escapes (AREs only), all other special characters "
"lose their special significance within a bracket expression. In particular, "
"<literal>\\</literal> is not special when following ERE or BRE rules, though "
"it is special (as introducing an escape) in AREs."
msgstr ""
"Чтобы включить в список <literal>]</literal>, этот символ нужно написать "
"первым (сразу за <literal>^</literal>, если он присутствует). Чтобы включить "
"в список символ <literal>-</literal>, его нужно написать первым или "
"последним, либо как вторую границу интервала. Указать <literal>-</literal> в "
"качестве первой границы интервал можно, заключив его между <literal>[.</"
"literal> и <literal>.]</literal>, чтобы он стал элементом сортировки (см. "
"ниже). За исключением этих символов, некоторых комбинаций с <literal>[</"
"literal> (см. следующие абзацы) и спецсимволов (в ARE), все остальные "
"специальные символы в квадратных скобках теряют своё особое значение. В "
"частности, символ <literal>\\</literal> по правилам ERE или BRE "
"воспринимается как обычный, хотя в ARE он экранирует символ, следующий за "
"ним."

#: func.xml:4610(para)
msgid ""
"Within a bracket expression, a collating element (a character, a multiple-"
"character sequence that collates as if it were a single character, or a "
"collating-sequence name for either) enclosed in <literal>[.</literal> and "
"<literal>.]</literal> stands for the sequence of characters of that "
"collating element. The sequence is treated as a single element of the "
"bracket expression's list. This allows a bracket expression containing a "
"multiple-character collating element to match more than one character, e.g., "
"if the collating sequence includes a <literal>ch</literal> collating "
"element, then the RE <literal>[[.ch.]]*c</literal> matches the first five "
"characters of <literal>chchcc</literal>."
msgstr ""
"Выражения в квадратных скобках могут содержать элемент сортировки (символ "
"или последовательность символов или имя такой последовательности), "
"определение которого заключается между <literal>[.</literal> и <literal>.]</"
"literal>. Определяющая его последовательность воспринимается в выражении в "
"скобках как один элемент. Это позволяет включать в такие выражения элементы, "
"соответствующие последовательности нескольких символов. Например, с "
"элементом сортировки <literal>ch</literal> в квадратных скобках регулярному "
"выражению <literal>[[.ch.]]*c</literal> будут соответствовать первые пять "
"символов строки <literal>chchcc</literal>."

#: func.xml:4626(para)
msgid ""
"<productname>PostgreSQL</productname> currently does not support multi-"
"character collating elements. This information describes possible future "
"behavior."
msgstr ""
"В настоящее время <productname>PostgreSQL</productname> не поддерживает "
"элементы сортировки, состоящие из нескольких символов. Эта информация "
"относится к возможному в будущем поведению."

#: func.xml:4632(para)
msgid ""
"Within a bracket expression, a collating element enclosed in <literal>[=</"
"literal> and <literal>=]</literal> is an <firstterm>equivalence class</"
"firstterm>, standing for the sequences of characters of all collating "
"elements equivalent to that one, including itself. (If there are no other "
"equivalent collating elements, the treatment is as if the enclosing "
"delimiters were <literal>[.</literal> and <literal>.]</literal>.) For "
"example, if <literal>o</literal> and <literal>^</literal> are the members of "
"an equivalence class, then <literal>[[=o=]]</literal>, <literal>[[=^=]]</"
"literal>, and <literal>[o^]</literal> are all synonymous. An equivalence "
"class cannot be an endpoint of a range."
msgstr ""
"В квадратных скобках могут содержаться элементы сортировки, заключённые "
"между <literal>[=</literal> и <literal>=]</literal>, обозначающие "
"<firstterm>классы эквивалентности</firstterm>, т. е. последовательности "
"символов из всех элементов сортировки, эквивалентных указанному, включая его "
"самого. (Если для этого символа нет эквивалентных, он обрабатывается, как "
"заключённый между <literal>[.</literal> и <literal>.]</literal>.) Например, "
"если <literal>е</literal> и <literal>ё</literal> &mdash; члены одного класса "
"эквивалентности, выражения <literal>[[=е=]]</literal>, <literal>[[=ё=]]</"
"literal> и <literal>[её]</literal> будут равнозначными. Класс "
"эквивалентности нельзя указать в качестве границы интервала."

#: func.xml:4646(para)
msgid ""
"Within a bracket expression, the name of a character class enclosed in "
"<literal>[:</literal> and <literal>:]</literal> stands for the list of all "
"characters belonging to that class. Standard character class names are: "
"<literal>alnum</literal>, <literal>alpha</literal>, <literal>blank</"
"literal>, <literal>cntrl</literal>, <literal>digit</literal>, "
"<literal>graph</literal>, <literal>lower</literal>, <literal>print</"
"literal>, <literal>punct</literal>, <literal>space</literal>, "
"<literal>upper</literal>, <literal>xdigit</literal>. These stand for the "
"character classes defined in <citerefentry><refentrytitle>ctype</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>. A locale can provide "
"others. A character class cannot be used as an endpoint of a range."
msgstr ""
"В квадратных скобках может также содержаться имя класса символов, "
"заключённое между <literal>[:</literal> и <literal>:]</literal>, и "
"заменяющее список всех символов этого класса. Стандартные имена классов: "
"<literal>alnum</literal>, <literal>alpha</literal>, <literal>blank</"
"literal>, <literal>cntrl</literal>, <literal>digit</literal>, "
"<literal>graph</literal>, <literal>lower</literal>, <literal>print</"
"literal>, <literal>punct</literal>, <literal>space</literal>, "
"<literal>upper</literal> и <literal>xdigit</literal>. Весь этот набор "
"классов определён в <citerefentry><refentrytitle>ctype</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> и он может меняться в "
"зависимости от локали (языковой среды). Класс символов также нельзя "
"использовать в качестве границы интервала."

#: func.xml:4663(para)
msgid ""
"There are two special cases of bracket expressions: the bracket expressions "
"<literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal> are "
"constraints, matching empty strings at the beginning and end of a word "
"respectively. A word is defined as a sequence of word characters that is "
"neither preceded nor followed by word characters. A word character is an "
"<literal>alnum</literal> character (as defined by "
"<citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>) or an underscore. This is an extension, compatible with but "
"not specified by <acronym>POSIX</acronym> 1003.2, and should be used with "
"caution in software intended to be portable to other systems. The constraint "
"escapes described below are usually preferable; they are no more standard, "
"but are easier to type."
msgstr ""
"Есть два особых вида выражений в квадратных скобках: выражения <literal>[[:"
"&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>, представляющие собой "
"ограничения, соответствующие пустым строкам в начале и конце слова. Слово в "
"данном контексте определяется как последовательность словосоставляющих "
"символов, перед или после которой нет словосоставляющих символов. "
"Словосоставляющий символ &mdash; это символ класса <literal>alnum</literal> "
"(определённого в <citerefentry><refentrytitle>ctype</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>) или подчёркивание. "
"Это расширение совместимо со стандартом <acronym>POSIX</acronym> 1003.2, но "
"не описано в нём, и поэтому его следует использовать с осторожностью там, "
"где важна совместимость с другими системами. Обычно лучше использовать "
"ограничивающие спецсимволы, описанные ниже; они также не совсем стандартны, "
"но набрать их легче."

#: func.xml:4682(title)
msgid "Regular Expression Escapes"
msgstr "Спецсимволы регулярных выражений"

#: func.xml:4684(para)
msgid ""
"<firstterm>Escapes</firstterm> are special sequences beginning with <literal>"
"\\</literal> followed by an alphanumeric character. Escapes come in several "
"varieties: character entry, class shorthands, constraint escapes, and back "
"references. A <literal>\\</literal> followed by an alphanumeric character "
"but not constituting a valid escape is illegal in AREs. In EREs, there are "
"no escapes: outside a bracket expression, a <literal>\\</literal> followed "
"by an alphanumeric character merely stands for that character as an ordinary "
"character, and inside a bracket expression, <literal>\\</literal> is an "
"ordinary character. (The latter is the one actual incompatibility between "
"EREs and AREs.)"
msgstr ""
"<firstterm>Спецсимволы</firstterm> &mdash; это специальные команды, "
"состоящие из <literal>\\</literal> и последующего алфавитно-цифрового "
"символа. Можно выделить следующие категории спецсимволов: обозначения "
"символов, коды классов, ограничения и ссылки назад. Символ <literal>\\</"
"literal>, за которым идёт алфавитно-цифровой символ, не образующий "
"допустимый спецсимвол, считается ошибочным в ARE. В ERE спецсимволов нет: "
"вне квадратных скобок пара из <literal>\\</literal> и последующего алфавитно-"
"цифрового символа, воспринимается просто как данный символ, а в квадратных "
"скобках и сам символ <literal>\\</literal> воспринимается просто как "
"обратная косая черта. (Последнее на самом деле нарушает совместимость между "
"ERE и ARE.)"

#: func.xml:4697(para)
msgid ""
"<firstterm>Character-entry escapes</firstterm> exist to make it easier to "
"specify non-printing and other inconvenient characters in REs. They are "
"shown in <xref linkend=\"posix-character-entry-escapes-table\"/>."
msgstr ""
"<firstterm>Спецобозначения символов</firstterm> введены для того, чтобы "
"облегчить ввод в RE непечатаемых и других неудобных символов. Они приведены "
"в <xref remap=\"6\" linkend=\"posix-character-entry-escapes-table\"/>."

#: func.xml:4703(para)
msgid ""
"<firstterm>Class-shorthand escapes</firstterm> provide shorthands for "
"certain commonly-used character classes. They are shown in <xref linkend="
"\"posix-class-shorthand-escapes-table\"/>."
msgstr ""
"<firstterm>Коды классов</firstterm> представляют собой краткий способ записи "
"имён некоторых распространённых классов символов. Они перечислены в <xref "
"remap=\"6\" linkend=\"posix-class-shorthand-escapes-table\"/>."

#: func.xml:4709(para)
msgid ""
"A <firstterm>constraint escape</firstterm> is a constraint, matching the "
"empty string if specific conditions are met, written as an escape. They are "
"shown in <xref linkend=\"posix-constraint-escapes-table\"/>."
msgstr ""
"<firstterm>Спецсимволы ограничений</firstterm> обозначают ограничения, "
"которым при совпадении определённых условий соответствует пустая строка. Они "
"перечислены в <xref remap=\"6\" linkend=\"posix-constraint-escapes-table\"/>."

#: func.xml:4716(para)
msgid ""
"A <firstterm>back reference</firstterm> (<literal>\\</"
"literal><replaceable>n</replaceable>) matches the same string matched by the "
"previous parenthesized subexpression specified by the number <replaceable>n</"
"replaceable> (see <xref linkend=\"posix-constraint-backref-table\"/>). For "
"example, <literal>([bc])\\1</literal> matches <literal>bb</literal> or "
"<literal>cc</literal> but not <literal>bc</literal> or <literal>cb</"
"literal>. The subexpression must entirely precede the back reference in the "
"RE. Subexpressions are numbered in the order of their leading parentheses. "
"Non-capturing parentheses do not define subexpressions."
msgstr ""
"<firstterm>Ссылка назад</firstterm> (<literal>\\</literal><replaceable>n</"
"replaceable>) соответствует той же строке, какой соответствовало предыдущее "
"подвыражение в скобках под номером <replaceable>n</replaceable> (см. <xref "
"remap=\"4\" linkend=\"posix-constraint-backref-table\"/>). Например, "
"<literal>([bc])\\1</literal> соответствует <literal>bb</literal> или "
"<literal>cc</literal>, но не <literal>bc</literal> или <literal>cb</"
"literal>. Это подвыражение должно полностью предшествовать ссылке назад в "
"RE. Нумеруются подвыражения в порядке следования их открывающих скобок. При "
"этом скобки без захвата исключаются из рассмотрения."

#: func.xml:4729(title)
msgid "Regular Expression Character-entry Escapes"
msgstr "Спецобозначения символов в регулярных выражениях"

#: func.xml:4734(entry) func.xml:4875(entry) func.xml:4932(entry)
#: func.xml:4988(entry)
msgid "Escape"
msgstr "Спецсимвол"

#: func.xml:4741(literal)
msgid "\\a"
msgstr "\\a"

#: func.xml:4742(entry)
msgid "alert (bell) character, as in C"
msgstr "символ звонка, как в C"

#: func.xml:4746(literal)
msgid "\\b"
msgstr "\\b"

#: func.xml:4747(entry)
msgid "backspace, as in C"
msgstr "символ &laquo;забой&raquo;, как в C"

#: func.xml:4751(literal)
msgid "\\B"
msgstr "\\B"

#: func.xml:4752(entry)
msgid ""
"synonym for backslash (<literal>\\</literal>) to help reduce the need for "
"backslash doubling"
msgstr ""
"синоним для обратной косой черты (<literal>\\</literal>), сокращающий "
"потребность в дублировании этого символа"

#: func.xml:4757(literal)
msgid "\\c"
msgstr "\\c"

#: func.xml:4757(replaceable) func.xml:12922(replaceable)
#: func.xml:12942(replaceable) func.xml:12962(replaceable)
#: func.xml:12979(replaceable) func.xml:12997(replaceable)
#: func.xml:13015(replaceable) func.xml:13035(replaceable)
#: func.xml:13055(replaceable) func.xml:13075(replaceable)
#: func.xml:13094(replaceable) func.xml:13115(replaceable)
#: func.xml:13139(replaceable)
msgid "X"
msgstr "X"

#: func.xml:4758(entry)
msgid ""
"(where <replaceable>X</replaceable> is any character) the character whose "
"low-order 5 bits are the same as those of <replaceable>X</replaceable>, and "
"whose other bits are all zero"
msgstr ""
"(где <replaceable>X</replaceable> &mdash; любой символ) символ, младшие 5 "
"бит которого те же, что и у <replaceable>X</replaceable>, а остальные равны 0"

#: func.xml:4764(literal)
msgid "\\e"
msgstr "\\e"

#: func.xml:4765(entry)
msgid ""
"the character whose collating-sequence name is <literal>ESC</literal>, or "
"failing that, the character with octal value <literal>033</literal>"
msgstr ""
"символ, определённый в последовательности сортировки с именем <literal>ESC</"
"literal>, либо, если таковой не определён, символ с восьмеричным значением "
"<literal>033</literal>"

#: func.xml:4771(literal)
msgid "\\f"
msgstr "\\f"

#: func.xml:4772(entry)
msgid "form feed, as in C"
msgstr "подача формы, как в C"

#: func.xml:4776(literal)
msgid "\\n"
msgstr "\\n"

#: func.xml:4777(entry)
msgid "newline, as in C"
msgstr "новая строка, как в C"

#: func.xml:4781(literal)
msgid "\\r"
msgstr "\\r"

#: func.xml:4782(entry)
msgid "carriage return, as in C"
msgstr "возврат каретки, как в C"

#: func.xml:4786(literal)
msgid "\\t"
msgstr "\\t"

#: func.xml:4787(entry)
msgid "horizontal tab, as in C"
msgstr "горизонтальная табуляция, как в C"

#: func.xml:4791(literal)
msgid "\\u"
msgstr "\\u"

#: func.xml:4791(replaceable)
msgid "wxyz"
msgstr "wxyz"

#: func.xml:4792(entry)
msgid ""
"(where <replaceable>wxyz</replaceable> is exactly four hexadecimal digits) "
"the character whose hexadecimal value is <literal>0x</"
"literal><replaceable>wxyz</replaceable>"
msgstr ""
"(где <replaceable>wxyz</replaceable> ровно четыре шестнадцатеричные цифры) "
"символ с шестнадцатеричным кодом <literal>0x</literal><replaceable>wxyz</"
"replaceable>"

#: func.xml:4799(literal)
msgid "\\U"
msgstr "\\U"

#: func.xml:4799(replaceable)
msgid "stuvwxyz"
msgstr "stuvwxyz"

#: func.xml:4800(entry)
msgid ""
"(where <replaceable>stuvwxyz</replaceable> is exactly eight hexadecimal "
"digits) the character whose hexadecimal value is <literal>0x</"
"literal><replaceable>stuvwxyz</replaceable>"
msgstr ""
"(где <replaceable>stuvwxyz</replaceable> ровно восемь шестнадцатеричных "
"цифр) символ с шестнадцатеричным кодом <literal>0x</"
"literal><replaceable>stuvwxyz</replaceable>"

#: func.xml:4808(literal)
msgid "\\v"
msgstr "\\v"

#: func.xml:4809(entry)
msgid "vertical tab, as in C"
msgstr "вертикальная табуляция, как в C"

#: func.xml:4813(literal)
msgid "\\x"
msgstr "\\x"

#: func.xml:4813(replaceable)
msgid "hhh"
msgstr "hhh"

#: func.xml:4814(entry)
msgid ""
"(where <replaceable>hhh</replaceable> is any sequence of hexadecimal digits) "
"the character whose hexadecimal value is <literal>0x</"
"literal><replaceable>hhh</replaceable> (a single character no matter how "
"many hexadecimal digits are used)"
msgstr ""
"(где <replaceable>hhh</replaceable> &mdash; несколько шестнадцатеричных "
"цифр) символ с шестнадцатеричным кодом <literal>0x</"
"literal><replaceable>hhh</replaceable> (символ всегда один вне зависимости "
"от числа шестнадцатеричных цифр)"

#: func.xml:4823(literal)
msgid "\\0"
msgstr "\\0"

#: func.xml:4824(entry)
msgid "the character whose value is <literal>0</literal> (the null byte)"
msgstr "символ с кодом <literal>0</literal> (нулевой байт)"

#: func.xml:4828(replaceable)
msgid "xy"
msgstr "xy"

#: func.xml:4829(entry)
msgid ""
"(where <replaceable>xy</replaceable> is exactly two octal digits, and is not "
"a <firstterm>back reference</firstterm>) the character whose octal value is "
"<literal>0</literal><replaceable>xy</replaceable>"
msgstr ""
"(где <replaceable>xy</replaceable> &mdash; ровно две восьмеричных цифры, не "
"<firstterm>ссылка назад</firstterm>) символ с восьмеричным кодом <literal>0</"
"literal><replaceable>xy</replaceable>"

#: func.xml:4836(replaceable)
msgid "xyz"
msgstr "xyz"

#: func.xml:4837(entry)
msgid ""
"(where <replaceable>xyz</replaceable> is exactly three octal digits, and is "
"not a <firstterm>back reference</firstterm>) the character whose octal value "
"is <literal>0</literal><replaceable>xyz</replaceable>"
msgstr ""
"(где <replaceable>xyz</replaceable> &mdash; ровно три восьмеричных цифры, не "
"<firstterm>ссылка назад</firstterm>) символ с восьмеричным кодом <literal>0</"
"literal><replaceable>xyz</replaceable>"

#: func.xml:4846(para)
msgid ""
"Hexadecimal digits are <literal>0</literal>-<literal>9</literal>, "
"<literal>a</literal>-<literal>f</literal>, and <literal>A</literal>-"
"<literal>F</literal>. Octal digits are <literal>0</literal>-<literal>7</"
"literal>."
msgstr ""
"Шестнадцатеричные цифры записываются символами <literal>0</literal>-"
"<literal>9</literal> и <literal>a</literal>-<literal>f</literal> или "
"<literal>A</literal>-<literal>F</literal>. Восьмеричные цифры &mdash; цифры "
"от <literal>0</literal> до <literal>7</literal>."

#: func.xml:4852(para)
msgid ""
"Numeric character-entry escapes specifying values outside the ASCII range "
"(0-127) have meanings dependent on the database encoding. When the encoding "
"is UTF-8, escape values are equivalent to Unicode code points, for example "
"<literal>\\u1234</literal> means the character <literal>U+1234</literal>. "
"For other multibyte encodings, character-entry escapes usually just specify "
"the concatenation of the byte values for the character. If the escape value "
"does not correspond to any legal character in the database encoding, no "
"error will be raised, but it will never match any data."
msgstr ""
"Спецпоследовательности с числовыми кодами, задающими значения вне диапазона "
"ASCII (0-127), воспринимаются по-разному в зависимости от кодировки базы "
"данных. Когда база данных имеет кодировку UTF-8, спецкод равнозначен позиции "
"символа в Unicode, например, <literal>\\u1234</literal> обозначает символ "
"<literal>U+1234</literal>. Для других многобайтных кодировок "
"спецпоследовательности обычно просто задают серию байт, определяющих символ. "
"Если в кодировке базы данных отсутствует символ, заданный "
"спецпоследовательностью, ошибки не будет, но и никакие данные не будут ей "
"соответствовать."

#: func.xml:4863(para)
msgid ""
"The character-entry escapes are always taken as ordinary characters. For "
"example, <literal>\\135</literal> is <literal>]</literal> in ASCII, but "
"<literal>\\135</literal> does not terminate a bracket expression."
msgstr ""
"Символы, переданные спецобозначением, всегда воспринимаются как обычные "
"символы. Например, <literal>\\135</literal> кодирует <literal>]</literal> в "
"ASCII, но спецпоследовательность <literal>\\135</literal> не будет закрывать "
"выражение в квадратных скобках."

#: func.xml:4870(title)
msgid "Regular Expression Class-shorthand Escapes"
msgstr "Спецкоды классов в регулярных выражениях"

#: func.xml:4882(literal)
msgid "\\d"
msgstr "\\d"

#: func.xml:4883(literal)
msgid "[[:digit:]]"
msgstr "[[:digit:]]"

#: func.xml:4887(literal)
msgid "\\s"
msgstr "\\s"

#: func.xml:4888(literal)
msgid "[[:space:]]"
msgstr "[[:space:]]"

#: func.xml:4892(literal)
msgid "\\w"
msgstr "\\w"

#: func.xml:4893(entry)
msgid "<literal>[[:alnum:]_]</literal> (note underscore is included)"
msgstr "<literal>[[:alnum:]_]</literal> (подчёркивание также включается)"

#: func.xml:4898(literal)
msgid "\\D"
msgstr "\\D"

#: func.xml:4899(literal)
msgid "[^[:digit:]]"
msgstr "[^[:digit:]]"

#: func.xml:4903(literal)
msgid "\\S"
msgstr "\\S"

#: func.xml:4904(literal)
msgid "[^[:space:]]"
msgstr "[^[:space:]]"

#: func.xml:4908(literal)
msgid "\\W"
msgstr "\\W"

#: func.xml:4909(entry)
msgid "<literal>[^[:alnum:]_]</literal> (note underscore is included)"
msgstr "<literal>[^[:alnum:]_]</literal> (подчёркивание также включается)"

#: func.xml:4916(para)
msgid ""
"Within bracket expressions, <literal>\\d</literal>, <literal>\\s</literal>, "
"and <literal>\\w</literal> lose their outer brackets, and <literal>\\D</"
"literal>, <literal>\\S</literal>, and <literal>\\W</literal> are illegal. "
"(So, for example, <literal>[a-c\\d]</literal> is equivalent to <literal>[a-"
"c[:digit:]]</literal>. Also, <literal>[a-c\\D]</literal>, which is "
"equivalent to <literal>[a-c^[:digit:]]</literal>, is illegal.)"
msgstr ""
"В выражениях в квадратных скобках спецсимволы <literal>\\d</literal>, "
"<literal>\\s</literal> и <literal>\\w</literal> теряют свои внешние "
"квадратные скобки, а <literal>\\D</literal>, <literal>\\S</literal> и "
"<literal>\\W</literal> &mdash; недопустимы. (Так что, например запись "
"<literal>[a-c\\d]</literal> равнозначна <literal>[a-c[:digit:]]</literal>. А "
"запись <literal>[a-c\\D]</literal>, которая была бы равнозначна <literal>[a-"
"c^[:digit:]]</literal>, &mdash; недопустима.)"

#: func.xml:4927(title)
msgid "Regular Expression Constraint Escapes"
msgstr "Спецсимволы ограничений в регулярных выражений"

#: func.xml:4939(literal)
msgid "\\A"
msgstr "\\A"

#: func.xml:4940(entry)
msgid ""
"matches only at the beginning of the string (see <xref linkend=\"posix-"
"matching-rules\"/> for how this differs from <literal>^</literal>)"
msgstr ""
"соответствует только началу строки (чем это отличается от <literal>^</"
"literal>, описано в <xref remap=\"6\" linkend=\"posix-matching-rules\"/>)"

#: func.xml:4946(literal)
msgid "\\m"
msgstr "\\m"

#: func.xml:4947(entry)
msgid "matches only at the beginning of a word"
msgstr "соответствует только началу слова"

#: func.xml:4951(literal)
msgid "\\M"
msgstr "\\M"

#: func.xml:4952(entry)
msgid "matches only at the end of a word"
msgstr "соответствует только концу слова"

#: func.xml:4956(literal)
msgid "\\y"
msgstr "\\y"

#: func.xml:4957(entry)
msgid "matches only at the beginning or end of a word"
msgstr "соответствует только началу или концу слова"

#: func.xml:4961(literal)
msgid "\\Y"
msgstr "\\Y"

#: func.xml:4962(entry)
msgid "matches only at a point that is not the beginning or end of a word"
msgstr "соответствует только положению не в начале и не в конце слова"

#: func.xml:4967(literal)
msgid "\\Z"
msgstr "\\Z"

#: func.xml:4968(entry)
msgid ""
"matches only at the end of the string (see <xref linkend=\"posix-matching-"
"rules\"/> for how this differs from <literal>$</literal>)"
msgstr ""
"соответствует только концу строки (чем это отличается от <literal>$</"
"literal>, описано в <xref remap=\"6\" linkend=\"posix-matching-rules\"/>)"

#: func.xml:4976(para)
msgid ""
"A word is defined as in the specification of <literal>[[:&lt;:]]</literal> "
"and <literal>[[:&gt;:]]</literal> above. Constraint escapes are illegal "
"within bracket expressions."
msgstr ""
"Определением слова здесь служит то же, что было приведено выше в описании "
"<literal>[[:&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>. В квадратных "
"скобках спецсимволы ограничений не допускаются."

#: func.xml:4983(title)
msgid "Regular Expression Back References"
msgstr "Ссылки назад в регулярных выражениях"

#: func.xml:4996(entry)
msgid ""
"(where <replaceable>m</replaceable> is a nonzero digit) a back reference to "
"the <replaceable>m</replaceable>'th subexpression"
msgstr ""
"(где <replaceable>m</replaceable> &mdash; цифра, отличная от 0) &mdash; "
"ссылка назад на подвыражение под номером <replaceable>m</replaceable>"

#: func.xml:5001(replaceable)
msgid "mnn"
msgstr "mnn"

#: func.xml:5002(entry)
msgid ""
"(where <replaceable>m</replaceable> is a nonzero digit, and <replaceable>nn</"
"replaceable> is some more digits, and the decimal value <replaceable>mnn</"
"replaceable> is not greater than the number of closing capturing parentheses "
"seen so far) a back reference to the <replaceable>mnn</replaceable>'th "
"subexpression"
msgstr ""
"(где <replaceable>m</replaceable> &mdash; цифра, отличная от 0, а "
"<replaceable>nn</replaceable> &mdash; ещё несколько цифр с десятичным "
"значением <replaceable>mnn</replaceable>, не превышающим число закрытых до "
"этого скобок с захватом) ссылка назад на подвыражение под номером "
"<replaceable>mnn</replaceable>"

#: func.xml:5013(para)
msgid ""
"There is an inherent ambiguity between octal character-entry escapes and "
"back references, which is resolved by the following heuristics, as hinted at "
"above. A leading zero always indicates an octal escape. A single non-zero "
"digit, not followed by another digit, is always taken as a back reference. A "
"multi-digit sequence not starting with a zero is taken as a back reference "
"if it comes after a suitable subexpression (i.e., the number is in the legal "
"range for a back reference), and otherwise is taken as octal."
msgstr ""
"Регулярным выражениям присуща неоднозначность между восьмеричными кодами "
"символов и ссылками назад, которая разрешается следующим образом (это "
"упоминалось выше). Ведущий ноль всегда считается признаком восьмеричной "
"последовательности. Единственная цифра, отличная от 0, за которой не следует "
"ещё одна цифра, всегда воспринимается как ссылка назад. Последовательность "
"из нескольких цифр, которая начинается не с 0, воспринимается как ссылка "
"назад, если она идёт за подходящим подвыражением (т. е. число оказывается в "
"диапазоне, допустимом для ссылки назад), в противном случае она "
"воспринимается как восьмеричное число."

#: func.xml:5029(title)
msgid "Regular Expression Metasyntax"
msgstr "Метасинтаксис регулярных выражений"

#: func.xml:5031(para)
msgid ""
"In addition to the main syntax described above, there are some special forms "
"and miscellaneous syntactic facilities available."
msgstr ""
"В дополнение к основному синтаксису, описанному выше, можно использовать "
"также несколько особых форм и разнообразные синтаксические удобства."

#: func.xml:5036(para)
msgid ""
"An RE can begin with one of two special <firstterm>director</firstterm> "
"prefixes. If an RE begins with <literal>***:</literal>, the rest of the RE "
"is taken as an ARE. (This normally has no effect in <productname>PostgreSQL</"
"productname>, since REs are assumed to be AREs; but it does have an effect "
"if ERE or BRE mode had been specified by the <replaceable>flags</"
"replaceable> parameter to a regex function.) If an RE begins with "
"<literal>***=</literal>, the rest of the RE is taken to be a literal string, "
"with all characters considered ordinary characters."
msgstr ""
"Регулярное выражение может начинаться с одного из двух специальных префиксов "
"режима. Если RE начинается с <literal>***:</literal>, его продолжение "
"рассматривается как ARE. (В <productname>PostgreSQL</productname> это обычно "
"не имеет значения, так как регулярные выражения воспринимаются как ARE по "
"умолчанию; но это может быть полезно, когда параметр <replaceable>флаги</"
"replaceable> функций regex включает режим ERE или BRE.) Если RE начинается с "
"<literal>***=</literal>, его продолжение воспринимается как обычная "
"текстовая строка, все его символы воспринимаются буквально."

#: func.xml:5048(para)
msgid ""
"An ARE can begin with <firstterm>embedded options</firstterm>: a sequence "
"<literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal> "
"(where <replaceable>xyz</replaceable> is one or more alphabetic characters) "
"specifies options affecting the rest of the RE. These options override any "
"previously determined options &mdash; in particular, they can override the "
"case-sensitivity behavior implied by a regex operator, or the "
"<replaceable>flags</replaceable> parameter to a regex function. The "
"available option letters are shown in <xref linkend=\"posix-embedded-options-"
"table\"/>. Note that these same option letters are used in the "
"<replaceable>flags</replaceable> parameters of regex functions."
msgstr ""
"ARE может начинаться со <firstterm>встроенных параметров</firstterm>: "
"последовательности <literal>(?</literal><replaceable>xyz</"
"replaceable><literal>)</literal> (где <replaceable>xyz</replaceable> &mdash; "
"один или несколько алфавитно-цифровых символов), определяющих параметры "
"остального регулярного выражения. Эти параметры переопределяют любые ранее "
"определённые параметры, в частности они могут переопределить режим "
"чувствительности к регистру, подразумеваемый для оператора regex, или "
"параметр <replaceable>флаги</replaceable> функции regex. Допустимые буквы "
"параметров показаны в <xref remap=\"6\" linkend=\"posix-embedded-options-"
"table\"/>. Заметьте, что те же буквы используются в параметре "
"<replaceable>флаги</replaceable> функций regex."

#: func.xml:5064(title)
msgid "ARE Embedded-option Letters"
msgstr "Буквы встроенных параметров ARE"

#: func.xml:5069(entry)
msgid "Option"
msgstr "Параметр"

#: func.xml:5076(literal)
msgctxt "literal"
msgid "b"
msgstr "b"

#: func.xml:5077(entry)
msgid "rest of RE is a BRE"
msgstr "продолжение регулярного выражения &mdash; BRE"

#: func.xml:5081(literal)
msgctxt "literal"
msgid "c"
msgstr "c"

#: func.xml:5082(entry)
msgid "case-sensitive matching (overrides operator type)"
msgstr "поиск соответствий с учётом регистра (переопределяет тип оператора)"

#: func.xml:5086(literal)
msgid "e"
msgstr "e"

#: func.xml:5087(entry)
msgid "rest of RE is an ERE"
msgstr "продолжение RE &mdash; ERE"

#: func.xml:5091(literal)
msgid "i"
msgstr "i"

#: func.xml:5092(entry)
msgid ""
"case-insensitive matching (see <xref linkend=\"posix-matching-rules\"/>) "
"(overrides operator type)"
msgstr ""
"поиск соответствий без учёта регистра (см. <xref remap=\"4\" linkend=\"posix-"
"matching-rules\"/>) (переопределяет тип оператора)"

#: func.xml:5097(literal)
msgctxt "literal"
msgid "m"
msgstr "m"

#: func.xml:5098(entry)
msgid "historical synonym for <literal>n</literal>"
msgstr "исторически сложившийся синоним <literal>n</literal>"

#: func.xml:5102(literal)
msgctxt "literal"
msgid "n"
msgstr "n"

#: func.xml:5103(entry)
msgid ""
"newline-sensitive matching (see <xref linkend=\"posix-matching-rules\"/>)"
msgstr ""
"поиск соответствий с учётом перевода строк (см. <xref remap=\"4\" linkend="
"\"posix-matching-rules\"/>)"

#: func.xml:5108(literal)
msgid "p"
msgstr "p"

#: func.xml:5109(entry)
msgid ""
"partial newline-sensitive matching (see <xref linkend=\"posix-matching-rules"
"\"/>)"
msgstr ""
"переводы строк учитываются частично (см. <xref remap=\"4\" linkend=\"posix-"
"matching-rules\"/>)"

#: func.xml:5114(literal)
msgid "q"
msgstr "q"

#: func.xml:5115(entry)
msgid ""
"rest of RE is a literal (<quote>quoted</quote>) string, all ordinary "
"characters"
msgstr ""
"продолжение регулярного выражения &mdash; обычная строка (<quote>в кавычках</"
"quote>), содержимое которой воспринимается буквально"

#: func.xml:5120(literal)
msgctxt "literal"
msgid "s"
msgstr "s"

#: func.xml:5121(entry)
msgid "non-newline-sensitive matching (default)"
msgstr "поиск соответствий без учёта перевода строк (по умолчанию)"

#: func.xml:5125(literal) func.xml:8949(literal) func.xml:8956(literal)
#: func.xml:9005(literal) func.xml:11661(literal) func.xml:11668(literal)
#: func.xml:11675(literal) func.xml:11682(literal) func.xml:11689(literal)
#: func.xml:11696(literal) func.xml:11703(literal) func.xml:11710(literal)
#: func.xml:11717(literal) func.xml:12136(literal) func.xml:12143(literal)
#: func.xml:12150(literal) func.xml:12157(literal) func.xml:12164(literal)
#: func.xml:12171(literal) func.xml:12178(literal) func.xml:12185(literal)
#: func.xml:12192(literal) func.xml:12206(literal) func.xml:12213(literal)
#: func.xml:12220(literal) func.xml:12227(literal) func.xml:12234(literal)
#: func.xml:12241(literal)
msgid "t"
msgstr "t"

#: func.xml:5126(entry)
msgid "tight syntax (default; see below)"
msgstr "компактный синтаксис (по умолчанию; см. ниже)"

#: func.xml:5130(literal)
msgid "w"
msgstr "w"

#: func.xml:5131(entry)
msgid ""
"inverse partial newline-sensitive (<quote>weird</quote>) matching (see <xref "
"linkend=\"posix-matching-rules\"/>)"
msgstr ""
"переводы строк учитываются частично, но в другом, <quote>странном</quote> "
"режиме (см. <xref remap=\"4\" linkend=\"posix-matching-rules\"/>)"

#: func.xml:5136(literal)
msgctxt "literal"
msgid "x"
msgstr "x"

#: func.xml:5137(entry)
msgid "expanded syntax (see below)"
msgstr "развёрнутый синтаксис (см. ниже)"

#: func.xml:5143(para)
msgid ""
"Embedded options take effect at the <literal>)</literal> terminating the "
"sequence. They can appear only at the start of an ARE (after the "
"<literal>***:</literal> director if any)."
msgstr ""
"Внедрённые параметры начинают действовать сразу после скобки <literal>)</"
"literal>, завершающей их последовательность. Они могут находиться только в "
"начале ARE (после указания <literal>***:</literal>, если оно присутствует)."

#: func.xml:5162(para)
msgid ""
"a white-space character or <literal>#</literal> preceded by <literal>\\</"
"literal> is retained"
msgstr ""
"пробельный символ или <literal>#</literal>, за которым следует <literal>\\</"
"literal>, сохраняется"

#: func.xml:5168(para)
msgid ""
"white space or <literal>#</literal> within a bracket expression is retained"
msgstr ""
"пробельный символ или <literal>#</literal> внутри выражения в квадратных "
"скобках сохраняется"

#: func.xml:5173(para)
msgid ""
"white space and comments cannot appear within multi-character symbols, such "
"as <literal>(?:</literal>"
msgstr ""
"пробельные символы и комментарии не могут присутствовать в составных "
"символах, например, в <literal>(?:</literal>"

#: func.xml:5149(para)
msgid ""
"In addition to the usual (<firstterm>tight</firstterm>) RE syntax, in which "
"all characters are significant, there is an <firstterm>expanded</firstterm> "
"syntax, available by specifying the embedded <literal>x</literal> option. In "
"the expanded syntax, white-space characters in the RE are ignored, as are "
"all characters between a <literal>#</literal> and the following newline (or "
"the end of the RE). This permits paragraphing and commenting a complex RE. "
"There are three exceptions to that basic rule: <placeholder-1/> For this "
"purpose, white-space characters are blank, tab, newline, and any character "
"that belongs to the <replaceable>space</replaceable> character class."
msgstr ""
"Помимо обычного (<firstterm>компактного</firstterm>) синтаксиса RE, в "
"котором имеют значение все символы, поддерживается также "
"<firstterm>развёрнутый</firstterm> синтаксис, включить который можно с "
"помощью встроенного параметра <literal>x</literal>. В развёрнутом синтаксисе "
"игнорируются пробельные символы, а также все символы от <literal>#</literal> "
"до конца строки (или конца RE). Это позволяет разделять RE на строки и "
"добавлять в него комментарии. Но есть три исключения: <placeholder-1/> В "
"данном контексте пробельными символами считаются пробел, табуляция, перевод "
"строки и любой другой символ, относящийся к классу символов "
"<replaceable>space</replaceable>."

#: func.xml:5184(para)
msgid ""
"Finally, in an ARE, outside bracket expressions, the sequence <literal>(?#</"
"literal><replaceable>ttt</replaceable><literal>)</literal> (where "
"<replaceable>ttt</replaceable> is any text not containing a <literal>)</"
"literal>) is a comment, completely ignored. Again, this is not allowed "
"between the characters of multi-character symbols, like <literal>(?:</"
"literal>. Such comments are more a historical artifact than a useful "
"facility, and their use is deprecated; use the expanded syntax instead."
msgstr ""
"И наконец, в ARE последовательность <literal>(?#</literal><replaceable>ttt</"
"replaceable><literal>)</literal> (где <replaceable>ttt</replaceable> &mdash; "
"любой текст, не содержащий <literal>)</literal>) вне квадратных скобок также "
"считается комментарием и полностью игнорируется. При этом она так же не "
"может находиться внутри составных символов, таких как <literal>(?:</"
"literal>. Эти комментарии в большей степени историческое наследие, чем "
"полезное средство; они считаются устаревшими, а вместо них рекомендуется "
"использовать развёрнутый синтаксис."

#: func.xml:5195(para)
msgid ""
"<emphasis>None</emphasis> of these metasyntax extensions is available if an "
"initial <literal>***=</literal> director has specified that the user's input "
"be treated as a literal string rather than as an RE."
msgstr ""
"<emphasis>Ни одно</emphasis> из этих расширений метасинтаксиса не будет "
"работать, если выражение начинается с префикса <literal>***=</literal>, "
"после которого строка воспринимается буквально, а не как RE."

#: func.xml:5204(title)
msgid "Regular Expression Matching Rules"
msgstr "Правила соответствия регулярным выражениям"

#: func.xml:5206(para)
msgid ""
"In the event that an RE could match more than one substring of a given "
"string, the RE matches the one starting earliest in the string. If the RE "
"could match more than one substring starting at that point, either the "
"longest possible match or the shortest possible match will be taken, "
"depending on whether the RE is <firstterm>greedy</firstterm> or "
"<firstterm>non-greedy</firstterm>."
msgstr ""
"В случае, когда RE может соответствовать более чем одной подстроке в "
"заданной строке, соответствующей RE считается подстрока, которая начинается "
"в ней первой. Если к данной позиции подобных соответствующих подстрок "
"оказывается несколько, из них выбирается либо самая длинная, либо самая "
"короткая из возможных, в зависимости от того, какой режим выбран в RE: "
"<firstterm>жадный</firstterm> или <firstterm>не жадный</firstterm>."

#: func.xml:5219(para)
msgid ""
"Most atoms, and all constraints, have no greediness attribute (because they "
"cannot match variable amounts of text anyway)."
msgstr ""
"Большинство атомов и все ограничения не имеют признака жадности (так как они "
"всё равно не могут соответствовать подстрокам разного состава)."

#: func.xml:5225(para)
msgid "Adding parentheses around an RE does not change its greediness."
msgstr "Скобки, окружающие RE, не влияют на его &laquo;жадность&raquo;."

#: func.xml:5230(para)
msgid ""
"A quantified atom with a fixed-repetition quantifier (<literal>{</"
"literal><replaceable>m</replaceable><literal>}</literal> or <literal>{</"
"literal><replaceable>m</replaceable><literal>}?</literal>) has the same "
"greediness (possibly none) as the atom itself."
msgstr ""
"Атом с определителем фиксированного количества (<literal>{</"
"literal><replaceable>m</replaceable><literal>}</literal> или <literal>{</"
"literal><replaceable>m</replaceable><literal>}?</literal>) имеет ту же "
"характеристику жадности (или может не иметь её), как и сам атом."

#: func.xml:5239(para)
msgid ""
"A quantified atom with other normal quantifiers (including <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}</literal> with <replaceable>m</replaceable> equal to "
"<replaceable>n</replaceable>) is greedy (prefers longest match)."
msgstr ""
"Атом с другими обычными определителями количества (включая <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}</literal>, где <replaceable>m</replaceable> равняется "
"<replaceable>n</replaceable>) считается жадным (предпочитает соответствие "
"максимальной длины)."

#: func.xml:5247(para)
msgid ""
"A quantified atom with a non-greedy quantifier (including <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}?</literal> with <replaceable>m</replaceable> equal to "
"<replaceable>n</replaceable>) is non-greedy (prefers shortest match)."
msgstr ""
"Атом с не жадным определителем количества (включая <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}?</literal>, где <replaceable>m</replaceable> равно "
"<replaceable>n</replaceable>) считается не жадным (предпочитает соответствие "
"минимальной длины)."

#: func.xml:5255(para)
msgid ""
"A branch &mdash; that is, an RE that has no top-level <literal>|</literal> "
"operator &mdash; has the same greediness as the first quantified atom in it "
"that has a greediness attribute."
msgstr ""
"Ветвь (RE без оператора <literal>|</literal> на верхнем уровне) имеет ту же "
"характеристику жадности, что и первый количественный атом в нём, имеющий "
"атрибут жадности."

#: func.xml:5262(para)
msgid ""
"An RE consisting of two or more branches connected by the <literal>|</"
"literal> operator is always greedy."
msgstr ""
"RE, образованное из двух или более ветвей, соединённых оператором <literal>|"
"</literal>, всегда считается жадным."

#: func.xml:5215(para)
msgid ""
"Whether an RE is greedy or not is determined by the following rules: "
"<placeholder-1/>"
msgstr ""
"Где жадный или не жадный характер RE определяется по следующим правилам: "
"<placeholder-1/>"

#: func.xml:5270(para)
msgid ""
"The above rules associate greediness attributes not only with individual "
"quantified atoms, but with branches and entire REs that contain quantified "
"atoms. What that means is that the matching is done in such a way that the "
"branch, or whole RE, matches the longest or shortest possible substring "
"<emphasis>as a whole</emphasis>. Once the length of the entire match is "
"determined, the part of it that matches any particular subexpression is "
"determined on the basis of the greediness attribute of that subexpression, "
"with subexpressions starting earlier in the RE taking priority over ones "
"starting later."
msgstr ""
"Эти правила связывают характеристики жадности не только с отдельными "
"количественными атомами, но и с ветвями и целыми RE, содержащими "
"количественные атомы. Это означает, что при сопоставлении ветвь или целое RE "
"может соответствовать максимально длинной или короткой подстроке <emphasis>в "
"целом</emphasis>. Когда определена длина всего соответствия, часть его, "
"соответствующая конкретному подвыражению, определяется с учётом "
"характеристики жадности для этого подвыражения, при этом подвыражения, "
"начинающиеся в RE раньше, имеют больший приоритет, чем следующие за ними."

#: func.xml:5282(para)
msgid ""
"An example of what this means: <screen>SELECT SUBSTRING('XY1234Z', 'Y*([0-9]"
"{1,3})');\n"
"<lineannotation>Result: </lineannotation><computeroutput>123</"
"computeroutput>\n"
"SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');\n"
"<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput></"
"screen> In the first case, the RE as a whole is greedy because <literal>Y*</"
"literal> is greedy. It can match beginning at the <literal>Y</literal>, and "
"it matches the longest possible string starting there, i.e., <literal>Y123</"
"literal>. The output is the parenthesized part of that, or <literal>123</"
"literal>. In the second case, the RE as a whole is non-greedy because "
"<literal>Y*?</literal> is non-greedy. It can match beginning at the "
"<literal>Y</literal>, and it matches the shortest possible string starting "
"there, i.e., <literal>Y1</literal>. The subexpression <literal>[0-9]{1,3}</"
"literal> is greedy but it cannot change the decision as to the overall match "
"length; so it is forced to match just <literal>1</literal>."
msgstr ""
"Это иллюстрирует следующий пример: <screen>SELECT SUBSTRING('XY1234Z', "
"'Y*([0-9]{1,3})');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>123</"
"computeroutput>\n"
"SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>1</"
"computeroutput></screen> В первом случае, RE в целом жадное, так как жадным "
"является атом <literal>Y*</literal>. Соответствие ему начинается с буквы "
"<literal>Y</literal> и оно включает подстроку максимальной длины с этого "
"места, т. е. подстроку <literal>Y123</literal>. Результат выражения &mdash; "
"её часть, соответствующая подвыражению в скобках, т. е. <literal>123</"
"literal>. Во втором случае, RE в целом наследует не жадный характер от атома "
"<literal>Y*?</literal>. Соответствие ему так же начинается с <literal>Y</"
"literal>, но включает оно подстроку минимальной длины с этого места, т. е. "
"<literal>Y1</literal>. И хотя подвыражение <literal>[0-9]{1,3}</literal> "
"имеет жадный характер, оно не может повлиять на выбор длины соответствия в "
"целом, поэтому ему остаётся только подстрока <literal>1</literal>."

#: func.xml:5300(para)
msgid ""
"In short, when an RE contains both greedy and non-greedy subexpressions, the "
"total match length is either as long as possible or as short as possible, "
"according to the attribute assigned to the whole RE. The attributes assigned "
"to the subexpressions only affect how much of that match they are allowed to "
"<quote>eat</quote> relative to each other."
msgstr ""
"Другими словами, когда RE содержит и жадные, и не жадные подвыражения, всё "
"соответствие будет максимально длинным или коротким в зависимости от "
"характеристики всего RE. Характеристики, связанные с подвыражениями, влияют "
"только на то, какую часть подстроки может <quote>поглотить</quote> одно "
"подвыражение относительно другого."

#: func.xml:5308(para)
msgid ""
"The quantifiers <literal>{1,1}</literal> and <literal>{1,1}?</literal> can "
"be used to force greediness or non-greediness, respectively, on a "
"subexpression or a whole RE. This is useful when you need the whole RE to "
"have a greediness attribute different from what's deduced from its elements. "
"As an example, suppose that we are trying to separate a string containing "
"some digits into the digits and the parts before and after them. We might "
"try to do that like this: <screen>SELECT regexp_matches('abc01234xyz', '(.*)"
"(\\d+)(.*)');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</"
"computeroutput></screen> That didn't work: the first <literal>.*</literal> "
"is greedy so it <quote>eats</quote> as much as it can, leaving the <literal>"
"\\d+</literal> to match at the last possible place, the last digit. We might "
"try to fix that by making it non-greedy: <screen>SELECT "
"regexp_matches('abc01234xyz', '(.*?)(\\d+)(.*)');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc,0,\"\"}</"
"computeroutput></screen> That didn't work either, because now the RE as a "
"whole is non-greedy and so it ends the overall match as soon as possible. We "
"can get what we want by forcing the RE as a whole to be greedy: "
"<screen>SELECT regexp_matches('abc01234xyz', '(?:(.*?)(\\d+)(.*)){1,1}');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</"
"computeroutput></screen> Controlling the RE's overall greediness separately "
"from its components' greediness allows great flexibility in handling "
"variable-length patterns."
msgstr ""
"Чтобы явно придать характеристику «жадности» или «нежадности» подвыражению "
"или всему RE, можно использовать определители <literal>{1,1}</literal> и "
"<literal>{1,1}?</literal>, соответственно. Это полезно, когда вам нужно, "
"чтобы общая характеристика жадности RE отличалась от той, что вытекает из "
"его элементов. Например, предположим, что вы пытаетесь выделить из строки, "
"содержащей несколько цифр, эти цифры и части до и после них. Можно "
"попытаться сделать это так: <screen>SELECT regexp_matches('abc01234xyz', '(."
"*)(\\d+)(.*)');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc0123,4,xyz}</"
"computeroutput></screen> Но это не будет работать: первая группа <literal>."
"*</literal> — &laquo;жадная&raquo;, она <quote>съест</quote> всё, что "
"сможет, оставляя для соответствия <literal>\\d+</literal> только последнюю "
"возможность, то есть последнюю цифру. Можно попытаться сделать запрос &laquo;"
"нежадным&raquo;: <screen>SELECT regexp_matches('abc01234xyz', '(.*?)(\\d+)(."
"*)');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc,0,\"\"}</"
"computeroutput></screen> И это не будет работать, так теперь весь RE в целом "
"стал нежадным, и все соответствия завершаются как можно раньше. Но мы можем "
"получить нужный результат, явно сделав жадным всё RE: <screen>SELECT "
"regexp_matches('abc01234xyz', '(?:(.*?)(\\d+)(.*)){1,1}');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc,01234,xyz}</"
"computeroutput></screen> Управление общей характеристикой &laquo;"
"жадности&raquo; RE независимо от &laquo;жадности&raquo; его компонентов даёт "
"большую гибкость в описании шаблонов переменной длины."

#: func.xml:5334(para)
msgid ""
"When deciding what is a longer or shorter match, match lengths are measured "
"in characters, not collating elements. An empty string is considered longer "
"than no match at all. For example: <literal>bb*</literal> matches the three "
"middle characters of <literal>abbbc</literal>; <literal>(week|wee)(night|"
"knights)</literal> matches all ten characters of <literal>weeknights</"
"literal>; when <literal>(.*).*</literal> is matched against <literal>abc</"
"literal> the parenthesized subexpression matches all three characters; and "
"when <literal>(a*)*</literal> is matched against <literal>bc</literal> both "
"the whole RE and the parenthesized subexpression match an empty string."
msgstr ""
"При определении более длинного или более короткого соответствия длины "
"соответствий определяются в символах, а не в элементах сортировки. Пустая "
"строка считается длиннее, чем отсутствие соответствия. Например, выражению "
"<literal>bb*</literal> соответствуют три символа в середине строки "
"<literal>abbbc</literal>, выражению <literal>(week|wee)(night|knights)</"
"literal> &mdash; все десять символов <literal>weeknights</literal>; когда "
"выражение <literal>(.*).*</literal> сопоставляется со строкой <literal>abc</"
"literal>, подвыражению в скобках соответствуют все три символа; а когда "
"<literal>(a*)*</literal> сопоставляется со строкой <literal>bc</literal>, то "
"и RE в целом, и подстроке в скобках соответствует пустая строка."

#: func.xml:5351(para)
msgid ""
"If case-independent matching is specified, the effect is much as if all case "
"distinctions had vanished from the alphabet. When an alphabetic that exists "
"in multiple cases appears as an ordinary character outside a bracket "
"expression, it is effectively transformed into a bracket expression "
"containing both cases, e.g., <literal>x</literal> becomes <literal>[xX]</"
"literal>. When it appears inside a bracket expression, all case counterparts "
"of it are added to the bracket expression, e.g., <literal>[x]</literal> "
"becomes <literal>[xX]</literal> and <literal>[^x]</literal> becomes "
"<literal>[^xX]</literal>."
msgstr ""
"Игнорирование регистра символов даёт практически тот же эффект, как если бы "
"в алфавите исчезли различия прописных и строчных букв. Если буква, "
"существующая и в верхнем, и в нижнем регистре, фигурирует вне квадратных "
"скобок как обычный символ, она по сути преобразуется в выражение в "
"квадратных скобках, содержащее оба варианта, например <literal>x</literal> "
"становится <literal>[xX]</literal>. Если же она фигурирует в выражении в "
"квадратных скобках, в это выражение добавляются все её варианты, например "
"<literal>[x]</literal> становится <literal>[xX]</literal>, а <literal>[^x]</"
"literal> &mdash; <literal>[^xX]</literal>."

#: func.xml:5365(para)
msgid ""
"If newline-sensitive matching is specified, <literal>.</literal> and bracket "
"expressions using <literal>^</literal> will never match the newline "
"character (so that matches will never cross newlines unless the RE "
"explicitly arranges it) and <literal>^</literal> and <literal>$</literal> "
"will match the empty string after and before a newline respectively, in "
"addition to matching at beginning and end of string respectively. But the "
"ARE escapes <literal>\\A</literal> and <literal>\\Z</literal> continue to "
"match beginning or end of string <emphasis>only</emphasis>."
msgstr ""
"Когда включён режим учёта перевода строк, атом <literal>.</literal> и "
"выражения в квадратных скобках с <literal>^</literal> никогда не будут "
"соответствовать символам конца строки (так что соответствия никогда не будут "
"пересекать границы строк, если в RE нет явных указаний на эти символы), а "
"<literal>^</literal> и <literal>$</literal> будут соответствовать пустой "
"подстроке не только в начале и конце всего текста, но и в начале и конце "
"каждой отдельной его строки. Однако спецсимволы ARE <literal>\\A</literal> и "
"<literal>\\Z</literal> по-прежнему будут соответствовать <emphasis>только</"
"emphasis> началу и концу всего текста."

#: func.xml:5379(para)
msgid ""
"If partial newline-sensitive matching is specified, this affects <literal>.</"
"literal> and bracket expressions as with newline-sensitive matching, but not "
"<literal>^</literal> and <literal>$</literal>."
msgstr ""
"В режиме, когда переводы строк учитываются частично, особый смысл перевод "
"строк имеет для атома <literal>.</literal> и выражений в квадратных скобках, "
"но не для <literal>^</literal> и <literal>$</literal>."

#: func.xml:5386(para)
msgid ""
"If inverse partial newline-sensitive matching is specified, this affects "
"<literal>^</literal> and <literal>$</literal> as with newline-sensitive "
"matching, but not <literal>.</literal> and bracket expressions. This isn't "
"very useful but is provided for symmetry."
msgstr ""
"В обратном частичном режиме, перевод строк имеет особый смысл для "
"<literal>^</literal> и <literal>$</literal>, как и в режиме с учётом "
"перевода строк, но не для <literal>.</literal> и выражений в квадратных "
"скобках. Данный режим не очень полезен, но существует для симметрии."

#: func.xml:5396(title)
msgid "Limits and Compatibility"
msgstr "Пределы и совместимость"

#: func.xml:5398(para)
msgid ""
"No particular limit is imposed on the length of REs in this implementation. "
"However, programs intended to be highly portable should not employ REs "
"longer than 256 bytes, as a POSIX-compliant implementation can refuse to "
"accept such REs."
msgstr ""
"В текущей реализации отсутствует какой-либо явно заданный предел длины RE. "
"Однако, разрабатывая программы высокой степени переносимости, не следует "
"применять RE длиннее 256 байт, так как другая POSIX-совместимая реализация "
"может отказаться обрабатывать такие регулярные выражения."

#: func.xml:5406(para)
msgid ""
"The only feature of AREs that is actually incompatible with POSIX EREs is "
"that <literal>\\</literal> does not lose its special significance inside "
"bracket expressions. All other ARE features use syntax which is illegal or "
"has undefined or unspecified effects in POSIX EREs; the <literal>***</"
"literal> syntax of directors likewise is outside the POSIX syntax for both "
"BREs and EREs."
msgstr ""
"Единственная особенность ARE, действительно несовместимая с ERE стандарта "
"POSIX проявляется в том, что в ARE знак <literal>\\</literal> не теряет своё "
"специальное значение в квадратных скобках. Все другие расширения ARE "
"используют синтаксические возможности, которые не определены, не допустимы "
"или не поддерживаются в ERE; синтаксис переключения режимов (<literal>***</"
"literal>) также выходит за рамки синтаксиса POSIX как для BRE, так и для ERE."

#: func.xml:5416(para)
#, fuzzy
msgid ""
"Many of the ARE extensions are borrowed from Perl, but some have been "
"changed to clean them up, and a few Perl extensions are not present. "
"Incompatibilities of note include <literal>\\b</literal>, <literal>\\B</"
"literal>, the lack of special treatment for a trailing newline, the addition "
"of complemented bracket expressions to the things affected by newline-"
"sensitive matching, the restrictions on parentheses and back references in "
"lookahead/lookbehind constraints, and the longest/shortest-match (rather "
"than first-match) matching semantics."
msgstr ""
"Многие расширения ARE заимствованы из языка Perl, но некоторые были "
"изменены, оптимизированы, а некоторые расширения Perl были исключены. В "
"результате имеют место следующие несовместимости: атомы <literal>\\b</"
"literal> и <literal>\\B</literal>, отсутствие специальной обработки "
"завершающего перевода строки, добавление исключений в квадратных скобках в "
"число случаев, когда учитывается перевод строк, особые условия для скобок и "
"ссылок назад в ограничениях предпросмотра и семантика <quote>наиболее "
"длинное/короткое соответствие</quote> (вместо <quote>первое соответствие</"
"quote>)."

#: func.xml:5434(para)
msgid ""
"In AREs, <literal>\\</literal> followed by an alphanumeric character is "
"either an escape or an error, while in previous releases, it was just "
"another way of writing the alphanumeric. This should not be much of a "
"problem because there was no reason to write such a sequence in earlier "
"releases."
msgstr ""
"В ARE <literal>\\</literal> с последующим алфавитно-цифровым символом "
"представляет либо спецсимвол, либо ошибочную последовательность, тогда как в "
"предыдущих версиях так можно было записывать алфавитно-цифровые символы. Это "
"не должно быть большой проблемой, так как раньше не было причин использовать "
"такие последовательности."

#: func.xml:5443(para)
msgid ""
"In AREs, <literal>\\</literal> remains a special character within "
"<literal>[]</literal>, so a literal <literal>\\</literal> within a bracket "
"expression must be written <literal>\\\\</literal>."
msgstr ""
"В ARE знак <literal>\\</literal> сохраняет своё специальное значение в "
"<literal>[]</literal>, поэтому, чтобы передать <literal>\\</literal> в "
"квадратных скобках буквально, его нужно записать как <literal>\\\\</literal>."

#: func.xml:5428(para)
msgid ""
"Two significant incompatibilities exist between AREs and the ERE syntax "
"recognized by pre-7.4 releases of <productname>PostgreSQL</productname>: "
"<placeholder-1/>"
msgstr ""
"Важно отметить две несовместимости синтаксиса ARE и регулярных выражений "
"ERE, которые воспринимал <productname>PostgreSQL</productname> до версии "
"7.4: <placeholder-1/>"

#: func.xml:5454(title)
msgid "Basic Regular Expressions"
msgstr "Простые регулярные выражения"

#: func.xml:5456(para)
msgid ""
"BREs differ from EREs in several respects. In BREs, <literal>|</literal>, "
"<literal>+</literal>, and <literal>?</literal> are ordinary characters and "
"there is no equivalent for their functionality. The delimiters for bounds "
"are <literal>\\{</literal> and <literal>\\}</literal>, with <literal>{</"
"literal> and <literal>}</literal> by themselves ordinary characters. The "
"parentheses for nested subexpressions are <literal>\\(</literal> and "
"<literal>\\)</literal>, with <literal>(</literal> and <literal>)</literal> "
"by themselves ordinary characters. <literal>^</literal> is an ordinary "
"character except at the beginning of the RE or the beginning of a "
"parenthesized subexpression, <literal>$</literal> is an ordinary character "
"except at the end of the RE or the end of a parenthesized subexpression, and "
"<literal>*</literal> is an ordinary character if it appears at the beginning "
"of the RE or the beginning of a parenthesized subexpression (after a "
"possible leading <literal>^</literal>). Finally, single-digit back "
"references are available, and <literal>\\&lt;</literal> and <literal>\\&gt;</"
"literal> are synonyms for <literal>[[:&lt;:]]</literal> and <literal>[[:"
"&gt;:]]</literal> respectively; no other escapes are available in BREs."
msgstr ""
"BRE имеют ряд отличий от ERE. В BRE знаки <literal>|</literal>, <literal>+</"
"literal> и <literal>?</literal> теряют специальное значение, а замены им "
"нет. Границы количества окружаются символами <literal>\\{</literal> и "
"<literal>\\}</literal>, тогда как <literal>{</literal> и <literal>}</"
"literal> рассматриваются как обычные символы. Вложенные подвыражения "
"помещаются между <literal>\\(</literal> и <literal>\\)</literal>, а "
"<literal>(</literal> и <literal>)</literal> представляют обычные символы. "
"Символ <literal>^</literal> воспринимается как обычный, если только он не "
"находится в начале RE или подвыражения в скобках, <literal>$</literal> "
"&mdash; тоже обычный символ, если он находится не в конце RE или в конце "
"подвыражения в скобках, и <literal>*</literal> &mdash; обычный символ, когда "
"он находится в начале RE или подвыражения в скобках (возможно, после "
"начального <literal>^</literal>). И, наконец, в BRE работают ссылки назад с "
"одной цифрой, <literal>\\&lt;</literal> и <literal>\\&gt;</literal> &mdash; "
"синонимы для <literal>[[:&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>, "
"соответственно; никакие другие спецсимволы в BRE не поддерживаются."

#: func.xml:5490(title)
msgid "Data Type Formatting Functions"
msgstr "Функции форматирования данных"

#: func.xml:5492(indexterm)
msgid "<primary>formatting</primary>"
msgstr "<primary>форматирование</primary>"

#: func.xml:5496(para)
msgid ""
"The <productname>PostgreSQL</productname> formatting functions provide a "
"powerful set of tools for converting various data types (date/time, integer, "
"floating point, numeric) to formatted strings and for converting from "
"formatted strings to specific data types. <xref linkend=\"functions-"
"formatting-table\"/> lists them. These functions all follow a common calling "
"convention: the first argument is the value to be formatted and the second "
"argument is a template that defines the output or input format."
msgstr ""
"Функции форматирования в <productname>PostgreSQL</productname> предоставляют "
"богатый набор инструментов для преобразования самых разных типов данных "
"(дата/время, целое, числа с плавающей и фиксированной точкой) в "
"форматированные строки и обратно. Все они перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-table\"/>. Все эти функции следует одному "
"соглашению: в первом аргументе передаётся значение, которое нужно "
"отформатировать, а во втором &mdash; шаблон, определяющий формат ввода или "
"вывода."

#: func.xml:5508(title)
msgid "Formatting Functions"
msgstr "Функции форматирования"

#: func.xml:5521(indexterm)
msgid "<primary>to_char</primary>"
msgstr "<primary>to_char</primary>"

#: func.xml:5524(type) func.xml:6619(type) func.xml:6629(type)
#: func.xml:6701(type) func.xml:6726(type) func.xml:6728(type)
#: func.xml:6750(type) func.xml:6783(type) func.xml:6859(type)
#: func.xml:6951(type)
msgid "timestamp"
msgstr "timestamp"

#: func.xml:5524(function) func.xml:5531(function) func.xml:5537(function)
#: func.xml:5550(function)
msgid "to_char(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_char(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:5527(entry)
msgid "convert time stamp to string"
msgstr "преобразует время в текст"

#: func.xml:5528(literal)
msgid "to_char(current_timestamp, 'HH12:MI:SS')"
msgstr "to_char(current_timestamp, 'HH12:MI:SS')"

#: func.xml:5531(type) func.xml:6621(type) func.xml:6630(type)
#: func.xml:6712(type) func.xml:6736(type) func.xml:6737(type)
#: func.xml:6761(type) func.xml:6791(type) func.xml:6803(type)
#: func.xml:6805(type) func.xml:6816(type) func.xml:6818(type)
#: func.xml:6829(type) func.xml:6831(type) func.xml:6905(type)
#: func.xml:14647(type)
msgid "interval"
msgstr "interval"

#: func.xml:5533(entry)
msgid "convert interval to string"
msgstr "преобразует интервал в текст"

#: func.xml:5534(literal)
msgid "to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')"
msgstr "to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')"

#: func.xml:5539(entry)
msgid "convert integer to string"
msgstr "преобразует целое в текст"

#: func.xml:5540(literal)
msgid "to_char(125, '999')"
msgstr "to_char(125, '999')"

#: func.xml:5543(function)
msgid "to_char"
msgstr "to_char"

#: func.xml:5543(type) func.xml:6703(type) func.xml:6713(type)
#: func.xml:6752(type) func.xml:6762(type) func.xml:6901(type)
#: func.xml:6923(type) func.xml:6947(type) func.xml:6971(type)
#: func.xml:7051(type) func.xml:8255(type) func.xml:8267(type)
#: func.xml:8273(type) func.xml:8291(type) func.xml:8330(type)
#: func.xml:8336(type) func.xml:8403(type) func.xml:8453(type)
#: func.xml:8454(type) func.xml:12925(type) func.xml:12928(type)
#: func.xml:12945(type) func.xml:12948(type) func.xml:12965(type)
#: func.xml:12968(type) func.xml:12982(type) func.xml:12985(type)
#: func.xml:13000(type) func.xml:13003(type) func.xml:13018(type)
#: func.xml:13038(type) func.xml:13041(type) func.xml:13058(type)
#: func.xml:13061(type) func.xml:13078(type) func.xml:13081(type)
#: func.xml:13097(type) func.xml:13100(type) func.xml:13118(type)
#: func.xml:13121(type) func.xml:13142(type) func.xml:13145(type)
#: func.xml:13357(type) func.xml:13402(type) func.xml:13540(type)
#: func.xml:13562(type) func.xml:13741(type) func.xml:13754(type)
msgid "double precision"
msgstr "double precision"

#: func.xml:5543(literal) func.xml:8453(literal) func.xml:11843(literal)
#: func.xml:11854(literal) func.xml:11900(literal) func.xml:11911(literal)
#: func.xml:11935(literal) func.xml:11948(literal) func.xml:11959(literal)
#: func.xml:11994(literal) func.xml:12409(literal) func.xml:15260(literal)
#: func.xml:15292(literal) func.xml:15307(literal) func.xml:15322(literal)
#: func.xml:15337(literal) func.xml:15352(literal) func.xml:15367(literal)
#: func.xml:15382(literal) func.xml:15397(literal) func.xml:15412(literal)
#: func.xml:15427(literal)
msgctxt "literal"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"

#: func.xml:5546(entry)
msgid "convert real/double precision to string"
msgstr "преобразует плавающее одинарной/двойной точности в текст"

#: func.xml:5547(literal)
msgid "to_char(125.8::real, '999D9')"
msgstr "to_char(125.8::real, '999D9')"

#: func.xml:5552(entry)
msgid "convert numeric to string"
msgstr "преобразует числовое значение в текст"

#: func.xml:5553(literal)
msgid "to_char(-125.8, '999D99S')"
msgstr "to_char(-125.8, '999D99S')"

#: func.xml:5557(indexterm)
msgid "<primary>to_date</primary>"
msgstr "<primary>to_date</primary>"

#: func.xml:5560(function)
msgid "to_date(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_date(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:5562(type) func.xml:6658(type) func.xml:6774(type)
#: func.xml:6880(type)
msgid "date"
msgstr "date"

#: func.xml:5563(entry)
msgid "convert string to date"
msgstr "преобразует текст в дату"

#: func.xml:5564(literal)
msgid "to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"
msgstr "to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"

#: func.xml:5568(indexterm)
msgid "<primary>to_number</primary>"
msgstr "<primary>to_number</primary>"

#: func.xml:5571(function)
msgid "to_number(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_number(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:5574(entry)
msgid "convert string to numeric"
msgstr "преобразует текст в число"

#: func.xml:5575(literal)
msgid "to_number('12,454.8-', '99G999D9S')"
msgstr "to_number('12,454.8-', '99G999D9S')"

#: func.xml:5579(indexterm) func.xml:7048(indexterm)
msgid "<primary>to_timestamp</primary>"
msgstr "<primary>to_timestamp</primary>"

#: func.xml:5582(function)
msgid "to_timestamp(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_timestamp(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:5584(type) func.xml:6643(type) func.xml:6688(type)
#: func.xml:6976(type) func.xml:6993(type) func.xml:7008(type)
#: func.xml:7039(type) func.xml:7053(type) func.xml:7653(type)
#: func.xml:7659(type) func.xml:14954(type) func.xml:14984(type)
#: func.xml:16617(type) func.xml:16809(type) func.xml:16850(type)
#: func.xml:17322(type) func.xml:17540(type)
msgid "timestamp with time zone"
msgstr "timestamp with time zone"

#: func.xml:5585(entry)
msgid "convert string to time stamp"
msgstr "преобразует строку во время"

#: func.xml:5586(literal)
msgid "to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"
msgstr "to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"

#: func.xml:5593(para)
#, fuzzy
msgid ""
"There is also a single-argument <function>to_timestamp</function> function; "
"see <xref linkend=\"functions-datetime-table\"/>."
msgstr ""
"Возвращает поле даты (равнозначно <function>extract</function>); см. <xref "
"remap=\"4\" linkend=\"functions-datetime-extract\"/>"

#: func.xml:5599(para)
msgid ""
"In a <function>to_char</function> output template string, there are certain "
"patterns that are recognized and replaced with appropriately-formatted data "
"based on the given value. Any text that is not a template pattern is simply "
"copied verbatim. Similarly, in an input template string (for the other "
"functions), template patterns identify the values to be supplied by the "
"input data string."
msgstr ""
"Шаблон вывода <function>to_char</function> может содержать ряд кодов, "
"которые распознаются при форматировании и заменяются соответствующими "
"данными. Любой текст, который не является кодом, копируется в результат в "
"неизменном виде. Подобным образом, в строке шаблона ввода (для других "
"функций) коды шаблона определяют, какие значения содержит передаваемая "
"текстовая строка."

#: func.xml:5608(para)
msgid ""
"<xref linkend=\"functions-formatting-datetime-table\"/> shows the template "
"patterns available for formatting date and time values."
msgstr ""
"Все коды форматирования даты и времени перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-datetime-table\"/>."

#: func.xml:5614(title)
msgid "Template Patterns for Date/Time Formatting"
msgstr "Коды форматирования даты/времени"

#: func.xml:5618(entry) func.xml:6096(entry)
msgid "Pattern"
msgstr "Код"

#: func.xml:5624(literal)
msgid "HH"
msgstr "HH"

#: func.xml:5625(entry) func.xml:5629(entry)
msgid "hour of day (01-12)"
msgstr "час (01-12)"

#: func.xml:5628(literal)
msgid "HH12"
msgstr "HH12"

#: func.xml:5632(literal)
msgid "HH24"
msgstr "HH24"

#: func.xml:5633(entry)
msgid "hour of day (00-23)"
msgstr "час (00-23)"

#: func.xml:5636(literal) func.xml:6138(literal)
msgid "MI"
msgstr "MI"

#: func.xml:5637(entry)
msgid "minute (00-59)"
msgstr "минута (00-59)"

#: func.xml:5640(literal)
msgid "SS"
msgstr "SS"

#: func.xml:5641(entry)
msgid "second (00-59)"
msgstr "секунда (00-59)"

#: func.xml:5644(literal)
msgid "MS"
msgstr "MS"

#: func.xml:5645(entry)
msgid "millisecond (000-999)"
msgstr "миллисекунда (000-999)"

#: func.xml:5648(literal)
msgid "US"
msgstr "US"

#: func.xml:5649(entry)
msgid "microsecond (000000-999999)"
msgstr "микросекунда (000000-999999)"

#: func.xml:5652(literal)
msgid "SSSS"
msgstr "SSSS"

#: func.xml:5653(entry)
msgid "seconds past midnight (0-86399)"
msgstr "число секунд с начала суток (0-86399)"

#: func.xml:5656(entry)
msgid ""
"<literal>AM</literal>, <literal>am</literal>, <literal>PM</literal> or "
"<literal>pm</literal>"
msgstr ""
"<literal>AM</literal>, <literal>am</literal>, <literal>PM</literal> или "
"<literal>pm</literal>"

#: func.xml:5658(entry)
msgid "meridiem indicator (without periods)"
msgstr "обозначение времени до/после полудня (без точек)"

#: func.xml:5661(entry)
msgid ""
"<literal>A.M.</literal>, <literal>a.m.</literal>, <literal>P.M.</literal> or "
"<literal>p.m.</literal>"
msgstr ""
"<literal>A.M.</literal>, <literal>a.m.</literal>, <literal>P.M.</literal> "
"или <literal>p.m.</literal>"

#: func.xml:5663(entry)
msgid "meridiem indicator (with periods)"
msgstr "обозначение времени до/после полудня (с точками)"

#: func.xml:5666(literal)
msgid "Y,YYY"
msgstr "Y,YYY"

#: func.xml:5667(entry)
msgid "year (4 or more digits) with comma"
msgstr "год (4 или более цифр) с разделителем"

#: func.xml:5670(literal)
msgid "YYYY"
msgstr "YYYY"

#: func.xml:5671(entry)
msgid "year (4 or more digits)"
msgstr "год (4 или более цифр)"

#: func.xml:5674(literal)
msgid "YYY"
msgstr "YYY"

#: func.xml:5675(entry)
msgid "last 3 digits of year"
msgstr "последние 3 цифры года"

#: func.xml:5678(literal)
msgid "YY"
msgstr "YY"

#: func.xml:5679(entry)
msgid "last 2 digits of year"
msgstr "последние 2 цифры года"

#: func.xml:5682(literal)
msgctxt "literal"
msgid "Y"
msgstr "Y"

#: func.xml:5683(entry)
msgid "last digit of year"
msgstr "последняя цифра года"

#: func.xml:5686(literal)
msgid "IYYY"
msgstr "IYYY"

#: func.xml:5687(entry)
msgid "ISO 8601 week-numbering year (4 or more digits)"
msgstr "недельный год по ISO 8601 (4 или более цифр)"

#: func.xml:5690(literal)
msgid "IYY"
msgstr "IYY"

#: func.xml:5691(entry)
msgid "last 3 digits of ISO 8601 week-numbering year"
msgstr "последние 3 цифры недельного года по ISO 8601"

#: func.xml:5694(literal)
msgid "IY"
msgstr "IY"

#: func.xml:5695(entry)
msgid "last 2 digits of ISO 8601 week-numbering year"
msgstr "последние 2 цифры недельного года по ISO 8601"

#: func.xml:5698(literal)
msgid "I"
msgstr "I"

#: func.xml:5699(entry)
msgid "last digit of ISO 8601 week-numbering year"
msgstr "последняя цифра недельного года по ISO 8601"

#: func.xml:5702(entry)
msgid ""
"<literal>BC</literal>, <literal>bc</literal>, <literal>AD</literal> or "
"<literal>ad</literal>"
msgstr ""
"<literal>BC</literal>, <literal>bc</literal>, <literal>AD</literal> или "
"<literal>ad</literal>"

#: func.xml:5704(entry)
msgid "era indicator (without periods)"
msgstr "обозначение эры (без точек)"

#: func.xml:5707(entry)
msgid ""
"<literal>B.C.</literal>, <literal>b.c.</literal>, <literal>A.D.</literal> or "
"<literal>a.d.</literal>"
msgstr ""
"<literal>B.C.</literal>, <literal>b.c.</literal>, <literal>A.D.</literal> "
"или <literal>a.d.</literal>"

#: func.xml:5709(entry)
msgid "era indicator (with periods)"
msgstr "обозначение эры (с точками)"

#: func.xml:5712(literal)
msgid "MONTH"
msgstr "MONTH"

#: func.xml:5713(entry)
msgid "full upper case month name (blank-padded to 9 chars)"
msgstr ""
"полное название месяца в верхнем регистре (дополненное пробелами до 9 "
"символов)"

#: func.xml:5716(literal)
msgid "Month"
msgstr "Month"

#: func.xml:5717(entry)
msgid "full capitalized month name (blank-padded to 9 chars)"
msgstr ""
"полное название месяца с большой буквы (дополненное пробелами до 9 символов)"

#: func.xml:5720(literal) func.xml:7409(literal) func.xml:7600(literal)
msgctxt "literal"
msgid "month"
msgstr "month"

#: func.xml:5721(entry)
msgid "full lower case month name (blank-padded to 9 chars)"
msgstr ""
"полное название месяца в нижнем регистре (дополненное пробелами до 9 "
"символов)"

#: func.xml:5724(literal)
msgid "MON"
msgstr "MON"

#: func.xml:5725(entry)
msgid ""
"abbreviated upper case month name (3 chars in English, localized lengths "
"vary)"
msgstr ""
"сокращённое название месяца в верхнем регистре (3 буквы в английском; в "
"других языках длина может меняться)"

#: func.xml:5728(literal)
msgid "Mon"
msgstr "Mon"

#: func.xml:5729(entry)
msgid ""
"abbreviated capitalized month name (3 chars in English, localized lengths "
"vary)"
msgstr ""
"сокращённое название месяца с большой буквы (3 буквы в английском; в других "
"языках длина может меняться)"

#: func.xml:5732(literal)
msgid "mon"
msgstr "mon"

#: func.xml:5733(entry)
msgid ""
"abbreviated lower case month name (3 chars in English, localized lengths "
"vary)"
msgstr ""
"сокращённое название месяца в нижнем регистре (3 буквы в английском; в "
"других языках длина может меняться)"

#: func.xml:5736(literal)
msgid "MM"
msgstr "MM"

#: func.xml:5737(entry)
msgid "month number (01-12)"
msgstr "номер месяца (01-12)"

#: func.xml:5740(literal)
msgid "DAY"
msgstr "DAY"

#: func.xml:5741(entry)
msgid "full upper case day name (blank-padded to 9 chars)"
msgstr ""
"полное название дня недели в верхнем регистре (дополненное пробелами до 9 "
"символов)"

#: func.xml:5744(literal)
msgid "Day"
msgstr "Day"

#: func.xml:5745(entry)
msgid "full capitalized day name (blank-padded to 9 chars)"
msgstr ""
"полное название дня недели с большой буквы (дополненное пробелами до 9 "
"символов)"

#: func.xml:5748(literal) func.xml:7209(literal) func.xml:7598(literal)
msgctxt "literal"
msgid "day"
msgstr "day"

#: func.xml:5749(entry)
msgid "full lower case day name (blank-padded to 9 chars)"
msgstr ""
"полное название дня недели в нижнем регистре (дополненное пробелами до 9 "
"символов)"

#: func.xml:5752(literal)
msgid "DY"
msgstr "DY"

#: func.xml:5753(entry)
msgid ""
"abbreviated upper case day name (3 chars in English, localized lengths vary)"
msgstr ""
"сокращённое название дня недели в верхнем регистре (3 буквы в английском; в "
"других языках может меняться)"

#: func.xml:5756(literal)
msgid "Dy"
msgstr "Dy"

#: func.xml:5757(entry)
msgid ""
"abbreviated capitalized day name (3 chars in English, localized lengths vary)"
msgstr ""
"сокращённое название дня недели с большой буквы (3 буквы в английском; в "
"других языках длина может меняться)"

#: func.xml:5760(literal)
msgid "dy"
msgstr "dy"

#: func.xml:5761(entry)
msgid ""
"abbreviated lower case day name (3 chars in English, localized lengths vary)"
msgstr ""
"сокращённое название дня недели в нижнем регистре (3 буквы в английском; в "
"других языках длина может меняться)"

#: func.xml:5764(literal)
msgid "DDD"
msgstr "DDD"

#: func.xml:5765(entry)
msgid "day of year (001-366)"
msgstr "номер дня в году (001-366)"

#: func.xml:5768(literal)
msgid "IDDD"
msgstr "IDDD"

#: func.xml:5769(entry)
msgid ""
"day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of "
"the first ISO week)"
msgstr ""
"номер дня в году по ISO 8601 (001-371; 1 день &mdash; понедельник первой "
"недели по ISO)"

#: func.xml:5772(literal)
msgid "DD"
msgstr "DD"

#: func.xml:5773(entry)
msgid "day of month (01-31)"
msgstr "день месяца (01-31)"

#: func.xml:5776(literal) func.xml:6130(literal)
msgid "D"
msgstr "D"

#: func.xml:5777(entry)
msgid ""
"day of the week, Sunday (<literal>1</literal>) to Saturday (<literal>7</"
"literal>)"
msgstr ""
"номер дня недели, считая с воскресенья (<literal>1</literal>) до субботы "
"(<literal>7</literal>)"

#: func.xml:5780(literal)
msgid "ID"
msgstr "ID"

#: func.xml:5781(entry)
msgid ""
"ISO 8601 day of the week, Monday (<literal>1</literal>) to Sunday "
"(<literal>7</literal>)"
msgstr ""
"номер дня недели по ISO 8601, считая с понедельника (<literal>1</literal>) "
"до воскресенья (<literal>7</literal>)"

#: func.xml:5784(literal)
msgid "W"
msgstr "W"

#: func.xml:5785(entry)
msgid ""
"week of month (1-5) (the first week starts on the first day of the month)"
msgstr "неделя месяца (1-5) (первая неделя начинается в первое число месяца)"

#: func.xml:5788(literal)
msgid "WW"
msgstr "WW"

#: func.xml:5789(entry)
msgid ""
"week number of year (1-53) (the first week starts on the first day of the "
"year)"
msgstr ""
"номер недели в году (1-53) (первая неделя начинается в первый день года)"

#: func.xml:5792(literal)
msgid "IW"
msgstr "IW"

#: func.xml:5793(entry)
msgid ""
"week number of ISO 8601 week-numbering year (01-53; the first Thursday of "
"the year is in week 1)"
msgstr ""
"номер недели в году по ISO 8601 (01-53; первый четверг года относится к "
"неделе 1)"

#: func.xml:5796(literal)
msgid "CC"
msgstr "CC"

#: func.xml:5797(entry)
msgid "century (2 digits) (the twenty-first century starts on 2001-01-01)"
msgstr "век (2 цифры) (двадцать первый век начался 2001-01-01)"

#: func.xml:5800(literal)
msgid "J"
msgstr "J"

#: func.xml:5801(entry)
msgid "Julian Day (integer days since November 24, 4714 BC at midnight UTC)"
msgstr "День по юлианскому календарю (номер дня с 24 ноября 4714 г. до н. э.)"

#: func.xml:5804(literal)
msgid "Q"
msgstr "Q"

#: func.xml:5805(entry)
msgid ""
"quarter (ignored by <function>to_date</function> and <function>to_timestamp</"
"function>)"
msgstr ""
"квартал (игнорируется функциями <function>to_date</function> и "
"<function>to_timestamp</function>)"

#: func.xml:5808(literal)
msgid "RM"
msgstr "RM"

#: func.xml:5809(entry)
msgid "month in upper case Roman numerals (I-XII; I=January)"
msgstr "номер месяца римскими цифрами в верхнем регистре (I-XII; I=январь)"

#: func.xml:5812(literal)
msgid "rm"
msgstr "rm"

#: func.xml:5813(entry)
msgid "month in lower case Roman numerals (i-xii; i=January)"
msgstr "номер месяца римскими цифрами в нижнем регистре (i-xii; i=январь)"

#: func.xml:5816(literal)
msgid "TZ"
msgstr "TZ"

#: func.xml:5817(entry)
msgid "upper case time-zone name"
msgstr "название часового пояса в верхнем регистре"

#: func.xml:5820(literal)
msgid "tz"
msgstr "tz"

#: func.xml:5821(entry)
msgid "lower case time-zone name"
msgstr "название часового пояса в нижнем регистре"

#: func.xml:5824(literal)
msgid "OF"
msgstr "OF"

#: func.xml:5825(entry)
msgid "time-zone offset"
msgstr "смещение часового пояса"

#: func.xml:5831(para)
msgid ""
"Modifiers can be applied to any template pattern to alter its behavior. For "
"example, <literal>FMMonth</literal> is the <literal>Month</literal> pattern "
"with the <literal>FM</literal> modifier. <xref linkend=\"functions-"
"formatting-datetimemod-table\"/> shows the modifier patterns for date/time "
"formatting."
msgstr ""
"К любым кодам форматирования можно добавить модификаторы, изменяющие их "
"поведение. Например, шаблон форматирования <literal>FMMonth</literal> "
"включает код <literal>Month</literal> с модификатором <literal>FM</literal>. "
"Модификаторы, предназначенные для форматирования даты/времени, перечислены в "
"<xref remap=\"6\" linkend=\"functions-formatting-datetimemod-table\"/>."

#: func.xml:5841(title)
msgid "Template Pattern Modifiers for Date/Time Formatting"
msgstr "Модификаторы кодов для форматирования даты/времени"

#: func.xml:5845(entry) func.xml:6250(entry)
msgid "Modifier"
msgstr "Модификатор"

#: func.xml:5852(entry) func.xml:6257(entry)
msgid "<literal>FM</literal> prefix"
msgstr "Приставка <literal>FM</literal>"

#: func.xml:5853(entry) func.xml:6258(entry)
msgid "fill mode (suppress leading zeroes and padding blanks)"
msgstr "режим заполнения (подавляет ведущие нули и дополнение пробелами)"

#: func.xml:5854(literal)
msgid "FMMonth"
msgstr "FMMonth"

#: func.xml:5857(entry) func.xml:6262(entry)
msgid "<literal>TH</literal> suffix"
msgstr "Окончание <literal>TH</literal>"

#: func.xml:5858(entry) func.xml:6263(entry)
msgid "upper case ordinal number suffix"
msgstr "окончание порядкового числительного в верхнем регистре"

#: func.xml:5859(entry)
msgid "<literal>DDTH</literal>, e.g., <literal>12TH</literal>"
msgstr "<literal>DDTH</literal>, например <literal>12TH</literal>"

#: func.xml:5862(entry) func.xml:6267(entry)
msgid "<literal>th</literal> suffix"
msgstr "Окончание <literal>th</literal>"

#: func.xml:5863(entry) func.xml:6268(entry)
msgid "lower case ordinal number suffix"
msgstr "окончание порядкового числительного в нижнем регистре"

#: func.xml:5864(entry)
msgid "<literal>DDth</literal>, e.g., <literal>12th</literal>"
msgstr "<literal>DDth</literal>, например <literal>12th</literal>"

#: func.xml:5867(entry)
msgid "<literal>FX</literal> prefix"
msgstr "Приставка <literal>FX</literal>"

#: func.xml:5868(entry)
msgid "fixed format global option (see usage notes)"
msgstr "глобальный параметр фиксированного формата (см. замечания)"

#: func.xml:5869(literal)
msgid "FX&nbsp;Month&nbsp;DD&nbsp;Day"
msgstr "FX&nbsp;Month&nbsp;DD&nbsp;Day"

#: func.xml:5872(entry)
msgid "<literal>TM</literal> prefix"
msgstr "Приставка <literal>TM</literal>"

#: func.xml:5873(entry)
msgid ""
"translation mode (print localized day and month names based on <xref linkend="
"\"guc-lc-time\"/>)"
msgstr ""
"режим перевода (выводятся локализованные названия дней и месяцев, исходя из "
"<xref linkend=\"guc-lc-time\"/>)"

#: func.xml:5875(literal)
msgid "TMMonth"
msgstr "TMMonth"

#: func.xml:5878(entry)
msgid "<literal>SP</literal> suffix"
msgstr "Окончание <literal>SP</literal>"

#: func.xml:5879(entry)
msgid "spell mode (not implemented)"
msgstr "режим числа прописью (не реализован)"

#: func.xml:5880(literal)
msgid "DDSP"
msgstr "DDSP"

#: func.xml:5891(para)
msgid ""
"<literal>FM</literal> suppresses leading zeroes and trailing blanks that "
"would otherwise be added to make the output of a pattern be fixed-width. In "
"<productname>PostgreSQL</productname>, <literal>FM</literal> modifies only "
"the next specification, while in Oracle <literal>FM</literal> affects all "
"subsequent specifications, and repeated <literal>FM</literal> modifiers "
"toggle fill mode on and off."
msgstr ""
"<literal>FM</literal> подавляет дополняющие пробелы и нули справа, которые в "
"противном случае будут добавлены, чтобы результат имел фиксированную ширину. "
"В <productname>PostgreSQL</productname> модификатор <literal>FM</literal> "
"действует только на следующий код, тогда как в Oracle <literal>FM</literal> "
"её действие распространяется на все последующие коды, пока не будет "
"отключено последующим модификатором <literal>FM</literal>."

#: func.xml:5903(para)
msgid ""
"<literal>TM</literal> does not include trailing blanks. "
"<function>to_timestamp</function> and <function>to_date</function> ignore "
"the <literal>TM</literal> modifier."
msgstr ""
"<literal>TM</literal> не затрагивает замыкающие пробелы. Функции "
"<function>to_timestamp</function> и <function>to_date</function> игнорируют "
"указание <literal>TM</literal>."

#: func.xml:5911(para)
msgid ""
"<function>to_timestamp</function> and <function>to_date</function> skip "
"multiple blank spaces in the input string unless the <literal>FX</literal> "
"option is used. For example, <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;"
"&nbsp;JUN', 'YYYY MON')</literal> works, but "
"<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</"
"literal> returns an error because <function>to_timestamp</function> expects "
"one space only. <literal>FX</literal> must be specified as the first item in "
"the template."
msgstr ""
"<function>to_timestamp</function> и <function>to_date</function> пропускают "
"повторяющиеся пробелы во входной строке, если только не используется "
"параметр <literal>FX</literal>. Например, <literal>to_timestamp('2000&nbsp;"
"&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> будет работать, но "
"<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</"
"literal> вернёт ошибку, так как <function>to_timestamp</function> в данном "
"случае ожидает только один разделяющий пробел. Приставка <literal>FX</"
"literal> должна быть первой в шаблоне."

#: func.xml:5924(para)
msgid ""
"<function>to_timestamp</function> and <function>to_date</function> exist to "
"handle input formats that cannot be converted by simple casting. These "
"functions interpret input liberally, with minimal error checking. While they "
"produce valid output, the conversion can yield unexpected results. For "
"example, input to these functions is not restricted by normal ranges, thus "
"<literal>to_date('20096040','YYYYMMDD')</literal> returns "
"<literal>2014-01-17</literal> rather than causing an error. Casting does not "
"have this behavior."
msgstr ""
"<function>to_timestamp</function> и <function>to_date</function> "
"предназначены для обработки входных форматов, для которых недостаточно "
"простого приведения. Эти функции интерпретируют вводимые данные с "
"послаблениями, проверяя только грубые ошибки. Хотя они выдают корректные "
"данные, результат может отличаться от ожидаемого. В частности, входные "
"аргументы этих функций не ограничиваются обычными диапазонами, так что "
"<literal>to_date('20096040','YYYYMMDD')</literal> выдаёт "
"<literal>2014-01-17</literal>, а не ошибку. С приведением такого не "
"происходит."

#: func.xml:5938(para)
msgid ""
"Ordinary text is allowed in <function>to_char</function> templates and will "
"be output literally. You can put a substring in double quotes to force it to "
"be interpreted as literal text even if it contains pattern key words. For "
"example, in <literal>'\"Hello Year \"YYYY'</literal>, the <literal>YYYY</"
"literal> will be replaced by the year data, but the single <literal>Y</"
"literal> in <literal>Year</literal> will not be. In <function>to_date</"
"function>, <function>to_number</function>, and <function>to_timestamp</"
"function>, double-quoted strings skip the number of input characters "
"contained in the string, e.g. <literal>\"XX\"</literal> skips two input "
"characters."
msgstr ""
"Шаблоны для функций <function>to_char</function> могут содержать обычный "
"текст; он будет выведен в неизменном виде. Чтобы вывести текст "
"принудительно, например, если в нём оказываются поддерживаемые коды, его "
"можно заключить в кавычки. Например, в строке <literal>'\"Hello Year "
"\"YYYY'</literal>, код <literal>YYYY</literal> будет заменён номером года, а "
"буква <literal>Y</literal> в слове <literal>Year</literal> останется "
"неизменной. В функциях <function>to_date</function>, <function>to_number</"
"function> и <function>to_timestamp</function> при обработке подстроки в "
"кавычках просто пропускаются символы входной строки по числу символов в "
"подстроке, например для <literal>\"XX\"</literal> будут пропущены два "
"символа."

#: func.xml:5953(para)
msgid ""
"If you want to have a double quote in the output you must precede it with a "
"backslash, for example <literal>'\\\"YYYY Month\\\"'</literal>."
msgstr ""
"Если вы хотите получить в результате кавычки, перед ними нужно добавить "
"обратную косую черту, например так: <literal>'\\\"YYYY Month\\\"'</literal>."

#: func.xml:5961(para)
msgid ""
"If the year format specification is less than four digits, e.g. "
"<literal>YYY</literal>, and the supplied year is less than four digits, the "
"year will be adjusted to be nearest to the year 2020, e.g. <literal>95</"
"literal> becomes 1995."
msgstr ""
"Если формат года определяется менее, чем 4 цифрами, например, как "
"<literal>YYY</literal>, и в переданном значении года тоже меньше 4 цифр, год "
"пересчитывается в максимально близкий к году 2020, т. е. <literal>95</"
"literal> воспринимается как 1995."

#: func.xml:5970(para)
msgid ""
"The <literal>YYYY</literal> conversion from string to <type>timestamp</type> "
"or <type>date</type> has a restriction when processing years with more than "
"4 digits. You must use some non-digit character or template after "
"<literal>YYYY</literal>, otherwise the year is always interpreted as 4 "
"digits. For example (with the year 20000): <literal>to_date('200001131', "
"'YYYYMMDD')</literal> will be interpreted as a 4-digit year; instead use a "
"non-digit separator after the year, like <literal>to_date('20000-1131', "
"'YYYY-MMDD')</literal> or <literal>to_date('20000Nov31', 'YYYYMonDD')</"
"literal>."
msgstr ""
"С преобразованием <literal>YYYY</literal> из строки в тип <type>timestamp</"
"type> или <type>date</type> связано ограничение, когда обрабатываемый год "
"записывается более чем 4 цифрами. После <literal>YYYY</literal> необходимо "
"будет добавить не цифровой символ или соответствующий код, иначе год всегда "
"будет восприниматься как 4 цифры. Например, в <literal>to_date('200001131', "
"'YYYYMMDD')</literal> (с годом 20000) год будет интерпретирован как "
"состоящий из 4 цифр; чтобы исправить ситуацию, нужно добавить не цифровой "
"разделитель после года, как в <literal>to_date('20000-1131', 'YYYY-MMDD')</"
"literal>, или код как в <literal>to_date('20000Nov31', 'YYYYMonDD')</"
"literal>."

#: func.xml:5985(para)
msgid ""
"In conversions from string to <type>timestamp</type> or <type>date</type>, "
"the <literal>CC</literal> (century) field is ignored if there is a "
"<literal>YYY</literal>, <literal>YYYY</literal> or <literal>Y,YYY</literal> "
"field. If <literal>CC</literal> is used with <literal>YY</literal> or "
"<literal>Y</literal> then the year is computed as the year in the specified "
"century. If the century is specified but the year is not, the first year of "
"the century is assumed."
msgstr ""
"В преобразованиях из строки в тип <type>timestamp</type> или <type>date</"
"type>, поле <literal>CC</literal> (век) игнорируется, если шаблон включает "
"поля <literal>YYY</literal>, <literal>YYYY</literal> или <literal>Y,YYY</"
"literal>. Когда <literal>CC</literal> используется с <literal>YY</literal> "
"или <literal>Y</literal>, год вычисляется как год данного столетия. Если "
"присутствует только код столетия, без года, подразумевается первый год этого "
"века."

#: func.xml:6004(para)
msgid ""
"Year, week number, and weekday: for example <literal>to_date('2006-42-4', "
"'IYYY-IW-ID')</literal> returns the date <literal>2006-10-19</literal>. If "
"you omit the weekday it is assumed to be 1 (Monday)."
msgstr ""
"Год, номер недели и дня недели: например, <literal>to_date('2006-42-4', "
"'IYYY-IW-ID')</literal> возвращает дату <literal>2006-10-19</literal>. Если "
"день недели опускается, он считается равным 1 (понедельнику)."

#: func.xml:6012(para)
msgid ""
"Year and day of year: for example <literal>to_date('2006-291', 'IYYY-IDDD')</"
"literal> also returns <literal>2006-10-19</literal>."
msgstr ""
"Год и день года: например, <literal>to_date('2006-291', 'IYYY-IDDD')</"
"literal> также возвращает <literal>2006-10-19</literal>."

#: func.xml:5998(para)
msgid ""
"An ISO 8601 week-numbering date (as distinct from a Gregorian date) can be "
"specified to <function>to_timestamp</function> and <function>to_date</"
"function> in one of two ways: <placeholder-1/>"
msgstr ""
"Даты по недельному календарю ISO 8601 (отличающиеся от григорианских) можно "
"передать функциям <function>to_timestamp</function> и <function>to_date</"
"function> одним из двух способов: <placeholder-1/>"

#: func.xml:6019(para)
msgid ""
"Attempting to enter a date using a mixture of ISO 8601 week-numbering fields "
"and Gregorian date fields is nonsensical, and will cause an error. In the "
"context of an ISO 8601 week-numbering year, the concept of a <quote>month</"
"quote> or <quote>day of month</quote> has no meaning. In the context of a "
"Gregorian year, the ISO week has no meaning."
msgstr ""
"Попытка ввести дату из смеси полей григорианского и недельного календаря ISO "
"8601 бессмысленна, поэтому это будет считаться ошибкой. В контексте ISO 8601 "
"понятия <quote>номер месяца</quote> и <quote>день месяца</quote> не "
"существуют, а в григорианском календаре нет понятия номера недели по ISO."

#: func.xml:6028(para)
msgid ""
"While <function>to_date</function> will reject a mixture of Gregorian and "
"ISO week-numbering date fields, <function>to_char</function> will not, since "
"output format specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</literal> "
"can be useful. But avoid writing something like <literal>IYYY-MM-DD</"
"literal>; that would yield surprising results near the start of the year. "
"(See <xref linkend=\"functions-datetime-extract\"/> for more information.)"
msgstr ""
"Тогда как <function>to_date</function> не примет смесь полей григорианского "
"и недельного календаря ISO, <function>to_char</function> способна на это, "
"так как форматы вроде <literal>YYYY-MM-DD (IYYY-IDDD)</literal> могут быть "
"полезны. Но избегайте форматов типа <literal>IYYY-MM-DD</literal>; в "
"противном случае с датами в начале года возможны сюрпризы. (За "
"дополнительными сведениями обратитесь к <xref remap=\"3\" linkend="
"\"functions-datetime-extract\"/>.)"

#: func.xml:6042(para)
msgid ""
"In a conversion from string to <type>timestamp</type>, millisecond "
"(<literal>MS</literal>) or microsecond (<literal>US</literal>) values are "
"used as the seconds digits after the decimal point. For example "
"<literal>to_timestamp('12:3', 'SS:MS')</literal> is not 3 milliseconds, but "
"300, because the conversion counts it as 12 + 0.3 seconds. This means for "
"the format <literal>SS:MS</literal>, the input values <literal>12:3</"
"literal>, <literal>12:30</literal>, and <literal>12:300</literal> specify "
"the same number of milliseconds. To get three milliseconds, one must use "
"<literal>12:003</literal>, which the conversion counts as 12 + 0.003 = "
"12.003 seconds."
msgstr ""
"При преобразовании из текстовой строки в <type>timestamp</type>, "
"миллисекунды (<literal>MS</literal>) или микросекунды (<literal>US</"
"literal>) воспринимаются как дробная часть числа секунд. Например, "
"<literal>to_timestamp('12:3', 'SS:MS')</literal> &mdash; это не 3 "
"миллисекунды, а 300, так как это значение воспринимается как 12 + 0.3 сек. "
"Это значит, что для формата <literal>SS:MS</literal> вводимые значения "
"<literal>12:3</literal>, <literal>12:30</literal> и <literal>12:300</"
"literal> задают одно и то же число миллисекунд. Чтобы получить три "
"миллисекунды, время нужно записать в виде <literal>12:003</literal>, тогда "
"это будет воспринято как 12 + 0.003 = 12.003 сек."

#: func.xml:6056(para)
msgid ""
"Here is a more complex example: <literal>to_timestamp('15:12:02.020.001230', "
"'HH:MI:SS.MS.US')</literal> is 15 hours, 12 minutes, and 2 seconds + 20 "
"milliseconds + 1230 microseconds = 2.021230 seconds."
msgstr ""
"Ещё более сложный пример: <literal>to_timestamp('15:12:02.020.001230', 'HH:"
"MI:SS.MS.US')</literal> будет преобразовано в 15 часов, 12 минут и 2 секунды "
"+ 20 миллисекунд + 1230 микросекунд = 2.021230 seconds."

#: func.xml:6066(para)
msgid ""
"<function>to_char(..., 'ID')</function>'s day of the week numbering matches "
"the <function>extract(isodow from ...)</function> function, but "
"<function>to_char(..., 'D')</function>'s does not match "
"<function>extract(dow from ...)</function>'s day numbering."
msgstr ""
"Нумерация дней недели в <function>to_char(..., 'ID')</function> "
"соответствует функции <function>extract(isodow from ...)</function>, но "
"нумерация <function>to_char(..., 'D')</function> не соответствует нумерации, "
"принятой в <function>extract(dow from ...)</function>."

#: func.xml:6075(para)
msgid ""
"<function>to_char(interval)</function> formats <literal>HH</literal> and "
"<literal>HH12</literal> as shown on a 12-hour clock, i.e. zero hours and 36 "
"hours output as <literal>12</literal>, while <literal>HH24</literal> outputs "
"the full hour value, which can exceed 23 for intervals."
msgstr ""
"Функция <function>to_char(interval)</function> обрабатывает форматы "
"<literal>HH</literal> и <literal>HH12</literal> в рамках 12 часов, то есть 0 "
"и 36 часов будут выводиться как <literal>12</literal>, тогда как "
"<literal>HH24</literal> выводит значение полностью и для интервалов "
"выводимое значение может превышать 23."

#: func.xml:5886(para)
msgid "Usage notes for date/time formatting: <placeholder-1/>"
msgstr "Замечания по использованию форматов даты/времени: <placeholder-1/>"

#: func.xml:6086(para)
msgid ""
"<xref linkend=\"functions-formatting-numeric-table\"/> shows the template "
"patterns available for formatting numeric values."
msgstr ""
"Коды форматирования числовых значений перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-numeric-table\"/>."

#: func.xml:6092(title)
msgid "Template Patterns for Numeric Formatting"
msgstr "Коды форматирования чисел"

#: func.xml:6102(literal)
msgid "9"
msgstr "9"

#: func.xml:6103(entry)
msgid "value with the specified number of digits"
msgstr "значение с заданным количеством цифр"

#: func.xml:6106(literal) func.xml:11918(literal)
msgid "0"
msgstr "0"

#: func.xml:6107(entry)
msgid "value with leading zeros"
msgstr "значение с ведущими нулями"

#: func.xml:6110(entry)
msgid "<literal>.</literal> (period)"
msgstr "<literal>.</literal> (точка)"

#: func.xml:6111(entry)
msgid "decimal point"
msgstr "десятичная точка"

#: func.xml:6114(entry)
msgid "<literal>,</literal> (comma)"
msgstr "<literal>,</literal> (запятая)"

#: func.xml:6115(entry)
msgid "group (thousand) separator"
msgstr "разделитель групп (тысяч)"

#: func.xml:6118(literal)
msgid "PR"
msgstr "PR"

#: func.xml:6119(entry)
msgid "negative value in angle brackets"
msgstr "отрицательное значение в угловых скобках"

#: func.xml:6122(literal)
msgid "S"
msgstr "S"

#: func.xml:6123(entry)
msgid "sign anchored to number (uses locale)"
msgstr "знак, добавляемый к числу (с учётом локали)"

#: func.xml:6126(literal)
msgid "L"
msgstr "L"

#: func.xml:6127(entry)
msgid "currency symbol (uses locale)"
msgstr "символ денежной единицы (с учётом локали)"

#: func.xml:6131(entry)
msgid "decimal point (uses locale)"
msgstr "разделитель целой и дробной части числа (с учётом локали)"

#: func.xml:6134(literal)
msgid "G"
msgstr "G"

#: func.xml:6135(entry)
msgid "group separator (uses locale)"
msgstr "разделитель групп (с учётом локали)"

#: func.xml:6139(entry)
msgid "minus sign in specified position (if number &lt; 0)"
msgstr "знак минус в заданной позиции (если число &lt; 0)"

#: func.xml:6142(literal)
msgid "PL"
msgstr "PL"

#: func.xml:6143(entry)
msgid "plus sign in specified position (if number &gt; 0)"
msgstr "знак плюс в заданной позиции (если число &gt; 0)"

#: func.xml:6146(literal)
msgid "SG"
msgstr "SG"

#: func.xml:6147(entry)
msgid "plus/minus sign in specified position"
msgstr "знак плюс или минус в заданной позиции"

#: func.xml:6150(literal)
msgid "RN"
msgstr "RN"

#: func.xml:6151(entry)
msgid "Roman numeral (input between 1 and 3999)"
msgstr "число римскими цифрами (в диапазоне от 1 до 3999)"

#: func.xml:6154(entry)
msgid "<literal>TH</literal> or <literal>th</literal>"
msgstr "<literal>TH</literal> или <literal>th</literal>"

#: func.xml:6155(entry)
msgid "ordinal number suffix"
msgstr "окончание порядкового числительного"

#: func.xml:6158(literal)
msgid "V"
msgstr "V"

#: func.xml:6159(entry)
msgid "shift specified number of digits (see notes)"
msgstr "сдвиг на заданное количество цифр (см. замечания)"

#: func.xml:6162(literal)
msgid "EEEE"
msgstr "EEEE"

#: func.xml:6163(entry)
msgid "exponent for scientific notation"
msgstr "экспоненциальная запись числа"

#: func.xml:6174(para)
msgid ""
"A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or "
"<literal>MI</literal> is not anchored to the number; for example, "
"<literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;"
"&nbsp;12'</literal> but <literal>to_char(-12, 'S9999')</literal> produces "
"<literal>'&nbsp;&nbsp;-12'</literal>. The Oracle implementation does not "
"allow the use of <literal>MI</literal> before <literal>9</literal>, but "
"rather requires that <literal>9</literal> precede <literal>MI</literal>."
msgstr ""
"Знак числа, полученный кодами <literal>SG</literal>, <literal>PL</literal> "
"или <literal>MI</literal>, не присоединяется к числу; например, "
"<literal>to_char(-12, 'MI9999')</literal> выдаёт <literal>'-&nbsp;&nbsp;12'</"
"literal>, тогда как <literal>to_char(-12, 'S9999')</literal> &mdash; "
"<literal>'&nbsp;&nbsp;-12'</literal>. В Oracle <literal>MI</literal> не "
"может идти перед <literal>9</literal>, наоборот <literal>9</literal> нужно "
"указать перед <literal>MI</literal>."

#: func.xml:6188(para)
msgid ""
"<literal>9</literal> results in a value with the same number of digits as "
"there are <literal>9</literal>s. If a digit is not available it outputs a "
"space."
msgstr ""
"<literal>9</literal> выводит значение с таким количеством цифр, какое было "
"бы, если бы оно состояло из девяток. Если цифры в данном месте не "
"оказывается, выводится пробел."

#: func.xml:6196(para)
msgid ""
"<literal>TH</literal> does not convert values less than zero and does not "
"convert fractional numbers."
msgstr ""
"<literal>TH</literal> не преобразует значения меньше 0 и не поддерживает "
"дробные числа."

#: func.xml:6203(para)
msgid ""
"<literal>PL</literal>, <literal>SG</literal>, and <literal>TH</literal> are "
"<productname>PostgreSQL</productname> extensions."
msgstr ""
"<literal>PL</literal>, <literal>SG</literal> и <literal>TH</literal> &mdash; "
"расширения <productname>PostgreSQL</productname>."

#: func.xml:6211(para)
#, fuzzy
msgid ""
"<literal>V</literal> with <function>to_char</function> multiplies the input "
"values by <literal>10^<replaceable>n</replaceable></literal>, where "
"<replaceable>n</replaceable> is the number of digits following <literal>V</"
"literal>. <literal>V</literal> with <function>to_number</function> divides "
"in a similar manner. <function>to_char</function> and <function>to_number</"
"function> do not support the use of <literal>V</literal> combined with a "
"decimal point (e.g., <literal>99.9V99</literal> is not allowed)."
msgstr ""
"<literal>V</literal> по сути умножает вводимое значение на "
"<literal>10^<replaceable>n</replaceable></literal>, где <replaceable>n</"
"replaceable> &mdash; число цифр, следующих за <literal>V</literal>. Функция "
"<function>to_char</function> не поддерживает <literal>V</literal> с дробными "
"числами (например, <literal>99.9V99</literal> не допускается)."

#: func.xml:6226(para)
msgid ""
"<literal>EEEE</literal> (scientific notation) cannot be used in combination "
"with any of the other formatting patterns or modifiers other than digit and "
"decimal point patterns, and must be at the end of the format string (e.g., "
"<literal>9.99EEEE</literal> is a valid pattern)."
msgstr ""
"Код <literal>EEEE</literal> (научная запись) не может сочетаться с любыми "
"другими вариантами форматирования или модификаторами, за исключением цифр и "
"десятичной точки, и должен располагаться в конце строки шаблона (например, "
"<literal>9.99EEEE</literal> &mdash; допустимый шаблон)."

#: func.xml:6169(para)
msgid "Usage notes for numeric formatting: <placeholder-1/>"
msgstr "Замечания по использованию форматов чисел: <placeholder-1/>"

#: func.xml:6236(para)
msgid ""
"Certain modifiers can be applied to any template pattern to alter its "
"behavior. For example, <literal>FM9999</literal> is the <literal>9999</"
"literal> pattern with the <literal>FM</literal> modifier. <xref linkend="
"\"functions-formatting-numericmod-table\"/> shows the modifier patterns for "
"numeric formatting."
msgstr ""
"Для изменения поведения кодов к ним могут быть применены определённые "
"модификаторы. Например, <literal>FM9999</literal> обрабатывается как код "
"<literal>9999</literal> с модификатором <literal>FM</literal>. Все "
"модификаторы для форматирования чисел перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-numericmod-table\"/>."

#: func.xml:6246(title)
msgid "Template Pattern Modifiers for Numeric Formatting"
msgstr "Модификаторы шаблонов для форматирования чисел"

#: func.xml:6259(literal)
msgid "FM9999"
msgstr "FM9999"

#: func.xml:6264(literal)
msgid "999TH"
msgstr "999TH"

#: func.xml:6269(literal)
msgid "999th"
msgstr "999th"

#: func.xml:6275(para)
msgid ""
"<xref linkend=\"functions-formatting-examples-table\"/> shows some examples "
"of the use of the <function>to_char</function> function."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-formatting-examples-table\"/> "
"приведены некоторые примеры использования функции <function>to_char</"
"function>."

#: func.xml:6281(title)
msgid "<function>to_char</function> Examples"
msgstr "Примеры <function>to_char</function>"

#: func.xml:6285(entry) func.xml:7642(entry)
msgid "Expression"
msgstr "Выражение"

#: func.xml:6291(literal)
msgid "to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')"
msgstr "to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')"

#: func.xml:6292(literal)
msgid "'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'"
msgstr "'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'"

#: func.xml:6295(literal)
msgid "to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')"
msgstr "to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')"

#: func.xml:6296(literal)
msgid "'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'"
msgstr "'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'"

#: func.xml:6299(literal)
msgid "to_char(-0.1, '99.99')"
msgstr "to_char(-0.1, '99.99')"

#: func.xml:6300(literal)
msgid "'&nbsp;&nbsp;-.10'"
msgstr "'&nbsp;&nbsp;-.10'"

#: func.xml:6303(literal)
msgid "to_char(-0.1, 'FM9.99')"
msgstr "to_char(-0.1, 'FM9.99')"

#: func.xml:6304(literal)
msgid "'-.1'"
msgstr "'-.1'"

#: func.xml:6307(literal)
msgid "to_char(0.1, '0.9')"
msgstr "to_char(0.1, '0.9')"

#: func.xml:6308(literal)
msgid "'&nbsp;0.1'"
msgstr "'&nbsp;0.1'"

#: func.xml:6311(literal)
msgid "to_char(12, '9990999.9')"
msgstr "to_char(12, '9990999.9')"

#: func.xml:6312(literal)
msgid "'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'"
msgstr "'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'"

#: func.xml:6315(literal)
msgid "to_char(12, 'FM9990999.9')"
msgstr "to_char(12, 'FM9990999.9')"

#: func.xml:6316(literal)
msgid "'0012.'"
msgstr "'0012.'"

#: func.xml:6319(literal)
msgid "to_char(485, '999')"
msgstr "to_char(485, '999')"

#: func.xml:6320(literal)
msgid "'&nbsp;485'"
msgstr "'&nbsp;485'"

#: func.xml:6323(literal)
msgid "to_char(-485, '999')"
msgstr "to_char(-485, '999')"

#: func.xml:6324(literal) func.xml:6384(literal)
msgid "'-485'"
msgstr "'-485'"

#: func.xml:6327(literal)
msgid "to_char(485, '9&nbsp;9&nbsp;9')"
msgstr "to_char(485, '9&nbsp;9&nbsp;9')"

#: func.xml:6328(literal)
msgid "'&nbsp;4&nbsp;8&nbsp;5'"
msgstr "'&nbsp;4&nbsp;8&nbsp;5'"

#: func.xml:6331(literal)
msgid "to_char(1485, '9,999')"
msgstr "to_char(1485, '9,999')"

#: func.xml:6332(literal)
msgid "'&nbsp;1,485'"
msgstr "'&nbsp;1,485'"

#: func.xml:6335(literal)
msgid "to_char(1485, '9G999')"
msgstr "to_char(1485, '9G999')"

#: func.xml:6336(literal)
msgid "'&nbsp;1&nbsp;485'"
msgstr "'&nbsp;1&nbsp;485'"

#: func.xml:6339(literal)
msgid "to_char(148.5, '999.999')"
msgstr "to_char(148.5, '999.999')"

#: func.xml:6340(literal)
msgid "'&nbsp;148.500'"
msgstr "'&nbsp;148.500'"

#: func.xml:6343(literal)
msgid "to_char(148.5, 'FM999.999')"
msgstr "to_char(148.5, 'FM999.999')"

#: func.xml:6344(literal)
msgid "'148.5'"
msgstr "'148.5'"

#: func.xml:6347(literal)
msgid "to_char(148.5, 'FM999.990')"
msgstr "to_char(148.5, 'FM999.990')"

#: func.xml:6348(literal)
msgid "'148.500'"
msgstr "'148.500'"

#: func.xml:6351(literal)
msgid "to_char(148.5, '999D999')"
msgstr "to_char(148.5, '999D999')"

#: func.xml:6352(literal)
msgid "'&nbsp;148,500'"
msgstr "'&nbsp;148,500'"

#: func.xml:6355(literal)
msgid "to_char(3148.5, '9G999D999')"
msgstr "to_char(3148.5, '9G999D999')"

#: func.xml:6356(literal)
msgid "'&nbsp;3&nbsp;148,500'"
msgstr "'&nbsp;3&nbsp;148,500'"

#: func.xml:6359(literal)
msgid "to_char(-485, '999S')"
msgstr "to_char(-485, '999S')"

#: func.xml:6360(literal) func.xml:6364(literal)
msgid "'485-'"
msgstr "'485-'"

#: func.xml:6363(literal)
msgid "to_char(-485, '999MI')"
msgstr "to_char(-485, '999MI')"

#: func.xml:6367(literal)
msgid "to_char(485, '999MI')"
msgstr "to_char(485, '999MI')"

#: func.xml:6368(literal)
msgid "'485&nbsp;'"
msgstr "'485&nbsp;'"

#: func.xml:6371(literal)
msgid "to_char(485, 'FM999MI')"
msgstr "to_char(485, 'FM999MI')"

#: func.xml:6372(literal)
msgid "'485'"
msgstr "'485'"

#: func.xml:6375(literal)
msgid "to_char(485, 'PL999')"
msgstr "to_char(485, 'PL999')"

#: func.xml:6376(literal) func.xml:6380(literal)
msgid "'+485'"
msgstr "'+485'"

#: func.xml:6379(literal)
msgid "to_char(485, 'SG999')"
msgstr "to_char(485, 'SG999')"

#: func.xml:6383(literal)
msgid "to_char(-485, 'SG999')"
msgstr "to_char(-485, 'SG999')"

#: func.xml:6387(literal)
msgid "to_char(-485, '9SG99')"
msgstr "to_char(-485, '9SG99')"

#: func.xml:6388(literal)
msgid "'4-85'"
msgstr "'4-85'"

#: func.xml:6391(literal)
msgid "to_char(-485, '999PR')"
msgstr "to_char(-485, '999PR')"

#: func.xml:6392(literal)
msgid "'&lt;485&gt;'"
msgstr "'&lt;485&gt;'"

#: func.xml:6395(literal)
msgid "to_char(485, 'L999')"
msgstr "to_char(485, 'L999')"

#: func.xml:6396(literal)
msgid "'DM&nbsp;485'"
msgstr "'DM&nbsp;485'"

#: func.xml:6399(literal)
msgid "to_char(485, 'RN')"
msgstr "to_char(485, 'RN')"

#: func.xml:6400(literal)
msgid "'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'"
msgstr "'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'"

#: func.xml:6403(literal)
msgid "to_char(485, 'FMRN')"
msgstr "to_char(485, 'FMRN')"

#: func.xml:6404(literal)
msgid "'CDLXXXV'"
msgstr "'CDLXXXV'"

#: func.xml:6407(literal)
msgid "to_char(5.2, 'FMRN')"
msgstr "to_char(5.2, 'FMRN')"

#: func.xml:6408(literal)
msgid "'V'"
msgstr "'V'"

#: func.xml:6411(literal)
msgid "to_char(482, '999th')"
msgstr "to_char(482, '999th')"

#: func.xml:6412(literal)
msgid "'&nbsp;482nd'"
msgstr "'&nbsp;482nd'"

#: func.xml:6415(literal)
msgid "to_char(485, '\"Good&nbsp;number:\"999')"
msgstr "to_char(485, '\"Good&nbsp;number:\"999')"

#: func.xml:6416(literal)
msgid "'Good&nbsp;number:&nbsp;485'"
msgstr "'Good&nbsp;number:&nbsp;485'"

#: func.xml:6419(literal)
msgid "to_char(485.8, '\"Pre:\"999\"&nbsp;Post:\"&nbsp;.999')"
msgstr "to_char(485.8, '\"Pre:\"999\"&nbsp;Post:\"&nbsp;.999')"

#: func.xml:6420(literal)
msgid "'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'"
msgstr "'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'"

#: func.xml:6423(literal)
msgid "to_char(12, '99V999')"
msgstr "to_char(12, '99V999')"

#: func.xml:6424(literal)
msgid "'&nbsp;12000'"
msgstr "'&nbsp;12000'"

#: func.xml:6427(literal)
msgid "to_char(12.4, '99V999')"
msgstr "to_char(12.4, '99V999')"

#: func.xml:6428(literal)
msgid "'&nbsp;12400'"
msgstr "'&nbsp;12400'"

#: func.xml:6431(literal)
msgid "to_char(12.45, '99V9')"
msgstr "to_char(12.45, '99V9')"

#: func.xml:6432(literal)
msgid "'&nbsp;125'"
msgstr "'&nbsp;125'"

#: func.xml:6435(literal)
msgid "to_char(0.0004859, '9.99EEEE')"
msgstr "to_char(0.0004859, '9.99EEEE')"

#: func.xml:6436(literal)
msgid "' 4.86e-04'"
msgstr "' 4.86e-04'"

#: func.xml:6446(title)
msgid "Date/Time Functions and Operators"
msgstr "Операторы и функции даты/времени"

#: func.xml:6448(para)
msgid ""
"<xref linkend=\"functions-datetime-table\"/> shows the available functions "
"for date/time value processing, with details appearing in the following "
"subsections. <xref linkend=\"operators-datetime-table\"/> illustrates the "
"behaviors of the basic arithmetic operators (<literal>+</literal>, "
"<literal>*</literal>, etc.). For formatting functions, refer to <xref "
"linkend=\"functions-formatting\"/>. You should be familiar with the "
"background information on date/time data types from <xref linkend=\"datatype-"
"datetime\"/>."
msgstr ""
"Все существующие функции для обработки даты/времени перечислены в <xref "
"remap=\"6\" linkend=\"functions-datetime-table\"/>, а подробнее они описаны "
"в следующих подразделах. Поведение основных арифметических операторов "
"(<literal>+</literal>, <literal>*</literal> и т. д.) описано в <xref remap="
"\"6\" linkend=\"operators-datetime-table\"/>. Функции форматирования этих "
"типов данных были перечислены в <xref remap=\"6\" linkend=\"functions-"
"formatting\"/>. Общую информацию об этих типах вы получили (или можете "
"получить) в <xref remap=\"6\" linkend=\"datatype-datetime\"/>."

#: func.xml:6460(para)
msgid ""
"All the functions and operators described below that take <type>time</type> "
"or <type>timestamp</type> inputs actually come in two variants: one that "
"takes <type>time with time zone</type> or <type>timestamp with time zone</"
"type>, and one that takes <type>time without time zone</type> or "
"<type>timestamp without time zone</type>. For brevity, these variants are "
"not shown separately. Also, the <literal>+</literal> and <literal>*</"
"literal> operators come in commutative pairs (for example both date + "
"integer and integer + date); we show only one of each such pair."
msgstr ""
"Все описанные ниже функции и операторы принимают две разновидности типов "
"<type>time</type> или <type>timestamp</type>: с часовым поясом (<type>time "
"with time zone</type> и <type>timestamp with time zone</type>) и без него "
"(<type>time without time zone</type> и <type>timestamp without time zone</"
"type>). Для краткости здесь они рассматриваются вместе. Кроме того, "
"операторы <literal>+</literal> и <literal>*</literal> обладают "
"переместительным свойством (например, date + integer = integer + date); "
"здесь будет приведён только один вариант для каждой пары."

#: func.xml:6471(title)
msgid "Date/Time Operators"
msgstr "Операторы даты/времени"

#: func.xml:6485(literal)
msgid "date '2001-09-28' + integer '7'"
msgstr "date '2001-09-28' + integer '7'"

#: func.xml:6486(literal)
msgid "date '2001-10-05'"
msgstr "date '2001-10-05'"

#: func.xml:6491(literal)
msgid "date '2001-09-28' + interval '1 hour'"
msgstr "date '2001-09-28' + interval '1 hour'"

#: func.xml:6492(literal)
msgid "timestamp '2001-09-28 01:00:00'"
msgstr "timestamp '2001-09-28 01:00:00'"

#: func.xml:6497(literal)
msgid "date '2001-09-28' + time '03:00'"
msgstr "date '2001-09-28' + time '03:00'"

#: func.xml:6498(literal)
msgid "timestamp '2001-09-28 03:00:00'"
msgstr "timestamp '2001-09-28 03:00:00'"

#: func.xml:6503(literal)
msgid "interval '1 day' + interval '1 hour'"
msgstr "interval '1 day' + interval '1 hour'"

#: func.xml:6504(literal)
msgid "interval '1 day 01:00:00'"
msgstr "interval '1 day 01:00:00'"

#: func.xml:6509(literal)
msgid "timestamp '2001-09-28 01:00' + interval '23 hours'"
msgstr "timestamp '2001-09-28 01:00' + interval '23 hours'"

#: func.xml:6510(literal)
msgid "timestamp '2001-09-29 00:00:00'"
msgstr "timestamp '2001-09-29 00:00:00'"

#: func.xml:6515(literal)
msgid "time '01:00' + interval '3 hours'"
msgstr "time '01:00' + interval '3 hours'"

#: func.xml:6516(literal)
msgid "time '04:00:00'"
msgstr "time '04:00:00'"

#: func.xml:6521(literal)
msgid "- interval '23 hours'"
msgstr "- interval '23 hours'"

#: func.xml:6522(literal)
msgid "interval '-23:00:00'"
msgstr "interval '-23:00:00'"

#: func.xml:6527(literal)
msgid "date '2001-10-01' - date '2001-09-28'"
msgstr "date '2001-10-01' - date '2001-09-28'"

#: func.xml:6528(entry)
msgid "<literal>integer '3'</literal> (days)"
msgstr "<literal>integer '3'</literal> (дня)"

#: func.xml:6533(literal)
msgid "date '2001-10-01' - integer '7'"
msgstr "date '2001-10-01' - integer '7'"

#: func.xml:6534(literal)
msgid "date '2001-09-24'"
msgstr "date '2001-09-24'"

#: func.xml:6539(literal)
msgid "date '2001-09-28' - interval '1 hour'"
msgstr "date '2001-09-28' - interval '1 hour'"

#: func.xml:6540(literal)
msgid "timestamp '2001-09-27 23:00:00'"
msgstr "timestamp '2001-09-27 23:00:00'"

#: func.xml:6545(literal)
msgid "time '05:00' - time '03:00'"
msgstr "time '05:00' - time '03:00'"

#: func.xml:6546(literal)
msgid "interval '02:00:00'"
msgstr "interval '02:00:00'"

#: func.xml:6551(literal)
msgid "time '05:00' - interval '2 hours'"
msgstr "time '05:00' - interval '2 hours'"

#: func.xml:6552(literal)
msgid "time '03:00:00'"
msgstr "time '03:00:00'"

#: func.xml:6557(literal)
msgid "timestamp '2001-09-28 23:00' - interval '23 hours'"
msgstr "timestamp '2001-09-28 23:00' - interval '23 hours'"

#: func.xml:6558(literal)
msgid "timestamp '2001-09-28 00:00:00'"
msgstr "timestamp '2001-09-28 00:00:00'"

#: func.xml:6563(literal)
msgid "interval '1 day' - interval '1 hour'"
msgstr "interval '1 day' - interval '1 hour'"

#: func.xml:6564(literal)
msgid "interval '1 day -01:00:00'"
msgstr "interval '1 day -01:00:00'"

#: func.xml:6569(literal)
msgid "timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'"
msgstr "timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'"

#: func.xml:6570(literal)
msgid "interval '1 day 15:00:00'"
msgstr "interval '1 day 15:00:00'"

#: func.xml:6575(literal)
msgid "900 * interval '1 second'"
msgstr "900 * interval '1 second'"

#: func.xml:6576(literal)
msgid "interval '00:15:00'"
msgstr "interval '00:15:00'"

#: func.xml:6581(literal)
msgid "21 * interval '1 day'"
msgstr "21 * interval '1 day'"

#: func.xml:6582(literal)
msgid "interval '21 days'"
msgstr "interval '21 days'"

#: func.xml:6587(literal)
msgid "double precision '3.5' * interval '1 hour'"
msgstr "double precision '3.5' * interval '1 hour'"

#: func.xml:6588(literal)
msgid "interval '03:30:00'"
msgstr "interval '03:30:00'"

#: func.xml:6593(literal)
msgid "interval '1 hour' / double precision '1.5'"
msgstr "interval '1 hour' / double precision '1.5'"

#: func.xml:6594(literal)
msgid "interval '00:40:00'"
msgstr "interval '00:40:00'"

#: func.xml:6601(title)
msgid "Date/Time Functions"
msgstr "Функции даты/времени"

#: func.xml:6616(indexterm)
msgid "<primary>age</primary>"
msgstr "<primary>age</primary>"

#: func.xml:6619(function)
msgid "age(<placeholder-1/>, <placeholder-2/>)"
msgstr "age(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:6622(entry)
msgid ""
"Subtract arguments, producing a <quote>symbolic</quote> result that uses "
"years and months, rather than just days"
msgstr ""
"Вычитает аргументы и выдаёт <quote>символический</quote> результат с годами "
"и месяцами, а не просто днями"

#: func.xml:6624(literal)
msgid "age(timestamp '2001-04-10', timestamp '1957-06-13')"
msgstr "age(timestamp '2001-04-10', timestamp '1957-06-13')"

#: func.xml:6625(literal)
msgid "43 years 9 mons 27 days"
msgstr "43 years 9 mons 27 days (43 года 9 месяцев 27 дней)"

#: func.xml:6629(function)
msgid "age(<placeholder-1/>)"
msgstr "age(<placeholder-1/>)"

#: func.xml:6631(entry)
msgid "Subtract from <function>current_date</function> (at midnight)"
msgstr ""
"Вычитает дату/время из <function>current_date</function> (полночь текущего "
"дня)"

#: func.xml:6632(literal)
msgid "age(timestamp '1957-06-13')"
msgstr "age(timestamp '1957-06-13')"

#: func.xml:6633(literal)
msgid "43 years 8 mons 3 days"
msgstr "43 years 8 mons 3 days (43 года 8 месяцев 3 дня)"

#: func.xml:6638(indexterm)
msgid "<primary>clock_timestamp</primary>"
msgstr "<primary>clock_timestamp</primary>"

#: func.xml:6641(function)
msgid "clock_timestamp()"
msgstr "clock_timestamp&zwsp;()"

#: func.xml:6644(entry)
msgid ""
"Current date and time (changes during statement execution); see <xref "
"linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (меняется в процессе выполнения операторов); см. <xref "
"remap=\"4\" linkend=\"functions-datetime-current\"/>"

#: func.xml:6653(indexterm)
msgid "<primary>current_date</primary>"
msgstr "<primary>current_date</primary>"

#: func.xml:6656(function)
msgid "current_date"
msgstr "current_date"

#: func.xml:6659(entry)
msgid "Current date; see <xref linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата; см. <xref remap=\"4\" linkend=\"functions-datetime-current\"/>"

#: func.xml:6668(indexterm)
msgid "<primary>current_time</primary>"
msgstr "<primary>current_time</primary>"

#: func.xml:6671(function)
msgid "current_time"
msgstr "current_time"

#: func.xml:6673(type) func.xml:7668(type) func.xml:7670(type)
msgid "time with time zone"
msgstr "time with time zone"

#: func.xml:6674(entry) func.xml:6845(entry)
msgid "Current time of day; see <xref linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущее время суток; см. <xref remap=\"4\" linkend=\"functions-datetime-"
"current\"/>"

#: func.xml:6683(indexterm)
msgid "<primary>current_timestamp</primary>"
msgstr "<primary>current_timestamp</primary>"

#: func.xml:6686(function)
msgid "current_timestamp"
msgstr "current_timestamp"

#: func.xml:6689(entry) func.xml:6860(entry) func.xml:6994(entry)
#: func.xml:7040(entry)
msgid ""
"Current date and time (start of current transaction); see <xref linkend="
"\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (на момент начала транзакции); см. <xref remap=\"4\" "
"linkend=\"functions-datetime-current\"/>"

#: func.xml:6698(indexterm) func.xml:7160(indexterm)
msgid "<primary>date_part</primary>"
msgstr "<primary>date_part</primary>"

#: func.xml:6701(function) func.xml:6712(function)
msgid "date_part(<placeholder-1/>, <placeholder-2/>)"
msgstr "date_part(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:6704(entry) func.xml:6714(entry)
msgid ""
"Get subfield (equivalent to <function>extract</function>); see <xref linkend="
"\"functions-datetime-extract\"/>"
msgstr ""
"Возвращает поле даты (равнозначно <function>extract</function>); см. <xref "
"remap=\"4\" linkend=\"functions-datetime-extract\"/>"

#: func.xml:6707(literal)
msgid "date_part('hour', timestamp '2001-02-16 20:38:40')"
msgstr "date_part('hour', timestamp '2001-02-16 20:38:40')"

#: func.xml:6717(literal)
msgid "date_part('month', interval '2 years 3 months')"
msgstr "date_part('month', interval '2 years 3 months')"

#: func.xml:6723(indexterm) func.xml:7567(indexterm)
msgid "<primary>date_trunc</primary>"
msgstr "<primary>date_trunc</primary>"

#: func.xml:6726(function) func.xml:6736(function)
msgid "date_trunc(<placeholder-1/>, <placeholder-2/>)"
msgstr "date_trunc(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:6729(entry) func.xml:6738(entry)
msgid ""
"Truncate to specified precision; see also <xref linkend=\"functions-datetime-"
"trunc\"/>"
msgstr ""
"Отсекает компоненты даты до заданной точности; см. также <xref linkend="
"\"functions-datetime-trunc\"/>"

#: func.xml:6731(literal)
msgid "date_trunc('hour', timestamp '2001-02-16 20:38:40')"
msgstr "date_trunc('hour', timestamp '2001-02-16 20:38:40')"

#: func.xml:6732(literal)
msgid "2001-02-16 20:00:00"
msgstr "2001-02-16 20:00:00"

#: func.xml:6740(literal)
msgid "date_trunc('hour', interval '2 days 3 hours 40 minutes')"
msgstr "date_trunc('hour', interval '2 days 3 hours 40 minutes')"

#: func.xml:6741(literal)
msgid "2 days 03:00:00"
msgstr "2 days 03:00:00"

#: func.xml:6746(indexterm) func.xml:7163(indexterm)
msgid "<primary>extract</primary>"
msgstr "<primary>extract</primary>"

#: func.xml:6749(function) func.xml:6760(function)
msgid "extract"
msgstr "extract"

#: func.xml:6749(literal) func.xml:6760(literal)
msgid "<placeholder-1/>(<placeholder-2/> from <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/> from <placeholder-3/>)"

#: func.xml:6753(entry) func.xml:6763(entry)
msgid "Get subfield; see <xref linkend=\"functions-datetime-extract\"/>"
msgstr ""
"Возвращает поле даты; см. <xref remap=\"4\" linkend=\"functions-datetime-"
"extract\"/>"

#: func.xml:6755(literal)
msgid "extract(hour from timestamp '2001-02-16 20:38:40')"
msgstr "extract(hour from timestamp '2001-02-16 20:38:40')"

#: func.xml:6765(literal)
msgid "extract(month from interval '2 years 3 months')"
msgstr "extract(month from interval '2 years 3 months')"

#: func.xml:6771(indexterm)
msgid "<primary>isfinite</primary>"
msgstr "<primary>isfinite</primary>"

#: func.xml:6774(function) func.xml:6783(function) func.xml:6791(function)
msgid "isfinite(<placeholder-1/>)"
msgstr "isfinite(<placeholder-1/>)"

#: func.xml:6777(entry)
msgid "Test for finite date (not +/-infinity)"
msgstr "Проверяет конечность даты (её отличие от +/-бесконечности)"

#: func.xml:6778(literal)
msgid "isfinite(date '2001-02-16')"
msgstr "isfinite(date '2001-02-16')"

#: func.xml:6779(literal) func.xml:6787(literal) func.xml:6795(literal)
#: func.xml:12372(literal) func.xml:12394(literal) func.xml:12405(literal)
msgctxt "literal"
msgid "true"
msgstr "true"

#: func.xml:6785(entry)
msgid "Test for finite time stamp (not +/-infinity)"
msgstr "Проверяет конечность времени (его отличие от +/-бесконечности)"

#: func.xml:6786(literal)
msgid "isfinite(timestamp '2001-02-16 21:28:30')"
msgstr "isfinite(timestamp '2001-02-16 21:28:30')"

#: func.xml:6793(entry)
msgid "Test for finite interval"
msgstr "Проверяет конечность интервала"

#: func.xml:6794(literal)
msgid "isfinite(interval '4 hours')"
msgstr "isfinite(interval '4 hours')"

#: func.xml:6800(indexterm)
msgid "<primary>justify_days</primary>"
msgstr "<primary>justify_days</primary>"

#: func.xml:6803(function)
msgid "justify_days(<placeholder-1/>)"
msgstr "justify_days(<placeholder-1/>)"

#: func.xml:6806(entry)
msgid "Adjust interval so 30-day time periods are represented as months"
msgstr ""
"Преобразует интервал так, что каждый 30-дневный период считается одним "
"месяцем"

#: func.xml:6807(literal)
msgid "justify_days(interval '35 days')"
msgstr "justify_days(interval '35 days')"

#: func.xml:6808(literal)
msgid "1 mon 5 days"
msgstr "1 mon 5 days (1 месяц 5 дней)"

#: func.xml:6813(indexterm)
msgid "<primary>justify_hours</primary>"
msgstr "<primary>justify_hours</primary>"

#: func.xml:6816(function)
msgid "justify_hours(<placeholder-1/>)"
msgstr "justify_hours(<placeholder-1/>)"

#: func.xml:6819(entry)
msgid "Adjust interval so 24-hour time periods are represented as days"
msgstr ""
"Преобразует интервал так, что каждый 24-часовой период считается одним днём"

#: func.xml:6820(literal)
msgid "justify_hours(interval '27 hours')"
msgstr "justify_hours(interval '27 hours')"

#: func.xml:6821(literal)
msgid "1 day 03:00:00"
msgstr "1 day 03:00:00 (1 день 03:00:00)"

#: func.xml:6826(indexterm)
msgid "<primary>justify_interval</primary>"
msgstr "<primary>justify_interval</primary>"

#: func.xml:6829(function)
msgid "justify_interval(<placeholder-1/>)"
msgstr "justify_interval(<placeholder-1/>)"

#: func.xml:6832(entry)
msgid ""
"Adjust interval using <function>justify_days</function> and "
"<function>justify_hours</function>, with additional sign adjustments"
msgstr ""
"Преобразует интервал с применением <function>justify_days</function> и "
"<function>justify_hours</function> и дополнительно корректирует знаки"

#: func.xml:6833(literal)
msgid "justify_interval(interval '1 mon -1 hour')"
msgstr "justify_interval(interval '1 mon -1 hour')"

#: func.xml:6834(literal)
msgid "29 days 23:00:00"
msgstr "29 days 23:00:00 (29 дней 23:00:00)"

#: func.xml:6839(indexterm)
msgid "<primary>localtime</primary>"
msgstr "<primary>localtime</primary>"

#: func.xml:6842(function)
msgid "localtime"
msgstr "localtime"

#: func.xml:6844(type) func.xml:6927(type)
msgid "time"
msgstr "time"

#: func.xml:6854(indexterm)
msgid "<primary>localtimestamp</primary>"
msgstr "<primary>localtimestamp</primary>"

#: func.xml:6857(function)
msgid "localtimestamp"
msgstr "localtimestamp"

#: func.xml:6869(indexterm)
msgid "<primary>make_date</primary>"
msgstr "<primary>make_date</primary>"

#: func.xml:6874(parameter) func.xml:6942(parameter) func.xml:6966(parameter)
msgctxt "parameter"
msgid "year"
msgstr "year"

#: func.xml:6875(parameter) func.xml:6943(parameter) func.xml:6967(parameter)
msgctxt "parameter"
msgid "month"
msgstr "month"

#: func.xml:6876(parameter) func.xml:6944(parameter) func.xml:6968(parameter)
msgctxt "parameter"
msgid "day"
msgstr "day"

#: func.xml:6873(function)
msgid ""
"make_date(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"make_date(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:6881(entry)
msgid "Create date from year, month and day fields"
msgstr "Образует дату из полей: year (год), month (месяц) и day (день)"

#: func.xml:6884(literal)
msgid "make_date(2013, 7, 15)"
msgstr "make_date(2013, 7, 15)"

#: func.xml:6885(literal)
msgid "2013-07-15"
msgstr "2013-07-15"

#: func.xml:6890(indexterm)
msgid "<primary>make_interval</primary>"
msgstr "<primary>make_interval</primary>"

#: func.xml:6895(parameter)
msgid "years"
msgstr "years"

#: func.xml:6896(parameter)
msgid "months"
msgstr "months"

#: func.xml:6897(parameter)
msgid "weeks"
msgstr "weeks"

#: func.xml:6898(parameter)
msgid "days"
msgstr "days"

#: func.xml:6899(parameter)
msgid "hours"
msgstr "hours"

#: func.xml:6900(parameter)
msgid "mins"
msgstr "mins"

#: func.xml:6901(parameter)
msgid "secs"
msgstr "secs"

#: func.xml:6894(function)
msgid ""
"make_interval(<placeholder-1/> <placeholder-2/> DEFAULT 0, <placeholder-3/> "
"<placeholder-4/> DEFAULT 0, <placeholder-5/> <placeholder-6/> DEFAULT 0, "
"<placeholder-7/> <placeholder-8/> DEFAULT 0, <placeholder-9/> "
"<placeholder-10/> DEFAULT 0, <placeholder-11/> <placeholder-12/> DEFAULT 0, "
"<placeholder-13/> <placeholder-14/> DEFAULT 0.0)"
msgstr ""
"make_interval(<placeholder-1/> <placeholder-2/> DEFAULT 0, <placeholder-3/> "
"<placeholder-4/> DEFAULT 0, <placeholder-5/> <placeholder-6/> DEFAULT 0, "
"<placeholder-7/> <placeholder-8/> DEFAULT 0, <placeholder-9/> "
"<placeholder-10/> DEFAULT 0, <placeholder-11/> <placeholder-12/> DEFAULT 0, "
"<placeholder-13/> <placeholder-14/> DEFAULT 0.0)"

#: func.xml:6906(entry)
msgid ""
"Create interval from years, months, weeks, days, hours, minutes and seconds "
"fields"
msgstr ""
"Образует интервал из полей: years (годы), months (месяцы), weeks (недели), "
"days (дни), hours (часы), minutes (минуты) и secs (секунды)"

#: func.xml:6910(literal)
msgid "make_interval(days =&gt; 10)"
msgstr "make_interval(days =&gt; 10)"

#: func.xml:6911(literal)
msgid "10 days"
msgstr "10 days"

#: func.xml:6916(indexterm)
msgid "<primary>make_time</primary>"
msgstr "<primary>make_time</primary>"

#: func.xml:6921(parameter) func.xml:6945(parameter) func.xml:6969(parameter)
msgctxt "parameter"
msgid "hour"
msgstr "hour"

#: func.xml:6922(parameter) func.xml:6946(parameter) func.xml:6970(parameter)
msgid "min"
msgstr "min"

#: func.xml:6923(parameter) func.xml:6947(parameter) func.xml:6971(parameter)
msgid "sec"
msgstr "sec"

#: func.xml:6920(function)
msgid ""
"make_time(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"make_time(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:6928(entry)
msgid "Create time from hour, minute and seconds fields"
msgstr "Образует время из полей: hour (час), minute (минута) и sec (секунда)"

#: func.xml:6931(literal)
msgid "make_time(8, 15, 23.5)"
msgstr "make_time(8, 15, 23.5)"

#: func.xml:6932(literal)
msgid "08:15:23.5"
msgstr "08:15:23.5"

#: func.xml:6937(indexterm)
msgid "<primary>make_timestamp</primary>"
msgstr "<primary>make_timestamp</primary>"

#: func.xml:6941(function)
msgid ""
"make_timestamp(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>)"
msgstr ""
"make_timestamp(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>)"

#: func.xml:6952(entry)
msgid "Create timestamp from year, month, day, hour, minute and seconds fields"
msgstr ""
"Образует дату и время из полей: year (год), month (месяц), day (день), hour "
"(час), minute (минута) и sec (секунда)"

#: func.xml:6955(literal)
msgid "make_timestamp(2013, 7, 15, 8, 15, 23.5)"
msgstr "make_timestamp(2013, 7, 15, 8, 15, 23.5)"

#: func.xml:6956(literal)
msgid "2013-07-15 08:15:23.5"
msgstr "2013-07-15 08:15:23.5"

#: func.xml:6961(indexterm)
msgid "<primary>make_timestamptz</primary>"
msgstr "<primary>make_timestamptz</primary>"

#: func.xml:6972(parameter)
msgctxt "parameter"
msgid "timezone"
msgstr "timezone"

#: func.xml:6965(function)
msgid ""
"make_timestamptz(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>, <optional><placeholder-13/> <placeholder-14/></optional>)"
msgstr ""
"make_timestamptz(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>, <optional><placeholder-13/> <placeholder-14/></optional>)"

#: func.xml:6977(entry)
#, fuzzy
msgid ""
"Create timestamp with time zone from year, month, day, hour, minute and "
"seconds fields; if <parameter>timezone</parameter> is not specified, the "
"current time zone is used"
msgstr ""
"Образует дату и время с часовым поясом из полей: year (год), month (месяц), "
"day (день), hour (час), minute (минута) и sec (секунда). Если параметр "
"<parameter>timezone</parameter> (часовой пояс) не указан, используется "
"текущий часовой пояс."

#: func.xml:6982(literal)
msgid "make_timestamptz(2013, 7, 15, 8, 15, 23.5)"
msgstr "make_timestamptz(2013, 7, 15, 8, 15, 23.5)"

#: func.xml:6983(literal)
msgid "2013-07-15 08:15:23.5+01"
msgstr "2013-07-15 08:15:23.5+01"

#: func.xml:6988(indexterm)
msgid "<primary>now</primary>"
msgstr "<primary>now</primary>"

#: func.xml:6991(function)
msgid "now()"
msgstr "now()"

#: func.xml:7003(indexterm)
msgid "<primary>statement_timestamp</primary>"
msgstr "<primary>statement_timestamp</primary>"

#: func.xml:7006(function)
msgid "statement_timestamp()"
msgstr "statement_timestamp()"

#: func.xml:7009(entry)
msgid ""
"Current date and time (start of current statement); see <xref linkend="
"\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (на момент начала текущего оператора); см. <xref remap="
"\"4\" linkend=\"functions-datetime-current\"/>"

#: func.xml:7018(indexterm)
msgid "<primary>timeofday</primary>"
msgstr "<primary>timeofday</primary>"

#: func.xml:7021(function)
msgid "timeofday()"
msgstr "timeofday()"

#: func.xml:7024(entry)
msgid ""
"Current date and time (like <function>clock_timestamp</function>, but as a "
"<type>text</type> string); see <xref linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (как <function>clock_timestamp</function>, но в виде "
"строки типа <type>text</type>); см. <xref remap=\"4\" linkend=\"functions-"
"datetime-current\"/>"

#: func.xml:7034(indexterm)
msgid "<primary>transaction_timestamp</primary>"
msgstr "<primary>transaction_timestamp</primary>"

#: func.xml:7037(function)
msgid "transaction_timestamp()"
msgstr "transaction_timestamp()"

#: func.xml:7051(function)
msgid "to_timestamp(<placeholder-1/>)"
msgstr "to_timestamp(<placeholder-1/>)"

#: func.xml:7054(entry)
msgid "Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to timestamp"
msgstr ""

#: func.xml:7056(literal)
msgid "to_timestamp(1284352323)"
msgstr "to_timestamp(1284352323)"

#: func.xml:7057(literal)
msgid "2010-09-13 04:32:03+00"
msgstr ""

#: func.xml:7064(indexterm)
msgid "<primary>OVERLAPS</primary>"
msgstr "<primary>OVERLAPS</primary>"

#: func.xml:7063(para)
msgid ""
"<placeholder-1/> In addition to these functions, the SQL <literal>OVERLAPS</"
"literal> operator is supported: <synopsis>(<replaceable>start1</"
"replaceable>, <replaceable>end1</replaceable>) OVERLAPS "
"(<replaceable>start2</replaceable>, <replaceable>end2</replaceable>)\n"
"(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) "
"OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</"
"replaceable>)</synopsis> This expression yields true when two time periods "
"(defined by their endpoints) overlap, false when they do not overlap. The "
"endpoints can be specified as pairs of dates, times, or time stamps; or as a "
"date, time, or time stamp followed by an interval. When a pair of values is "
"provided, either the start or the end can be written first; "
"<literal>OVERLAPS</literal> automatically takes the earlier value of the "
"pair as the start. Each time period is considered to represent the half-open "
"interval <replaceable>start</replaceable> <literal>&lt;=</literal>\n"
"    <replaceable>time</replaceable> <literal>&lt;</literal> "
"<replaceable>end</replaceable>, unless <replaceable>start</replaceable> and "
"<replaceable>end</replaceable> are equal in which case it represents that "
"single time instant. This means for instance that two time periods with only "
"an endpoint in common do not overlap."
msgstr ""
"<placeholder-1/> В дополнение к этим функциям поддерживается SQL-оператор "
"<literal>OVERLAPS</literal>: <synopsis>(<replaceable>начало1</replaceable>, "
"<replaceable>конец1</replaceable>) OVERLAPS (<replaceable>начало2</"
"replaceable>, <replaceable>конец2</replaceable>)\n"
"(<replaceable>начало1</replaceable>, <replaceable>длительность1</"
"replaceable>) OVERLAPS (<replaceable>начало2</replaceable>, "
"<replaceable>длительность2</replaceable>)</synopsis> Его результатом будет "
"true, когда два периода времени (определённые своими границами) "
"пересекаются, и false в противном случае. Границы периода можно задать либо "
"в виде пары дат, времени или дат со временем, либо как дату, время (или дату "
"со временем) c интервалом. Когда указывается пара значений, первым может "
"быть и начало, и конец периода: <literal>OVERLAPS</literal> автоматически "
"считает началом периода меньшее значение. Периоды времени считаются "
"наполовину открытыми, т. е. <replaceable>начало</replaceable><literal>&lt;=</"
"literal><replaceable>время</replaceable><literal>&lt;</"
"literal><replaceable>конец</replaceable>, если только <replaceable>начало</"
"replaceable> и <replaceable>конец</replaceable> не равны &mdash; в этом "
"случае период представляет один момент времени. Это означает, например, что "
"два периода, имеющие только общую границу, не будут считаться "
"пересекающимися."

#: func.xml:7087(lineannotation) func.xml:7090(lineannotation)
#: func.xml:7093(lineannotation) func.xml:7096(lineannotation)
#: func.xml:7147(lineannotation) func.xml:7151(lineannotation)
#: func.xml:7153(lineannotation) func.xml:7155(lineannotation)
#: func.xml:7192(lineannotation) func.xml:7194(lineannotation)
#: func.xml:7217(lineannotation) func.xml:7220(lineannotation)
#: func.xml:7235(lineannotation) func.xml:7248(lineannotation)
#: func.xml:7266(lineannotation) func.xml:7283(lineannotation)
#: func.xml:7286(lineannotation) func.xml:7293(lineannotation)
#: func.xml:7305(lineannotation) func.xml:7318(lineannotation)
#: func.xml:7336(lineannotation) func.xml:7338(lineannotation)
#: func.xml:7362(lineannotation) func.xml:7374(lineannotation)
#: func.xml:7392(lineannotation) func.xml:7404(lineannotation)
#: func.xml:7418(lineannotation) func.xml:7421(lineannotation)
#: func.xml:7424(lineannotation) func.xml:7436(lineannotation)
#: func.xml:7450(lineannotation) func.xml:7453(lineannotation)
#: func.xml:7508(lineannotation) func.xml:7521(lineannotation)
#: func.xml:7557(lineannotation) func.xml:7560(lineannotation)
msgid "Result:"
msgstr "Результат:"

#: func.xml:7087(computeroutput) func.xml:7096(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "true"
msgstr "true"

#: func.xml:7090(computeroutput) func.xml:7093(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "false"
msgstr "false"

#: func.xml:7085(screen)
#, no-wrap
msgid ""
"SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-7/><placeholder-8/>"
msgstr ""
"SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-7/><placeholder-8/>"

#: func.xml:7098(para)
msgid ""
"When adding an <type>interval</type> value to (or subtracting an "
"<type>interval</type> value from) a <type>timestamp with time zone</type> "
"value, the days component advances or decrements the date of the "
"<type>timestamp with time zone</type> by the indicated number of days. "
"Across daylight saving time changes (when the session time zone is set to a "
"time zone that recognizes DST), this means <literal>interval '1 day'</"
"literal> does not necessarily equal <literal>interval '24 hours'</literal>. "
"For example, with the session time zone set to <literal>CST7CDT</literal>, "
"<literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'</"
"literal> will produce <literal>timestamp with time zone '2005-04-03 "
"12:00-06'</literal>, while adding <literal>interval '24 hours'</literal> to "
"the same initial <type>timestamp with time zone</type> produces "
"<literal>timestamp with time zone '2005-04-03 13:00-06'</literal>, as there "
"is a change in daylight saving time at <literal>2005-04-03 02:00</literal> "
"in time zone <literal>CST7CDT</literal>."
msgstr ""
"При добавлении к дате со временем типа <type>timestamp with time zone</type> "
"значения <type>interval</type> (или при вычитании из него <type>interval</"
"type>), поле дней в этой дате увеличивается (или уменьшается) на указанное "
"число дней. При пересечении границы перехода на летнее время (если в часовом "
"поясе текущего сеанса производится этот переход) это означает, что "
"<literal>interval '1 day'</literal> и <literal>interval '24 hours'</literal> "
"не обязательно будут равны. Например, в часовом поясе <literal>CST7CDT</"
"literal> результатом выражения <literal>timestamp with time zone '2005-04-02 "
"12:00-07' + interval '1 day' </literal> будет <literal>timestamp with time "
"zone '2005-04-03 12:00-06'</literal>, тогда как, если добавить "
"<literal>interval '24 hours'</literal> к тому же значению <type>timestamp "
"with time zone</type>, в результате получится <literal>timestamp with time "
"zone '2005-04-03 13:00-06'</literal>. Эта разница объясняется тем, что "
"<literal>2005-04-03 02:00</literal> в часовом поясе <literal>CST7CDT</"
"literal> произошёл переход на летнее время."

#: func.xml:7116(para)
msgid ""
"Note there can be ambiguity in the <literal>months</literal> field returned "
"by <function>age</function> because different months have different numbers "
"of days. <productname>PostgreSQL</productname>'s approach uses the month "
"from the earlier of the two dates when calculating partial months. For "
"example, <literal>age('2004-06-01', '2004-04-30')</literal> uses April to "
"yield <literal>1 mon 1 day</literal>, while using May would yield <literal>1 "
"mon 2 days</literal> because May has 31 days, while April has only 30."
msgstr ""
"Обратите внимание на возможную неоднозначность в поле <literal>months</"
"literal> в результате функции <function>age</function>, вызванную тем, что "
"число дней в разных месяцах неодинаково. Вычисляя оставшиеся дни месяца, "
"<productname>PostgreSQL</productname> рассматривает месяц меньшей из двух "
"дат. Например, результатом <literal>age('2004-06-01', '2004-04-30')</"
"literal> будет <literal>1 mon 1 day</literal>, так как в апреле 30 дней, а "
"то же выражение с датой 30 мая выдаст <literal>1 mon 2 days</literal>, так "
"как в мае 31 день."

#: func.xml:7126(para)
msgid ""
"Subtraction of dates and timestamps can also be complex. One conceptually "
"simple way to perform subtraction is to convert each value to a number of "
"seconds using <literal>EXTRACT(EPOCH FROM ...)</literal>, then subtract the "
"results; this produces the number of <emphasis>seconds</emphasis> between "
"the two values. This will adjust for the number of days in each month, "
"timezone changes, and daylight saving time adjustments. Subtraction of date "
"or timestamp values with the <quote><literal>-</literal></quote> operator "
"returns the number of days (24-hours) and hours/minutes/seconds between the "
"values, making the same adjustments. The <function>age</function> function "
"returns years, months, days, and hours/minutes/seconds, performing field-by-"
"field subtraction and then adjusting for negative field values. The "
"following queries illustrate the differences in these approaches. The sample "
"results were produced with <literal>timezone = 'US/Eastern'</literal>; there "
"is a daylight saving time change between the two dates used:"
msgstr ""
"Вычитание дат и дат со временем также может быть нетривиальной операцией. "
"Один принципиально простой способ выполнить такое вычисление &mdash; "
"преобразовать каждое значение в количество секунд, используя "
"<literal>EXTRACT(EPOCH FROM ...)</literal>, а затем найти разницу "
"результатов; при этом будет получено число <emphasis>секунд</emphasis> между "
"двумя датами. При этом будет учтено неодинаковое число дней в месяцах, "
"изменения часовых поясов и переходы на летнее время. При вычитании дат или "
"дат со временем с помощью оператора <quote><literal>-</literal></quote> "
"выдаётся число дней (по 24 часа) и часов/минут/секунд между данными "
"значениями, с учётом тех же факторов. Функция <function>age</function> "
"возвращает число лет, месяцев, дней и часов/минут/секунд, выполняя вычитание "
"по полям, а затем пересчитывая отрицательные значения. Различие этих "
"подходов иллюстрируют следующие запросы. Показанные результаты были получены "
"для часового пояса <literal>'US/Eastern'</literal>; между двумя заданными "
"датами произошёл переход на летнее время:"

#: func.xml:7147(computeroutput)
#, no-wrap
msgid "10537200"
msgstr "10537200"

#: func.xml:7151(computeroutput)
#, no-wrap
msgid "121.958333333333"
msgstr "121.958333333333"

#: func.xml:7153(computeroutput)
#, no-wrap
msgid "121 days 23:00:00"
msgstr "121 days 23:00:00"

#: func.xml:7155(computeroutput)
#, no-wrap
msgid "4 mons"
msgstr "4 mons"

#: func.xml:7145(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))\n"
"        / 60 / 60 / 24;\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-7/><placeholder-8/>"
msgstr ""
"SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))\n"
"        / 60 / 60 / 24;\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-7/><placeholder-8/>"

#: func.xml:7158(title)
msgid "<function>EXTRACT</function>, <function>date_part</function>"
msgstr "<function>EXTRACT</function>, <function>date_part</function>"

#: func.xml:7167(replaceable)
msgctxt "replaceable"
msgid "field"
msgstr "field"

#: func.xml:7167(replaceable)
msgid "source"
msgstr "source"

#: func.xml:7167(synopsis)
#, no-wrap
msgid "EXTRACT(<placeholder-1/> FROM <placeholder-2/>)"
msgstr "EXTRACT(<placeholder-1/> FROM <placeholder-2/>)"

#: func.xml:7185(literal) func.xml:7604(literal)
msgid "century"
msgstr "century"

#: func.xml:7187(para)
msgid "The century"
msgstr "Век:"

#: func.xml:7192(computeroutput) func.xml:7305(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "20"
msgstr "20"

#: func.xml:7194(computeroutput)
#, no-wrap
msgid "21"
msgstr "21"

#: func.xml:7191(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7196(para)
msgid ""
"The first century starts at 0001-01-01 00:00:00 AD, although they did not "
"know it at the time. This definition applies to all Gregorian calendar "
"countries. There is no century number 0, you go from -1 century to 1 "
"century. If you disagree with this, please write your complaint to: Pope, "
"Cathedral Saint-Peter of Roma, Vatican."
msgstr ""
"Первый век начался 0001-01-01 00:00:00, хотя люди в то время и не считали "
"так. Это определение распространяется на все страны с григорианским "
"календарём. Века с номером 0 нет было; считается, что 1 наступил после -1. "
"Если такое положение вещей вас не устраивает, направляйте жалобы по адресу: "
"Ватикан, Собор Святого Петра, Папе."

#: func.xml:7211(para)
msgid ""
"For <type>timestamp</type> values, the day (of the month) field (1 - 31) ; "
"for <type>interval</type> values, the number of days"
msgstr ""
"Для значений <type>timestamp</type> это день месяца (1 - 31), для значений "
"<type>interval</type> &mdash; число дней"

#: func.xml:7217(computeroutput) func.xml:7557(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "16"
msgstr "16"

#: func.xml:7220(computeroutput) func.xml:7450(computeroutput)
#, no-wrap
msgid "40"
msgstr "40"

#: func.xml:7216(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7228(literal) func.xml:7603(literal)
msgid "decade"
msgstr "decade"

#: func.xml:7230(para)
msgid "The year field divided by 10"
msgstr "Год, делённый на 10"

#: func.xml:7235(computeroutput)
#, no-wrap
msgid "200"
msgstr "200"

#: func.xml:7234(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7240(literal)
msgid "dow"
msgstr "dow"

#: func.xml:7242(para)
msgid ""
"The day of the week as Sunday (<literal>0</literal>) to Saturday "
"(<literal>6</literal>)"
msgstr ""
"День недели, считая с воскресенья (<literal>0</literal>) до субботы "
"(<literal>6</literal>)"

#: func.xml:7248(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "5"
msgstr "5"

#: func.xml:7247(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7249(para)
msgid ""
"Note that <function>extract</function>'s day of the week numbering differs "
"from that of the <function>to_char(..., 'D')</function> function."
msgstr ""
"Заметьте, что в <function>extract</function> дни недели нумеруются не так, "
"как в функции <function>to_char(..., 'D')</function>."

#: func.xml:7259(literal)
msgid "doy"
msgstr "doy"

#: func.xml:7261(para)
msgid "The day of the year (1 - 365/366)"
msgstr "День года (1 - 365/366)"

#: func.xml:7266(computeroutput)
#, no-wrap
msgid "47"
msgstr "47"

#: func.xml:7265(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7271(literal)
msgid "epoch"
msgstr "epoch"

#: func.xml:7273(para)
msgid ""
"For <type>timestamp with time zone</type> values, the number of seconds "
"since 1970-01-01 00:00:00 UTC (can be negative); for <type>date</type> and "
"<type>timestamp</type> values, the number of seconds since 1970-01-01 "
"00:00:00 local time; for <type>interval</type> values, the total number of "
"seconds in the interval"
msgstr ""
"Для значений <type>timestamp with time zone</type> это число секунд с "
"1970-01-01 00:00:00 UTC (может быть отрицательным); для значений <type>date</"
"type> и <type>timestamp</type> это число секунд с 1970-01-01 00:00:00 по "
"местному времени, а для <type>interval</type> &mdash; общая длительность "
"интервала в секундах"

#: func.xml:7283(computeroutput)
#, no-wrap
msgid "982384720.12"
msgstr "982384720.12"

#: func.xml:7286(computeroutput)
#, no-wrap
msgid "442800"
msgstr "442800"

#: func.xml:7282(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE\n"
" '2001-02-16 20:38:40.12-08');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7288(para)
#, fuzzy
msgid ""
"You can convert an epoch value back to a time stamp with "
"<function>to_timestamp</function>:"
msgstr "Преобразовать время эпохи назад, в значение дата/время можно так:"

#: func.xml:7293(computeroutput)
#, fuzzy, no-wrap
msgid "2001-02-17 04:38:40.12+00"
msgstr "2001-02-16 20:00:00"

#: func.xml:7292(screen)
#, fuzzy, no-wrap
msgid ""
"SELECT to_timestamp(982384720.12);\n"
"<placeholder-1/><placeholder-2/>"
msgstr "to_timestamp(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:7298(literal) func.xml:7597(literal)
msgctxt "literal"
msgid "hour"
msgstr "hour"

#: func.xml:7300(para)
msgid "The hour field (0 - 23)"
msgstr "Час (0 - 23)"

#: func.xml:7304(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7310(literal)
msgid "isodow"
msgstr "isodow"

#: func.xml:7312(para)
msgid ""
"The day of the week as Monday (<literal>1</literal>) to Sunday (<literal>7</"
"literal>)"
msgstr ""
"День недели, считая с понедельника (<literal>1</literal>) до воскресенья "
"(<literal>7</literal>)"

#: func.xml:7318(computeroutput) func.xml:7508(computeroutput)
#, no-wrap
msgid "7"
msgstr "7"

#: func.xml:7317(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7319(para)
msgid ""
"This is identical to <literal>dow</literal> except for Sunday. This matches "
"the <acronym>ISO</acronym> 8601 day of the week numbering."
msgstr ""
"Результат отличается от <literal>dow</literal> только для воскресенья. Такая "
"нумерация соответствует <acronym>ISO</acronym> 8601."

#: func.xml:7328(literal)
msgid "isoyear"
msgstr "isoyear"

#: func.xml:7330(para)
msgid ""
"The <acronym>ISO</acronym> 8601 week-numbering year that the date falls in "
"(not applicable to intervals)"
msgstr ""
"Год по недельному календарю <acronym>ISO</acronym> 8601, в который попадает "
"дата (неприменимо к интервалам)"

#: func.xml:7336(computeroutput)
#, no-wrap
msgid "2005"
msgstr "2005"

#: func.xml:7338(computeroutput)
#, no-wrap
msgid "2006"
msgstr "2006"

#: func.xml:7335(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7340(para)
msgid ""
"Each <acronym>ISO</acronym> 8601 week-numbering year begins with the Monday "
"of the week containing the 4th of January, so in early January or late "
"December the <acronym>ISO</acronym> year may be different from the Gregorian "
"year. See the <literal>week</literal> field for more information."
msgstr ""
"Год по недельному календарю <acronym>ISO</acronym> начинается с понедельника "
"недели, в которой оказывается 4 января, так что в начале января или в конце "
"декабря год по <acronym>ISO</acronym> может отличаться от года по "
"григорианскому календарю. Подробнее об этом рассказывается в описании поля "
"<literal>week</literal>."

#: func.xml:7347(para)
msgid "This field is not available in PostgreSQL releases prior to 8.3."
msgstr "Этого поля не было в PostgreSQL до версии 8.3."

#: func.xml:7354(literal) func.xml:7593(literal)
msgid "microseconds"
msgstr "microseconds"

#: func.xml:7356(para)
msgid ""
"The seconds field, including fractional parts, multiplied by 1 000 000; note "
"that this includes full seconds"
msgstr ""
"Значение секунд с дробной частью, умноженное на 1 000 000; заметьте, что оно "
"включает и целые секунды"

#: func.xml:7362(computeroutput)
#, no-wrap
msgid "28500000"
msgstr "28500000"

#: func.xml:7361(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7367(literal) func.xml:7605(literal)
msgid "millennium"
msgstr "millennium"

#: func.xml:7369(para)
msgid "The millennium"
msgstr "Тысячелетие"

#: func.xml:7374(computeroutput) func.xml:7421(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "3"
msgstr "3"

#: func.xml:7373(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7376(para)
msgid ""
"Years in the 1900s are in the second millennium. The third millennium "
"started January 1, 2001."
msgstr ""
"Годы 20 века относятся ко второму тысячелетию. Третье тысячелетие началось 1 "
"января 2001 г."

#: func.xml:7384(literal) func.xml:7594(literal)
msgid "milliseconds"
msgstr "milliseconds"

#: func.xml:7386(para)
msgid ""
"The seconds field, including fractional parts, multiplied by 1000. Note that "
"this includes full seconds."
msgstr ""
"Значение секунд с дробной частью, умноженное на 1 000; заметьте, что оно "
"включает и целые секунды."

#: func.xml:7392(computeroutput)
#, no-wrap
msgid "28500"
msgstr "28500"

#: func.xml:7391(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7397(literal) func.xml:7596(literal)
msgid "minute"
msgstr "minute"

#: func.xml:7399(para)
msgid "The minutes field (0 - 59)"
msgstr "Минуты (0 - 59)"

#: func.xml:7404(computeroutput)
#, no-wrap
msgid "38"
msgstr "38"

#: func.xml:7403(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7411(para)
msgid ""
"For <type>timestamp</type> values, the number of the month within the year "
"(1 - 12) ; for <type>interval</type> values, the number of months, modulo 12 "
"(0 - 11)"
msgstr ""
"Для значений <type>timestamp</type> это номер месяца в году (1 - 12), а для "
"<type>interval</type> &mdash; остаток от деления числа месяцев на 12 (в "
"интервале 0 - 11)"

#: func.xml:7418(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "2"
msgstr "2"

#: func.xml:7424(computeroutput) func.xml:7436(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "1"
msgstr "1"

#: func.xml:7417(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');\n"
"<placeholder-3/><placeholder-4/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');\n"
"<placeholder-5/><placeholder-6/>"
msgstr ""
"SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');\n"
"<placeholder-3/><placeholder-4/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');\n"
"<placeholder-5/><placeholder-6/>"

#: func.xml:7429(literal) func.xml:7601(literal)
msgid "quarter"
msgstr "quarter"

#: func.xml:7431(para)
msgid "The quarter of the year (1 - 4) that the date is in"
msgstr "Квартал года (1 - 4), к которому относится дата"

#: func.xml:7435(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7441(literal) func.xml:7595(literal)
msgid "second"
msgstr "second"

#: func.xml:7445(simpara)
msgid "60 if leap seconds are implemented by the operating system"
msgstr "60, если операционная система поддерживает секунды координации"

#: func.xml:7443(para)
msgid "The seconds field, including fractional parts (0 - 59<placeholder-1/>)"
msgstr "Секунды, включая дробную часть (0 - 59<placeholder-1/>)"

#: func.xml:7453(computeroutput)
#, no-wrap
msgid "28.5"
msgstr "28.5"

#: func.xml:7449(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7457(literal)
msgctxt "literal"
msgid "timezone"
msgstr "timezone"

#: func.xml:7459(para)
msgid ""
"The time zone offset from UTC, measured in seconds. Positive values "
"correspond to time zones east of UTC, negative values to zones west of UTC. "
"(Technically, <productname>PostgreSQL</productname> uses <acronym>UT1</"
"acronym> because leap seconds are not handled.)"
msgstr ""
"Смещение часового пояса от UTC, представленное в секундах. Положительные "
"значения соответствуют часовым поясам к востоку от UTC, а отрицательные "
"&mdash; к западу. (Выражаясь технически точно, <productname>PostgreSQL</"
"productname> использует <acronym>UT1</acronym>, так как секунды координации "
"не учитываются.)"

#: func.xml:7470(literal)
msgid "timezone_hour"
msgstr "timezone_hour"

#: func.xml:7472(para)
msgid "The hour component of the time zone offset"
msgstr "Поле часов в смещении часового пояса"

#: func.xml:7479(literal)
msgid "timezone_minute"
msgstr "timezone_minute"

#: func.xml:7481(para)
msgid "The minute component of the time zone offset"
msgstr "Поле минут в смещении часового пояса"

#: func.xml:7488(literal) func.xml:7599(literal)
msgid "week"
msgstr "week"

#: func.xml:7490(para)
msgid ""
"The number of the <acronym>ISO</acronym> 8601 week-numbering week of the "
"year. By definition, ISO weeks start on Mondays and the first week of a year "
"contains January 4 of that year. In other words, the first Thursday of a "
"year is in week 1 of that year."
msgstr ""
"Номер недели в году по недельному календарю <acronym>ISO</acronym> 8601. По "
"определению, недели <acronym>ISO</acronym> 8601 начинаются с понедельника, а "
"первая неделя года включает 4 января этого года. Другими словами, первый "
"четверг года всегда оказывается в 1 неделе этого года."

#: func.xml:7496(para)
msgid ""
"In the ISO week-numbering system, it is possible for early-January dates to "
"be part of the 52nd or 53rd week of the previous year, and for late-December "
"dates to be part of the first week of the next year. For example, "
"<literal>2005-01-01</literal> is part of the 53rd week of year 2004, and "
"<literal>2006-01-01</literal> is part of the 52nd week of year 2005, while "
"<literal>2012-12-31</literal> is part of the first week of 2013. It's "
"recommended to use the <literal>isoyear</literal> field together with "
"<literal>week</literal> to get consistent results."
msgstr ""
"В системе нумерации недель ISO первые числа января могут относиться к 52-ой "
"или 53-ей неделе предыдущего года, а последние числа декабря &mdash; к "
"первой неделе следующего года. Например, <literal>2005-01-01</literal> "
"относится к 53-ей неделе 2004 г., а <literal>2006-01-01</literal> &mdash; к "
"52-ей неделе 2005 г., тогда как <literal>2012-12-31</literal> включается в "
"первую неделю 2013 г. Поэтому для получения согласованных результатов "
"рекомендуется использовать поле <literal>isoyear</literal> в паре с "
"<literal>week</literal>."

#: func.xml:7507(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7513(literal) func.xml:7602(literal)
msgctxt "literal"
msgid "year"
msgstr "year"

#: func.xml:7515(para)
msgid ""
"The year field. Keep in mind there is no <literal>0 AD</literal>, so "
"subtracting <literal>BC</literal> years from <literal>AD</literal> years "
"should be done with care."
msgstr ""
"Поле года. Учтите, что года <literal>0</literal> не было, и это следует "
"иметь в виду, вычитая из годов нашей эры годы до нашей эры."

#: func.xml:7521(computeroutput)
#, no-wrap
msgid "2001"
msgstr "2001"

#: func.xml:7520(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7169(para)
msgid ""
"The <function>extract</function> function retrieves subfields such as year "
"or hour from date/time values. <replaceable>source</replaceable> must be a "
"value expression of type <type>timestamp</type>, <type>time</type>, or "
"<type>interval</type>. (Expressions of type <type>date</type> are cast to "
"<type>timestamp</type> and can therefore be used as well.) "
"<replaceable>field</replaceable> is an identifier or string that selects "
"what field to extract from the source value. The <function>extract</"
"function> function returns values of type <type>double precision</type>. The "
"following are valid field names: <placeholder-1/>"
msgstr ""
"Функция <function>extract</function> получает из значений даты/времени поля, "
"такие как год или час. Здесь <replaceable>источник</replaceable> &mdash; "
"значение типа <type>timestamp</type>, <type>time</type> или <type>interval</"
"type>. (Выражения типа <type>date</type> приводятся к типу <type>timestamp</"
"type>, так что допускается и этот тип.) Указанное <replaceable>поле</"
"replaceable> представляет собой идентификатор, по которому из источника "
"выбирается заданное поле. Функция <function>extract</function> возвращает "
"значения типа <type>double precision</type>. Допустимые поля: <placeholder-1/"
">"

#: func.xml:7529(para)
msgid ""
"When the input value is +/-Infinity, <function>extract</function> returns +/-"
"Infinity for monotonically-increasing fields (<literal>epoch</literal>, "
"<literal>julian</literal>, <literal>year</literal>, <literal>isoyear</"
"literal>, <literal>decade</literal>, <literal>century</literal>, and "
"<literal>millennium</literal>). For other fields, NULL is returned. "
"<productname>PostgreSQL</productname> versions before 9.6 returned zero for "
"all cases of infinite input."
msgstr ""

#: func.xml:7539(para)
msgid ""
"The <function>extract</function> function is primarily intended for "
"computational processing. For formatting date/time values for display, see "
"<xref linkend=\"functions-formatting\"/>."
msgstr ""
"Функция <function>extract</function> в основном предназначена для "
"вычислительных целей. Функции форматирования даты/времени описаны в <xref "
"remap=\"6\" linkend=\"functions-formatting\"/>."

#: func.xml:7545(para)
msgid ""
"The <function>date_part</function> function is modeled on the traditional "
"<productname>Ingres</productname> equivalent to the <acronym>SQL</acronym>-"
"standard function <function>extract</function>: "
"<synopsis>date_part('<replaceable>field</replaceable>', <replaceable>source</"
"replaceable>)</synopsis> Note that here the <replaceable>field</replaceable> "
"parameter needs to be a string value, not a name. The valid field names for "
"<function>date_part</function> are the same as for <function>extract</"
"function>."
msgstr ""
"Функция <function>date_part</function> эмулирует традиционный для "
"<productname>Ingres</productname> эквивалент стандартной <acronym>SQL</"
"acronym>-функции <function>extract</function>: "
"<synopsis>date_part('<replaceable>поле</replaceable>', "
"<replaceable>источник</replaceable>)</synopsis> Заметьте, что здесь параметр "
"<replaceable>поле</replaceable> должен быть строковым значением, а не "
"именем. Функция <function>date_part</function> воспринимает те же поля, что "
"и <function>extract</function>."

#: func.xml:7560(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "4"
msgstr "4"

#: func.xml:7556(screen)
#, no-wrap
msgid ""
"SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT date_part('hour', INTERVAL '4 hours 3 minutes');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT date_part('hour', INTERVAL '4 hours 3 minutes');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7565(function)
msgid "date_trunc"
msgstr "date_trunc"

#: func.xml:7571(para)
msgid ""
"The function <function>date_trunc</function> is conceptually similar to the "
"<function>trunc</function> function for numbers."
msgstr ""
"Функция <function>date_trunc</function> работает подобно <function>trunc</"
"function> для чисел."

#: func.xml:7576(para)
msgid ""
"<synopsis>date_trunc('<replaceable>field</replaceable>', "
"<replaceable>source</replaceable>)</synopsis>\n"
"    <replaceable>source</replaceable> is a value expression of type "
"<type>timestamp</type> or <type>interval</type>. (Values of type <type>date</"
"type> and <type>time</type> are cast automatically to <type>timestamp</type> "
"or <type>interval</type>, respectively.) <replaceable>field</replaceable> "
"selects to which precision to truncate the input value. The return value is "
"of type <type>timestamp</type> or <type>interval</type> with all fields that "
"are less significant than the selected one set to zero (or one, for day and "
"month)."
msgstr ""
"<synopsis>date_trunc('<replaceable>поле</replaceable>', "
"<replaceable>значение</replaceable>)</synopsis>\n"
"Здесь <replaceable>значение</replaceable> &mdash; это выражение типа "
"<type>timestamp</type> или <type>interval</type>. (Значения типов "
"<type>date</type> и <type>time</type> автоматически приводятся к типам "
"<type>timestamp</type> и <type>interval</type>, соответственно.) Параметр "
"<replaceable>поле</replaceable> определяет, до какой точности обрезать "
"переданное значение. Возвращаемое значение будет иметь тип <type>timestamp</"
"type> или <type>interval</type> и все его значения, менее значимые, чем "
"заданное поле, будут равны нулю (или единице, если это номер дня или месяца)."

#: func.xml:7590(para)
msgid "Valid values for <replaceable>field</replaceable> are: <placeholder-1/>"
msgstr ""
"Параметр <replaceable>поле</replaceable> может принимать следующие значения: "
"<placeholder-1/>"

#: func.xml:7609(para)
msgid ""
"Examples: <screen>SELECT date_trunc('hour', TIMESTAMP '2001-02-16 "
"20:38:40');\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 "
"20:00:00</computeroutput>\n"
"\n"
"SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 "
"00:00:00</computeroutput></screen>"
msgstr ""
"Примеры: <screen>SELECT date_trunc('hour', TIMESTAMP '2001-02-16 "
"20:38:40');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 "
"20:00:00</computeroutput>\n"
"\n"
"SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-01-01 "
"00:00:00</computeroutput></screen>"

#: func.xml:7620(literal)
msgid "AT TIME ZONE"
msgstr "AT TIME ZONE"

#: func.xml:7622(indexterm)
msgid "<primary>time zone</primary><secondary>conversion</secondary>"
msgstr "<primary>часовой пояс</primary><secondary>преобразование</secondary>"

#: func.xml:7626(indexterm)
msgid "<primary>AT TIME ZONE</primary>"
msgstr "<primary>AT TIME ZONE</primary>"

#: func.xml:7630(para)
msgid ""
"The <literal>AT TIME ZONE</literal> construct allows conversions of time "
"stamps to different time zones. <xref linkend=\"functions-datetime-"
"zoneconvert-table\"/> shows its variants."
msgstr ""
"Конструкция <literal>AT TIME ZONE</literal> позволяет переводить время в "
"разные часовые пояса. Все её разновидности показаны в <xref remap=\"6\" "
"linkend=\"functions-datetime-zoneconvert-table\"/>."

#: func.xml:7638(title)
msgid "<literal>AT TIME ZONE</literal> Variants"
msgstr "Разновидности <literal>AT TIME ZONE</literal>"

#: func.xml:7651(type) func.xml:7661(type)
msgid "timestamp without time zone"
msgstr "timestamp without time zone"

#: func.xml:7651(replaceable) func.xml:7659(replaceable)
#: func.xml:7668(replaceable)
msgid "zone"
msgstr "часовой_пояс"

#: func.xml:7651(literal) func.xml:7659(literal) func.xml:7668(literal)
msgid "<placeholder-1/> AT TIME ZONE <placeholder-2/>"
msgstr "<placeholder-1/> AT TIME ZONE <placeholder-2/>"

#: func.xml:7654(entry)
msgid ""
"Treat given time stamp <emphasis>without time zone</emphasis> as located in "
"the specified time zone"
msgstr ""
"Воспринимает заданное время <emphasis>без указания часового пояса</emphasis> "
"как время в указанном часовом поясе"

#: func.xml:7662(entry)
msgid ""
"Convert given time stamp <emphasis>with time zone</emphasis> to the new time "
"zone, with no time zone designation"
msgstr ""
"Переводит данное значение timestamp <emphasis>с часовым поясом</emphasis> в "
"другой часовой пояс, но не сохраняет информацию о нём в результате"

#: func.xml:7671(entry)
msgid ""
"Convert given time <emphasis>with time zone</emphasis> to the new time zone"
msgstr ""
"Переводит данное время <emphasis>с часовым поясом</emphasis> в другой "
"часовой пояс"

#: func.xml:7677(para)
msgid ""
"In these expressions, the desired time zone <replaceable>zone</replaceable> "
"can be specified either as a text string (e.g., <literal>'PST'</literal>) or "
"as an interval (e.g., <literal>INTERVAL '-08:00'</literal>). In the text "
"case, a time zone name can be specified in any of the ways described in "
"<xref linkend=\"datatype-timezones\"/>."
msgstr ""
"В этих выражениях желаемый <replaceable>часовой_пояс</replaceable> можно "
"задать либо в виде текстовой строки (например, <literal>'PST'</literal>) или "
"как интервал (например, <literal>INTERVAL '-08:00'</literal>). В первом "
"случае название часового пояса можно указать любым из способов, описанных в "
"<xref remap=\"6\" linkend=\"datatype-timezones\"/>."

#: func.xml:7685(para)
msgid ""
"Examples (assuming the local time zone is <literal>PST8PDT</literal>): "
"<screen>SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 "
"19:38:40-08</computeroutput>\n"
"\n"
"SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE "
"'MST';\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 "
"18:38:40</computeroutput></screen> The first example takes a time stamp "
"without time zone and interprets it as MST time (UTC-7), which is then "
"converted to PST (UTC-8) for display. The second example takes a time stamp "
"specified in EST (UTC-5) and converts it to local time in MST (UTC-7)."
msgstr ""
"Примеры (в предположении, что местный часовой пояс <literal>PST8PDT</"
"literal>): <screen>SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE "
"'MST';\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 "
"19:38:40-08</computeroutput>\n"
"\n"
"SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE "
"'MST';\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 "
"18:38:40</computeroutput></screen> В первом примере время без часового пояса "
"интерпретируется как время в часовом поясе MST (UTC-7), а затем оно "
"преобразуется в PST (UTC-8) для вывода. Во втором примере время, указанное с "
"часовым поясом EST (UTC-5), преобразуется во время для часового пояса MST "
"(UTC-7)."

#: func.xml:7697(para)
msgid ""
"The function <literal><function>timezone</function>(<replaceable>zone</"
"replaceable>, <replaceable>timestamp</replaceable>)</literal> is equivalent "
"to the SQL-conforming construct <literal><replaceable>timestamp</"
"replaceable> AT TIME ZONE <replaceable>zone</replaceable></literal>."
msgstr ""
"Функция <literal><function>timezone</function>(<replaceable>часовой_пояс</"
"replaceable>, <replaceable>время</replaceable>)</literal> равнозначна SQL-"
"совместимой конструкции <literal><replaceable>время</replaceable> AT TIME "
"ZONE <replaceable>часовой_пояс</replaceable></literal>."

#: func.xml:7706(title)
msgid "Current Date/Time"
msgstr "Текущая дата/время"

#: func.xml:7708(indexterm)
msgid "<primary>date</primary><secondary>current</secondary>"
msgstr "<primary>дата</primary><secondary>текущая</secondary>"

#: func.xml:7712(indexterm)
msgid "<primary>time</primary><secondary>current</secondary>"
msgstr "<primary>время</primary><secondary>текущее</secondary>"

#: func.xml:7716(para)
msgid ""
"<productname>PostgreSQL</productname> provides a number of functions that "
"return values related to the current date and time. These SQL-standard "
"functions all return values based on the start time of the current "
"transaction: <synopsis>CURRENT_DATE\n"
"CURRENT_TIME\n"
"CURRENT_TIMESTAMP\n"
"CURRENT_TIME(<replaceable>precision</replaceable>)\n"
"CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)\n"
"LOCALTIME\n"
"LOCALTIMESTAMP\n"
"LOCALTIME(<replaceable>precision</replaceable>)\n"
"LOCALTIMESTAMP(<replaceable>precision</replaceable>)</synopsis>"
msgstr ""
"<productname>PostgreSQL</productname> предоставляет набор функций, результат "
"которых зависит от текущей даты и времени. Все следующие функции "
"соответствуют стандарту SQL и возвращают значения, отражающие время начала "
"текущей транзакции: <synopsis>CURRENT_DATE\n"
"CURRENT_TIME\n"
"CURRENT_TIMESTAMP\n"
"CURRENT_TIME(<replaceable>точность</replaceable>)\n"
"CURRENT_TIMESTAMP(<replaceable>точность</replaceable>)\n"
"LOCALTIME\n"
"LOCALTIMESTAMP\n"
"LOCALTIME(<replaceable>точность</replaceable>)\n"
"LOCALTIMESTAMP(<replaceable>точность</replaceable>)</synopsis>"

#: func.xml:7732(para)
msgid ""
"<function>CURRENT_TIME</function> and <function>CURRENT_TIMESTAMP</function> "
"deliver values with time zone; <function>LOCALTIME</function> and "
"<function>LOCALTIMESTAMP</function> deliver values without time zone."
msgstr ""
"<function>CURRENT_TIME</function> и <function>CURRENT_TIMESTAMP</function> "
"возвращают время с часовым поясом. В результатах <function>LOCALTIME</"
"function> и <function>LOCALTIMESTAMP</function> нет информации о часовом "
"поясе."

#: func.xml:7739(para)
msgid ""
"<function>CURRENT_TIME</function>, <function>CURRENT_TIMESTAMP</function>, "
"<function>LOCALTIME</function>, and <function>LOCALTIMESTAMP</function> can "
"optionally take a precision parameter, which causes the result to be rounded "
"to that many fractional digits in the seconds field. Without a precision "
"parameter, the result is given to the full available precision."
msgstr ""
"<function>CURRENT_TIME</function>, <function>CURRENT_TIMESTAMP</function>, "
"<function>LOCALTIME</function> и <function>LOCALTIMESTAMP</function> могут "
"принимать необязательный параметр точности, определяющий, до какого знака "
"после запятой следует округлять поле секунд. Если этот параметр отсутствует, "
"результат будет иметь максимально возможную точность."

#: func.xml:7750(para)
msgid ""
"Some examples: <screen>SELECT CURRENT_TIME;\n"
"<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</"
"computeroutput>\n"
"\n"
"SELECT CURRENT_DATE;\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23</"
"computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP;\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522-05</computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP(2);\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.66-05</computeroutput>\n"
"\n"
"SELECT LOCALTIMESTAMP;\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522</computeroutput></screen>"
msgstr ""
"Несколько примеров: <screen>SELECT CURRENT_TIME;\n"
"<lineannotation>Результат: </"
"lineannotation><computeroutput>14:39:53.662522-05</computeroutput>\n"
"\n"
"SELECT CURRENT_DATE;\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23</"
"computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP;\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522-05</computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP(2);\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.66-05</computeroutput>\n"
"\n"
"SELECT LOCALTIMESTAMP;\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522</computeroutput></screen>"

#: func.xml:7768(para)
msgid ""
"Since these functions return the start time of the current transaction, "
"their values do not change during the transaction. This is considered a "
"feature: the intent is to allow a single transaction to have a consistent "
"notion of the <quote>current</quote> time, so that multiple modifications "
"within the same transaction bear the same time stamp."
msgstr ""
"Так как эти функции возвращают время начала текущей транзакции, во время "
"транзакции эти значения не меняются. Это считается не ошибкой, а "
"особенностью реализации: цель такого поведения в том, чтобы в одной "
"транзакции <quote>текущее</quote> время было одинаковым и для разных "
"изменений в одной транзакций записывалась одна отметка времени."

#: func.xml:7779(para)
msgid "Other database systems might advance these values more frequently."
msgstr "В других СУБД эти значения могут изменяться чаще."

#: func.xml:7785(para)
msgid ""
"<productname>PostgreSQL</productname> also provides functions that return "
"the start time of the current statement, as well as the actual current time "
"at the instant the function is called. The complete list of non-SQL-standard "
"time functions is: <synopsis>transaction_timestamp()\n"
"statement_timestamp()\n"
"clock_timestamp()\n"
"timeofday()\n"
"now()</synopsis>"
msgstr ""
"В <productname>PostgreSQL</productname> есть также функции, возвращающие "
"время начала текущего оператора, а также текущее время в момент вызова "
"функции. Таким образом, в <productname>PostgreSQL</productname> есть "
"следующие функции, не описанные в стандарте SQL: "
"<synopsis>transaction_timestamp()\n"
"statement_timestamp()\n"
"clock_timestamp()\n"
"timeofday()\n"
"now()</synopsis>"

#: func.xml:7797(para)
msgid ""
"<function>transaction_timestamp()</function> is equivalent to "
"<function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect what "
"it returns. <function>statement_timestamp()</function> returns the start "
"time of the current statement (more specifically, the time of receipt of the "
"latest command message from the client). <function>statement_timestamp()</"
"function> and <function>transaction_timestamp()</function> return the same "
"value during the first command of a transaction, but might differ during "
"subsequent commands. <function>clock_timestamp()</function> returns the "
"actual current time, and therefore its value changes even within a single "
"SQL command. <function>timeofday()</function> is a historical "
"<productname>PostgreSQL</productname> function. Like "
"<function>clock_timestamp()</function>, it returns the actual current time, "
"but as a formatted <type>text</type> string rather than a <type>timestamp "
"with time zone</type> value. <function>now()</function> is a traditional "
"<productname>PostgreSQL</productname> equivalent to "
"<function>transaction_timestamp()</function>."
msgstr ""
"Функция <function>transaction_timestamp()</function> равнозначна конструкции "
"<function>CURRENT_TIMESTAMP</function>, но в её названии явно отражено, что "
"она возвращает. Функция <function>statement_timestamp()</function> "
"возвращает время начала текущего оператора (более точно, время получения "
"последнего командного сообщения от клиента). Функции "
"<function>statement_timestamp()</function> и "
"<function>transaction_timestamp()</function> возвращают одно и то же "
"значение в первой команде транзакции, но в последующих их показания будут "
"расходиться. Функция <function>clock_timestamp()</function> возвращает "
"фактическое текущее время, так что её значение меняется в рамках одной "
"команды SQL. Функция <function>timeofday()</function> существует в "
"<productname>PostgreSQL</productname> по историческим причинам и, подобно "
"<function>clock_timestamp()</function>, она возвращает фактическое текущее "
"время, но представленное в виде форматированной строки типа <type>text</"
"type>, а не значения <type>timestamp with time zone</type>. Функция "
"<function>now()</function> &mdash; традиционный для <productname>PostgreSQL</"
"productname> эквивалент функции <function>transaction_timestamp()</function>."

#: func.xml:7823(programlisting)
#, no-wrap
msgid ""
"SELECT CURRENT_TIMESTAMP;\n"
"SELECT now();\n"
"SELECT TIMESTAMP 'now';  -- incorrect for use with DEFAULT"
msgstr ""
"SELECT CURRENT_TIMESTAMP;\n"
"SELECT now();\n"
"SELECT TIMESTAMP 'now';  -- не подходит для DEFAULT"

#: func.xml:7818(para)
msgid ""
"All the date/time data types also accept the special literal value "
"<literal>now</literal> to specify the current date and time (again, "
"interpreted as the transaction start time). Thus, the following three all "
"return the same result: <placeholder-1/>"
msgstr ""
"Все типы даты/времени также принимают специальное буквальное значение "
"<literal>now</literal>, подразумевающее текущую дату и время (тоже на момент "
"начала транзакции). Таким образом, результат следующих трёх операторов будет "
"одинаковым: <placeholder-1/>"

#: func.xml:7829(para)
msgid ""
"You do not want to use the third form when specifying a <literal>DEFAULT</"
"literal> clause while creating a table. The system will convert "
"<literal>now</literal> to a <type>timestamp</type> as soon as the constant "
"is parsed, so that when the default value is needed, the time of the table "
"creation would be used! The first two forms will not be evaluated until the "
"default value is used, because they are function calls. Thus they will give "
"the desired behavior of defaulting to the time of row insertion."
msgstr ""
"Третья форма не подходит для указания в качестве значения <literal>DEFAULT</"
"literal> при создании таблицы. Система преобразует <literal>now</literal> в "
"значение <type>timestamp</type> в момент разбора константы, поэтому, когда "
"будет вставляться значение по умолчанию, в соответствующем столбце окажется "
"время создания таблицы! Первые две формы не будут вычисляться, пока не "
"потребуется значение по умолчанию, так как это вызовы функции. Поэтому они "
"дадут желаемый результат при добавлении строки в таблицу."

#: func.xml:7843(title)
msgid "Delaying Execution"
msgstr "Задержка выполнения"

#: func.xml:7845(indexterm)
msgid "<primary>pg_sleep</primary>"
msgstr "<primary>pg_sleep</primary>"

#: func.xml:7848(indexterm)
msgid "<primary>pg_sleep_for</primary>"
msgstr "<primary>pg_sleep_for</primary>"

#: func.xml:7851(indexterm)
msgid "<primary>pg_sleep_until</primary>"
msgstr "<primary>pg_sleep_until</primary>"

#: func.xml:7854(indexterm)
msgid "<primary>sleep</primary>"
msgstr "<primary>sleep</primary>"

#: func.xml:7857(indexterm)
msgid "<primary>delay</primary>"
msgstr "<primary>задержка</primary>"

#: func.xml:7878(programlisting)
#, no-wrap
msgid ""
"SELECT pg_sleep(1.5);\n"
"SELECT pg_sleep_for('5 minutes');\n"
"SELECT pg_sleep_until('tomorrow 03:00');"
msgstr ""
"SELECT pg_sleep(1.5);\n"
"SELECT pg_sleep_for('5 minutes');\n"
"SELECT pg_sleep_until('tomorrow 03:00');"

#: func.xml:7861(para)
msgid ""
"The following functions are available to delay execution of the server "
"process: <synopsis>pg_sleep(<replaceable>seconds</replaceable>)\n"
"pg_sleep_for(<type>interval</type>)\n"
"pg_sleep_until(<type>timestamp with time zone</type>)</synopsis>\n"
"\n"
"    <function>pg_sleep</function> makes the current session's process sleep "
"until <replaceable>seconds</replaceable> seconds have elapsed. "
"<replaceable>seconds</replaceable> is a value of type <type>double "
"precision</type>, so fractional-second delays can be specified. "
"<function>pg_sleep_for</function> is a convenience function for larger sleep "
"times specified as an <type>interval</type>. <function>pg_sleep_until</"
"function> is a convenience function for when a specific wake-up time is "
"desired. For example: <placeholder-1/>"
msgstr ""
"В случае необходимости вы можете приостановить выполнение серверного "
"процесса, используя следующие функции: <synopsis>pg_sleep(<replaceable>сек</"
"replaceable>)\n"
"pg_sleep_for(<type>interval</type>)\n"
"pg_sleep_until(<type>timestamp with time zon</type>)</synopsis>\n"
"\n"
"    Функция <function>pg_sleep</function> переводит процесс текущего сеанса "
"в спящее состояние на указанное число секунд (<replaceable>сек</"
"replaceable>). Параметр <replaceable>сек</replaceable> имеет тип "
"<type>double precision</type>, так что в нём можно указать и дробное число. "
"Функция <function>pg_sleep_for</function> введена для удобства, ей можно "
"передать большие значения задержки в типе <type>interval</type>. А "
"<function>pg_sleep_until</function> удобнее использовать, когда необходимо "
"задать определённое время выхода из спящего состояния. Например: "
"<placeholder-1/>"

#: func.xml:7884(para)
msgid ""
"The effective resolution of the sleep interval is platform-specific; 0.01 "
"seconds is a common value. The sleep delay will be at least as long as "
"specified. It might be longer depending on factors such as server load. In "
"particular, <function>pg_sleep_until</function> is not guaranteed to wake up "
"exactly at the specified time, but it will not wake up any earlier."
msgstr ""
"Действительное разрешение интервала задержки зависит от платформы; обычно "
"это 0.01. Фактическая длительность задержки не будет меньше указанного "
"времени, но может быть больше, в зависимости, например от нагрузки на "
"сервер. В частности, не гарантируется, что <function>pg_sleep_until</"
"function> проснётся именно в указанное время, но она точно не проснётся "
"раньше."

#: func.xml:7894(para)
msgid ""
"Make sure that your session does not hold more locks than necessary when "
"calling <function>pg_sleep</function> or its variants. Otherwise other "
"sessions might have to wait for your sleeping process, slowing down the "
"entire system."
msgstr ""
"Прежде чем вызывать <function>pg_sleep</function> или её вариации, убедитесь "
"в том, что в текущем сеансе нет ненужных блокировок. В противном случае в "
"состояние ожидания могут перейти и другие сеансы, так что это отразится на "
"системе в целом."

#: func.xml:7907(title) func.xml:7921(title)
msgid "Enum Support Functions"
msgstr "Функции для перечислений"

#: func.xml:7916(programlisting)
#, no-wrap
msgid "CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');"
msgstr ""
"CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green',\n"
" 'blue', 'purple');"

#: func.xml:7909(para)
msgid ""
"For enum types (described in <xref linkend=\"datatype-enum\"/>), there are "
"several functions that allow cleaner programming without hard-coding "
"particular values of an enum type. These are listed in <xref linkend="
"\"functions-enum-table\"/>. The examples assume an enum type created as: "
"<placeholder-1/>"
msgstr ""
"Для типов перечислений (описанных в <xref remap=\"6\" linkend=\"datatype-enum"
"\"/>) предусмотрено несколько функций, которые позволяют сделать код чище, "
"не &laquo;зашивая&raquo; в нём конкретные значения перечисления. Эти функции "
"перечислены в <xref remap=\"6\" linkend=\"functions-enum-table\"/>. В этих "
"примерах подразумевается, что перечисление создано так: <placeholder-1/>"

#: func.xml:7934(indexterm)
msgid "<primary>enum_first</primary>"
msgstr "<primary>enum_first</primary>"

#: func.xml:7937(literal)
msgid "enum_first(anyenum)"
msgstr "enum_first(anyenum)"

#: func.xml:7939(entry)
msgid "Returns the first value of the input enum type"
msgstr "Возвращает первое значение заданного перечисления"

#: func.xml:7940(literal)
msgid "enum_first(null::rainbow)"
msgstr "enum_first(null::rainbow)"

#: func.xml:7941(literal)
msgid "red"
msgstr "red"

#: func.xml:7945(indexterm)
msgid "<primary>enum_last</primary>"
msgstr "<primary>enum_last</primary>"

#: func.xml:7948(literal)
msgid "enum_last(anyenum)"
msgstr "enum_last(anyenum)"

#: func.xml:7950(entry)
msgid "Returns the last value of the input enum type"
msgstr "Возвращает последнее значение заданного перечисления"

#: func.xml:7951(literal)
msgid "enum_last(null::rainbow)"
msgstr "enum_last(null::rainbow)"

#: func.xml:7952(literal)
msgid "purple"
msgstr "purple"

#: func.xml:7956(indexterm)
msgid "<primary>enum_range</primary>"
msgstr "<primary>enum_range</primary>"

#: func.xml:7959(literal)
msgid "enum_range(anyenum)"
msgstr "enum_range(anyenum)"

#: func.xml:7961(entry)
msgid "Returns all values of the input enum type in an ordered array"
msgstr "Возвращает все значения заданного перечисления в упорядоченном массиве"

#: func.xml:7962(literal)
msgid "enum_range(null::rainbow)"
msgstr "enum_range(null::rainbow)"

#: func.xml:7963(literal)
msgid "{red,orange,yellow,green,blue,purple}"
msgstr "{red,orange,yellow,green,blue,purple}"

#: func.xml:7966(literal)
msgid "enum_range(anyenum, anyenum)"
msgstr "enum_range(anyenum, anyenum)"

#: func.xml:7967(entry)
msgid ""
"Returns the range between the two given enum values, as an ordered array. "
"The values must be from the same enum type. If the first parameter is null, "
"the result will start with the first value of the enum type. If the second "
"parameter is null, the result will end with the last value of the enum type."
msgstr ""
"Возвращает набор значений, лежащих между двумя заданными, в виде "
"упорядоченного массива. Эти значения должны принадлежать одному "
"перечислению. Если первый параметр равен NULL, функция возвращает первое "
"значение перечисления, а если NULL второй &mdash; последнее."

#: func.xml:7975(literal)
msgid "enum_range('orange'::rainbow, 'green'::rainbow)"
msgstr "enum_range('orange'::rainbow, 'green'::rainbow)"

#: func.xml:7976(literal)
msgid "{orange,yellow,green}"
msgstr "{orange,yellow,green}"

#: func.xml:7979(literal)
msgid "enum_range(NULL, 'green'::rainbow)"
msgstr "enum_range(NULL, 'green'::rainbow)"

#: func.xml:7980(literal)
msgid "{red,orange,yellow,green}"
msgstr "{red,orange,yellow,green}"

#: func.xml:7983(literal)
msgid "enum_range('orange'::rainbow, NULL)"
msgstr "enum_range('orange'::rainbow, NULL)"

#: func.xml:7984(literal)
msgid "{orange,yellow,green,blue,purple}"
msgstr "{orange,yellow,green,blue,purple}"

#: func.xml:7990(para)
msgid ""
"Notice that except for the two-argument form of <function>enum_range</"
"function>, these functions disregard the specific value passed to them; they "
"care only about its declared data type. Either null or a specific value of "
"the type can be passed, with the same result. It is more common to apply "
"these functions to a table column or function argument than to a hardwired "
"type name as suggested by the examples."
msgstr ""
"Заметьте, что за исключением варианта <function>enum_range</function> с "
"двумя аргументами, эти функции не обращают внимание на конкретное переданное "
"им значение; их интересует только объявленный тип. Они возвращают один и тот "
"же результат, когда им передаётся NULL или любое другое значение типа. "
"Обычно эти функции применяются к столбцам таблицы или аргументам внешних "
"функций, а не к предопределённым типам, как показано в этих примерах."

#: func.xml:8001(title)
msgid "Geometric Functions and Operators"
msgstr "Геометрические функции и операторы"

#: func.xml:8003(para)
msgid ""
"The geometric types <type>point</type>, <type>box</type>, <type>lseg</type>, "
"<type>line</type>, <type>path</type>, <type>polygon</type>, and "
"<type>circle</type> have a large set of native support functions and "
"operators, shown in <xref linkend=\"functions-geometry-op-table\"/>, <xref "
"linkend=\"functions-geometry-func-table\"/>, and <xref linkend=\"functions-"
"geometry-conv-table\"/>."
msgstr ""
"Для геометрических типов <type>point</type>, <type>box</type>, <type>lseg</"
"type>, <type>line</type>, <type>path</type>, <type>polygon</type> и "
"<type>circle</type> разработан большой набор встроенных функций и "
"операторов, представленный в <xref remap=\"6\" linkend=\"functions-geometry-"
"op-table\"/>, <xref remap=\"6\" linkend=\"functions-geometry-func-table\"/> "
"и <xref remap=\"6\" linkend=\"functions-geometry-conv-table\"/>."

#: func.xml:8014(para)
msgid ""
"Note that the <quote>same as</quote> operator, <literal>~=</literal>, "
"represents the usual notion of equality for the <type>point</type>, "
"<type>box</type>, <type>polygon</type>, and <type>circle</type> types. Some "
"of these types also have an <literal>=</literal> operator, but <literal>=</"
"literal> compares for equal <emphasis>areas</emphasis> only. The other "
"scalar comparison operators (<literal>&lt;=</literal> and so on) likewise "
"compare areas for these types."
msgstr ""
"Заметьте, что оператор <quote>идентичности</quote>, <literal>~=</literal>, "
"представляет обычное сравнение на равенство значений <type>point</type>, "
"<type>box</type>, <type>polygon</type> и <type>circle</type>. Для некоторых "
"из этих типов определён также оператор <literal>=</literal>, но <literal>=</"
"literal> проверяет только равенство <emphasis>площадей</emphasis>. Другие "
"скалярные операторы сравнения (<literal>&lt;=</literal> и т. д.) так же "
"сравнивают площади значений этих типов."

#: func.xml:8026(title)
msgid "Geometric Operators"
msgstr "Геометрические операторы"

#: func.xml:8038(entry) func.xml:8043(entry)
msgid "Translation"
msgstr "Сдвиг"

#: func.xml:8039(literal)
msgid "box '((0,0),(1,1))' + point '(2.0,0)'"
msgstr "box '((0,0),(1,1))' + point '(2.0,0)'"

#: func.xml:8044(literal)
msgid "box '((0,0),(1,1))' - point '(2.0,0)'"
msgstr "box '((0,0),(1,1))' - point '(2.0,0)'"

#: func.xml:8048(entry) func.xml:8053(entry)
msgid "Scaling/rotation"
msgstr "Масштабирование/поворот"

#: func.xml:8049(literal)
msgid "box '((0,0),(1,1))' * point '(2.0,0)'"
msgstr "box '((0,0),(1,1))' * point '(2.0,0)'"

#: func.xml:8054(literal)
msgid "box '((0,0),(2,2))' / point '(2.0,0)'"
msgstr "box '((0,0),(2,2))' / point '(2.0,0)'"

#: func.xml:8058(entry)
msgid "Point or box of intersection"
msgstr "Точка или прямоугольник в пересечении"

#: func.xml:8059(literal)
msgid "'((1,-1),(-1,1))' # '((1,1),(-1,-1))'"
msgstr "'((1,-1),(-1,1))' # '((1,1),(-1,-1))'"

#: func.xml:8063(entry)
msgid "Number of points in path or polygon"
msgstr "Число точек в пути или вершин в многоугольнике"

#: func.xml:8064(literal)
msgid "# '((1,0),(0,1),(-1,0))'"
msgstr "# '((1,0),(0,1),(-1,0))'"

#: func.xml:8067(literal)
msgid "@-@"
msgstr "@-@"

#: func.xml:8068(entry)
msgid "Length or circumference"
msgstr "Длина, периметр или длина окружности"

#: func.xml:8069(literal)
msgid "@-@ path '((0,0),(1,0))'"
msgstr "@-@ path '((0,0),(1,0))'"

#: func.xml:8072(literal) func.xml:8945(literal)
msgid "@@"
msgstr "@@"

#: func.xml:8073(entry)
msgid "Center"
msgstr "Центр"

#: func.xml:8074(literal)
msgid "@@ circle '((0,0),10)'"
msgstr "@@ circle '((0,0),10)'"

#: func.xml:8077(literal)
msgid "##"
msgstr "##"

#: func.xml:8078(entry)
msgid "Closest point to first operand on second operand"
msgstr "Точка, ближайшая к первому операнду и принадлежащая второму"

#: func.xml:8079(literal)
msgid "point '(0,0)' ## lseg '((2,0),(0,2))'"
msgstr "point '(0,0)' ## lseg '((2,0),(0,2))'"

#: func.xml:8082(literal) func.xml:8987(literal)
msgid "&lt;-&gt;"
msgstr "&lt;-&gt;"

#: func.xml:8083(entry)
msgid "Distance between"
msgstr "Расстояние между операндами"

#: func.xml:8084(literal)
msgid "circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'"
msgstr "circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'"

#: func.xml:8087(literal) func.xml:8623(literal) func.xml:8966(literal)
#: func.xml:11714(literal) func.xml:12203(literal)
msgid "&amp;&amp;"
msgstr "&amp;&amp;"

#: func.xml:8088(entry)
msgid "Overlaps? (One point in common makes this true.)"
msgstr ""
"Пересекаются ли операнды? (Для положительного ответа достаточно одной общей "
"точки.)"

#: func.xml:8089(literal)
msgid "box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'"
msgstr "box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'"

#: func.xml:8093(entry)
msgid "Is strictly left of?"
msgstr "Строго слева?"

#: func.xml:8094(literal)
msgid "circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'"
msgstr "circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'"

#: func.xml:8098(entry)
msgid "Is strictly right of?"
msgstr "Строго справа?"

#: func.xml:8099(literal)
msgid "circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'"
msgstr "circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'"

#: func.xml:8102(literal) func.xml:12224(literal)
msgid "&amp;&lt;"
msgstr "&amp;&lt;"

#: func.xml:8103(entry)
msgid "Does not extend to the right of?"
msgstr "Не простирается правее?"

#: func.xml:8104(literal)
msgid "box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'"
msgstr "box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'"

#: func.xml:8107(literal) func.xml:12231(literal)
msgid "&amp;&gt;"
msgstr "&amp;&gt;"

#: func.xml:8108(entry)
msgid "Does not extend to the left of?"
msgstr "Не простирается левее?"

#: func.xml:8109(literal)
msgid "box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'"
msgstr "box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'"

#: func.xml:8112(literal)
msgid "&lt;&lt;|"
msgstr "&lt;&lt;|"

#: func.xml:8113(entry)
msgid "Is strictly below?"
msgstr "Строго ниже?"

#: func.xml:8114(literal)
msgid "box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'"
msgstr "box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'"

#: func.xml:8117(literal)
msgid "|&gt;&gt;"
msgstr "|&gt;&gt;"

#: func.xml:8118(entry)
msgid "Is strictly above?"
msgstr "Строго выше?"

#: func.xml:8119(literal)
msgid "box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'"
msgstr "box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'"

#: func.xml:8122(literal)
msgid "&amp;&lt;|"
msgstr "&amp;&lt;|"

#: func.xml:8123(entry)
msgid "Does not extend above?"
msgstr "Не простирается выше?"

#: func.xml:8124(literal)
msgid "box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'"
msgstr "box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'"

#: func.xml:8127(literal)
msgid "|&amp;&gt;"
msgstr "|&amp;&gt;"

#: func.xml:8128(entry)
msgid "Does not extend below?"
msgstr "Не простирается ниже?"

#: func.xml:8129(literal)
msgid "box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'"
msgstr "box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'"

#: func.xml:8132(literal)
msgid "&lt;^"
msgstr "&lt;^"

#: func.xml:8133(entry)
msgid "Is below (allows touching)?"
msgstr "Ниже (может касаться)?"

#: func.xml:8134(literal)
msgid "circle '((0,0),1)' &lt;^ circle '((0,5),1)'"
msgstr "circle '((0,0),1)' &lt;^ circle '((0,5),1)'"

#: func.xml:8137(literal)
msgid "&gt;^"
msgstr "&gt;^"

#: func.xml:8138(entry)
msgid "Is above (allows touching)?"
msgstr "Выше (может касаться)?"

#: func.xml:8139(literal)
msgid "circle '((0,5),1)' &gt;^ circle '((0,0),1)'"
msgstr "circle '((0,5),1)' &gt;^ circle '((0,0),1)'"

#: func.xml:8142(literal)
msgid "?#"
msgstr "?#"

#: func.xml:8143(entry)
msgid "Intersects?"
msgstr "Пересекает?"

#: func.xml:8144(literal)
msgid "lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'"
msgstr "lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'"

#: func.xml:8147(literal) func.xml:8152(literal)
msgid "?-"
msgstr "?-"

#: func.xml:8148(entry)
msgid "Is horizontal?"
msgstr "Горизонтальный объект?"

#: func.xml:8149(literal)
msgid "?- lseg '((-1,0),(1,0))'"
msgstr "?- lseg '((-1,0),(1,0))'"

#: func.xml:8153(entry)
msgid "Are horizontally aligned?"
msgstr "Выровнены по горизонтали?"

#: func.xml:8154(literal)
msgid "point '(1,0)' ?- point '(0,0)'"
msgstr "point '(1,0)' ?- point '(0,0)'"

#: func.xml:8157(literal) func.xml:8162(literal) func.xml:10457(literal)
msgid "?|"
msgstr "?|"

#: func.xml:8158(entry)
msgid "Is vertical?"
msgstr "Вертикальный объект?"

#: func.xml:8159(literal)
msgid "?| lseg '((-1,0),(1,0))'"
msgstr "?| lseg '((-1,0),(1,0))'"

#: func.xml:8163(entry)
msgid "Are vertically aligned?"
msgstr "Выровнены по вертикали?"

#: func.xml:8164(literal)
msgid "point '(0,1)' ?| point '(0,0)'"
msgstr "point '(0,1)' ?| point '(0,0)'"

#: func.xml:8167(literal)
msgid "?-|"
msgstr "?-|"

#: func.xml:8168(entry)
msgid "Is perpendicular?"
msgstr "Перпендикулярны?"

#: func.xml:8169(literal)
msgid "lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'"
msgstr "lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'"

#: func.xml:8172(literal)
msgid "?||"
msgstr "?||"

#: func.xml:8173(entry)
msgid "Are parallel?"
msgstr "Параллельны?"

#: func.xml:8174(literal)
msgid "lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'"
msgstr "lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'"

#: func.xml:8177(literal) func.xml:8994(literal) func.xml:10436(literal)
#: func.xml:11700(literal) func.xml:12175(literal) func.xml:12182(literal)
msgid "@&gt;"
msgstr "@&gt;"

#: func.xml:8178(entry)
msgid "Contains?"
msgstr "Первый объект включает второй?"

#: func.xml:8179(literal)
msgid "circle '((0,0),2)' @&gt; point '(1,1)'"
msgstr "circle '((0,0),2)' @&gt; point '(1,1)'"

#: func.xml:8182(literal) func.xml:9001(literal) func.xml:10443(literal)
#: func.xml:11707(literal) func.xml:12189(literal) func.xml:12196(literal)
msgid "&lt;@"
msgstr "&lt;@"

#: func.xml:8183(entry)
msgid "Contained in or on?"
msgstr "Первый объект включён во второй?"

#: func.xml:8184(literal)
msgid "point '(1,1)' &lt;@ circle '((0,0),2)'"
msgstr "point '(1,1)' &lt;@ circle '((0,0),2)'"

#: func.xml:8187(literal)
msgid "~="
msgstr "~="

#: func.xml:8188(entry)
msgid "Same as?"
msgstr "Одинаковы?"

#: func.xml:8189(literal)
msgid "polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'"
msgstr "polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'"

#: func.xml:8196(para)
msgid ""
"Before <productname>PostgreSQL</productname> 8.2, the containment operators "
"<literal>@&gt;</literal> and <literal>&lt;@</literal> were respectively "
"called <literal>~</literal> and <literal>@</literal>. These names are still "
"available, but are deprecated and will eventually be removed."
msgstr ""
"До <productname>PostgreSQL</productname> 8.2 операторы включения "
"<literal>@&gt;</literal> и <literal>&lt;@</literal> назывались "
"соответственно <literal>~</literal> и <literal>@</literal>. Эти имена по-"
"прежнему доступны, но считаются устаревшими и в конце концов будут удалены."

#: func.xml:8204(indexterm)
msgid "<primary>area</primary>"
msgstr "<primary>area</primary>"

#: func.xml:8207(indexterm)
msgid "<primary>center</primary>"
msgstr "<primary>center</primary>"

#: func.xml:8210(indexterm)
msgid "<primary>diameter</primary>"
msgstr "<primary>diameter</primary>"

#: func.xml:8213(indexterm)
msgid "<primary>height</primary>"
msgstr "<primary>height</primary>"

#: func.xml:8216(indexterm)
msgid "<primary>isclosed</primary>"
msgstr "<primary>isclosed</primary>"

#: func.xml:8219(indexterm)
msgid "<primary>isopen</primary>"
msgstr "<primary>isopen</primary>"

#: func.xml:8225(indexterm)
msgid "<primary>npoints</primary>"
msgstr "<primary>npoints</primary>"

#: func.xml:8228(indexterm)
msgid "<primary>pclose</primary>"
msgstr "<primary>pclose</primary>"

#: func.xml:8231(indexterm)
msgid "<primary>popen</primary>"
msgstr "<primary>popen</primary>"

#: func.xml:8234(indexterm)
msgid "<primary>radius</primary>"
msgstr "<primary>radius</primary>"

#: func.xml:8237(indexterm)
msgid "<primary>width</primary>"
msgstr "<primary>width</primary>"

#: func.xml:8242(title)
msgid "Geometric Functions"
msgstr "Геометрические функции"

#: func.xml:8254(replaceable) func.xml:8260(replaceable)
#: func.xml:8290(replaceable)
msgid "object"
msgstr "объект"

#: func.xml:8254(function)
msgid "area(<placeholder-1/>)"
msgstr "area(<placeholder-1/>)"

#: func.xml:8256(entry)
msgid "area"
msgstr "площадь"

#: func.xml:8257(literal)
msgid "area(box '((0,0),(1,1))')"
msgstr "area(box '((0,0),(1,1))')"

#: func.xml:8260(function)
msgid "center(<placeholder-1/>)"
msgstr "center(<placeholder-1/>)"

#: func.xml:8261(type) func.xml:8368(type) func.xml:8374(type)
#: func.xml:8403(type) func.xml:8415(type) func.xml:8432(type)
#: func.xml:8456(type) func.xml:8462(type) func.xml:8468(type)
#: func.xml:8474(type) func.xml:8480(type)
msgctxt "type"
msgid "point"
msgstr "point"

#: func.xml:8262(entry)
msgid "center"
msgstr "центр"

#: func.xml:8263(literal)
msgid "center(box '((0,0),(1,2))')"
msgstr "center(box '((0,0),(1,2))')"

#: func.xml:8266(type) func.xml:8329(type) func.xml:8361(type)
#: func.xml:8398(type) func.xml:8404(type) func.xml:8410(type)
#: func.xml:8467(type) func.xml:8496(type) func.xml:8502(type)
msgid "circle"
msgstr "circle"

#: func.xml:8266(function)
msgid "diameter(<placeholder-1/>)"
msgstr "diameter(<placeholder-1/>)"

#: func.xml:8268(entry)
msgid "diameter of circle"
msgstr "диаметр круга"

#: func.xml:8269(literal)
msgid "diameter(circle '((0,0),2.0)')"
msgstr "diameter(circle '((0,0),2.0)')"

#: func.xml:8272(type) func.xml:8335(type) func.xml:8363(type)
#: func.xml:8369(type) func.xml:8375(type) func.xml:8381(type)
#: func.xml:8386(type) func.xml:8387(type) func.xml:8396(type)
#: func.xml:8425(type) func.xml:8461(type) func.xml:8489(type)
msgid "box"
msgstr "box"

#: func.xml:8272(function)
msgid "height(<placeholder-1/>)"
msgstr "height(<placeholder-1/>)"

#: func.xml:8274(entry)
msgid "vertical size of box"
msgstr "вертикальный размер прямоугольника"

#: func.xml:8275(literal)
msgid "height(box '((0,0),(1,1))')"
msgstr "height(box '((0,0),(1,1))')"

#: func.xml:8278(type) func.xml:8284(type) func.xml:8296(type)
#: func.xml:8308(type) func.xml:8309(type) func.xml:8323(type)
#: func.xml:8324(type) func.xml:8444(type) func.xml:8508(type)
msgid "path"
msgstr "path"

#: func.xml:8278(function)
msgid "isclosed(<placeholder-1/>)"
msgstr "isclosed(<placeholder-1/>)"

#: func.xml:8280(entry)
msgid "a closed path?"
msgstr "замкнутый путь?"

#: func.xml:8281(literal)
msgid "isclosed(path '((0,0),(1,1),(2,0))')"
msgstr "isclosed(path '((0,0),(1,1),(2,0))')"

#: func.xml:8284(function)
msgid "isopen(<placeholder-1/>)"
msgstr "isopen(<placeholder-1/>)"

#: func.xml:8286(entry)
msgid "an open path?"
msgstr "открытый путь?"

#: func.xml:8287(literal)
msgid "isopen(path '[(0,0),(1,1),(2,0)]')"
msgstr "isopen(path '[(0,0),(1,1),(2,0)]')"

#: func.xml:8292(entry)
msgctxt "entry"
msgid "length"
msgstr "длина"

#: func.xml:8293(literal)
msgid "length(path '((-1,0),(1,0))')"
msgstr "length(path '((-1,0),(1,0))')"

#: func.xml:8296(function) func.xml:8302(function)
msgid "npoints(<placeholder-1/>)"
msgstr "npoints(<placeholder-1/>)"

#: func.xml:8298(entry) func.xml:8304(entry)
msgid "number of points"
msgstr "число точек"

#: func.xml:8299(literal)
msgid "npoints(path '[(0,0),(1,1),(2,0)]')"
msgstr "npoints(path '[(0,0),(1,1),(2,0)]')"

#: func.xml:8302(type) func.xml:8380(type) func.xml:8409(type)
#: func.xml:8442(type) func.xml:8479(type) func.xml:8491(type)
#: func.xml:8497(type) func.xml:8503(type) func.xml:8509(type)
msgid "polygon"
msgstr "polygon"

#: func.xml:8305(literal)
msgid "npoints(polygon '((1,1),(0,0))')"
msgstr "npoints(polygon '((1,1),(0,0))')"

#: func.xml:8308(function)
msgid "pclose(<placeholder-1/>)"
msgstr "pclose(<placeholder-1/>)"

#: func.xml:8310(entry)
msgid "convert path to closed"
msgstr "преобразует путь в замкнутый"

#: func.xml:8311(literal)
msgid "pclose(path '[(0,0),(1,1),(2,0)]')"
msgstr "pclose(path '[(0,0),(1,1),(2,0)]')"

#: func.xml:8323(function)
msgid "popen(<placeholder-1/>)"
msgstr "popen(<placeholder-1/>)"

#: func.xml:8325(entry)
msgid "convert path to open"
msgstr "преобразует путь в открытый"

#: func.xml:8326(literal)
msgid "popen(path '((0,0),(1,1),(2,0))')"
msgstr "popen(path '((0,0),(1,1),(2,0))')"

#: func.xml:8329(function)
msgid "radius(<placeholder-1/>)"
msgstr "radius(<placeholder-1/>)"

#: func.xml:8331(entry)
msgid "radius of circle"
msgstr "радиус окружности"

#: func.xml:8332(literal)
msgid "radius(circle '((0,0),2.0)')"
msgstr "radius(circle '((0,0),2.0)')"

#: func.xml:8335(function)
msgid "width(<placeholder-1/>)"
msgstr "width(<placeholder-1/>)"

#: func.xml:8337(entry)
msgid "horizontal size of box"
msgstr "горизонтальный размер прямоугольника"

#: func.xml:8338(literal)
msgid "width(box '((0,0),(1,1))')"
msgstr "width(box '((0,0),(1,1))')"

#: func.xml:8345(title)
msgid "Geometric Type Conversion Functions"
msgstr "Функции преобразования геометрических типов"

#: func.xml:8358(indexterm)
msgid "<primary>box</primary>"
msgstr "<primary>box</primary>"

#: func.xml:8361(function) func.xml:8368(function) func.xml:8380(function)
msgid "box(<placeholder-1/>)"
msgstr "box(<placeholder-1/>)"

#: func.xml:8364(entry)
msgid "circle to box"
msgstr "окружность в прямоугольник"

#: func.xml:8365(literal)
msgid "box(circle '((0,0),2.0)')"
msgstr "box(circle '((0,0),2.0)')"

#: func.xml:8370(entry)
msgid "point to empty box"
msgstr "точка в пустой прямоугольник"

#: func.xml:8371(literal)
msgid "box(point '(0,0)')"
msgstr "box(point '(0,0)')"

#: func.xml:8374(function)
msgid "box(<placeholder-1/>, <placeholder-2/>)"
msgstr "box(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8376(entry)
msgid "points to box"
msgstr "точки в прямоугольник"

#: func.xml:8377(literal)
msgid "box(point '(0,0)', point '(1,1)')"
msgstr "box(point '(0,0)', point '(1,1)')"

#: func.xml:8382(entry)
msgid "polygon to box"
msgstr "многоугольник в прямоугольник"

#: func.xml:8383(literal)
msgid "box(polygon '((0,0),(1,1),(2,0))')"
msgstr "box(polygon '((0,0),(1,1),(2,0))')"

#: func.xml:8386(function)
msgid "bound_box(<placeholder-1/>, <placeholder-2/>)"
msgstr "bound_box(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8388(entry)
msgid "boxes to bounding box"
msgstr "прямоугольники в окружающий прямоугольник"

#: func.xml:8389(literal)
msgid "bound_box(box '((0,0),(1,1))', box '((3,3),(4,4))')"
msgstr "bound_box(box '((0,0),(1,1))', box '((3,3),(4,4))')"

#: func.xml:8393(indexterm)
msgid "<primary>circle</primary>"
msgstr "<primary>круг</primary>"

#: func.xml:8396(function) func.xml:8409(function)
msgid "circle(<placeholder-1/>)"
msgstr "circle(<placeholder-1/>)"

#: func.xml:8399(entry)
msgid "box to circle"
msgstr "прямоугольник в окружность"

#: func.xml:8400(literal)
msgid "circle(box '((0,0),(1,1))')"
msgstr "circle(box '((0,0),(1,1))')"

#: func.xml:8403(function)
msgid "circle(<placeholder-1/>, <placeholder-2/>)"
msgstr "circle(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8405(entry)
msgid "center and radius to circle"
msgstr "окружность из центра и радиуса"

#: func.xml:8406(literal)
msgid "circle(point '(0,0)', 2.0)"
msgstr "circle(point '(0,0)', 2.0)"

#: func.xml:8411(entry)
msgid "polygon to circle"
msgstr "многоугольник в окружность"

#: func.xml:8412(literal)
msgid "circle(polygon '((0,0),(1,1),(2,0))')"
msgstr "circle(polygon '((0,0),(1,1),(2,0))')"

#: func.xml:8415(function)
msgid "line(<placeholder-1/>, <placeholder-2/>)"
msgstr "line(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8416(type)
msgid "line"
msgstr "line"

#: func.xml:8417(entry)
msgid "points to line"
msgstr "точки в прямую"

#: func.xml:8418(literal)
msgid "line(point '(-1,0)', point '(1,0)')"
msgstr "line(point '(-1,0)', point '(1,0)')"

#: func.xml:8422(indexterm)
msgid "<primary>lseg</primary>"
msgstr "<primary>lseg</primary>"

#: func.xml:8425(function)
msgid "lseg(<placeholder-1/>)"
msgstr "lseg(<placeholder-1/>)"

#: func.xml:8427(type) func.xml:8433(type) func.xml:8473(type)
msgid "lseg"
msgstr "lseg"

#: func.xml:8428(entry)
msgid "box diagonal to line segment"
msgstr "диагональ прямоугольника в отрезок"

#: func.xml:8429(literal)
msgid "lseg(box '((-1,0),(1,0))')"
msgstr "lseg(box '((-1,0),(1,0))')"

#: func.xml:8432(function)
msgid "lseg(<placeholder-1/>, <placeholder-2/>)"
msgstr "lseg(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8434(entry)
msgid "points to line segment"
msgstr "точки в отрезок"

#: func.xml:8435(literal)
msgid "lseg(point '(-1,0)', point '(1,0)')"
msgstr "lseg(point '(-1,0)', point '(1,0)')"

#: func.xml:8439(indexterm)
msgid "<primary>path</primary>"
msgstr "<primary>path</primary>"

#: func.xml:8442(function)
msgid "path(<placeholder-1/>)"
msgstr "path(<placeholder-1/>)"

#: func.xml:8445(entry)
msgid "polygon to path"
msgstr "многоугольник в путь"

#: func.xml:8446(literal)
msgid "path(polygon '((0,0),(1,1),(2,0))')"
msgstr "path(polygon '((0,0),(1,1),(2,0))')"

#: func.xml:8450(indexterm)
msgid "<primary>point</primary>"
msgstr "<primary>точка</primary>"

#: func.xml:8453(function)
msgctxt "function"
msgid "point"
msgstr "point"

#: func.xml:8457(entry)
msgid "construct point"
msgstr "образует точку"

#: func.xml:8458(literal)
msgid "point(23.4, -44.5)"
msgstr "point(23.4, -44.5)"

#: func.xml:8461(function) func.xml:8467(function) func.xml:8473(function)
#: func.xml:8479(function)
msgid "point(<placeholder-1/>)"
msgstr "point(<placeholder-1/>)"

#: func.xml:8463(entry)
msgid "center of box"
msgstr "центр прямоугольника"

#: func.xml:8464(literal)
msgid "point(box '((-1,0),(1,0))')"
msgstr "point(box '((-1,0),(1,0))')"

#: func.xml:8469(entry)
msgid "center of circle"
msgstr "центр окружности"

#: func.xml:8470(literal)
msgid "point(circle '((0,0),2.0)')"
msgstr "point(circle '((0,0),2.0)')"

#: func.xml:8475(entry)
msgid "center of line segment"
msgstr "центр отрезка"

#: func.xml:8476(literal)
msgid "point(lseg '((-1,0),(1,0))')"
msgstr "point(lseg '((-1,0),(1,0))')"

#: func.xml:8481(entry)
msgid "center of polygon"
msgstr "центр многоугольника"

#: func.xml:8482(literal)
msgid "point(polygon '((0,0),(1,1),(2,0))')"
msgstr "point(polygon '((0,0),(1,1),(2,0))')"

#: func.xml:8486(indexterm)
msgid "<primary>polygon</primary>"
msgstr "<primary>многоугольник</primary>"

#: func.xml:8489(function) func.xml:8496(function) func.xml:8508(function)
msgid "polygon(<placeholder-1/>)"
msgstr "polygon(<placeholder-1/>)"

#: func.xml:8492(entry)
msgid "box to 4-point polygon"
msgstr "прямоугольник в многоугольник с 4 вершинами"

#: func.xml:8493(literal)
msgid "polygon(box '((0,0),(1,1))')"
msgstr "polygon(box '((0,0),(1,1))')"

#: func.xml:8498(entry)
msgid "circle to 12-point polygon"
msgstr "круг в многоугольник с 12 вершинами"

#: func.xml:8499(literal)
msgid "polygon(circle '((0,0),2.0)')"
msgstr "polygon(circle '((0,0),2.0)')"

#: func.xml:8502(replaceable)
msgid "npts"
msgstr "число_точек"

#: func.xml:8502(function)
msgid "polygon(<placeholder-1/>, <placeholder-2/>)"
msgstr "polygon(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8504(entry)
msgid ""
"circle to <replaceable class=\"parameter\">npts</replaceable>-point polygon"
msgstr ""
"окружность с заданным <replaceable class=\"parameter\">числом_точек</"
"replaceable>"

#: func.xml:8505(literal)
msgid "polygon(12, circle '((0,0),2.0)')"
msgstr "polygon(12, circle '((0,0),2.0)')"

#: func.xml:8510(entry)
msgid "path to polygon"
msgstr "путь в многоугольник"

#: func.xml:8511(literal)
msgid "polygon(path '((0,0),(1,1),(2,0))')"
msgstr "polygon(path '((0,0),(1,1),(2,0))')"

#: func.xml:8517(para)
msgid ""
"It is possible to access the two component numbers of a <type>point</type> "
"as though the point were an array with indexes 0 and 1. For example, if "
"<literal>t.p</literal> is a <type>point</type> column then <literal>SELECT "
"p[0] FROM t</literal> retrieves the X coordinate and <literal>UPDATE t SET "
"p[1] = ...</literal> changes the Y coordinate. In the same way, a value of "
"type <type>box</type> or <type>lseg</type> can be treated as an array of two "
"<type>point</type> values."
msgstr ""
"К двум компонентам типа <type>point</type> (точка) можно обратиться, как к "
"элементам массива с индексами 0 и 1. Например, если <literal>t.p</literal> "
"&mdash; столбец типа <type>point</type>, <literal>SELECT p[0] FROM t</"
"literal> вернёт координату X, а <literal>UPDATE t SET p[1] = ...</literal> "
"изменит координату Y. Таким же образом, значение типа <type>box</type> или "
"<type>lseg</type> можно воспринимать как массив двух значений типа "
"<type>point</type>."

#: func.xml:8527(para)
msgid ""
"The <function>area</function> function works for the types <type>box</type>, "
"<type>circle</type>, and <type>path</type>. The <function>area</function> "
"function only works on the <type>path</type> data type if the points in the "
"<type>path</type> are non-intersecting. For example, the <type>path</type>\n"
"     <literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal> "
"will not work; however, the following visually identical <type>path</type>\n"
"     <literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::"
"PATH</literal> will work. If the concept of an intersecting versus non-"
"intersecting <type>path</type> is confusing, draw both of the above "
"<type>path</type>s side by side on a piece of graph paper."
msgstr ""
"Функция <function>area</function> работает с типами <type>box</type>, "
"<type>circle</type> и <type>path</type>. При этом для типа <type>path</type> "
"заданный путь не должен быть самопересекающимся. Например, эта функция не "
"примет значение типа <type>path</type> <literal>'((0,0),(0,1),(2,1),(2,2),"
"(1,2),(1,0),(0,0))'::PATH</literal>, но примет визуально идентичный путь "
"<literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</"
"literal>. Если вы не вполне поняли, что здесь подразумевается под "
"самопересечением пути, нарисуйте на бумаге две фигуры по приведённым "
"координатам."

#: func.xml:8547(title)
msgid "Network Address Functions and Operators"
msgstr "Функции и операторы для работы с сетевыми адресами"

#: func.xml:8549(para)
msgid ""
"<xref linkend=\"cidr-inet-operators-table\"/> shows the operators available "
"for the <type>cidr</type> and <type>inet</type> types. The operators "
"<literal>&lt;&lt;</literal>, <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;"
"</literal>, <literal>&gt;&gt;=</literal>, and <literal>&amp;&amp;</literal> "
"test for subnet inclusion. They consider only the network parts of the two "
"addresses (ignoring any host part) and determine whether one network is "
"identical to or a subnet of the other."
msgstr ""
"В <xref linkend=\"cidr-inet-operators-table\"/> показаны операторы, "
"работающие с типами <type>cidr</type> и <type>inet</type>. Операторы "
"<literal>&lt;&lt;</literal>, <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;"
"</literal>, <literal>&gt;&gt;=</literal> и <literal>&amp;&amp;</literal> "
"проверяют включения подсетей, рассматривая только биты сети в обоих адресах "
"(игнорируя биты узлов) и определяя, идентична ли одна сеть другой или её "
"подсети."

#: func.xml:8562(title)
msgid "<type>cidr</type> and <type>inet</type> Operators"
msgstr "Операторы для типов <type>cidr</type> и <type>inet</type>"

#: func.xml:8574(entry)
msgid "is less than"
msgstr "меньше"

#: func.xml:8575(literal)
msgid "inet '192.168.1.5' &lt; inet '192.168.1.6'"
msgstr "inet '192.168.1.5' &lt; inet '192.168.1.6'"

#: func.xml:8579(entry)
msgid "is less than or equal"
msgstr "меньше или равно"

#: func.xml:8580(literal)
msgid "inet '192.168.1.5' &lt;= inet '192.168.1.5'"
msgstr "inet '192.168.1.5' &lt;= inet '192.168.1.5'"

#: func.xml:8584(entry)
msgid "equals"
msgstr "равно"

#: func.xml:8585(literal)
msgid "inet '192.168.1.5' = inet '192.168.1.5'"
msgstr "inet '192.168.1.5' = inet '192.168.1.5'"

#: func.xml:8589(entry)
msgid "is greater or equal"
msgstr "больше или равно"

#: func.xml:8590(literal)
msgid "inet '192.168.1.5' &gt;= inet '192.168.1.5'"
msgstr "inet '192.168.1.5' &gt;= inet '192.168.1.5'"

#: func.xml:8594(entry)
msgid "is greater than"
msgstr "больше"

#: func.xml:8595(literal)
msgid "inet '192.168.1.5' &gt; inet '192.168.1.4'"
msgstr "inet '192.168.1.5' &gt; inet '192.168.1.4'"

#: func.xml:8598(literal) func.xml:11665(literal) func.xml:12140(literal)
msgid "&lt;&gt;"
msgstr "&lt;&gt;"

#: func.xml:8599(entry)
msgid "is not equal"
msgstr "не равно"

#: func.xml:8600(literal)
msgid "inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'"
msgstr "inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'"

#: func.xml:8604(entry) func.xml:11708(entry)
msgid "is contained by"
msgstr "содержится в"

#: func.xml:8605(literal)
msgid "inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'"
msgstr "inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'"

#: func.xml:8608(literal)
msgid "&lt;&lt;="
msgstr "&lt;&lt;="

#: func.xml:8609(entry)
msgid "is contained by or equals"
msgstr "равно или содержится в"

#: func.xml:8610(literal)
msgid "inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'"
msgstr "inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'"

#: func.xml:8614(entry) func.xml:11701(entry)
msgid "contains"
msgstr "содержит"

#: func.xml:8615(literal)
msgid "inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'"
msgstr "inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'"

#: func.xml:8618(literal)
msgid "&gt;&gt;="
msgstr "&gt;&gt;="

#: func.xml:8619(entry)
msgid "contains or equals"
msgstr "равно или содержит"

#: func.xml:8620(literal)
msgid "inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'"
msgstr "inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'"

#: func.xml:8624(entry)
msgid "contains or is contained by"
msgstr "содержит или содержится в"

#: func.xml:8625(literal)
msgid "inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'"
msgstr "inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'"

#: func.xml:8630(literal)
msgid "~ inet '192.168.1.6'"
msgstr "~ inet '192.168.1.6'"

#: func.xml:8635(literal)
msgid "inet '192.168.1.6' &amp; inet '0.0.0.255'"
msgstr "inet '192.168.1.6' &amp; inet '0.0.0.255'"

#: func.xml:8640(literal)
msgid "inet '192.168.1.6' | inet '0.0.0.255'"
msgstr "inet '192.168.1.6' | inet '0.0.0.255'"

#: func.xml:8645(literal)
msgid "inet '192.168.1.6' + 25"
msgstr "inet '192.168.1.6' + 25"

#: func.xml:8650(literal)
msgid "inet '192.168.1.43' - 36"
msgstr "inet '192.168.1.43' - 36"

#: func.xml:8655(literal)
msgid "inet '192.168.1.43' - inet '192.168.1.19'"
msgstr "inet '192.168.1.43' - inet '192.168.1.19'"

#: func.xml:8661(para)
msgid ""
"<xref linkend=\"cidr-inet-functions-table\"/> shows the functions available "
"for use with the <type>cidr</type> and <type>inet</type> types. The "
"<function>abbrev</function>, <function>host</function>, and <function>text</"
"function> functions are primarily intended to offer alternative display "
"formats."
msgstr ""
"В <xref remap=\"6\" linkend=\"cidr-inet-functions-table\"/> перечислены "
"функции, работающие с типами <type>cidr</type> и <type>inet</type>. Функции "
"<function>abbrev</function>, <function>host</function> и <function>text</"
"function> предназначены в основном для вывода данных в альтернативных "
"форматах."

#: func.xml:8671(title)
msgid "<type>cidr</type> and <type>inet</type> Functions"
msgstr "Функции для типов <type>cidr</type> и <type>inet</type>"

#: func.xml:8685(indexterm)
msgid "<primary>abbrev</primary>"
msgstr "<primary>abbrev</primary>"

#: func.xml:8688(type) func.xml:8707(type) func.xml:8709(type)
#: func.xml:8719(type) func.xml:8732(type) func.xml:8744(type)
#: func.xml:8746(type) func.xml:8756(type) func.xml:8768(type)
#: func.xml:8770(type) func.xml:8780(type) func.xml:8792(type)
#: func.xml:8794(type) func.xml:8811(type) func.xml:8823(type)
#: func.xml:8835(type) func.xml:14915(type) func.xml:14927(type)
msgid "inet"
msgstr "inet"

#: func.xml:8688(function) func.xml:8696(function)
msgid "abbrev(<placeholder-1/>)"
msgstr "abbrev(<placeholder-1/>)"

#: func.xml:8691(entry) func.xml:8698(entry)
msgid "abbreviated display format as text"
msgstr "вывод адрес в кратком текстовом виде"

#: func.xml:8692(literal)
msgid "abbrev(inet '10.1.0.0/16')"
msgstr "abbrev(inet '10.1.0.0/16')"

#: func.xml:8693(literal)
msgid "10.1.0.0/16"
msgstr "10.1.0.0/16"

#: func.xml:8696(type) func.xml:8782(type) func.xml:8800(type)
#: func.xml:8801(type) func.xml:8837(type)
msgid "cidr"
msgstr "cidr"

#: func.xml:8699(literal)
msgid "abbrev(cidr '10.1.0.0/16')"
msgstr "abbrev(cidr '10.1.0.0/16')"

#: func.xml:8700(literal)
msgid "10.1/16"
msgstr "10.1/16"

#: func.xml:8704(indexterm)
msgid "<primary>broadcast</primary>"
msgstr "<primary>broadcast</primary>"

#: func.xml:8707(function)
msgid "broadcast(<placeholder-1/>)"
msgstr "broadcast(<placeholder-1/>)"

#: func.xml:8710(entry)
msgid "broadcast address for network"
msgstr "широковещательный адрес сети"

#: func.xml:8711(literal)
msgid "broadcast('192.168.1.5/24')"
msgstr "broadcast('192.168.1.5/&zwsp;24')"

#: func.xml:8712(literal)
msgid "192.168.1.255/24"
msgstr "192.168.1.255/&zwsp;24"

#: func.xml:8716(indexterm)
msgid "<primary>family</primary>"
msgstr "<primary>family</primary>"

#: func.xml:8719(function)
msgid "family(<placeholder-1/>)"
msgstr "family(<placeholder-1/>)"

#: func.xml:8722(entry)
msgid ""
"extract family of address; <literal>4</literal> for IPv4, <literal>6</"
"literal> for IPv6"
msgstr ""
"возвращает семейство адреса; <literal>4</literal> для адреса IPv4, "
"<literal>6</literal> для IPv6"

#: func.xml:8724(literal)
msgid "family('::1')"
msgstr "family('::1')"

#: func.xml:8729(indexterm)
msgid "<primary>host</primary>"
msgstr "<primary>host</primary>"

#: func.xml:8732(function)
msgid "host(<placeholder-1/>)"
msgstr "host(<placeholder-1/>)"

#: func.xml:8735(entry)
msgid "extract IP address as text"
msgstr "извлекает IP-адрес в виде текста"

#: func.xml:8736(literal)
msgid "host('192.168.1.5/24')"
msgstr "host('192.168.1.5/&zwsp;24')"

#: func.xml:8737(literal)
msgid "192.168.1.5"
msgstr "192.168.1.5"

#: func.xml:8741(indexterm)
msgid "<primary>hostmask</primary>"
msgstr "<primary>hostmask</primary>"

#: func.xml:8744(function)
msgid "hostmask(<placeholder-1/>)"
msgstr "hostmask(<placeholder-1/>)"

#: func.xml:8747(entry)
msgid "construct host mask for network"
msgstr "вычисляет маску узла для сетевого адреса"

#: func.xml:8748(literal)
msgid "hostmask('192.168.23.20/30')"
msgstr "hostmask('192.168.23.20/&zwsp;30')"

#: func.xml:8749(literal)
msgid "0.0.0.3"
msgstr "0.0.0.3"

#: func.xml:8753(indexterm)
msgid "<primary>masklen</primary>"
msgstr "<primary>masklen</primary>"

#: func.xml:8756(function)
msgid "masklen(<placeholder-1/>)"
msgstr "masklen(<placeholder-1/>)"

#: func.xml:8759(entry)
msgid "extract netmask length"
msgstr "выдаёт длину маски сети"

#: func.xml:8760(literal)
msgid "masklen('192.168.1.5/24')"
msgstr "masklen('192.168.1.5/&zwsp;24')"

#: func.xml:8761(literal)
msgid "24"
msgstr "24"

#: func.xml:8765(indexterm)
msgid "<primary>netmask</primary>"
msgstr "<primary>netmask</primary>"

#: func.xml:8768(function)
msgid "netmask(<placeholder-1/>)"
msgstr "netmask(<placeholder-1/>)"

#: func.xml:8771(entry)
msgid "construct netmask for network"
msgstr "вычисляет маску сети для сетевого адреса"

#: func.xml:8772(literal)
msgid "netmask('192.168.1.5/24')"
msgstr "netmask('192.168.1.5/&zwsp;24')"

#: func.xml:8773(literal)
msgid "255.255.255.0"
msgstr "255.255.255.0"

#: func.xml:8777(indexterm)
msgid "<primary>network</primary>"
msgstr "<primary>network</primary>"

#: func.xml:8780(function)
msgid "network(<placeholder-1/>)"
msgstr "network(<placeholder-1/>)"

#: func.xml:8783(entry)
msgid "extract network part of address"
msgstr "извлекает компонент сети из адреса"

#: func.xml:8784(literal)
msgid "network('192.168.1.5/24')"
msgstr "network('192.168.1.5/&zwsp;24')"

#: func.xml:8785(literal)
msgid "192.168.1.0/24"
msgstr "192.168.1.0/24"

#: func.xml:8789(indexterm)
msgid "<primary>set_masklen</primary>"
msgstr "<primary>set_masklen</primary>"

#: func.xml:8792(function) func.xml:8800(function)
msgid "set_masklen(<placeholder-1/>, <placeholder-2/>)"
msgstr "set_masklen(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8795(entry)
msgid "set netmask length for <type>inet</type> value"
msgstr "задаёт размер маски для значения <type>inet</type>"

#: func.xml:8796(literal)
msgid "set_masklen('192.168.1.5/24', 16)"
msgstr "set_masklen('192.168.1.5/&zwsp;24', 16)"

#: func.xml:8797(literal)
msgid "192.168.1.5/16"
msgstr "192.168.1.5/16"

#: func.xml:8802(entry)
msgid "set netmask length for <type>cidr</type> value"
msgstr "задаёт размер маски для значения <type>cidr</type>"

#: func.xml:8803(literal)
msgid "set_masklen('192.168.1.0/24'::cidr, 16)"
msgstr "set_masklen('192.168.1.0/&zwsp;24'::cidr, 16)"

#: func.xml:8804(literal)
msgid "192.168.0.0/16"
msgstr "192.168.0.0/16"

#: func.xml:8808(indexterm)
msgid "<primary>text</primary>"
msgstr "<primary>text</primary>"

#: func.xml:8811(function)
msgid "text(<placeholder-1/>)"
msgstr "text(<placeholder-1/>)"

#: func.xml:8814(entry)
msgid "extract IP address and netmask length as text"
msgstr "выводит в текстовом виде IP-адрес и длину маски"

#: func.xml:8815(literal)
msgid "text(inet '192.168.1.5')"
msgstr "text(inet '192.168.1.5')"

#: func.xml:8816(literal)
msgid "192.168.1.5/32"
msgstr "192.168.1.5/32"

#: func.xml:8820(indexterm)
msgid "<primary>inet_same_family</primary>"
msgstr "<primary>inet_same_family</primary>"

#: func.xml:8823(function)
msgid "inet_same_family(<placeholder-1/>, <placeholder-2/>)"
msgstr "inet_same_family(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8826(entry)
msgid "are the addresses from the same family?"
msgstr "адреса относятся к одному семейству?"

#: func.xml:8827(literal)
msgid "inet_same_family('192.168.1.5/24', '::1')"
msgstr "inet_same_family('192.168.1.5/24', '::1')"

#: func.xml:8828(literal) func.xml:12361(literal) func.xml:12383(literal)
msgctxt "literal"
msgid "false"
msgstr "false"

#: func.xml:8832(indexterm)
msgid "<primary>inet_merge</primary>"
msgstr "<primary>inet_merge</primary>"

#: func.xml:8835(function)
msgid "inet_merge(<placeholder-1/>, <placeholder-2/>)"
msgstr "inet_merge(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8838(entry)
msgid "the smallest network which includes both of the given networks"
msgstr "наименьшая сеть, включающая обе заданные сети"

#: func.xml:8839(literal)
msgid "inet_merge('192.168.1.5/24', '192.168.2.5/24')"
msgstr "inet_merge('192.168.1.5/24', '192.168.2.5/24')"

#: func.xml:8840(literal)
msgid "192.168.0.0/22"
msgstr "192.168.0.0/22"

#: func.xml:8846(para)
msgid ""
"Any <type>cidr</type> value can be cast to <type>inet</type> implicitly or "
"explicitly; therefore, the functions shown above as operating on <type>inet</"
"type> also work on <type>cidr</type> values. (Where there are separate "
"functions for <type>inet</type> and <type>cidr</type>, it is because the "
"behavior should be different for the two cases.) Also, it is permitted to "
"cast an <type>inet</type> value to <type>cidr</type>. When this is done, any "
"bits to the right of the netmask are silently zeroed to create a valid "
"<type>cidr</type> value. In addition, you can cast a text value to "
"<type>inet</type> or <type>cidr</type> using normal casting syntax: for "
"example, <literal>inet(<replaceable>expression</replaceable>)</literal> or "
"<literal><replaceable>colname</replaceable>::cidr</literal>."
msgstr ""
"Любое значение <type>cidr</type> можно привести к типу <type>inet</type>, "
"явно или нет; поэтому все функции, показанные выше с типом <type>inet</"
"type>, также будут работать со значениями <type>cidr</type>. (Некоторые из "
"функций указаны отдельно для типов <type>inet</type> и <type>cidr</type>, "
"потому что их поведение с разными типами различается.) Кроме того, значение "
"<type>inet</type> тоже можно привести к типу <type>cidr</type>. При этом все "
"биты справа от сетевой маски просто обнуляются, чтобы значение стало "
"допустимым для типа <type>cidr</type>. К типам <type>inet</type> и "
"<type>cidr</type> можно привести и обычные текстовые значения, используя "
"обычный синтаксис, например: <literal>inet(<replaceable>выражение</"
"replaceable>)</literal> или <literal><replaceable>столбец</replaceable>::"
"cidr</literal>."

#: func.xml:8862(para)
msgid ""
"<xref linkend=\"macaddr-functions-table\"/> shows the functions available "
"for use with the <type>macaddr</type> type. The function "
"<literal><function>trunc(<type>macaddr</type>)</function></literal> returns "
"a MAC address with the last 3 bytes set to zero. This can be used to "
"associate the remaining prefix with a manufacturer."
msgstr ""
"В <xref remap=\"6\" linkend=\"macaddr-functions-table\"/> приведена функция, "
"предназначенная для работы с типом <type>macaddr</type>. Функция "
"<literal><function>trunc(<type>macaddr</type>)</function></literal> "
"возвращает MAC-адрес, последние 3 байта в котором равны 0. Это может быть "
"полезно для вычисления префикса, определяющего производителя."

#: func.xml:8871(title)
msgid "<type>macaddr</type> Functions"
msgstr "Функции <type>macaddr</type>"

#: func.xml:8888(type) func.xml:8890(type)
msgid "macaddr"
msgstr "macaddr"

#: func.xml:8888(function)
msgid "trunc(<placeholder-1/>)"
msgstr "trunc(<placeholder-1/>)"

#: func.xml:8891(entry)
msgid "set last 3 bytes to zero"
msgstr "обнуляет последние 3 байта"

#: func.xml:8892(literal)
msgid "trunc(macaddr '12:34:56:78:90:ab')"
msgstr "trunc(macaddr '12:34:56:&zwsp;78:90:ab')"

#: func.xml:8893(literal)
msgid "12:34:56:00:00:00"
msgstr "12:34:56:&zwsp;00:00:00"

#: func.xml:8899(para)
msgid ""
"The <type>macaddr</type> type also supports the standard relational "
"operators (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) for "
"lexicographical ordering, and the bitwise arithmetic operators (<literal>~</"
"literal>, <literal>&amp;</literal> and <literal>|</literal>) for NOT, AND "
"and OR."
msgstr ""
"Тип <type>macaddr</type> также поддерживает стандартные реляционные "
"операторы лексической сортировки (<literal>&gt;</literal>, <literal>&lt;=</"
"literal> и т. д.) и операторы битовой арифметики (<literal>~</literal>, "
"<literal>&amp;</literal> и <literal>|</literal>), соответствующие операциям "
"NOT, AND и OR."

#: func.xml:8911(title)
msgid "Text Search Functions and Operators"
msgstr "Функции и операторы текстового поиска"

#: func.xml:8913(indexterm)
msgid ""
"<primary>full text search</primary><secondary>functions and operators</"
"secondary>"
msgstr ""
"<primary>полнотекстовый поиск</primary><secondary>функции и операторы</"
"secondary>"

#: func.xml:8917(indexterm)
msgid ""
"<primary>text search</primary><secondary>functions and operators</secondary>"
msgstr ""
"<primary>поиск текста</primary><secondary>функции и операторы</secondary>"

#: func.xml:8921(para)
msgid ""
"<xref linkend=\"textsearch-operators-table\"/>, <xref linkend=\"textsearch-"
"functions-table\"/> and <xref linkend=\"textsearch-functions-debug-table\"/> "
"summarize the functions and operators that are provided for full text "
"searching. See <xref linkend=\"textsearch\"/> for a detailed explanation of "
"<productname>PostgreSQL</productname>'s text search facility."
msgstr ""
"В <xref remap=\"6\" linkend=\"textsearch-operators-table\"/>, <xref remap="
"\"6\" linkend=\"textsearch-functions-table\"/> и <xref remap=\"6\" linkend="
"\"textsearch-functions-debug-table\"/> собраны все существующие функции и "
"операторы, предназначенные для полнотекстового поиска. Во всех деталях "
"возможности полнотекстового поиска в <productname>PostgreSQL</productname> "
"описаны в <xref remap=\"6\" linkend=\"textsearch\"/>."

#: func.xml:8932(title)
msgid "Text Search Operators"
msgstr "Операторы текстового поиска"

#: func.xml:8947(entry)
msgid "<type>tsvector</type> matches <type>tsquery</type> ?"
msgstr "<type>tsvector</type> соответствует <type>tsquery</type> ?"

#: func.xml:8948(literal)
msgid "to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')"
msgstr "to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')"

#: func.xml:8952(literal)
msgid "@@@"
msgstr "@@@"

#: func.xml:8954(entry)
msgid "deprecated synonym for <literal>@@</literal>"
msgstr "устаревший синоним для <literal>@@</literal>"

#: func.xml:8955(literal)
msgid "to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')"
msgstr "to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')"

#: func.xml:8960(type) func.xml:9046(type) func.xml:9068(type)
#: func.xml:9129(type) func.xml:9131(type) func.xml:9141(type)
#: func.xml:9143(type) func.xml:9153(type) func.xml:9155(type)
#: func.xml:9179(type) func.xml:9189(type) func.xml:9191(type)
#: func.xml:9199(type) func.xml:9201(type) func.xml:9211(type)
#: func.xml:9213(type) func.xml:9235(type) func.xml:9247(type)
#: func.xml:9303(type) func.xml:9339(type)
msgid "tsvector"
msgstr "tsvector"

#: func.xml:8961(entry)
msgid "concatenate <type>tsvector</type>s"
msgstr "объединяет два значения <type>tsvector</type>"

#: func.xml:8962(literal)
msgid "'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector"
msgstr "'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector"

#: func.xml:8963(literal)
msgid "'a':1 'b':2,5 'c':3 'd':4"
msgstr "'a':1 'b':2,5 'c':3 'd':4"

#: func.xml:8967(type) func.xml:8974(type) func.xml:8981(type)
#: func.xml:8988(type) func.xml:9080(type) func.xml:9094(type)
#: func.xml:9106(type) func.xml:9117(type) func.xml:9167(type)
#: func.xml:9223(type) func.xml:9235(type) func.xml:9247(type)
#: func.xml:9259(type) func.xml:9261(type) func.xml:9268(type)
#: func.xml:9269(type) func.xml:9279(type) func.xml:9281(type)
#: func.xml:9290(type) func.xml:9292(type)
msgid "tsquery"
msgstr "tsquery"

#: func.xml:8968(entry)
msgid "AND <type>tsquery</type>s together"
msgstr "логическое И (AND) двух запросов <type>tsquery</type>"

#: func.xml:8969(literal)
msgid "'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery"
msgstr "'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery"

#: func.xml:8970(literal)
msgid "( 'fat' | 'rat' ) &amp; 'cat'"
msgstr "( 'fat' | 'rat' ) &amp; 'cat'"

#: func.xml:8975(entry)
msgid "OR <type>tsquery</type>s together"
msgstr "логическое ИЛИ (OR) двух запросов <type>tsquery</type>"

#: func.xml:8976(literal)
msgid "'fat | rat'::tsquery || 'cat'::tsquery"
msgstr "'fat | rat'::tsquery || 'cat'::tsquery"

#: func.xml:8977(literal)
msgid "( 'fat' | 'rat' ) | 'cat'"
msgstr "( 'fat' | 'rat' ) | 'cat'"

#: func.xml:8982(entry)
msgid "negate a <type>tsquery</type>"
msgstr "отрицание запроса <type>tsquery</type>"

#: func.xml:8983(literal)
msgid "!! 'cat'::tsquery"
msgstr "!! 'cat'::tsquery"

#: func.xml:8984(literal)
msgid "!'cat'"
msgstr "!'cat'"

#: func.xml:8989(entry)
#, fuzzy
msgid "<type>tsquery</type> followed by <type>tsquery</type>"
msgstr "<type>tsvector</type> соответствует <type>tsquery</type> ?"

#: func.xml:8990(literal)
#, fuzzy
msgid "to_tsquery('fat') &lt;-&gt; to_tsquery('rat')"
msgstr "to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')"

#: func.xml:8991(literal) func.xml:9110(literal)
#, fuzzy
msgid "'fat' &lt;-&gt; 'rat'"
msgstr "'fat' &amp; 'rat'"

#: func.xml:8996(entry)
msgid "<type>tsquery</type> contains another ?"
msgstr "запрос <type>tsquery</type> включает другой?"

#: func.xml:8997(literal)
msgid "'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery"
msgstr "'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery"

#: func.xml:8998(literal) func.xml:12199(literal)
msgid "f"
msgstr "f"

#: func.xml:9003(entry)
msgid "<type>tsquery</type> is contained in ?"
msgstr "запрос <type>tsquery</type> включён в другой?"

#: func.xml:9004(literal)
msgid "'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery"
msgstr "'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery"

#: func.xml:9012(para)
msgid ""
"The <type>tsquery</type> containment operators consider only the lexemes "
"listed in the two queries, ignoring the combining operators."
msgstr ""
"Операторы включения <type>tsquery</type> рассматривают только лексемы двух "
"запросов, игнорируя операторы их сочетания."

#: func.xml:9018(para)
msgid ""
"In addition to the operators shown in the table, the ordinary B-tree "
"comparison operators (<literal>=</literal>, <literal>&lt;</literal>, etc) "
"are defined for types <type>tsvector</type> and <type>tsquery</type>. These "
"are not very useful for text searching but allow, for example, unique "
"indexes to be built on columns of these types."
msgstr ""
"В дополнение к операторам, перечисленным в этой таблице, для типов "
"<type>tsvector</type> и <type>tsquery</type> определены обычные операторы "
"сравнения для B-дерева (<literal>=</literal>, <literal>&lt;</literal> и т. "
"д.). Они не очень полезны для поиска, но позволяют, в частности, создавать "
"индексы для столбцов этих типов."

#: func.xml:9027(title)
msgid "Text Search Functions"
msgstr "Функции текстового поиска"

#: func.xml:9041(indexterm)
#, fuzzy
msgid "<primary>array_to_tsvector</primary>"
msgstr "<primary>to_tsvector</primary>"

#: func.xml:9044(function)
#, fuzzy
msgid "array_to_tsvector(<placeholder-1/>)"
msgstr "encode_array_constructor(<placeholder-1/>)"

#: func.xml:9047(entry)
#, fuzzy
msgid "convert array of lexemes to <type>tsvector</type>"
msgstr "число лексем в значении <type>tsvector</type>"

#: func.xml:9048(literal)
msgid "array_to_tsvector('{fat,cat,rat}'::text[])"
msgstr ""

#: func.xml:9049(literal)
#, fuzzy
msgid "'fat' 'cat' 'rat'"
msgstr "'cat' 'fat' 'rat'"

#: func.xml:9053(indexterm)
msgid "<primary>get_current_ts_config</primary>"
msgstr "<primary>get_current_ts_config</primary>"

#: func.xml:9056(function)
msgctxt "function"
msgid "get_current_ts_config()"
msgstr "get_current_ts_config()"

#: func.xml:9058(type) func.xml:9092(type) func.xml:9104(type)
#: func.xml:9165(type) func.xml:9177(type) func.xml:9223(type)
#: func.xml:9385(type)
msgid "regconfig"
msgstr "regconfig"

#: func.xml:9059(entry)
msgid "get default text search configuration"
msgstr "получает конфигурацию текстового поиска по умолчанию"

#: func.xml:9060(literal)
msgctxt "literal"
msgid "get_current_ts_config()"
msgstr "get_current_ts_config()"

#: func.xml:9061(literal)
msgid "english"
msgstr "english"

#: func.xml:9070(type) func.xml:9082(type) func.xml:9235(type)
#: func.xml:9247(type) func.xml:9290(type) func.xml:9409(type)
#: func.xml:9417(type) func.xml:9428(type) func.xml:9436(type)
#: func.xml:9447(type) func.xml:10486(type) func.xml:13606(type)
#: func.xml:13764(type) func.xml:13767(type) func.xml:13780(type)
#: func.xml:13809(type) func.xml:13869(type) func.xml:16304(type)
#: func.xml:16309(type) func.xml:16739(type) func.xml:16744(type)
#: func.xml:16835(type) func.xml:16840(type) func.xml:16876(type)
#: func.xml:16881(type) func.xml:16886(type) func.xml:16891(type)
#: func.xml:16896(type) func.xml:16901(type) func.xml:16906(type)
#: func.xml:16911(type) func.xml:16916(type) func.xml:16936(type)
#: func.xml:16967(type) func.xml:18498(type) func.xml:19047(type)
msgid "integer"
msgstr "integer"

#: func.xml:9071(entry)
msgid "number of lexemes in <type>tsvector</type>"
msgstr "число лексем в значении <type>tsvector</type>"

#: func.xml:9072(literal)
msgid "length('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "length('fat:2,4 cat:3 rat:5A'::tsvector)"

#: func.xml:9077(indexterm)
msgid "<primary>numnode</primary>"
msgstr "<primary>numnode</primary>"

#: func.xml:9080(function)
msgid "numnode(<placeholder-1/>)"
msgstr "numnode(<placeholder-1/>)"

#: func.xml:9083(entry)
msgid "number of lexemes plus operators in <type>tsquery</type>"
msgstr "число лексем и операторов в запросе <type>tsquery</type>"

#: func.xml:9084(literal)
msgid "numnode('(fat &amp; rat) | cat'::tsquery)"
msgstr "numnode('(fat &amp; rat) | cat'::tsquery)"

#: func.xml:9089(indexterm)
msgid "<primary>plainto_tsquery</primary>"
msgstr "<primary>plainto_tsquery</primary>"

#: func.xml:9092(replaceable) func.xml:9104(replaceable)
#: func.xml:9165(replaceable) func.xml:9177(replaceable)
#: func.xml:9223(replaceable) func.xml:9385(replaceable)
msgid "config"
msgstr "конфигурация"

#: func.xml:9092(optional) func.xml:9104(optional) func.xml:9165(optional)
#: func.xml:9177(optional)
msgid "<placeholder-1/> <placeholder-2/> ,"
msgstr "<placeholder-1/> <placeholder-2/> ,"

#: func.xml:9092(replaceable) func.xml:9104(replaceable)
#: func.xml:9117(replaceable) func.xml:9165(replaceable)
#: func.xml:9223(replaceable) func.xml:9235(replaceable)
#: func.xml:9247(replaceable) func.xml:9259(replaceable)
#: func.xml:9268(replaceable)
msgid "query"
msgstr "запрос"

#: func.xml:9092(function)
msgid "plainto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "plainto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:9095(entry)
msgid "produce <type>tsquery</type> ignoring punctuation"
msgstr "выдаёт значение <type>tsquery</type>, игнорируя пунктуацию"

#: func.xml:9096(literal)
msgid "plainto_tsquery('english', 'The Fat Rats')"
msgstr "plainto_tsquery('english', 'The Fat Rats')"

#: func.xml:9097(literal) func.xml:9170(literal)
msgid "'fat' &amp; 'rat'"
msgstr "'fat' &amp; 'rat'"

#: func.xml:9101(indexterm)
#, fuzzy
msgid "<primary>phraseto_tsquery</primary>"
msgstr "<primary>to_tsquery</primary>"

#: func.xml:9104(function)
#, fuzzy
msgid "phraseto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "to_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:9107(entry)
#, fuzzy
msgid ""
"produce <type>tsquery</type> that searches for a phrase, ignoring punctuation"
msgstr "выдаёт значение <type>tsquery</type>, игнорируя пунктуацию"

#: func.xml:9109(literal)
#, fuzzy
msgid "phraseto_tsquery('english', 'The Fat Rats')"
msgstr "plainto_tsquery('english', 'The Fat Rats')"

#: func.xml:9114(indexterm)
msgid "<primary>querytree</primary>"
msgstr "<primary>querytree</primary>"

#: func.xml:9117(function)
msgid "querytree(<placeholder-1/> <placeholder-2/>)"
msgstr "querytree(<placeholder-1/> <placeholder-2/>)"

#: func.xml:9120(entry)
msgid "get indexable part of a <type>tsquery</type>"
msgstr "получает индексируемую часть запроса <type>tsquery</type>"

#: func.xml:9121(literal)
msgid "querytree('foo &amp; ! bar'::tsquery)"
msgstr "querytree('foo &amp; ! bar'::tsquery)"

#: func.xml:9122(literal)
msgid "'foo'"
msgstr "'foo'"

#: func.xml:9126(indexterm)
msgid "<primary>setweight</primary>"
msgstr "<primary>setweight</primary>"

#: func.xml:9129(replaceable) func.xml:9141(replaceable)
#: func.xml:9189(replaceable) func.xml:9199(replaceable)
#: func.xml:9211(replaceable) func.xml:9235(replaceable)
#: func.xml:9247(replaceable)
msgid "vector"
msgstr "вектор"

#: func.xml:9129(replaceable) func.xml:9141(replaceable)
msgid "weight"
msgstr "вес"

#: func.xml:9129(type) func.xml:9141(type)
msgid "\"char\""
msgstr "\"char\""

#: func.xml:9129(function)
#, fuzzy
msgid ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"right(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:9132(entry)
#, fuzzy
msgid ""
"assign <replaceable class=\"parameter\">weight</replaceable> to each element "
"of <replaceable class=\"parameter\">vector</replaceable>"
msgstr ""
"cat <replaceable class=\"parameter\">имя_файла</replaceable>* | psql "
"<replaceable class=\"parameter\">имя_базы</replaceable>"

#: func.xml:9133(literal)
msgid "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')"
msgstr "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')"

#: func.xml:9134(literal)
msgid "'cat':3A 'fat':2A,4A 'rat':5A"
msgstr "'cat':3A 'fat':2A,4A 'rat':5A"

#: func.xml:9138(indexterm)
#, fuzzy
msgid ""
"<primary>setweight</primary><secondary>setweight for specific lexeme(s)</"
"secondary>"
msgstr "<primary>шифрование</primary><secondary>избранных столбцов</secondary>"

#: func.xml:9141(replaceable) func.xml:9199(replaceable)
#: func.xml:9385(replaceable)
msgid "lexemes"
msgstr "лексемы"

#: func.xml:9141(function)
#, fuzzy
msgid ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:9144(entry)
#, fuzzy
msgid ""
"assign <replaceable class=\"parameter\">weight</replaceable> to elements of "
"<replaceable class=\"parameter\">vector</replaceable> that are listed in "
"<replaceable class=\"parameter\">lexemes</replaceable>"
msgstr ""
"pg_dump -j <replaceable class=\"parameter\">число</replaceable> -F d -f "
"<replaceable class=\"parameter\">выходной_каталог</replaceable> <replaceable "
"class=\"parameter\">имя_базы</replaceable>"

#: func.xml:9145(literal)
#, fuzzy
msgid "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A', '{cat,rat}')"
msgstr "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')"

#: func.xml:9146(literal)
#, fuzzy
msgid "'cat':3A 'fat':2,4 'rat':5A"
msgstr "'cat':3A 'fat':2A,4A 'rat':5A"

#: func.xml:9150(indexterm)
msgid "<primary>strip</primary>"
msgstr "<primary>strip</primary>"

#: func.xml:9153(function)
msgid "strip(<placeholder-1/>)"
msgstr "strip(<placeholder-1/>)"

#: func.xml:9156(entry)
msgid "remove positions and weights from <type>tsvector</type>"
msgstr "убирает позиции и веса из значения <type>tsvector</type>"

#: func.xml:9157(literal)
msgid "strip('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "strip('fat:2,4 cat:3 rat:5A'::tsvector)"

#: func.xml:9158(literal)
msgid "'cat' 'fat' 'rat'"
msgstr "'cat' 'fat' 'rat'"

#: func.xml:9162(indexterm)
msgid "<primary>to_tsquery</primary>"
msgstr "<primary>to_tsquery</primary>"

#: func.xml:9165(function)
msgid "to_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "to_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:9168(entry)
msgid "normalize words and convert to <type>tsquery</type>"
msgstr "нормализует слова и переводит их в <type>tsquery</type>"

#: func.xml:9169(literal)
msgid "to_tsquery('english', 'The &amp; Fat &amp; Rats')"
msgstr "to_tsquery('english', 'The &amp; Fat &amp; Rats')"

#: func.xml:9174(indexterm)
msgid "<primary>to_tsvector</primary>"
msgstr "<primary>to_tsvector</primary>"

#: func.xml:9177(replaceable) func.xml:9223(replaceable)
#: func.xml:9385(replaceable) func.xml:9409(replaceable)
#: func.xml:9417(replaceable)
msgid "document"
msgstr "документ"

#: func.xml:9177(function)
msgid "to_tsvector(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "to_tsvector(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:9180(entry)
msgid "reduce document text to <type>tsvector</type>"
msgstr "сокращает текст документа до значения <type>tsvector</type>"

#: func.xml:9181(literal)
msgid "to_tsvector('english', 'The Fat Rats')"
msgstr "to_tsvector('english', 'The Fat Rats')"

#: func.xml:9182(literal)
msgid "'fat':2 'rat':3"
msgstr "'fat':2 'rat':3"

#: func.xml:9186(indexterm)
#, fuzzy
msgid "<primary>ts_delete</primary>"
msgstr "<primary>delete</primary>"

#: func.xml:9189(replaceable) func.xml:9339(replaceable)
#, fuzzy
msgid "lexeme"
msgstr "лексемы"

#: func.xml:9189(function) func.xml:9199(function)
#, fuzzy
msgid ""
"ts_delete(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"ts_lexize(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#: func.xml:9192(entry)
#, fuzzy
msgid ""
"remove given <replaceable class=\"parameter\">lexeme</replaceable> from "
"<replaceable class=\"parameter\">vector</replaceable>"
msgstr ""
"pg_restore -d <replaceable class=\"parameter\">имя_базы</replaceable> "
"<replaceable class=\"parameter\">имя_файла</replaceable>"

#: func.xml:9193(literal)
#, fuzzy
msgid "ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')"
msgstr "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')"

#: func.xml:9194(literal)
#, fuzzy
msgid "'cat':3 'rat':5A"
msgstr "'fat':2 'rat':3"

#: func.xml:9202(entry)
#, fuzzy
msgid ""
"remove any occurrence of lexemes in <replaceable class=\"parameter"
"\">lexemes</replaceable> from <replaceable class=\"parameter\">vector</"
"replaceable>"
msgstr ""
"pg_restore -d <replaceable class=\"parameter\">имя_базы</replaceable> "
"<replaceable class=\"parameter\">имя_файла</replaceable>"

#: func.xml:9203(literal)
#, fuzzy
msgid "ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])"
msgstr "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')"

#: func.xml:9204(literal)
#, fuzzy
msgid "'cat':3"
msgstr "!'cat'"

#: func.xml:9208(indexterm)
#, fuzzy
msgid "<primary>ts_filter</primary>"
msgstr "<primary>ntile</primary>"

#: func.xml:9211(replaceable) func.xml:9235(replaceable)
#: func.xml:9247(replaceable) func.xml:9339(replaceable)
#: func.xml:9447(replaceable)
msgid "weights"
msgstr "веса"

#: func.xml:9211(type)
msgid "\"char\"[]"
msgstr "\"char\"[]"

#: func.xml:9211(function)
#, fuzzy
msgid ""
"ts_filter(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:9214(entry)
#, fuzzy
msgid ""
"Select only elements with given <replaceable class=\"parameter\">weights</"
"replaceable> from <replaceable class=\"parameter\">vector</replaceable>"
msgstr ""
"pg_restore -d <replaceable class=\"parameter\">имя_базы</replaceable> "
"<replaceable class=\"parameter\">имя_файла</replaceable>"

#: func.xml:9215(literal)
#, fuzzy
msgid "ts_filter('fat:2,4 cat:3b rat:5A'::tsvector, '{a,b}')"
msgstr "strip('fat:2,4 cat:3 rat:5A'::tsvector)"

#: func.xml:9216(literal)
#, fuzzy
msgid "'cat':3B 'rat':5A"
msgstr "'fat':2 'rat':3"

#: func.xml:9220(indexterm)
msgid "<primary>ts_headline</primary>"
msgstr "<primary>ts_headline</primary>"

#: func.xml:9223(optional) func.xml:9235(optional) func.xml:9247(optional)
#: func.xml:9385(optional) func.xml:9447(optional)
msgid "<placeholder-1/> <placeholder-2/>,"
msgstr "<placeholder-1/> <placeholder-2/>,"

#: func.xml:9223(replaceable)
msgctxt "replaceable"
msgid "options"
msgstr "параметры"

#: func.xml:9223(function)
msgid ""
"ts_headline(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_headline(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"

#: func.xml:9226(entry)
msgid "display a query match"
msgstr "выводит фрагмент, соответствующий запросу"

#: func.xml:9227(literal)
msgid "ts_headline('x y z', 'z'::tsquery)"
msgstr "ts_headline('x y z', 'z'::tsquery)"

#: func.xml:9228(literal)
msgid "x y &lt;b&gt;z&lt;/b&gt;"
msgstr "x y &lt;b&gt;z&lt;/b&gt;"

#: func.xml:9232(indexterm)
msgid "<primary>ts_rank</primary>"
msgstr "<primary>ts_rank</primary>"

#: func.xml:9235(type) func.xml:9247(type)
msgid "float4[]"
msgstr "float4[]"

#: func.xml:9235(replaceable) func.xml:9247(replaceable)
msgid "normalization"
msgstr "нормализация"

#: func.xml:9235(function)
msgid ""
"ts_rank(<placeholder-1/> <placeholder-2/> <placeholder-3/>, <placeholder-4/> "
"<placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_rank(<placeholder-1/> <placeholder-2/> <placeholder-3/>, <placeholder-4/> "
"<placeholder-5/> <placeholder-6/>)"

#: func.xml:9237(type) func.xml:9249(type)
msgid "float4"
msgstr "float4"

#: func.xml:9238(entry)
msgid "rank document for query"
msgstr "вычисляет ранг документа по отношению к запросу"

#: func.xml:9239(literal)
msgid "ts_rank(textsearch, query)"
msgstr "ts_rank(textsearch, query)"

#: func.xml:9240(literal)
msgid "0.818"
msgstr "0.818"

#: func.xml:9244(indexterm)
msgid "<primary>ts_rank_cd</primary>"
msgstr "<primary>ts_rank_cd</primary>"

#: func.xml:9247(function)
msgid ""
"ts_rank_cd(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_rank_cd(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"

#: func.xml:9250(entry)
msgid "rank document for query using cover density"
msgstr ""
"вычисляет ранг документа по отношению к запросу, используя плотность "
"покрытия (CDR)"

#: func.xml:9251(literal)
msgid "ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)"
msgstr "ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)"

#: func.xml:9252(literal)
msgid "2.01317"
msgstr "2.01317"

#: func.xml:9256(indexterm)
msgid "<primary>ts_rewrite</primary>"
msgstr "<primary>ts_rewrite</primary>"

#: func.xml:9259(replaceable) func.xml:9723(replaceable)
msgid "target"
msgstr "цель"

#: func.xml:9259(replaceable)
msgid "substitute"
msgstr "замена"

#: func.xml:9259(function)
msgid ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:9262(entry)
#, fuzzy
msgid ""
"replace <replaceable>target</replaceable> with <replaceable>substitute</"
"replaceable> within query"
msgstr "<replaceable>a</replaceable> OR <replaceable>b</replaceable>"

#: func.xml:9264(literal)
msgid "ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)"
msgstr "ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)"

#: func.xml:9265(literal) func.xml:9272(literal)
msgid "'b' &amp; ( 'foo' | 'bar' )"
msgstr "'b' &amp; ( 'foo' | 'bar' )"

#: func.xml:9268(replaceable)
msgid "select"
msgstr "выборка"

#: func.xml:9268(function)
msgid ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:9270(entry)
msgid ""
"replace using targets and substitutes from a <command>SELECT</command> "
"command"
msgstr ""
"заменяет элементы запроса, выбирая цели и подстановки командой "
"<command>SELECT</command>"

#: func.xml:9271(literal)
msgid "SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')"
msgstr "SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')"

#: func.xml:9276(indexterm)
#, fuzzy
msgid "<primary>tsquery_phrase</primary>"
msgstr "<primary>ts_parse</primary>"

#: func.xml:9279(replaceable) func.xml:9290(replaceable)
msgid "query1"
msgstr "запрос1"

#: func.xml:9279(replaceable) func.xml:9290(replaceable)
msgid "query2"
msgstr "запрос2"

#: func.xml:9279(function)
#, fuzzy
msgid ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:9282(entry)
#, fuzzy
msgid ""
"make query that searches for <replaceable>query1</replaceable> followed by "
"<replaceable>query2</replaceable> (same as <literal>&lt;-&gt;</literal> "
"operator)"
msgstr ""
"Возвращает значение JSON по пути, заданному элементами пути "
"(<replaceable>path_elems</replaceable>) (равнозначно оператору <literal>#&gt;"
"</literal> operator)."

#: func.xml:9285(literal)
msgid "tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))"
msgstr ""

#: func.xml:9286(literal)
#, fuzzy
msgid "'fat' &lt;-&gt; 'cat'"
msgstr "'fat' &amp; 'rat'"

#: func.xml:9290(replaceable)
msgid "distance"
msgstr "distance"

#: func.xml:9290(function)
#, fuzzy
msgid ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"translate(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:9293(entry)
#, fuzzy
msgid ""
"make query that searches for <replaceable>query1</replaceable> followed by "
"<replaceable>query2</replaceable> at maximum distance <replaceable>distance</"
"replaceable>"
msgstr ""
"от <replaceable>m</replaceable> до <replaceable>n</replaceable> (включая "
"границы) вхождений атома; <replaceable>m</replaceable> не может быть больше "
"<replaceable>n</replaceable>"

#: func.xml:9295(literal)
msgid "tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)"
msgstr ""

#: func.xml:9296(literal)
#, fuzzy
msgid "'fat' &lt;10&gt; 'cat'"
msgstr "'fat' &amp; 'rat'"

#: func.xml:9300(indexterm)
#, fuzzy
msgid "<primary>tsvector_to_array</primary>"
msgstr "<primary>hstore_to_array</primary>"

#: func.xml:9303(function)
#, fuzzy
msgid "tsvector_to_array(<placeholder-1/>)"
msgstr "is_array_ref(<placeholder-1/>)"

#: func.xml:9306(entry)
#, fuzzy
msgid "convert <type>tsvector</type> to array of lexemes"
msgstr ""
"преобразует <type>hstore</type> в массив перемежающихся ключей и значений"

#: func.xml:9307(literal)
#, fuzzy
msgid "tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "strip('fat:2,4 cat:3 rat:5A'::tsvector)"

#: func.xml:9308(literal)
msgid "{cat,fat,rat}"
msgstr ""

#: func.xml:9312(indexterm)
msgid "<primary>tsvector_update_trigger</primary>"
msgstr "<primary>tsvector_update_trigger</primary>"

#: func.xml:9315(function)
msgid "tsvector_update_trigger()"
msgstr "tsvector_update_trigger()"

#: func.xml:9317(type) func.xml:9329(type)
msgid "trigger"
msgstr "trigger"

#: func.xml:9318(entry) func.xml:9330(entry)
msgid "trigger function for automatic <type>tsvector</type> column update"
msgstr ""
"триггерная функция для автоматического изменения столбца типа "
"<type>tsvector</type>"

#: func.xml:9319(literal)
msgid ""
"CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', "
"title, body)"
msgstr ""
"CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.&zwsp;"
"swedish', title, body)"

#: func.xml:9324(indexterm)
msgid "<primary>tsvector_update_trigger_column</primary>"
msgstr "<primary>tsvector_update_trigger_column</primary>"

#: func.xml:9327(function)
msgid "tsvector_update_trigger_column()"
msgstr "tsvector_update_trigger_column()"

#: func.xml:9331(literal)
msgid ""
"CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, "
"body)"
msgstr ""
"CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, "
"body)"

#: func.xml:9336(indexterm)
#, fuzzy
msgid "<primary>unnest</primary><secondary>for tsvector</secondary>"
msgstr "<primary>соединение</primary><secondary>внешнее</secondary>"

#: func.xml:9339(replaceable)
#, fuzzy
msgid "positions"
msgstr "array_positions"

#: func.xml:9339(type)
msgid "smallint[]"
msgstr "smallint[]"

#: func.xml:9339(function)
#, fuzzy
msgid ""
"unnest(<placeholder-1/>, OUT <placeholder-2/> <placeholder-3/>, OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>)"
msgstr ""
"ts_rank(<placeholder-1/> <placeholder-2/> <placeholder-3/>, <placeholder-4/> "
"<placeholder-5/> <placeholder-6/>) возвращает <placeholder-7/>"

#: func.xml:9341(type) func.xml:9387(type) func.xml:9411(type)
#: func.xml:9418(type) func.xml:9430(type) func.xml:9437(type)
#: func.xml:9449(type) func.xml:10981(type) func.xml:15990(type)
#: func.xml:16053(type) func.xml:17308(type)
msgid "setof record"
msgstr "setof record"

#: func.xml:9342(entry)
#, fuzzy
msgid "expand a tsvector to a set of rows"
msgstr "разворачивает массив в набор строк"

#: func.xml:9343(literal)
#, fuzzy
msgid "unnest('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "strip('fat:2,4 cat:3 rat:5A'::tsvector)"

#: func.xml:9344(literal)
msgid "(cat,{3},{D}) ..."
msgstr ""

#: func.xml:9351(para)
msgid ""
"All the text search functions that accept an optional <type>regconfig</type> "
"argument will use the configuration specified by <xref linkend=\"guc-default-"
"text-search-config\"/> when that argument is omitted."
msgstr ""
"Все функции текстового поиска, принимающие необязательный аргумент "
"<type>regconfig</type>, будут использовать конфигурацию, указанную в "
"параметре <xref linkend=\"guc-default-text-search-config\"/>, когда этот "
"аргумент опущен."

#: func.xml:9359(para)
msgid ""
"The functions in <xref linkend=\"textsearch-functions-debug-table\"/> are "
"listed separately because they are not usually used in everyday text "
"searching operations. They are helpful for development and debugging of new "
"text search configurations."
msgstr ""
"Функции в <xref remap=\"6\" linkend=\"textsearch-functions-debug-table\"/> "
"перечислены отдельно, так как они не очень полезны в традиционных операциях "
"поиска. Они предназначены в основном для разработки и отладки новых "
"конфигураций текстового поиска."

#: func.xml:9368(title)
msgid "Text Search Debugging Functions"
msgstr "Функции отладки текстового поиска"

#: func.xml:9382(indexterm)
msgid "<primary>ts_debug</primary>"
msgstr "<primary>ts_debug</primary>"

#: func.xml:9385(replaceable) func.xml:9428(replaceable)
#: func.xml:9436(replaceable)
msgid "alias"
msgstr "псевдоним"

#: func.xml:9385(replaceable) func.xml:9428(replaceable)
#: func.xml:9436(replaceable)
msgid "description"
msgstr "описание"

#: func.xml:9385(replaceable) func.xml:9397(replaceable)
#: func.xml:9409(replaceable) func.xml:9417(replaceable)
msgid "token"
msgstr "фрагмент"

#: func.xml:9385(replaceable)
msgid "dictionaries"
msgstr "словари"

#: func.xml:9385(type)
msgid "regdictionary[]"
msgstr "regdictionary[]"

#: func.xml:9385(replaceable)
msgid "dictionary"
msgstr "словарь"

#: func.xml:9385(type) func.xml:9397(type)
msgid "regdictionary"
msgstr "regdictionary"

#: func.xml:9385(function)
msgid ""
"ts_debug(<placeholder-1/> <placeholder-2/> <placeholder-3/>, OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>, OUT <placeholder-10/> <placeholder-11/"
">, OUT <placeholder-12/> <placeholder-13/>, OUT <placeholder-14/> "
"<placeholder-15/>)"
msgstr ""
"ts_debug(<placeholder-1/> <placeholder-2/> <placeholder-3/>, OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>, OUT <placeholder-10/> <placeholder-11/"
">, OUT <placeholder-12/> <placeholder-13/>, OUT <placeholder-14/> "
"<placeholder-15/>)"

#: func.xml:9388(entry)
msgid "test a configuration"
msgstr "проверяет конфигурацию"

#: func.xml:9389(literal)
msgid "ts_debug('english', 'The Brightest supernovaes')"
msgstr "ts_debug('english', 'The Brightest supernovaes')"

#: func.xml:9390(literal)
msgid "(asciiword,\"Word, all ASCII\",The,{english_stem},english_stem,{}) ..."
msgstr ""
"(asciiword,\"Word, all ASCII\",The,{&zwsp;english_stem&zwsp;},&zwsp;"
"english_stem,{}) ..."

#: func.xml:9394(indexterm)
msgid "<primary>ts_lexize</primary>"
msgstr "<primary>ts_lexize</primary>"

#: func.xml:9397(replaceable)
msgid "dict"
msgstr "словарь"

#: func.xml:9397(function)
msgid ""
"ts_lexize(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"ts_lexize(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#: func.xml:9400(entry)
msgid "test a dictionary"
msgstr "проверяет словарь"

#: func.xml:9401(literal)
msgid "ts_lexize('english_stem', 'stars')"
msgstr "ts_lexize('english_stem', 'stars')"

#: func.xml:9402(literal)
msgid "{star}"
msgstr "{star}"

#: func.xml:9406(indexterm)
msgid "<primary>ts_parse</primary>"
msgstr "<primary>ts_parse</primary>"

#: func.xml:9409(replaceable) func.xml:9428(replaceable)
msgid "parser_name"
msgstr "имя_анализатора"

#: func.xml:9409(replaceable) func.xml:9417(replaceable)
#: func.xml:9428(replaceable) func.xml:9436(replaceable)
msgid "tokid"
msgstr "код_фрагмента"

#: func.xml:9409(function) func.xml:9417(function)
msgid ""
"ts_parse(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/> "
"<placeholder-8/>)"
msgstr ""
"ts_parse(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/> "
"<placeholder-8/>)"

#: func.xml:9412(entry) func.xml:9419(entry)
msgid "test a parser"
msgstr "проверяет анализатор"

#: func.xml:9413(literal)
msgid "ts_parse('default', 'foo - bar')"
msgstr "ts_parse('default', 'foo - bar')"

#: func.xml:9414(literal) func.xml:9421(literal)
msgid "(1,foo) ..."
msgstr "(1,foo) ..."

#: func.xml:9417(replaceable) func.xml:9436(replaceable)
msgctxt "replaceable"
msgid "parser_oid"
msgstr "oid_анализатора"

#: func.xml:9417(type) func.xml:9436(type) func.xml:14960(type)
#: func.xml:14965(type) func.xml:16304(type) func.xml:16309(type)
#: func.xml:16759(type) func.xml:16779(type) func.xml:16794(type)
#: func.xml:17886(type) func.xml:17918(type) func.xml:18165(type)
#: func.xml:18247(type) func.xml:18412(type) func.xml:18428(type)
msgid "oid"
msgstr "oid"

#: func.xml:9420(literal)
msgid "ts_parse(3722, 'foo - bar')"
msgstr "ts_parse(3722, 'foo - bar')"

#: func.xml:9425(indexterm)
msgid "<primary>ts_token_type</primary>"
msgstr "<primary>ts_token_type</primary>"

#: func.xml:9428(function) func.xml:9436(function)
msgid ""
"ts_token_type(<placeholder-1/> <placeholder-2/>, OUT <placeholder-3/> "
"<placeholder-4/>, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/"
"> <placeholder-8/>)"
msgstr ""
"ts_token_type(<placeholder-1/> <placeholder-2/>, OUT <placeholder-3/> "
"<placeholder-4/>, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/"
"> <placeholder-8/>)"

#: func.xml:9431(entry) func.xml:9438(entry)
msgid "get token types defined by parser"
msgstr "получает типы фрагментов, определённые анализатором"

#: func.xml:9432(literal)
msgid "ts_token_type('default')"
msgstr "ts_token_type('default')"

#: func.xml:9433(literal) func.xml:9440(literal)
msgid "(1,asciiword,\"Word, all ASCII\") ..."
msgstr "(1,asciiword,\"Word, all ASCII\") ..."

#: func.xml:9439(literal)
msgid "ts_token_type(3722)"
msgstr "ts_token_type(3722)"

#: func.xml:9444(indexterm)
msgid "<primary>ts_stat</primary>"
msgstr "<primary>ts_stat</primary>"

#: func.xml:9447(replaceable)
msgid "sqlquery"
msgstr "sql_запрос"

#: func.xml:9447(replaceable)
msgid "word"
msgstr "слово"

#: func.xml:9447(replaceable)
msgid "ndoc"
msgstr "число_док"

#: func.xml:9447(replaceable)
msgid "nentry"
msgstr "число_вхожд"

#: func.xml:9447(function)
msgid ""
"ts_stat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>)"
msgstr ""
"ts_stat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>)"

#: func.xml:9450(entry)
msgid "get statistics of a <type>tsvector</type> column"
msgstr "получает статистику столбца <type>tsvector</type>"

#: func.xml:9451(literal)
msgid "ts_stat('SELECT vector from apod')"
msgstr "ts_stat('SELECT vector from apod')"

#: func.xml:9452(literal)
msgid "(foo,10,15) ..."
msgstr "(foo,10,15) ..."

#: func.xml:9462(title)
msgid "XML Functions"
msgstr "XML-функции"

#: func.xml:9464(para)
msgid ""
"The functions and function-like expressions described in this section "
"operate on values of type <type>xml</type>. Check <xref linkend=\"datatype-"
"xml\"/> for information about the <type>xml</type> type. The function-like "
"expressions <function>xmlparse</function> and <function>xmlserialize</"
"function> for converting to and from type <type>xml</type> are not repeated "
"here. Use of most of these functions requires the installation to have been "
"built with <command>configure --with-libxml</command>."
msgstr ""
"Функции и подобные им выражения, описанные в этом разделе, работают со "
"значениями типа <type>xml</type>. Информацию о типе <type>xml</type> вы "
"можете найти в <xref remap=\"6\" linkend=\"datatype-xml\"/>. Выражения "
"<function>xmlparse</function> и <function>xmlserialize</function>, "
"преобразующие значения <type>xml</type> в текст и обратно, здесь повторно не "
"рассматриваются. Для использования большинства этих функций дистрибутив "
"должен быть собран с ключом <command>configure --with-libxml</command>."

#: func.xml:9476(title)
msgid "Producing XML Content"
msgstr "Создание XML-контента"

#: func.xml:9478(para)
msgid ""
"A set of functions and function-like expressions are available for producing "
"XML content from SQL data. As such, they are particularly suitable for "
"formatting query results into XML documents for processing in client "
"applications."
msgstr ""
"Для получения XML-контента из данных SQL существует целый набор функций и "
"функциональных выражений, особенно полезных для выдачи клиентским "
"приложениям результатов запроса в виде XML-документов."

#: func.xml:9486(literal)
msgctxt "literal"
msgid "xmlcomment"
msgstr "xmlcomment"

#: func.xml:9488(indexterm)
msgid "<primary>xmlcomment</primary>"
msgstr "<primary>xmlcomment</primary>"

#: func.xml:9492(function)
msgctxt "function"
msgid "xmlcomment"
msgstr "xmlcomment"

#: func.xml:9492(replaceable) func.xml:9750(replaceable)
#: func.xml:9866(replaceable) func.xml:9914(replaceable)
#: func.xml:9915(replaceable) func.xml:9916(replaceable)
msgctxt "replaceable"
msgid "text"
msgstr "текст"

#: func.xml:9492(synopsis) func.xml:9780(synopsis)
#, no-wrap
msgctxt "synopsis"
msgid "<placeholder-1/>(<placeholder-2/>)"
msgstr "<placeholder-1/>(<placeholder-2/>)"

#: func.xml:9494(para)
msgid ""
"The function <function>xmlcomment</function> creates an XML value containing "
"an XML comment with the specified text as content. The text cannot contain "
"<quote><literal>--</literal></quote> or end with a <quote><literal>-</"
"literal></quote> so that the resulting construct is a valid XML comment. If "
"the argument is null, the result is null."
msgstr ""
"Функция <function>xmlcomment</function> создаёт XML-значение, содержащее XML-"
"комментарий с заданным текстом. Этот текст не должен содержать "
"<quote><literal>--</literal></quote> или заканчиваться знаком "
"<quote><literal>-</literal></quote>, чтобы результирующая конструкция была "
"допустимой в XML. Если аргумент этой функции NULL, результатом её тоже будет "
"NULL."

#: func.xml:9502(para)
#, fuzzy
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlcomment('hello');\n"
"\n"
"  xmlcomment\n"
"--------------\n"
" <!--hello-->\n"
"]]></screen>"
msgstr ""
"Пример: <screen>SELECT xmlcomment('hello');\n"
"\n"
"  xmlcomment\n"
"--------------\n"
" &lt;!--hello--&gt;</screen>"

#: func.xml:9515(literal)
msgctxt "literal"
msgid "xmlconcat"
msgstr "xmlconcat"

#: func.xml:9517(indexterm)
msgid "<primary>xmlconcat</primary>"
msgstr "<primary>xmlconcat</primary>"

#: func.xml:9521(function)
msgctxt "function"
msgid "xmlconcat"
msgstr "xmlconcat"

#: func.xml:9521(replaceable) func.xml:9750(replaceable)
#: func.xml:9780(replaceable) func.xml:9848(replaceable)
#: func.xml:9866(replaceable) func.xml:9990(replaceable)
#: func.xml:10049(replaceable)
msgctxt "replaceable"
msgid "xml"
msgstr "xml"

#: func.xml:9521(optional) func.xml:9576(optional) func.xml:9668(optional)
#: func.xml:11558(optional) func.xml:11615(optional) func.xml:11616(optional)
#: func.xml:14326(optional) func.xml:14353(optional)
msgid ", ..."
msgstr ", ..."

#: func.xml:9521(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/><placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/><placeholder-3/>)"

#: func.xml:9523(para)
msgid ""
"The function <function>xmlconcat</function> concatenates a list of "
"individual XML values to create a single value containing an XML content "
"fragment. Null values are omitted; the result is only null if there are no "
"nonnull arguments."
msgstr ""
"Функция <function>xmlconcat</function> объединяет несколько XML-значений и "
"выдаёт в результате один фрагмент XML-контента. Значения NULL отбрасываются, "
"так что результат будет равен NULL, только если все аргументы равны NULL."

#: func.xml:9530(para)
#, fuzzy
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlconcat('<abc/>', '<bar>foo</bar>');\n"
"\n"
"      xmlconcat\n"
"----------------------\n"
" <abc/><bar>foo</bar>\n"
"]]></screen>"
msgstr ""
"Пример: <screen>SELECT xmlconcat('&lt;abc/&gt;', '&lt;bar&gt;foo&lt;/"
"bar&gt;');\n"
"\n"
"      xmlconcat\n"
"----------------------\n"
" &lt;abc/&gt;&lt;bar&gt;foo&lt;/bar&gt;</screen>"

#: func.xml:9541(para)
msgid ""
"XML declarations, if present, are combined as follows. If all argument "
"values have the same XML version declaration, that version is used in the "
"result, else no version is used. If all argument values have the standalone "
"declaration value <quote>yes</quote>, then that value is used in the result. "
"If all argument values have a standalone declaration value and at least one "
"is <quote>no</quote>, then that is used in the result. Else the result will "
"have no standalone declaration. If the result is determined to require a "
"standalone declaration but no version declaration, a version declaration "
"with version 1.0 will be used because XML requires an XML declaration to "
"contain a version declaration. Encoding declarations are ignored and removed "
"in all cases."
msgstr ""
"XML-объявления, если они присутствуют, обрабатываются следующим образом. "
"Если во всех аргументах содержатся объявления одной версии XML, эта версия "
"будет выдана в результате; в противном случае версии не будет. Если во всех "
"аргументах определён атрибут standalone со значением <quote>yes</quote>, это "
"же значение будет выдано в результате. Если во всех аргументах есть "
"объявление standalone, но минимум в одном со значением <quote>no</quote>, в "
"результате будет это значение. В противном случае в результате не будет "
"объявления standalone. Если же окажется, что в результате должно "
"присутствовать объявление standalone, а версия не определена, тогда в "
"результате будет выведена версия 1.0, так как XML-объявление не будет "
"допустимым без указания версии. Указания кодировки игнорируются и будут "
"удалены в любых случаях."

#: func.xml:9557(para)
#, fuzzy
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlconcat('<?xml version=\"1.1\"?><foo/>', '<?xml version=\"1.1\" "
"standalone=\"no\"?><bar/>');\n"
"\n"
"             xmlconcat\n"
"-----------------------------------\n"
" <?xml version=\"1.1\"?><foo/><bar/>\n"
"]]></screen>"
msgstr ""
"Пример: <screen>SELECT xmlconcat('&lt;?xml version=\"1.1\"?&gt;&lt;foo/"
"&gt;',\n"
" '&lt;?xml version=\"1.1\" standalone=\"no\"?&gt;&lt;bar/&gt;');\n"
"\n"
"             xmlconcat\n"
"-----------------------------------\n"
" &lt;?xml version=\"1.1\"?&gt;&lt;foo/&gt;&lt;bar/&gt;</screen>"

#: func.xml:9570(literal)
msgctxt "literal"
msgid "xmlelement"
msgstr "xmlelement"

#: func.xml:9572(indexterm)
msgid "<primary>xmlelement</primary>"
msgstr "<primary>xmlelement</primary>"

#: func.xml:9576(function)
msgctxt "function"
msgid "xmlelement"
msgstr "xmlelement"

#: func.xml:9576(replaceable) func.xml:9668(replaceable)
#: func.xml:12677(replaceable) func.xml:12694(replaceable)
msgctxt "replaceable"
msgid "name"
msgstr "имя"

#: func.xml:9576(replaceable) func.xml:11558(replaceable)
#: func.xml:11615(replaceable) func.xml:11616(replaceable)
#: func.xml:12677(replaceable) func.xml:12694(replaceable)
#: func.xml:13779(replaceable) func.xml:13785(replaceable)
#: func.xml:13808(replaceable) func.xml:13814(replaceable)
#: func.xml:13836(replaceable) func.xml:13839(replaceable)
#: func.xml:13852(replaceable) func.xml:13855(replaceable)
#: func.xml:13869(replaceable) func.xml:13873(replaceable)
#: func.xml:14326(replaceable) func.xml:14353(replaceable)
msgctxt "replaceable"
msgid "value"
msgstr "значение"

#: func.xml:9576(replaceable)
msgid "attname"
msgstr "атрибут"

#: func.xml:9576(optional) func.xml:9668(optional)
msgid "AS <placeholder-1/>"
msgstr "AS <placeholder-1/>"

#: func.xml:9576(optional)
msgid ", xmlattributes(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr ", xmlattributes(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:9576(replaceable)
msgid ", content, ..."
msgstr ", содержимое, ..."

#: func.xml:9576(synopsis)
#, no-wrap
msgid "<placeholder-1/>(name <placeholder-2/> <placeholder-3/> <optional><placeholder-4/></optional>)"
msgstr ""
"<placeholder-1/>(name <placeholder-2/> <placeholder-3/>\n"
"  <optional><placeholder-4/></optional>)"

#: func.xml:9578(para)
msgid ""
"The <function>xmlelement</function> expression produces an XML element with "
"the given name, attributes, and content."
msgstr ""
"Выражение <function>xmlelement</function> создаёт XML-элемент с заданным "
"именем, атрибутами и содержимым."

#: func.xml:9583(para)
#, fuzzy
msgid ""
"Examples: <screen><![CDATA[\n"
"SELECT xmlelement(name foo);\n"
"\n"
" xmlelement\n"
"------------\n"
" <foo/>\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes('xyz' as bar));\n"
"\n"
"    xmlelement\n"
"------------------\n"
" <foo bar=\"xyz\"/>\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', "
"'ent');\n"
"\n"
"             xmlelement\n"
"-------------------------------------\n"
" <foo bar=\"2007-01-26\">content</foo>\n"
"]]></screen>"
msgstr ""
"Примеры: <screen>SELECT xmlelement(name foo);\n"
"\n"
" xmlelement\n"
"------------\n"
" &lt;foo/&gt;\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes('xyz' as bar));\n"
"\n"
"    xmlelement\n"
"------------------\n"
" &lt;foo bar=\"xyz\"/&gt;\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes(current_date as bar),\n"
"  'cont', 'ent');\n"
"\n"
"             xmlelement\n"
"-------------------------------------\n"
" &lt;foo bar=\"2007-01-26\"&gt;content&lt;/foo&gt;</screen>"

#: func.xml:9606(para)
#, fuzzy
msgid ""
"Element and attribute names that are not valid XML names are escaped by "
"replacing the offending characters by the sequence "
"<literal>_x<replaceable>HHHH</replaceable>_</literal>, where "
"<replaceable>HHHH</replaceable> is the character's Unicode codepoint in "
"hexadecimal notation. For example: <screen><![CDATA[\n"
"SELECT xmlelement(name \"foo$bar\", xmlattributes('xyz' as \"a&b\"));\n"
"\n"
"            xmlelement\n"
"----------------------------------\n"
" <foo_x0024_bar a_x0026_b=\"xyz\"/>\n"
"]]></screen>"
msgstr ""
"Если имена элементов и атрибутов содержат символы, недопустимые в XML, эти "
"символы заменяются последовательностями <literal>_x<replaceable>HHHH</"
"replaceable>_</literal>, где <replaceable>HHHH</replaceable> &mdash; "
"шестнадцатеричный код символа в Unicode. Например: <screen>SELECT "
"xmlelement(name \"foo$bar\", xmlattributes('xyz' as \"a&amp;b\"));\n"
"\n"
"            xmlelement\n"
"----------------------------------\n"
" &lt;foo_x0024_bar a_x0026_b=\"xyz\"/&gt;</screen>"

#: func.xml:9621(para)
msgid ""
"An explicit attribute name need not be specified if the attribute value is a "
"column reference, in which case the column's name will be used as the "
"attribute name by default. In other cases, the attribute must be given an "
"explicit name. So this example is valid: <screen>CREATE TABLE test (a xml, b "
"xml);\n"
"SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;</screen> But "
"these are not: <screen>SELECT xmlelement(name test, "
"xmlattributes('constant'), a, b) FROM test;\n"
"SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;</screen>"
msgstr ""
"Если в качестве значения атрибута используется столбец таблицы, имя атрибута "
"можно не указывать явно, этим именем станет имя столбца. Во всех остальных "
"случаях имя атрибута должно быть определено явно. Таким образом, это "
"выражение допустимо: <screen>CREATE TABLE test (a xml, b xml);\n"
"SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;</screen> А "
"следующие варианты &mdash; нет: <screen>SELECT xmlelement(name test, "
"xmlattributes('constant'), a, b) FROM test;\n"
"SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;</screen>"

#: func.xml:9634(para)
#, fuzzy
msgid ""
"Element content, if specified, will be formatted according to its data type. "
"If the content is itself of type <type>xml</type>, complex XML documents can "
"be constructed. For example: <screen><![CDATA[\n"
"SELECT xmlelement(name foo, xmlattributes('xyz' as bar),\n"
"                            xmlelement(name abc),\n"
"                            xmlcomment('test'),\n"
"                            xmlelement(name xyz));\n"
"\n"
"                  xmlelement\n"
"----------------------------------------------\n"
" <foo bar=\"xyz\"><abc/><!--test--><xyz/></foo>\n"
"]]></screen> Content of other types will be formatted into valid XML "
"character data. This means in particular that the characters &lt;, &gt;, and "
"&amp; will be converted to entities. Binary data (data type <type>bytea</"
"type>) will be represented in base64 or hex encoding, depending on the "
"setting of the configuration parameter <xref linkend=\"guc-xmlbinary\"/>. "
"The particular behavior for individual data types is expected to evolve in "
"order to align the SQL and PostgreSQL data types with the XML Schema "
"specification, at which point a more precise description will appear."
msgstr ""
"Содержимое элемента, если оно задано, будет форматировано согласно его типу "
"данных. Когда оно имеет тип <type>xml</type>, из него можно конструировать "
"сложные XML-документы. Например: <screen>SELECT xmlelement(name foo, "
"xmlattributes('xyz' as bar),\n"
"                            xmlelement(name abc),\n"
"                            xmlcomment('test'),\n"
"                            xmlelement(name xyz));\n"
"\n"
"                  xmlelement\n"
"----------------------------------------------\n"
" &lt;foo bar=\"xyz\"&gt;&lt;abc/&gt;&lt;!--test--&gt;&lt;xyz/&gt;&lt;/foo&gt;"
"</screen> Содержимое других типов будет оформлено в виде блока символьных "
"данных XML. Это, в частности, означает, что символы &lt;, &gt; и &amp; будут "
"преобразованы в сущности XML. Двоичные данные (данные типа <type>bytea</"
"type>) представляются в кодировке base64 или в шестнадцатеричном виде, в "
"зависимости от значения параметра <xref linkend=\"guc-xmlbinary\"/>. Следует "
"ожидать, что конкретные представления отдельных типов данных могут быть "
"изменены для приведения типов SQL и PostgreSQL в соответствие со стандартом "
"XML Schema, когда появится его более полное описание."

#: func.xml:9662(literal)
msgctxt "literal"
msgid "xmlforest"
msgstr "xmlforest"

#: func.xml:9664(indexterm)
msgid "<primary>xmlforest</primary>"
msgstr "<primary>xmlforest</primary>"

#: func.xml:9668(function)
msgctxt "function"
msgid "xmlforest"
msgstr "xmlforest"

#: func.xml:9668(replaceable) func.xml:9723(replaceable)
msgctxt "replaceable"
msgid "content"
msgstr "содержимое"

#: func.xml:9668(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/> <placeholder-3/> <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/> <placeholder-3/> <placeholder-4/>)"

#: func.xml:9670(para)
msgid ""
"The <function>xmlforest</function> expression produces an XML forest "
"(sequence) of elements using the given names and content."
msgstr ""
"Выражение <function>xmlforest</function> создаёт последовательность XML-"
"элементов с заданными именами и содержимым."

#: func.xml:9675(para)
#, fuzzy
msgid ""
"Examples: <screen><![CDATA[\n"
"SELECT xmlforest('abc' AS foo, 123 AS bar);\n"
"\n"
"          xmlforest\n"
"------------------------------\n"
" <foo>abc</foo><bar>123</bar>\n"
"\n"
"\n"
"SELECT xmlforest(table_name, column_name)\n"
"FROM information_schema.columns\n"
"WHERE table_schema = 'pg_catalog';\n"
"\n"
"                                         xmlforest\n"
"-------------------------------------------------------------------------------------------\n"
" <table_name>pg_authid</table_name><column_name>rolname</column_name>\n"
" <table_name>pg_authid</table_name><column_name>rolsuper</column_name>\n"
" ...\n"
"]]></screen> As seen in the second example, the element name can be omitted "
"if the content value is a column reference, in which case the column name is "
"used by default. Otherwise, a name must be specified."
msgstr ""
"Примеры: <screen>SELECT xmlforest('abc' AS foo, 123 AS bar);\n"
"\n"
"          xmlforest\n"
"------------------------------\n"
" &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;\n"
"\n"
"\n"
"SELECT xmlforest(table_name, column_name)\n"
"FROM information_schema.columns\n"
"WHERE table_schema = 'pg_catalog';\n"
"\n"
"                              xmlforest\n"
"---------------------------------------------------------------------------\n"
" &lt;table_name&gt;pg_authid&lt;/table_name&gt;&lt;column_name&gt;"
"rolname&lt;/column_name&gt;\n"
" &lt;table_name&gt;pg_authid&lt;/table_name&gt;&lt;column_name&gt;"
"rolsuper&lt;/column_name&gt;\n"
" ...</screen> Как показано во втором примере, имя элемента можно опустить, "
"если источником содержимого служит столбец (в этом случае именем элемента по "
"умолчанию будет имя столбца). В противном случае имя элемента необходимо "
"указывать."

#: func.xml:9701(para)
msgid ""
"Element names that are not valid XML names are escaped as shown for "
"<function>xmlelement</function> above. Similarly, content data is escaped to "
"make valid XML content, unless it is already of type <type>xml</type>."
msgstr ""
"Имена элементов с символами, недопустимыми для XML, преобразуются так же, "
"как и для <function>xmlelement</function>. Данные содержимого тоже "
"приводятся к виду, допустимому для XML (кроме данных, которые уже имеют тип "
"<type>xml</type>)."

#: func.xml:9708(para)
msgid ""
"Note that XML forests are not valid XML documents if they consist of more "
"than one element, so it might be useful to wrap <function>xmlforest</"
"function> expressions in <function>xmlelement</function>."
msgstr ""
"Заметьте, что такие XML-последовательности не являются допустимыми XML-"
"документами, если они содержат больше одного элемента на верхнем уровне, "
"поэтому может иметь смысл вложить выражения <function>xmlforest</function> в "
"<function>xmlelement</function>."

#: func.xml:9717(literal)
msgctxt "literal"
msgid "xmlpi"
msgstr "xmlpi"

#: func.xml:9719(indexterm)
msgid "<primary>xmlpi</primary>"
msgstr "<primary>xmlpi</primary>"

#: func.xml:9723(function)
msgctxt "function"
msgid "xmlpi"
msgstr "xmlpi"

#: func.xml:9723(synopsis)
#, no-wrap
msgid "<placeholder-1/>(name <placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/>(name <placeholder-2/> <placeholder-3/>)"

#: func.xml:9725(para)
msgid ""
"The <function>xmlpi</function> expression creates an XML processing "
"instruction. The content, if present, must not contain the character "
"sequence <literal>?&gt;</literal>."
msgstr ""
"Выражение <function>xmlpi</function> создаёт инструкцию обработки XML. "
"Содержимое, если оно задано, не должно содержать последовательность символов "
"<literal>?&gt;</literal>."

#: func.xml:9731(para)
#, fuzzy
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlpi(name php, 'echo \"hello world\";');\n"
"\n"
"            xmlpi\n"
"-----------------------------\n"
" <?php echo \"hello world\";?>\n"
"]]></screen>"
msgstr ""
"Пример: <screen>SELECT xmlpi(name php, 'echo \"hello world\";');\n"
"\n"
"            xmlpi\n"
"-----------------------------\n"
" &lt;?php echo \"hello world\";?&gt;</screen>"

#: func.xml:9744(literal)
msgctxt "literal"
msgid "xmlroot"
msgstr "xmlroot"

#: func.xml:9746(indexterm)
msgid "<primary>xmlroot</primary>"
msgstr "<primary>xmlroot</primary>"

#: func.xml:9750(function)
msgctxt "function"
msgid "xmlroot"
msgstr "xmlroot"

#: func.xml:9750(optional)
msgid ", standalone yes|no|no value"
msgstr ", standalone yes|no|нет значения"

#: func.xml:9750(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/>, version <placeholder-3/> | no value <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, version <placeholder-3/> | нет значения <placeholder-4/>)"

#: func.xml:9752(para)
msgid ""
"The <function>xmlroot</function> expression alters the properties of the "
"root node of an XML value. If a version is specified, it replaces the value "
"in the root node's version declaration; if a standalone setting is "
"specified, it replaces the value in the root node's standalone declaration."
msgstr ""
"Выражение <function>xmlroot</function> изменяет свойства корневого узла XML-"
"значения. Если в нём указывается версия, она заменяет значение в объявлении "
"версии корневого узла; также в корневой узел переносится значение свойства "
"standalone."

#: func.xml:9774(literal)
msgctxt "literal"
msgid "xmlagg"
msgstr "xmlagg"

#: func.xml:9776(indexterm) func.xml:12787(indexterm)
msgid "<primary>xmlagg</primary>"
msgstr "<primary>xmlagg</primary>"

#: func.xml:9780(function)
msgctxt "function"
msgid "xmlagg"
msgstr "xmlagg"

#: func.xml:9782(para)
msgid ""
"The function <function>xmlagg</function> is, unlike the other functions "
"described here, an aggregate function. It concatenates the input values to "
"the aggregate function call, much like <function>xmlconcat</function> does, "
"except that concatenation occurs across rows rather than across expressions "
"in a single row. See <xref linkend=\"functions-aggregate\"/> for additional "
"information about aggregate functions."
msgstr ""
"Функция <function>xmlagg</function>, в отличие от других описанных здесь "
"функций, является агрегатной. Она соединяет значения, поступающие на вход "
"агрегатной функции, подобно функции <function>xmlconcat</function>, но "
"делает это, обрабатывая множество строк, а не несколько выражений в одной "
"строке. Дополнительно агрегатные функции описаны в <xref remap=\"6\" linkend="
"\"functions-aggregate\"/>."

#: func.xml:9792(para)
#, fuzzy
msgid ""
"Example: <screen><![CDATA[\n"
"CREATE TABLE test (y int, x xml);\n"
"INSERT INTO test VALUES (1, '<foo>abc</foo>');\n"
"INSERT INTO test VALUES (2, '<bar/>');\n"
"SELECT xmlagg(x) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" <foo>abc</foo><bar/>\n"
"]]></screen>"
msgstr ""
"Пример: <screen>CREATE TABLE test (y int, x xml);\n"
"INSERT INTO test VALUES (1, '&lt;foo&gt;abc&lt;/foo&gt;');\n"
"INSERT INTO test VALUES (2, '&lt;bar/&gt;');\n"
"SELECT xmlagg(x) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" &lt;foo&gt;abc&lt;/foo&gt;&lt;bar/&gt;</screen>"

#: func.xml:9805(para)
#, fuzzy
msgid ""
"To determine the order of the concatenation, an <literal>ORDER BY</literal> "
"clause may be added to the aggregate call as described in <xref linkend="
"\"syntax-aggregates\"/>. For example: <screen><![CDATA[\n"
"SELECT xmlagg(x ORDER BY y DESC) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" <bar/><foo>abc</foo>\n"
"]]></screen>"
msgstr ""
"Чтобы задать порядок объединения элементов, в агрегатный вызов можно "
"добавить предложение <literal>ORDER BY</literal>, описанное в <xref remap="
"\"6\" linkend=\"syntax-aggregates\"/>. Например: <screen>SELECT xmlagg(x "
"ORDER BY y DESC) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" &lt;bar/&gt;&lt;foo&gt;abc&lt;/foo&gt;</screen>"

#: func.xml:9818(para)
#, fuzzy
msgid ""
"The following non-standard approach used to be recommended in previous "
"versions, and may still be useful in specific cases: <screen><![CDATA[\n"
"SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;\n"
"        xmlagg\n"
"----------------------\n"
" <bar/><foo>abc</foo>\n"
"]]></screen>"
msgstr ""
"Следующий нестандартный подход рекомендовался в предыдущих версиях и может "
"быть по-прежнему полезен в некоторых случаях: <screen>SELECT xmlagg(x) FROM "
"(SELECT * FROM test ORDER BY y DESC) AS tab;\n"
"        xmlagg\n"
"----------------------\n"
" &lt;bar/&gt;&lt;foo&gt;abc&lt;/foo&gt;</screen>"

#: func.xml:9834(title)
msgid "XML Predicates"
msgstr "Условия с XML"

#: func.xml:9836(para)
msgid ""
"The expressions described in this section check properties of <type>xml</"
"type> values."
msgstr ""
"Описанные в этом разделе выражения проверяют свойства значений <type>xml</"
"type>."

#: func.xml:9842(literal)
msgid "IS DOCUMENT"
msgstr "IS DOCUMENT"

#: func.xml:9844(indexterm)
msgid "<primary>IS DOCUMENT</primary>"
msgstr "<primary>IS DOCUMENT</primary>"

#: func.xml:9848(synopsis)
#, no-wrap
msgid "<placeholder-1/> IS DOCUMENT"
msgstr "<placeholder-1/> IS DOCUMENT"

#: func.xml:9850(para)
msgid ""
"The expression <literal>IS DOCUMENT</literal> returns true if the argument "
"XML value is a proper XML document, false if it is not (that is, it is a "
"content fragment), or null if the argument is null. See <xref linkend="
"\"datatype-xml\"/> about the difference between documents and content "
"fragments."
msgstr ""
"Выражение <literal>IS DOCUMENT</literal> возвращает true, если аргумент "
"представляет собой правильный XML-документ, false в противном случае (т. е. "
"если это фрагмент содержимого) и NULL, если его аргумент также NULL. Чем "
"документы отличаются от фрагментов содержимого, вы можете узнать в <xref "
"remap=\"6\" linkend=\"datatype-xml\"/>."

#: func.xml:9860(literal)
msgctxt "literal"
msgid "XMLEXISTS"
msgstr "XMLEXISTS"

#: func.xml:9862(indexterm)
msgid "<primary>XMLEXISTS</primary>"
msgstr "<primary>XMLEXISTS</primary>"

#: func.xml:9866(function)
msgctxt "function"
msgid "XMLEXISTS"
msgstr "XMLEXISTS"

#: func.xml:9866(optional)
msgid "BY REF"
msgstr "BY REF"

#: func.xml:9866(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/> PASSING <placeholder-3/> <placeholder-4/> <placeholder-5/>)"
msgstr ""
"<placeholder-1/>(<placeholder-2/>\n"
" PASSING <placeholder-3/> <placeholder-4/> <placeholder-5/>)"

#: func.xml:9868(para)
msgid ""
"The function <function>xmlexists</function> returns true if the XPath "
"expression in the first argument returns any nodes, and false otherwise. (If "
"either argument is null, the result is null.)"
msgstr ""
"Функция <function>xmlexists</function> возвращает true, если выражение XPath "
"в первом аргументе возвращает какие либо узлы, и false &mdash; в противном "
"случае. (Если один из аргументов равен NULL, результатом также будет NULL.)"

#: func.xml:9875(para)
#, fuzzy
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF "
"'<towns><town>Toronto</town><town>Ottawa</town></towns>');\n"
"\n"
" xmlexists\n"
"------------\n"
" t\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Пример: <screen>SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY "
"REF\n"
"  '&lt;towns&gt;&lt;town&gt;Toronto&lt;/town&gt;&lt;town&gt;Ottawa&lt;/"
"town&gt;&lt;/towns&gt;');\n"
"\n"
" xmlexists\n"
"------------\n"
" t\n"
"(1 row)</screen>"

#: func.xml:9887(para)
msgid ""
"The <literal>BY REF</literal> clauses have no effect in PostgreSQL, but are "
"allowed for SQL conformance and compatibility with other implementations. "
"Per SQL standard, the first <literal>BY REF</literal> is required, the "
"second is optional. Also note that the SQL standard specifies the "
"<function>xmlexists</function> construct to take an XQuery expression as "
"first argument, but PostgreSQL currently only supports XPath, which is a "
"subset of XQuery."
msgstr ""
"Указания <literal>BY REF</literal> не несут смысловой нагрузки в PostgreSQL, "
"но могут присутствовать для соответствия стандарту SQL и совместимости с "
"другими реализациями. По стандарту SQL первое указание <literal>BY REF</"
"literal> является обязательным, а второе &mdash; нет. Также заметьте, что, "
"согласно стандарту SQL, конструкция <function>xmlexists</function> должна "
"принимать в первом аргументе выражение XQuery, но PostgreSQL в настоящее "
"время поддерживает только XPath, подмножество XQuery."

#: func.xml:9900(literal)
msgctxt "literal"
msgid "xml_is_well_formed"
msgstr "xml_is_well_formed"

#: func.xml:9902(indexterm)
msgid "<primary>xml_is_well_formed</primary>"
msgstr "<primary>xml_is_well_formed</primary>"

#: func.xml:9906(indexterm)
msgid "<primary>xml_is_well_formed_document</primary>"
msgstr "<primary>xml_is_well_formed_document</primary>"

#: func.xml:9910(indexterm)
msgid "<primary>xml_is_well_formed_content</primary>"
msgstr "<primary>xml_is_well_formed_content</primary>"

#: func.xml:9914(function)
msgctxt "function"
msgid "xml_is_well_formed"
msgstr "xml_is_well_formed"

#: func.xml:9915(function)
msgid "xml_is_well_formed_document"
msgstr "xml_is_well_formed_document"

#: func.xml:9916(function)
msgid "xml_is_well_formed_content"
msgstr "xml_is_well_formed_content"

#: func.xml:9914(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/>(<placeholder-2/>)\n"
"<placeholder-3/>(<placeholder-4/>)\n"
"<placeholder-5/>(<placeholder-6/>)"
msgstr ""
"<placeholder-1/>(<placeholder-2/>)\n"
"<placeholder-3/>(<placeholder-4/>)\n"
"<placeholder-5/>(<placeholder-6/>)"

#: func.xml:9918(para)
msgid ""
"These functions check whether a <type>text</type> string is well-formed XML, "
"returning a Boolean result. <function>xml_is_well_formed_document</function> "
"checks for a well-formed document, while "
"<function>xml_is_well_formed_content</function> checks for well-formed "
"content. <function>xml_is_well_formed</function> does the former if the "
"<xref linkend=\"guc-xmloption\"/> configuration parameter is set to "
"<literal>DOCUMENT</literal>, or the latter if it is set to <literal>CONTENT</"
"literal>. This means that <function>xml_is_well_formed</function> is useful "
"for seeing whether a simple cast to type <type>xml</type> will succeed, "
"whereas the other two functions are useful for seeing whether the "
"corresponding variants of <function>XMLPARSE</function> will succeed."
msgstr ""
"Эти функции проверяют, является ли <type>текст</type> правильно оформленным "
"XML, и возвращают соответствующее логическое значение. Функция "
"<function>xml_is_well_formed_document</function> проверяет аргумент как "
"правильно оформленный документ, а <function>xml_is_well_formed_content</"
"function> &mdash; правильно оформленное содержание. Функция "
"<function>xml_is_well_formed</function> может делать первое или второе, в "
"зависимости от значения параметра конфигурации <xref linkend=\"guc-xmloption"
"\"/> (<literal>DOCUMENT</literal> или <literal>CONTENT</literal>, "
"соответственно). Это значит, что <function>xml_is_well_formed</function> "
"помогает понять, будет ли успешным простое приведение к типу <type>xml</"
"type>, тогда как две другие функции проверяют, будут ли успешны "
"соответствующие варианты <function>XMLPARSE</function>."

#: func.xml:9933(para)
#, fuzzy
msgid ""
"Examples: <screen><![CDATA[\n"
"SET xmloption TO DOCUMENT;\n"
"SELECT xml_is_well_formed('<>');\n"
" xml_is_well_formed \n"
"--------------------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed('<abc/>');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SET xmloption TO CONTENT;\n"
"SELECT xml_is_well_formed('abc');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document('<pg:foo xmlns:pg=\"http://postgresql.org/"
"stuff\">bar</pg:foo>');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document('<pg:foo xmlns:pg=\"http://postgresql.org/"
"stuff\">bar</my:foo>');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" f\n"
"(1 row)\n"
"]]></screen> The last example shows that the checks include whether "
"namespaces are correctly matched."
msgstr ""
"Примеры: <screen>SET xmloption TO DOCUMENT;\n"
"SELECT xml_is_well_formed('&lt;&gt;');\n"
" xml_is_well_formed \n"
"--------------------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed('&lt;abc/&gt;');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SET xmloption TO CONTENT;\n"
"SELECT xml_is_well_formed('abc');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document(\n"
" '&lt;pg:foo xmlns:pg=\"http://postgresql.org/stuff\"&gt;bar&lt;/pg:"
"foo&gt;');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document(\n"
" '&lt;pg:foo xmlns:pg=\"http://postgresql.org/stuff\"&gt;bar&lt;/my:"
"foo&gt;');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" f\n"
"(1 row)</screen> Последний пример показывает, что при проверке также "
"учитывается, совпадают ли пространства имён."

#: func.xml:9977(title)
msgid "Processing XML"
msgstr "Обработка XML"

#: func.xml:9979(indexterm)
msgid "<primary>XPath</primary>"
msgstr "<primary>XPath</primary>"

#: func.xml:9983(para)
msgid ""
"To process values of data type <type>xml</type>, PostgreSQL offers the "
"functions <function>xpath</function> and <function>xpath_exists</function>, "
"which evaluate XPath 1.0 expressions."
msgstr ""
"Для обработки значений типа <type>xml</type> с помощью выражений XPath 1.0 в "
"PostgreSQL представлены функции <function>xpath</function> и "
"<function>xpath_exists</function>."

#: func.xml:9990(function)
msgctxt "function"
msgid "xpath"
msgstr "xpath"

#: func.xml:9990(replaceable) func.xml:10049(replaceable)
msgctxt "replaceable"
msgid "xpath"
msgstr "xpath"

#: func.xml:9990(replaceable) func.xml:10049(replaceable)
msgid "nsarray"
msgstr "nsarray"

#: func.xml:9990(synopsis) func.xml:10049(synopsis)
#, no-wrap
msgctxt "synopsis"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:9992(para)
msgid ""
"The function <function>xpath</function> evaluates the XPath expression "
"<replaceable>xpath</replaceable> (a <type>text</type> value) against the XML "
"value <replaceable>xml</replaceable>. It returns an array of XML values "
"corresponding to the node set produced by the XPath expression. If the XPath "
"expression returns a scalar value rather than a node set, a single-element "
"array is returned."
msgstr ""
"Функция <function>xpath</function> вычисляет выражение XPath (аргумент "
"<replaceable>xpath</replaceable> типа <type>text</type>) для заданного "
"<replaceable>xml</replaceable>. Она возвращает массив XML-значений с набором "
"узлов, полученных в результате выражения XPath. Если выражение XPath выдаёт "
"не набор узлов, а скалярное значение, возвращается массив из одного элемента."

#: func.xml:10002(para)
msgid ""
"The second argument must be a well formed XML document. In particular, it "
"must have a single root node element."
msgstr ""
"Вторым аргументом должен быть правильно оформленный XML-документ. В "
"частности, в нём должен быть единственный корневой элемент."

#: func.xml:10007(para)
msgid ""
"The optional third argument of the function is an array of namespace "
"mappings. This array should be a two-dimensional <type>text</type> array "
"with the length of the second axis being equal to 2 (i.e., it should be an "
"array of arrays, each of which consists of exactly 2 elements). The first "
"element of each array entry is the namespace name (alias), the second the "
"namespace URI. It is not required that aliases provided in this array be the "
"same as those being used in the XML document itself (in other words, both in "
"the XML document and in the <function>xpath</function> function context, "
"aliases are <emphasis>local</emphasis>)."
msgstr ""
"В необязательном третьем аргументе функции передаются сопоставления "
"пространств имён. Эти сопоставления должны определяться в двумерном массиве "
"типа <type>text</type>, во второй размерности которого 2 элемента (т. е. это "
"должен быть массив массивов, состоящих из 2 элементов). В первом элементе "
"каждого массива определяется псевдоним (префикс) пространства имён, а во "
"втором &mdash; его URI. Псевдонимы, определённые в этом массиве, не "
"обязательно должны совпадать с префиксами пространств имён в самом XML-"
"документе (другими словами, для XML-документа и функции <function>xpath</"
"function> псевдонимы имеют <emphasis>локальный</emphasis> характер)."

#: func.xml:10019(para)
#, fuzzy
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xpath('/my:a/text()', '<my:a xmlns:my=\"http://example.com\">test</my:"
"a>',\n"
"             ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath  \n"
"--------\n"
" {test}\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Пример: <screen>SELECT xpath('/my:a/text()',\n"
"             '&lt;my:a xmlns:my=\"http://example.com\"&gt;test&lt;/my:"
"a&gt;',\n"
"             ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath  \n"
"--------\n"
" {test}\n"
"(1 row)</screen>"

#: func.xml:10032(para)
#, fuzzy
msgid ""
"To deal with default (anonymous) namespaces, do something like this: "
"<screen><![CDATA[\n"
"SELECT xpath('//mydefns:b/text()', '<a xmlns=\"http://example.com\"><b>test</"
"b></a>',\n"
"             ARRAY[ARRAY['mydefns', 'http://example.com']]);\n"
"\n"
" xpath\n"
"--------\n"
" {test}\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Для пространства имён по умолчанию (анонимного) это выражение можно записать "
"так: <screen>SELECT xpath('//mydefns:b/text()',\n"
"             '&lt;a xmlns=\"http://example.com\"&gt;&lt;b&gt;test&lt;/b&gt;"
"&lt;/a&gt;',\n"
"             ARRAY[ARRAY['mydefns', 'http://example.com']]);\n"
"\n"
" xpath\n"
"--------\n"
" {test}\n"
"(1 row)</screen>"

#: func.xml:10045(indexterm)
msgid "<primary>xpath_exists</primary>"
msgstr "<primary>xpath_exists</primary>"

#: func.xml:10049(function)
msgid "xpath_exists"
msgstr "xpath_exists"

#: func.xml:10051(para)
msgid ""
"The function <function>xpath_exists</function> is a specialized form of the "
"<function>xpath</function> function. Instead of returning the individual XML "
"values that satisfy the XPath, this function returns a Boolean indicating "
"whether the query was satisfied or not. This function is equivalent to the "
"standard <literal>XMLEXISTS</literal> predicate, except that it also offers "
"support for a namespace mapping argument."
msgstr ""
"Функция <function>xpath_exists</function> представляет собой "
"специализированную форму функции <function>xpath</function>. Она возвращает "
"не весь набор XML-узлов, удовлетворяющих выражению XPath, а только одно "
"логическое значение, показывающее, есть ли такие узлы. Эта функция "
"равнозначна стандартному условию <literal>XMLEXISTS</literal>, за "
"исключением того, что она также поддерживает сопоставления пространств имён."

#: func.xml:10060(para)
#, fuzzy
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my=\"http://example.com"
"\">test</my:a>',\n"
"                     ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath_exists  \n"
"--------------\n"
" t\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Пример: <screen>SELECT xpath_exists('/my:a/text()',\n"
"                     '&lt;my:a xmlns:my=\"http://example.com\"&gt;test&lt;/"
"my:a&gt;',\n"
"                     ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath_exists  \n"
"--------------\n"
" t\n"
"(1 row)</screen>"

#: func.xml:10075(title)
msgid "Mapping Tables to XML"
msgstr "Отображение таблиц в XML"

#: func.xml:10077(indexterm)
msgid "<primary>XML export</primary>"
msgstr "<primary>экспорт в XML</primary>"

#: func.xml:10081(para)
msgid ""
"The following functions map the contents of relational tables to XML values. "
"They can be thought of as XML export functionality: "
"<synopsis>table_to_xml(tbl regclass, nulls boolean, tableforest boolean, "
"targetns text)\n"
"query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)\n"
"cursor_to_xml(cursor refcursor, count int, nulls boolean,\n"
"              tableforest boolean, targetns text)</synopsis> The return type "
"of each function is <type>xml</type>."
msgstr ""
"Следующие функции отображают содержимое реляционных таблиц в значения XML. "
"Их можно рассматривать как средства экспорта в XML: "
"<synopsis>table_to_xml(tbl regclass, nulls boolean, tableforest boolean, "
"targetns text)\n"
"query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)\n"
"cursor_to_xml(cursor refcursor, count int, nulls boolean,\n"
"              tableforest boolean, targetns text)</synopsis> Результат всех "
"этих функций имеет тип <type>xml</type>."

#: func.xml:10091(para)
msgid ""
"<function>table_to_xml</function> maps the content of the named table, "
"passed as parameter <parameter>tbl</parameter>. The <type>regclass</type> "
"type accepts strings identifying tables using the usual notation, including "
"optional schema qualifications and double quotes. <function>query_to_xml</"
"function> executes the query whose text is passed as parameter "
"<parameter>query</parameter> and maps the result set. "
"<function>cursor_to_xml</function> fetches the indicated number of rows from "
"the cursor specified by the parameter <parameter>cursor</parameter>. This "
"variant is recommended if large tables have to be mapped, because the result "
"value is built up in memory by each function."
msgstr ""
"<function>table_to_xml</function> отображает в xml содержимое таблицы, имя "
"которой задаётся в параметре <parameter>tbl</parameter>. Тип <type>regclass</"
"type> принимает идентификаторы строк в обычной записи, которые могут "
"содержать указание схемы и кавычки. Функция <function>query_to_xml</"
"function> выполняет запрос, текст которого передаётся в параметре "
"<parameter>query</parameter>, и отображает в xml результирующий набор. "
"Последняя функция, <function>cursor_to_xml</function> выбирает указанное "
"число строк из курсора, переданного в параметре <parameter>cursor</"
"parameter>. Этот вариант рекомендуется использовать с большими таблицами, "
"так как все эти функции создают результирующий xml в памяти."

#: func.xml:10106(para)
#, fuzzy
msgid ""
"If <parameter>tableforest</parameter> is false, then the resulting XML "
"document looks like this: <screen><![CDATA[\n"
"<tablename>\n"
"  <row>\n"
"    <columnname1>data</columnname1>\n"
"    <columnname2>data</columnname2>\n"
"  </row>\n"
"\n"
"  <row>\n"
"    ...\n"
"  </row>\n"
"\n"
"  ...\n"
"</tablename>\n"
"]]></screen> If <parameter>tableforest</parameter> is true, the result is an "
"XML content fragment that looks like this: <screen><![CDATA[\n"
"<tablename>\n"
"  <columnname1>data</columnname1>\n"
"  <columnname2>data</columnname2>\n"
"</tablename>\n"
"\n"
"<tablename>\n"
"  ...\n"
"</tablename>\n"
"\n"
"...\n"
"]]></screen> If no table name is available, that is, when mapping a query or "
"a cursor, the string <literal>table</literal> is used in the first format, "
"<literal>row</literal> in the second format."
msgstr ""
"Если параметр <parameter>tableforest</parameter> имеет значение false, "
"результирующий XML-документ выглядит так: <screen>&lt;имя_таблицы&gt;\n"
"  &lt;row&gt;\n"
"    &lt;имя_столбца1&gt;данные&lt;/имя_столбца1&gt;\n"
"    &lt;имя_столбца2&gt;данные&lt;/имя_столбца2&gt;\n"
"  &lt;/row&gt;\n"
"\n"
"  &lt;row&gt;\n"
"    ...\n"
"  &lt;/row&gt;\n"
"\n"
"  ...\n"
"&lt;/имя_таблицы&gt;</screen> А если <parameter>tableforest</parameter> "
"равен true, в результате будет выведен следующий фрагмент XML: <screen>&lt;"
"имя_таблицы&gt;\n"
"  &lt;имя_столбца1&gt;data&lt;/имя_столбца1&gt;\n"
"  &lt;имя_столбца2&gt;data&lt;/имя_столбца2&gt;\n"
"&lt;/имя_таблицы&gt;\n"
"\n"
"&lt;имя_таблицы&gt;\n"
"  ...\n"
"&lt;/имя_таблицы&gt;\n"
"\n"
"...</screen> Если имя таблицы неизвестно, например, при отображении "
"результатов запроса или курсора, вместо него в первом случае вставляется "
"<literal>table</literal>, а во втором &mdash; <literal>row</literal>."

#: func.xml:10144(para)
msgid ""
"The choice between these formats is up to the user. The first format is a "
"proper XML document, which will be important in many applications. The "
"second format tends to be more useful in the <function>cursor_to_xml</"
"function> function if the result values are to be reassembled into one "
"document later on. The functions for producing XML content discussed above, "
"in particular <function>xmlelement</function>, can be used to alter the "
"results to taste."
msgstr ""
"Выбор между этими форматами остаётся за пользователем. Первый вариант "
"позволяет создать готовый XML-документ, что может быть полезно для многих "
"приложений, а второй удобно применять с функцией <function>cursor_to_xml</"
"function>, если её результаты будут собираться в документ позже. Полученный "
"результат можно изменить по вкусу с помощью рассмотренных выше функций "
"создания XML-содержимого, в частности <function>xmlelement</function>."

#: func.xml:10155(para)
msgid ""
"The data values are mapped in the same way as described for the function "
"<function>xmlelement</function> above."
msgstr ""
"Значения данных эти функции отображают так же, как и ранее описанная функция "
"<function>xmlelement</function>."

#: func.xml:10160(para)
#, fuzzy
msgid ""
"The parameter <parameter>nulls</parameter> determines whether null values "
"should be included in the output. If true, null values in columns are "
"represented as: <screen><![CDATA[\n"
"<columnname xsi:nil=\"true\"/>\n"
"]]></screen> where <literal>xsi</literal> is the XML namespace prefix for "
"XML Schema Instance. An appropriate namespace declaration will be added to "
"the result value. If false, columns containing null values are simply "
"omitted from the output."
msgstr ""
"Параметр <parameter>nulls</parameter> определяет, нужно ли включать в "
"результат значения NULL. Если он установлен, значения NULL в столбцах "
"представляются так: <screen>&lt;имя_столбца xsi:nil=\"true\"/&gt;</"
"screen>Здесь <literal>xsi</literal> &mdash; это префикс пространства имён "
"XML Schema Instance. При этом в результирующий XML будет добавлено "
"соответствующее объявление пространства имён. Если же данный параметр имеет "
"значение false, столбцы со значениями NULL просто не будут выводиться."

#: func.xml:10173(para)
msgid ""
"The parameter <parameter>targetns</parameter> specifies the desired XML "
"namespace of the result. If no particular namespace is wanted, an empty "
"string should be passed."
msgstr ""
"Параметр <parameter>targetns</parameter> определяет целевое пространство "
"имён для результирующего XML. Если пространство имён не нужно, значением "
"этого параметра должна быть пустая строка."

#: func.xml:10179(para)
msgid ""
"The following functions return XML Schema documents describing the mappings "
"performed by the corresponding functions above: "
"<synopsis>table_to_xmlschema(tbl regclass, nulls boolean, tableforest "
"boolean, targetns text)\n"
"query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns "
"text)\n"
"cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, "
"targetns text)</synopsis> It is essential that the same parameters are "
"passed in order to obtain matching XML data mappings and XML Schema "
"documents."
msgstr ""
"Следующие функции выдают документы XML Schema, которые содержат схемы "
"отображений, выполняемых соответствующими ранее рассмотренными функциями: "
"<synopsis>table_to_xmlschema(tbl regclass, nulls boolean, tableforest "
"boolean,\n"
"  targetns text)\n"
"query_to_xmlschema(query text, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean,\n"
"  targetns text)</synopsis> Чтобы результаты отображения данных в XML "
"соответствовали XML-схемам, важно, чтобы паре функций передавались "
"одинаковые параметры."

#: func.xml:10189(para)
msgid ""
"The following functions produce XML data mappings and the corresponding XML "
"Schema in one document (or forest), linked together. They can be useful "
"where self-contained and self-describing results are wanted: "
"<synopsis>table_to_xml_and_xmlschema(tbl regclass, nulls boolean, "
"tableforest boolean, targetns text)\n"
"query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, "
"targetns text)</synopsis>"
msgstr ""
"Следующие функции выдают отображение данных в XML и соответствующую XML-"
"схему в одном документе (или фрагменте), объединяя их вместе. Это может быть "
"полезно там, где желательно получить самодостаточные результаты с описанием: "
"<synopsis>table_to_xml_and_xmlschema(tbl regclass, nulls boolean, "
"tableforest boolean,\n"
"  targetns text)\n"
"query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean,\n"
"  targetns text)</synopsis>"

#: func.xml:10198(para)
msgid ""
"In addition, the following functions are available to produce analogous "
"mappings of entire schemas or the entire current database: "
"<synopsis>schema_to_xml(schema name, nulls boolean, tableforest boolean, "
"targetns text)\n"
"schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, "
"targetns text)\n"
"schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, "
"targetns text)\n"
"\n"
"database_to_xml(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns "
"text)</synopsis> Note that these potentially produce a lot of data, which "
"needs to be built up in memory. When requesting content mappings of large "
"schemas or databases, it might be worthwhile to consider mapping the tables "
"separately instead, possibly even through a cursor."
msgstr ""
"В дополнение к ним есть следующие функции, способные выдать аналогичные "
"представления для целых схем в базе данных или даже всей текущей базы "
"данных: <synopsis>schema_to_xml(schema name, nulls boolean, tableforest "
"boolean,\n"
"  targetns text)\n"
"schema_to_xmlschema(schema name, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest "
"boolean,\n"
"  targetns text)\n"
"\n"
"database_to_xml(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xml_and_xmlschema(nulls boolean, tableforest boolean,\n"
"  targetns text)</synopsis> Заметьте, что объём таких данных может быть "
"очень большим, а XML будет создаваться в памяти. Поэтому, вместо того, чтобы "
"пытаться отобразить в XML сразу всё содержимое больших схем или баз данных, "
"лучше делать это по таблицам, возможно даже используя курсор."

#: func.xml:10216(para)
#, fuzzy
msgid ""
"The result of a schema content mapping looks like this: <screen><![CDATA[\n"
"<schemaname>\n"
"\n"
"table1-mapping\n"
"\n"
"table2-mapping\n"
"\n"
"...\n"
"\n"
"</schemaname>]]></screen> where the format of a table mapping depends on the "
"<parameter>tableforest</parameter> parameter as explained above."
msgstr ""
"Результат отображения содержимого схемы будет выглядеть так: <screen>&lt;"
"имя_схемы&gt;\n"
"\n"
"отображение_таблицы1\n"
"\n"
"отображение_таблицы2\n"
"\n"
"...\n"
"\n"
"&lt;/имя_схемы&gt;</screen>Формат отображения таблицы определяется "
"параметром <parameter>tableforest</parameter>, описанным выше."

#: func.xml:10234(para)
#, fuzzy
msgid ""
"The result of a database content mapping looks like this: <screen><![CDATA[\n"
"<dbname>\n"
"\n"
"<schema1name>\n"
"  ...\n"
"</schema1name>\n"
"\n"
"<schema2name>\n"
"  ...\n"
"</schema2name>\n"
"\n"
"...\n"
"\n"
"</dbname>]]></screen> where the schema mapping is as above."
msgstr ""
"Результат отображения содержимого базы данных будет таким: <screen>&lt;"
"имя_БД&gt;\n"
"\n"
"&lt;имя_схемы1&gt;\n"
"  ...\n"
"&lt;/имя_схемы1&gt;\n"
"\n"
"&lt;имя_схемы2&gt;\n"
"  ...\n"
"&lt;/имя_схемы2&gt;\n"
"\n"
"...\n"
"\n"
"&lt;/имя_БД&gt;</screen>Здесь отображение схемы имеет вид, показанный выше."

#: func.xml:10255(para)
msgid ""
"As an example of using the output produced by these functions, <xref linkend="
"\"xslt-xml-html\"/> shows an XSLT stylesheet that converts the output of "
"<function>table_to_xml_and_xmlschema</function> to an HTML document "
"containing a tabular rendition of the table data. In a similar manner, the "
"results from these functions can be converted into other XML-based formats."
msgstr ""
"В качестве примера, иллюстрирующего использование результата этих функций, "
"на <xref remap=\"6\" linkend=\"xslt-xml-html\"/> показано XSLT-"
"преобразование, которое переводит результат функции "
"<function>table_to_xml_and_xmlschema</function> в HTML-документ, содержащий "
"таблицу с данными. Подобным образом результаты этих функций можно "
"преобразовать и в другие форматы на базе XML."

#: func.xml:10266(title)
msgid "XSLT Stylesheet for Converting SQL/XML Output to HTML"
msgstr "XSLT-преобразование, переводящее результат SQL/XML в формат HTML"

#: func.xml:10318(title)
msgid "JSON Functions and Operators"
msgstr "Функции и операторы JSON"

#: func.xml:10320(indexterm)
msgid "<primary>JSON</primary><secondary>functions and operators</secondary>"
msgstr "<primary>JSON</primary><secondary>функции и операторы</secondary>"

#: func.xml:10324(para)
msgid ""
"<xref linkend=\"functions-json-op-table\"/> shows the operators that are "
"available for use with the two JSON data types (see <xref linkend=\"datatype-"
"json\"/>)."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-json-op-table\"/> перечислены "
"функции, позволяющие создавать данные в формате JSON (см. <xref remap=\"4\" "
"linkend=\"datatype-json\"/>)."

#: func.xml:10331(title)
msgid "<type>json</type> and <type>jsonb</type> Operators"
msgstr "Операторы для типов <type>json</type> и <type>jsonb</type>"

#: func.xml:10336(entry) func.xml:10429(entry)
msgid "Right Operand Type"
msgstr "Тип правого операнда"

#: func.xml:10344(literal) func.xml:10352(literal)
msgid "-&gt;"
msgstr "-&gt;"

#: func.xml:10346(entry)
msgid ""
"Get JSON array element (indexed from zero, negative integers count from the "
"end)"
msgstr ""
"Выдаёт элемент массива JSON (по номеру от 0, отрицательные числа задают "
"позиции с конца)"

#: func.xml:10348(literal)
msgid "'[{\"a\":\"foo\"},{\"b\":\"bar\"},{\"c\":\"baz\"}]'::json-&gt;2"
msgstr "'[{\"a\":\"foo\"},{\"b\":\"bar\"},{\"c\":\"baz\"}]'::json-&gt;2"

#: func.xml:10349(literal)
msgid "{\"c\":\"baz\"}"
msgstr "{\"c\":\"baz\"}"

#: func.xml:10354(entry)
msgid "Get JSON object field by key"
msgstr "Выдаёт поле объекта JSON по ключу"

#: func.xml:10355(literal)
msgid "'{\"a\": {\"b\":\"foo\"}}'::json-&gt;'a'"
msgstr "'{\"a\": {\"b\":\"foo\"}}'::json-&gt;'a'"

#: func.xml:10356(literal)
msgid "{\"b\":\"foo\"}"
msgstr "{\"b\":\"foo\"}"

#: func.xml:10359(literal) func.xml:10366(literal)
msgid "-&gt;&gt;"
msgstr "-&gt;&gt;"

#: func.xml:10361(entry)
msgid "Get JSON array element as <type>text</type>"
msgstr "Выдаёт элемент массива JSON в типе <type>text</type>"

#: func.xml:10362(literal)
msgid "'[1,2,3]'::json-&gt;&gt;2"
msgstr "'[1,2,3]'::json-&gt;&gt;2"

#: func.xml:10368(entry)
msgid "Get JSON object field as <type>text</type>"
msgstr "Выдаёт поле объекта JSON в типе <type>text</type>"

#: func.xml:10369(literal)
msgid "'{\"a\":1,\"b\":2}'::json-&gt;&gt;'b'"
msgstr "'{\"a\":1,\"b\":2}'::json-&gt;&gt;'b'"

#: func.xml:10373(literal)
msgid "#&gt;"
msgstr "#&gt;"

#: func.xml:10375(entry)
msgid "Get JSON object at specified path"
msgstr "Выдаёт объект JSON по заданному пути"

#: func.xml:10376(literal)
msgid "'{\"a\": {\"b\":{\"c\": \"foo\"}}}'::json#&gt;'{a,b}'"
msgstr "'{\"a\": {\"b\":{\"c\": \"foo\"}}}'::json#&gt;'{a,b}'"

#: func.xml:10377(literal)
msgid "{\"c\": \"foo\"}"
msgstr "{\"c\": \"foo\"}"

#: func.xml:10380(literal)
msgid "#&gt;&gt;"
msgstr "#&gt;&gt;"

#: func.xml:10382(entry)
msgid "Get JSON object at specified path as <type>text</type>"
msgstr "Выдаёт объект JSON по заданному пути в типе <type>text</type>"

#: func.xml:10383(literal)
msgid "'{\"a\":[1,2,3],\"b\":[4,5,6]}'::json#&gt;&gt;'{a,2}'"
msgstr "'{\"a\":[1,2,3],\"b\":[4,5,6]}'::json#&gt;&gt;'{a,2}'"

#: func.xml:10391(para)
msgid ""
"There are parallel variants of these operators for both the <type>json</"
"type> and <type>jsonb</type> types. The field/element/path extraction "
"operators return the same type as their left-hand input (either <type>json</"
"type> or <type>jsonb</type>), except for those specified as returning "
"<type>text</type>, which coerce the value to text. The field/element/path "
"extraction operators return NULL, rather than failing, if the JSON input "
"does not have the right structure to match the request; for example if no "
"such element exists. The field/element/path extraction operators that accept "
"integer JSON array subscripts all support negative subscripting from the end "
"of arrays."
msgstr ""
"Эти операторы существуют в двух вариациях для типов <type>json</type> и "
"<type>jsonb</type>. Операторы извлечения поля/элемента/пути возвращают тот "
"же тип, что у операнда слева (<type>json</type> или <type>jsonb</type>), за "
"исключением тех, что возвращают тип <type>text</type> (они возвращают "
"значение как текстовое). Если входные данные JSON не содержат структуры, "
"удовлетворяющей запросу, например в них нет искомого элемента, то операторы "
"извлечения поля/элемента/пути не выдают ошибку, а возвращают NULL. Все "
"операторы извлечения поля/элемента/пути, принимающие целочисленные позиции в "
"массивах JSON, поддерживают и отсчёт от конца массива по отрицательной "
"позиции."

#: func.xml:10406(para)
#, fuzzy
msgid ""
"The standard comparison operators shown in <xref linkend=\"functions-"
"comparison-op-table\"/> are available for <type>jsonb</type>, but not for "
"<type>json</type>. They follow the ordering rules for B-tree operations "
"outlined at <xref linkend=\"json-indexing\"/>."
msgstr ""
"Стандартные операторы сравнения, приведённые в <xref remap=\"6\" linkend="
"\"functions-comparison-table\"/>, есть для типа <type>jsonb</type>, но не "
"для <type>json</type>. Они следуют правилам сортировки для операций B-"
"дерева, описанным в <xref remap=\"6\" linkend=\"json-indexing\"/>."

#: func.xml:10413(para)
msgid ""
"Some further operators also exist only for <type>jsonb</type>, as shown in "
"<xref linkend=\"functions-jsonb-op-table\"/>. Many of these operators can be "
"indexed by <type>jsonb</type> operator classes. For a full description of "
"<type>jsonb</type> containment and existence semantics, see <xref linkend="
"\"json-containment\"/>. <xref linkend=\"json-indexing\"/> describes how "
"these operators can be used to effectively index <type>jsonb</type> data."
msgstr ""
"Некоторые из следующих операторов существуют только для <type>jsonb</type>, "
"как показано в <xref remap=\"6\" linkend=\"functions-jsonb-op-table\"/>. "
"Многие из этих операторов могут быть проиндексированы с помощью классов "
"операторов <type>jsonb</type>. Полное описание проверок на вхождение и "
"существование для <type>jsonb</type> приведено в <xref remap=\"6\" linkend="
"\"json-containment\"/>. Как эти операторы могут использоваться для "
"эффективного индексирования данных <type>jsonb</type>, описано в <xref remap="
"\"6\" linkend=\"json-indexing\"/>."

#: func.xml:10424(title)
msgid "Additional <type>jsonb</type> Operators"
msgstr "Дополнительные операторы <type>jsonb</type>"

#: func.xml:10437(type) func.xml:10444(type) func.xml:10472(type)
#: func.xml:10836(type) func.xml:11000(type) func.xml:11012(type)
#: func.xml:11038(type) func.xml:12666(type) func.xml:12700(type)
msgid "jsonb"
msgstr "jsonb"

#: func.xml:10438(entry)
msgid ""
"Does the left JSON value contain the right JSON path/value entries at the "
"top level?"
msgstr ""
"Левое значение JSON содержит на верхнем уровне путь/значение JSON справа?"

#: func.xml:10440(literal)
msgid "'{\"a\":1, \"b\":2}'::jsonb @&gt; '{\"b\":2}'::jsonb"
msgstr "'{\"a\":1, \"b\":2}'::jsonb @&gt; '{\"b\":2}'::jsonb"

#: func.xml:10445(entry)
msgid ""
"Are the left JSON path/value entries contained at the top level within the "
"right JSON value?"
msgstr ""
"Путь/значение JSON слева содержится на верхнем уровне в правом значении JSON?"

#: func.xml:10447(literal)
msgid "'{\"b\":2}'::jsonb &lt;@ '{\"a\":1, \"b\":2}'::jsonb"
msgstr "'{\"b\":2}'::jsonb &lt;@ '{\"a\":1, \"b\":2}'::jsonb"

#: func.xml:10452(entry)
msgid ""
"Does the <emphasis>string</emphasis> exist as a top-level key within the "
"JSON value?"
msgstr ""
"Присутствует ли <emphasis>строка</emphasis> в качестве ключа верхнего уровня "
"в значении JSON?"

#: func.xml:10454(literal)
msgid "'{\"a\":1, \"b\":2}'::jsonb ? 'b'"
msgstr "'{\"a\":1, \"b\":2}'::jsonb ? 'b'"

#: func.xml:10459(entry)
msgid ""
"Do any of these array <emphasis>strings</emphasis> exist as top-level keys?"
msgstr ""
"Какие-либо <emphasis>строки</emphasis> массива присутствуют в качестве "
"ключей верхнего уровня?"

#: func.xml:10461(literal)
msgid "'{\"a\":1, \"b\":2, \"c\":3}'::jsonb ?| array['b', 'c']"
msgstr "'{\"a\":1, \"b\":2, \"c\":3}'::jsonb ?| array['b', 'c']"

#: func.xml:10464(literal)
msgid "?&amp;"
msgstr "?&amp;"

#: func.xml:10466(entry)
msgid ""
"Do all of these array <emphasis>strings</emphasis> exist as top-level keys?"
msgstr ""
"Все <emphasis>строки</emphasis> массива присутствуют в качестве ключей "
"верхнего уровня?"

#: func.xml:10468(literal)
msgid "'[\"a\", \"b\"]'::jsonb ?&amp; array['a', 'b']"
msgstr "'[\"a\", \"b\"]'::jsonb ?&amp; array['a', 'b']"

#: func.xml:10473(entry)
msgid ""
"Concatenate two <type>jsonb</type> values into a new <type>jsonb</type> value"
msgstr ""
"Соединяет два значения <type>jsonb</type> в новое значение <type>jsonb</type>"

#: func.xml:10474(literal)
msgid "'[\"a\", \"b\"]'::jsonb || '[\"c\", \"d\"]'::jsonb"
msgstr "'[\"a\", \"b\"]'::jsonb || '[\"c\", \"d\"]'::jsonb"

#: func.xml:10479(entry)
msgid ""
"Delete key/value pair or <emphasis>string</emphasis> element from left "
"operand. Key/value pairs are matched based on their key value."
msgstr ""
"Удаляет пару ключ/значение или элемент-<emphasis>строку</emphasis> из левого "
"операнда. Пары ключ/значение выбираются по значению ключа."

#: func.xml:10482(literal)
msgid "'{\"a\": \"b\"}'::jsonb - 'a'"
msgstr "'{\"a\": \"b\"}'::jsonb - 'a'"

#: func.xml:10487(entry)
msgid ""
"Delete the array element with specified index (Negative integers count from "
"the end). Throws an error if top level container is not an array."
msgstr ""
"Удаляет из массива элемент в заданной позиции (отрицательные номера позиций "
"отсчитываются от конца). Выдаёт ошибку, если контейнер верхнего уровня — не "
"массив."

#: func.xml:10490(literal)
msgid "'[\"a\", \"b\"]'::jsonb - 1"
msgstr "'[\"a\", \"b\"]'::jsonb - 1"

#: func.xml:10493(literal)
msgid "#-"
msgstr "#-"

#: func.xml:10495(entry)
msgid ""
"Delete the field or element with specified path (for JSON arrays, negative "
"integers count from the end)"
msgstr ""
"Удаляет поле или элемент с заданным путём (для массивов JSON отрицательные "
"номера позиций отсчитываются от конца)"

#: func.xml:10497(literal)
msgid "'[\"a\", {\"b\":1}]'::jsonb #- '{1,b}'"
msgstr "'[\"a\", {\"b\":1}]'::jsonb #- '{1,b}'"

#: func.xml:10504(para)
msgid ""
"The <literal>||</literal> operator concatenates the elements at the top "
"level of each of its operands. It does not operate recursively. For example, "
"if both operands are objects with a common key field name, the value of the "
"field in the result will just be the value from the right hand operand."
msgstr ""
"Оператор <literal>||</literal> соединяет элементы верхнего уровня обоих "
"операндов. Вложенность при этом не учитывается. Например, если оба операнда "
"содержат поле с одноимённым ключом, значением поля в результате будет "
"значение, взятое из правого операнда."

#: func.xml:10512(para)
msgid ""
"<xref linkend=\"functions-json-creation-table\"/> shows the functions that "
"are available for creating <type>json</type> and <type>jsonb</type> values. "
"(There are no equivalent functions for <type>jsonb</type>, of the "
"<literal>row_to_json</literal> and <literal>array_to_json</literal> "
"functions. However, the <literal>to_jsonb</literal> function supplies much "
"the same functionality as these functions would.)"
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-json-creation-table\"/> показаны "
"функции, позволяющие создавать значения типов <type>json</type> и "
"<type>jsonb</type>. (Для типа <type>jsonb</type> нет аналогов функций "
"<literal>row_to_json</literal> и <literal>array_to_json</literal>, но "
"практически тот же результат можно получить с помощью <literal>to_jsonb</"
"literal>.)"

#: func.xml:10520(indexterm)
msgid "<primary>to_json</primary>"
msgstr "<primary>to_json</primary>"

#: func.xml:10523(indexterm)
msgid "<primary>array_to_json</primary>"
msgstr "<primary>array_to_json</primary>"

#: func.xml:10526(indexterm)
msgid "<primary>row_to_json</primary>"
msgstr "<primary>row_to_json</primary>"

#: func.xml:10529(indexterm)
msgid "<primary>json_build_array</primary>"
msgstr "<primary>json_build_array</primary>"

#: func.xml:10532(indexterm)
msgid "<primary>json_build_object</primary>"
msgstr "<primary>json_build_object</primary>"

#: func.xml:10535(indexterm)
msgid "<primary>json_object</primary>"
msgstr "<primary>json_object</primary>"

#: func.xml:10538(indexterm)
msgid "<primary>to_jsonb</primary>"
msgstr "<primary>to_jsonb</primary>"

#: func.xml:10541(indexterm)
msgid "<primary>jsonb_build_array</primary>"
msgstr "<primary>jsonb_build_array</primary>"

#: func.xml:10544(indexterm)
msgid "<primary>jsonb_build_object</primary>"
msgstr "<primary>jsonb_build_object</primary>"

#: func.xml:10547(indexterm)
msgid "<primary>jsonb_object</primary>"
msgstr "<primary>jsonb_object</primary>"

#: func.xml:10552(title)
msgid "JSON Creation Functions"
msgstr "Функции для создания JSON"

#: func.xml:10564(literal)
msgid "to_json(anyelement)"
msgstr "to_json(anyelement)"

#: func.xml:10565(literal)
msgid "to_jsonb(anyelement)"
msgstr "to_jsonb(anyelement)"

#: func.xml:10567(entry)
msgid ""
"Returns the value as <type>json</type> or <type>jsonb</type>. Arrays and "
"composites are converted (recursively) to arrays and objects; otherwise, if "
"there is a cast from the type to <type>json</type>, the cast function will "
"be used to perform the conversion; otherwise, a scalar value is produced. "
"For any scalar type other than a number, a Boolean, or a null value, the "
"text representation will be used, in such a fashion that it is a valid "
"<type>json</type> or <type>jsonb</type> value."
msgstr ""
"Возвращает значение в виде <type>json</type> или <type>jsonb</type>. Массивы "
"и составные структуры преобразуются (рекурсивно) в массивы и объекты; для "
"других типов, для которых определено приведение к <type>json</type>, "
"применяется эта функция приведения, а для всех остальных выдаётся скалярное "
"значение. Значения всех скалярных типов, кроме числового, логического и "
"NULL, представляются в текстовом виде, в стиле, допустимом для значений "
"<type>json</type> или <type>jsonb</type>."

#: func.xml:10577(literal)
msgid "to_json('Fred said \"Hi.\"'::text)"
msgstr "to_json('Fred said \"Hi.\"'::text)"

#: func.xml:10578(literal)
msgid "\"Fred said \\\"Hi.\\\"\""
msgstr "\"Fred said \\\"Hi.\\\"\""

#: func.xml:10582(literal)
msgid "array_to_json(anyarray [, pretty_bool])"
msgstr "array_to_json(anyarray [, pretty_bool])"

#: func.xml:10584(entry)
msgid ""
"Returns the array as a JSON array. A PostgreSQL multidimensional array "
"becomes a JSON array of arrays. Line feeds will be added between dimension-1 "
"elements if <parameter>pretty_bool</parameter> is true."
msgstr ""
"Возвращает массив в виде массива JSON. Многомерный массив PostgreSQL "
"становится массивом массивов JSON. Если параметр <parameter>pretty_bool</"
"parameter> равен true, между элементами 1-ой размерности вставляются разрывы "
"строк."

#: func.xml:10589(literal)
msgid "array_to_json('{{1,5},{99,100}}'::int[])"
msgstr "array_to_json('{{1,5},{99,100}}'::int[])"

#: func.xml:10590(literal)
msgid "[[1,5],[99,100]]"
msgstr "[[1,5],[99,100]]"

#: func.xml:10594(literal)
msgid "row_to_json(record [, pretty_bool])"
msgstr "row_to_json(record [, pretty_bool])"

#: func.xml:10596(entry)
msgid ""
"Returns the row as a JSON object. Line feeds will be added between level-1 "
"elements if <parameter>pretty_bool</parameter> is true."
msgstr ""
"Возвращает кортеж в виде объекта JSON. Если параметр <parameter>pretty_bool</"
"parameter> равен true, между элементами 1-ой размерности вставляются разрывы "
"строк."

#: func.xml:10600(literal)
msgid "row_to_json(row(1,'foo'))"
msgstr "row_to_json(row(1,'foo'))"

#: func.xml:10601(literal)
msgid "{\"f1\":1,\"f2\":\"foo\"}"
msgstr "{\"f1\":1,\"f2\":\"foo\"}"

#: func.xml:10604(literal)
msgid "json_build_array(VARIADIC \"any\")"
msgstr "json_build_array(VARIADIC \"any\")"

#: func.xml:10605(literal)
msgid "jsonb_build_array(VARIADIC \"any\")"
msgstr "jsonb_build_array(VARIADIC \"any\")"

#: func.xml:10607(entry)
msgid ""
"Builds a possibly-heterogeneously-typed JSON array out of a variadic "
"argument list."
msgstr ""
"Формирует массив JSON (возможно, разнородный) из переменного списка "
"аргументов."

#: func.xml:10611(literal)
msgid "json_build_array(1,2,'3',4,5)"
msgstr "json_build_array(1,2,'3',4,5)"

#: func.xml:10612(literal)
msgid "[1, 2, \"3\", 4, 5]"
msgstr "[1, 2, \"3\", 4, 5]"

#: func.xml:10615(literal)
msgid "json_build_object(VARIADIC \"any\")"
msgstr "json_build_object(VARIADIC \"any\")"

#: func.xml:10616(literal)
msgid "jsonb_build_object(VARIADIC \"any\")"
msgstr "jsonb_build_object(VARIADIC \"any\")"

#: func.xml:10618(entry)
msgid ""
"Builds a JSON object out of a variadic argument list. By convention, the "
"argument list consists of alternating keys and values."
msgstr ""
"Формирует объект JSON из переменного списка аргументов. По соглашению в этом "
"списке перечисляются по очереди ключи и значения."

#: func.xml:10623(literal)
msgid "json_build_object('foo',1,'bar',2)"
msgstr "json_build_object('foo',1,'bar',2)"

#: func.xml:10624(literal)
msgid "{\"foo\": 1, \"bar\": 2}"
msgstr "{\"foo\": 1, \"bar\": 2}"

#: func.xml:10627(literal)
msgid "json_object(text[])"
msgstr "json_object(text[])"

#: func.xml:10628(literal)
msgid "jsonb_object(text[])"
msgstr "jsonb_object(text[])"

#: func.xml:10630(entry)
msgid ""
"Builds a JSON object out of a text array. The array must have either exactly "
"one dimension with an even number of members, in which case they are taken "
"as alternating key/value pairs, or two dimensions such that each inner array "
"has exactly two elements, which are taken as a key/value pair."
msgstr ""
"Формирует объект JSON из текстового массива. Этот массив должен иметь либо "
"одну размерность с чётным числом элементов (в этом случае они воспринимаются "
"как чередующиеся ключи/значения), либо две размерности и при этом каждый "
"внутренний массив содержит ровно два элемента, которые воспринимаются как "
"пара ключ/значение."

#: func.xml:10637(literal)
msgid "json_object('{a, 1, b, \"def\", c, 3.5}')"
msgstr "json_object('{a, 1, b, \"def\", c, 3.5}')"

#: func.xml:10638(literal)
msgid "json_object('{{a, 1},{b, \"def\"},{c, 3.5}}')"
msgstr "json_object('{{a, 1},{b, \"def\"},{c, 3.5}}')"

#: func.xml:10639(literal)
msgid "{\"a\": \"1\", \"b\": \"def\", \"c\": \"3.5\"}"
msgstr "{\"a\": \"1\", \"b\": \"def\", \"c\": \"3.5\"}"

#: func.xml:10642(literal)
msgid "json_object(keys text[], values text[])"
msgstr "json_object(keys text[], values text[])"

#: func.xml:10643(literal)
msgid "jsonb_object(keys text[], values text[])"
msgstr "jsonb_object(keys text[], values text[])"

#: func.xml:10645(entry)
msgid ""
"This form of <function>json_object</function> takes keys and values pairwise "
"from two separate arrays. In all other respects it is identical to the one-"
"argument form."
msgstr ""
"Эта форма <function>json_object</function> принимает ключи и значения по "
"парам из двух отдельных массивов. Во всех остальных отношениях она не "
"отличается от формы с одним аргументом."

#: func.xml:10649(literal)
msgid "json_object('{a, b}', '{1,2}')"
msgstr "json_object('{a, b}', '{1,2}')"

#: func.xml:10650(literal)
msgid "{\"a\": \"1\", \"b\": \"2\"}"
msgstr "{\"a\": \"1\", \"b\": \"2\"}"

#: func.xml:10657(para)
msgid ""
"<function>array_to_json</function> and <function>row_to_json</function> have "
"the same behavior as <function>to_json</function> except for offering a "
"pretty-printing option. The behavior described for <function>to_json</"
"function> likewise applies to each individual value converted by the other "
"JSON creation functions."
msgstr ""
"Функции <function>array_to_json</function> и <function>row_to_json</"
"function> подобны <function>to_json</function>, но предлагают возможность "
"улучшенного вывода. Действие <function>to_json</function>, описанное выше, "
"распространяется на каждое отдельное значение, преобразуемое этими функциями."

#: func.xml:10666(para)
msgid ""
"The <xref linkend=\"hstore\"/> extension has a cast from <type>hstore</type> "
"to <type>json</type>, so that <type>hstore</type> values converted via the "
"JSON creation functions will be represented as JSON objects, not as "
"primitive string values."
msgstr ""
"В расширении <xref linkend=\"hstore\"/> определено преобразование из "
"<type>hstore</type> в <type>json</type>, так что значения <type>hstore</"
"type>, преобразуемые функциями создания JSON, будут представлены в виде "
"объектов JSON, а не как примитивные строковые значения."

#: func.xml:10674(para)
msgid ""
"<xref linkend=\"functions-json-processing-table\"/> shows the functions that "
"are available for processing <type>json</type> and <type>jsonb</type> values."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-json-processing-table\"/> показаны "
"функции, предназначенные для работы со значениями <type>json</type> и "
"<type>jsonb</type>."

#: func.xml:10679(indexterm)
msgid "<primary>json_array_length</primary>"
msgstr "<primary>json_array_length</primary>"

#: func.xml:10682(indexterm)
msgid "<primary>jsonb_array_length</primary>"
msgstr "<primary>jsonb_array_length</primary>"

#: func.xml:10685(indexterm)
msgid "<primary>json_each</primary>"
msgstr "<primary>json_each</primary>"

#: func.xml:10688(indexterm)
msgid "<primary>jsonb_each</primary>"
msgstr "<primary>jsonb_each</primary>"

#: func.xml:10691(indexterm)
msgid "<primary>json_each_text</primary>"
msgstr "<primary>json_each_text</primary>"

#: func.xml:10694(indexterm)
msgid "<primary>jsonb_each_text</primary>"
msgstr "<primary>jsonb_each_text</primary>"

#: func.xml:10697(indexterm)
msgid "<primary>json_extract_path</primary>"
msgstr "<primary>json_extract_path</primary>"

#: func.xml:10700(indexterm)
msgid "<primary>jsonb_extract_path</primary>"
msgstr "<primary>jsonb_extract_path</primary>"

#: func.xml:10703(indexterm)
msgid "<primary>json_extract_path_text</primary>"
msgstr "<primary>json_extract_path_text</primary>"

#: func.xml:10706(indexterm)
msgid "<primary>jsonb_extract_path_text</primary>"
msgstr "<primary>jsonb_extract_path_text</primary>"

#: func.xml:10709(indexterm)
msgid "<primary>json_object_keys</primary>"
msgstr "<primary>json_object_keys</primary>"

#: func.xml:10712(indexterm)
msgid "<primary>jsonb_object_keys</primary>"
msgstr "<primary>jsonb_object_keys</primary>"

#: func.xml:10715(indexterm)
msgid "<primary>json_populate_record</primary>"
msgstr "<primary>json_populate_record</primary>"

#: func.xml:10718(indexterm)
msgid "<primary>jsonb_populate_record</primary>"
msgstr "<primary>jsonb_populate_record</primary>"

#: func.xml:10721(indexterm)
msgid "<primary>json_populate_recordset</primary>"
msgstr "<primary>json_populate_recordset</primary>"

#: func.xml:10724(indexterm)
msgid "<primary>jsonb_populate_recordset</primary>"
msgstr "<primary>jsonb_populate_recordset</primary>"

#: func.xml:10727(indexterm)
msgid "<primary>json_array_elements</primary>"
msgstr "<primary>json_array_elements</primary>"

#: func.xml:10730(indexterm)
msgid "<primary>jsonb_array_elements</primary>"
msgstr "<primary>jsonb_array_elements</primary>"

#: func.xml:10733(indexterm)
msgid "<primary>json_array_elements_text</primary>"
msgstr "<primary>json_array_elements_text</primary>"

#: func.xml:10736(indexterm)
msgid "<primary>jsonb_array_elements_text</primary>"
msgstr "<primary>jsonb_array_elements_text</primary>"

#: func.xml:10739(indexterm)
msgid "<primary>json_typeof</primary>"
msgstr "<primary>json_typeof</primary>"

#: func.xml:10742(indexterm)
msgid "<primary>jsonb_typeof</primary>"
msgstr "<primary>jsonb_typeof</primary>"

#: func.xml:10745(indexterm)
msgid "<primary>json_to_record</primary>"
msgstr "<primary>json_to_record</primary>"

#: func.xml:10748(indexterm)
msgid "<primary>jsonb_to_record</primary>"
msgstr "<primary>jsonb_to_record</primary>"

#: func.xml:10751(indexterm)
msgid "<primary>json_to_recordset</primary>"
msgstr "<primary>json_to_recordset</primary>"

#: func.xml:10754(indexterm)
msgid "<primary>jsonb_to_recordset</primary>"
msgstr "<primary>jsonb_to_recordset</primary>"

#: func.xml:10757(indexterm)
msgid "<primary>json_strip_nulls</primary>"
msgstr "<primary>json_strip_nulls</primary>"

#: func.xml:10760(indexterm)
msgid "<primary>jsonb_strip_nulls</primary>"
msgstr "<primary>jsonb_strip_nulls</primary>"

#: func.xml:10763(indexterm)
msgid "<primary>jsonb_set</primary>"
msgstr "<primary>jsonb_set</primary>"

#: func.xml:10766(indexterm)
#, fuzzy
msgid "<primary>jsonb_insert</primary>"
msgstr "<primary>jsonb_set</primary>"

#: func.xml:10769(indexterm)
msgid "<primary>jsonb_pretty</primary>"
msgstr "<primary>jsonb_pretty</primary>"

#: func.xml:10774(title)
msgid "JSON Processing Functions"
msgstr "Функции для обработки JSON"

#: func.xml:10787(literal)
msgid "json_array_length(json)"
msgstr "json_array_length(json)"

#: func.xml:10788(literal)
msgid "jsonb_array_length(jsonb)"
msgstr "jsonb_array_length(jsonb)"

#: func.xml:10791(entry)
msgid "Returns the number of elements in the outermost JSON array."
msgstr "Возвращает число элементов во внешнем массиве JSON."

#: func.xml:10794(literal)
msgid "json_array_length('[1,2,3,{\"f1\":1,\"f2\":[5,6]},4]')"
msgstr "json_array_length('[1,2,3,{\"f1\":1,\"f2\":[5,6]},4]')"

#: func.xml:10798(literal)
msgid "json_each(json)"
msgstr "json_each(json)"

#: func.xml:10799(literal)
msgid "jsonb_each(jsonb)"
msgstr "jsonb_each(jsonb)"

#: func.xml:10801(literal)
msgid "setof key text, value json"
msgstr "setof key text, value json"

#: func.xml:10802(literal)
msgid "setof key text, value jsonb"
msgstr "setof key text, value jsonb"

#: func.xml:10804(entry)
msgid "Expands the outermost JSON object into a set of key/value pairs."
msgstr ""
"Разворачивает внешний объект JSON в набор пар ключ/значение (key/value)."

#: func.xml:10807(literal)
msgid "select * from json_each('{\"a\":\"foo\", \"b\":\"bar\"}')"
msgstr "select * from json_each('{\"a\":\"foo\", \"b\":\"bar\"}')"

#: func.xml:10809(programlisting)
#, no-wrap
msgid ""
" key | value\n"
"-----+-------\n"
" a   | \"foo\"\n"
" b   | \"bar\""
msgstr ""
" key | value\n"
"-----+-------\n"
" a   | \"foo\"\n"
" b   | \"bar\""

#: func.xml:10816(literal)
msgid "json_each_text(json)"
msgstr "json_each_text(json)"

#: func.xml:10817(literal)
msgid "jsonb_each_text(jsonb)"
msgstr "jsonb_each_text(jsonb)"

#: func.xml:10819(type)
msgid "setof key text, value text"
msgstr "setof key text, value text"

#: func.xml:10820(entry)
msgid ""
"Expands the outermost JSON object into a set of key/value pairs. The "
"returned values will be of type <type>text</type>."
msgstr ""
"Разворачивает внешний объект JSON в набор пар ключ/значение (key/value). "
"Возвращаемые значения будут иметь тип <type>text</type>."

#: func.xml:10824(literal)
msgid "select * from json_each_text('{\"a\":\"foo\", \"b\":\"bar\"}')"
msgstr "select * from json_each_text('{\"a\":\"foo\", \"b\":\"bar\"}')"

#: func.xml:10826(programlisting)
#, no-wrap
msgid ""
" key | value\n"
"-----+-------\n"
" a   | foo\n"
" b   | bar"
msgstr ""
" key | value\n"
"-----+-------\n"
" a   | foo\n"
" b   | bar"

#: func.xml:10833(literal)
msgid "json_extract_path(from_json json, VARIADIC path_elems text[])"
msgstr "json_extract_path(from_json json, VARIADIC path_elems text[])"

#: func.xml:10834(literal)
msgid "jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])"
msgstr "jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])"

#: func.xml:10836(type) func.xml:11000(type) func.xml:12649(type)
#: func.xml:12683(type)
msgid "json"
msgstr "json"

#: func.xml:10838(entry)
msgid ""
"Returns JSON value pointed to by <replaceable>path_elems</replaceable> "
"(equivalent to <literal>#&gt;</literal> operator)."
msgstr ""
"Возвращает значение JSON по пути, заданному элементами пути "
"(<replaceable>path_elems</replaceable>) (равнозначно оператору <literal>#&gt;"
"</literal> operator)."

#: func.xml:10842(literal)
msgid ""
"json_extract_path('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4')"
msgstr ""
"json_extract_path('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4')"

#: func.xml:10843(literal)
msgid "{\"f5\":99,\"f6\":\"foo\"}"
msgstr "{\"f5\":99,\"f6\":\"foo\"}"

#: func.xml:10846(literal)
msgid "json_extract_path_text(from_json json, VARIADIC path_elems text[])"
msgstr "json_extract_path_text(from_json json, VARIADIC path_elems text[])"

#: func.xml:10847(literal)
msgid "jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])"
msgstr "jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])"

#: func.xml:10850(entry)
msgid ""
"Returns JSON value pointed to by <replaceable>path_elems</replaceable> as "
"<type>text</type> (equivalent to <literal>#&gt;&gt;</literal> operator)."
msgstr ""
"Возвращает значение JSON по пути, заданному элементами пути "
"<replaceable>path_elems</replaceable>, как <type>text</type> (равнозначно "
"оператору <literal>#&gt;&gt;</literal>)."

#: func.xml:10855(literal)
msgid ""
"json_extract_path_text('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4', 'f6')"
msgstr ""
"json_extract_path_text('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4', 'f6')"

#: func.xml:10856(literal)
msgid "foo"
msgstr "foo"

#: func.xml:10859(literal)
msgid "json_object_keys(json)"
msgstr "json_object_keys(json)"

#: func.xml:10860(literal)
msgid "jsonb_object_keys(jsonb)"
msgstr "jsonb_object_keys(jsonb)"

#: func.xml:10863(entry)
msgid "Returns set of keys in the outermost JSON object."
msgstr "Возвращает число ключей во внешнем объекте JSON."

#: func.xml:10866(literal)
msgid ""
"json_object_keys('{\"f1\":\"abc\",\"f2\":{\"f3\":\"a\", \"f4\":\"b\"}}')"
msgstr ""
"json_object_keys('{\"f1\":\"abc\",\"f2\":{\"f3\":\"a\", \"f4\":\"b\"}}')"

#: func.xml:10868(programlisting)
#, no-wrap
msgid ""
" json_object_keys\n"
"------------------\n"
" f1\n"
" f2"
msgstr ""
" json_object_keys\n"
"-----------------\n"
" f1\n"
" f2"

#: func.xml:10875(literal)
msgid "json_populate_record(base anyelement, from_json json)"
msgstr "json_populate_record(base anyelement, from_json json)"

#: func.xml:10876(literal)
msgid "jsonb_populate_record(base anyelement, from_json jsonb)"
msgstr "jsonb_populate_record(base anyelement, from_json jsonb)"

#: func.xml:10879(entry)
msgid ""
"Expands the object in <replaceable>from_json</replaceable> to a row whose "
"columns match the record type defined by <replaceable>base</replaceable> "
"(see note below)."
msgstr ""
"Разворачивает объект из <replaceable>from_json</replaceable> в табличную "
"строку, в которой столбцы соответствуют типу строки, заданному параметром "
"<replaceable>base</replaceable> (см. примечания ниже)."

#: func.xml:10884(literal)
msgid ""
"select * from json_populate_record(null::myrowtype, '{\"a\":1,\"b\":2}')"
msgstr ""
"select * from json_populate_record(null::myrowtype, '{\"a\":1,\"b\":2}')"

#: func.xml:10886(programlisting)
#, no-wrap
msgid ""
" a | b\n"
"---+---\n"
" 1 | 2"
msgstr ""
" a | b\n"
"---+---\n"
" 1 | 2"

#: func.xml:10892(literal)
msgid "json_populate_recordset(base anyelement, from_json json)"
msgstr "json_populate_recordset(base anyelement, from_json json)"

#: func.xml:10893(literal)
msgid "jsonb_populate_recordset(base anyelement, from_json jsonb)"
msgstr "jsonb_populate_recordset(base anyelement, from_json jsonb)"

#: func.xml:10895(type) func.xml:12032(type)
msgid "setof anyelement"
msgstr "setof anyelement"

#: func.xml:10896(entry)
msgid ""
"Expands the outermost array of objects in <replaceable>from_json</"
"replaceable> to a set of rows whose columns match the record type defined by "
"<replaceable>base</replaceable> (see note below)."
msgstr ""
"Разворачивает внешний массив объектов из <replaceable>from_json</"
"replaceable> в набор табличных строк, в котором столбцы соответствуют типу "
"строки, заданному параметром <replaceable>base</replaceable> (см. примечания "
"ниже)."

#: func.xml:10902(literal)
msgid ""
"select * from json_populate_recordset(null::myrowtype, '[{\"a\":1,\"b\":2},"
"{\"a\":3,\"b\":4}]')"
msgstr ""
"select * from json_populate_recordset(null::myrowtype, '[{\"a\":1,\"b\":2},"
"{\"a\":3,\"b\":4}]')"

#: func.xml:10904(programlisting)
#, no-wrap
msgid ""
" a | b\n"
"---+---\n"
" 1 | 2\n"
" 3 | 4"
msgstr ""
" a | b\n"
"---+---\n"
" 1 | 2\n"
" 3 | 4"

#: func.xml:10911(literal)
msgid "json_array_elements(json)"
msgstr "json_array_elements(json)"

#: func.xml:10912(literal)
msgid "jsonb_array_elements(jsonb)"
msgstr "jsonb_array_elements(jsonb)"

#: func.xml:10914(type)
msgid "setof json"
msgstr "setof json"

#: func.xml:10915(type)
msgid "setof jsonb"
msgstr "setof jsonb"

#: func.xml:10917(entry)
msgid "Expands a JSON array to a set of JSON values."
msgstr "Разворачивает массив JSON в набор значений JSON."

#: func.xml:10920(literal)
msgid "select * from json_array_elements('[1,true, [2,false]]')"
msgstr "select * from json_array_elements('[1,true, [2,false]]')"

#: func.xml:10922(programlisting)
#, no-wrap
msgid ""
"   value\n"
"-----------\n"
" 1\n"
" true\n"
" [2,false]"
msgstr ""
"   value\n"
"-----------\n"
" 1\n"
" true\n"
" [2,false]"

#: func.xml:10930(literal)
msgid "json_array_elements_text(json)"
msgstr "json_array_elements_text(json)"

#: func.xml:10931(literal)
msgid "jsonb_array_elements_text(jsonb)"
msgstr "jsonb_array_elements_text(jsonb)"

#: func.xml:10934(entry)
msgid "Expands a JSON array to a set of <type>text</type> values."
msgstr "Разворачивает массив JSON в набор значений <type>text</type>."

#: func.xml:10937(literal)
msgid "select * from json_array_elements_text('[\"foo\", \"bar\"]')"
msgstr "select * from json_array_elements_text('[\"foo\", \"bar\"]')"

#: func.xml:10939(programlisting)
#, no-wrap
msgid ""
"   value\n"
"-----------\n"
" foo\n"
" bar"
msgstr ""
"   value\n"
"-----------\n"
" foo\n"
" bar"

#: func.xml:10946(literal)
msgid "json_typeof(json)"
msgstr "json_typeof(json)"

#: func.xml:10947(literal)
msgid "jsonb_typeof(jsonb)"
msgstr "jsonb_typeof(jsonb)"

#: func.xml:10950(entry)
msgid ""
"Returns the type of the outermost JSON value as a text string. Possible "
"types are <literal>object</literal>, <literal>array</literal>, "
"<literal>string</literal>, <literal>number</literal>, <literal>boolean</"
"literal>, and <literal>null</literal>."
msgstr ""
"Возвращает тип внешнего значения JSON в виде текстовой строки. Возможные "
"типы: <literal>object</literal>, <literal>array</literal>, <literal>string</"
"literal>, <literal>number</literal>, <literal>boolean</literal> и "
"<literal>null</literal>."

#: func.xml:10956(literal)
msgid "json_typeof('-123.4')"
msgstr "json_typeof('-123.4')"

#: func.xml:10957(literal)
msgctxt "literal"
msgid "number"
msgstr "number"

#: func.xml:10960(literal)
msgid "json_to_record(json)"
msgstr "json_to_record(json)"

#: func.xml:10961(literal)
msgid "jsonb_to_record(jsonb)"
msgstr "jsonb_to_record(jsonb)"

#: func.xml:10963(type) func.xml:16657(type) func.xml:16668(type)
#: func.xml:16679(type) func.xml:16690(type) func.xml:18588(type)
msgctxt "type"
msgid "record"
msgstr "record"

#: func.xml:10964(entry)
msgid ""
"Builds an arbitrary record from a JSON object (see note below). As with all "
"functions returning <type>record</type>, the caller must explicitly define "
"the structure of the record with an <literal>AS</literal> clause."
msgstr ""
"Формирует обычную запись из объекта JSON (см. примечания ниже). Как и со "
"всеми функциями, возвращающими <type>record</type>, при вызове необходимо "
"явно определить структуру записи с помощью предложения <literal>AS</literal>."

#: func.xml:10970(literal)
msgid ""
"select * from json_to_record('{\"a\":1,\"b\":[1,2,3],\"c\":\"bar\"}') as x(a "
"int, b text, d text)"
msgstr ""
"select * from json_to_record('{\"a\":1,\"b\":[1,2,3],\"c\":\"bar\"}') as x(a "
"int, b text, d text)"

#: func.xml:10972(programlisting)
#, no-wrap
msgid ""
" a |    b    | d\n"
"---+---------+---\n"
" 1 | [1,2,3] |"
msgstr ""
" a |    b    | d\n"
"---+---------+---\n"
" 1 | [1,2,3] |"

#: func.xml:10978(literal)
msgid "json_to_recordset(json)"
msgstr "json_to_recordset(json)"

#: func.xml:10979(literal)
msgid "jsonb_to_recordset(jsonb)"
msgstr "jsonb_to_recordset(jsonb)"

#: func.xml:10982(entry)
msgid ""
"Builds an arbitrary set of records from a JSON array of objects (see note "
"below). As with all functions returning <type>record</type>, the caller must "
"explicitly define the structure of the record with an <literal>AS</literal> "
"clause."
msgstr ""
"Формирует обычный набор записей из массива объекта JSON (см. примечания "
"ниже). Как и со всеми функциями, возвращающими <type>record</type>, при "
"вызове необходимо явно определить структуру записи с помощью предложения "
"<literal>AS</literal>."

#: func.xml:10988(literal)
msgid ""
"select * from json_to_recordset('[{\"a\":1,\"b\":\"foo\"},{\"a\":\"2\",\"c\":"
"\"bar\"}]') as x(a int, b text);"
msgstr ""
"select * from json_to_recordset('[{\"a\":1,\"b\":\"foo\"},{\"a\":\"2\",\"c\":"
"\"bar\"}]') as x(a int, b text);"

#: func.xml:10990(programlisting)
#, no-wrap
msgid ""
" a |  b\n"
"---+-----\n"
" 1 | foo\n"
" 2 |"
msgstr ""
" a |  b\n"
"---+-----\n"
" 1 | foo\n"
" 2 |"

#: func.xml:10997(literal)
msgid "json_strip_nulls(from_json json)"
msgstr "json_strip_nulls(from_json json)"

#: func.xml:10998(literal)
msgid "jsonb_strip_nulls(from_json jsonb)"
msgstr "jsonb_strip_nulls(from_json jsonb)"

#: func.xml:11001(entry)
msgid ""
"Returns <replaceable>from_json</replaceable> with all object fields that "
"have null values omitted. Other null values are untouched."
msgstr ""
"Возвращает значение <replaceable>from_json</replaceable>, из которого "
"исключаются все поля объекта, содержащие значения NULL. Другие значения NULL "
"остаются нетронутыми."

#: func.xml:11006(literal)
msgid "json_strip_nulls('[{\"f1\":1,\"f2\":null},2,null,3]')"
msgstr "json_strip_nulls('[{\"f1\":1,\"f2\":null},2,null,3]')"

#: func.xml:11007(literal)
msgid "[{\"f1\":1},2,null,3]"
msgstr "[{\"f1\":1},2,null,3]"

#: func.xml:11010(parameter)
msgid "create_missing"
msgstr "create_missing"

#: func.xml:11010(literal)
msgid "jsonb_set(target jsonb, path text[], new_value jsonb<placeholder-1/>)"
msgstr "jsonb_set(target jsonb, path text[], new_value jsonb<placeholder-1/>)"

#: func.xml:11013(entry)
msgid ""
"Returns <replaceable>target</replaceable> with the section designated by "
"<replaceable>path</replaceable> replaced by <replaceable>new_value</"
"replaceable>, or with <replaceable>new_value</replaceable> added if "
"<replaceable>create_missing</replaceable> is true ( default is "
"<literal>true</literal>) and the item designated by <replaceable>path</"
"replaceable> does not exist. As with the path orientated operators, negative "
"integers that appear in <replaceable>path</replaceable> count from the end "
"of JSON arrays."
msgstr ""
"Возвращает значение <replaceable>target</replaceable>, в котором раздел с "
"заданным путём (<replaceable>path</replaceable>) заменяется новым значением "
"(<replaceable>new_value</replaceable>), либо в него добавляется значение "
"<replaceable>new_value</replaceable>, если аргумент "
"<replaceable>create_missing</replaceable> равен <literal>true</literal> (это "
"значение по умолчанию) и элемент, на который ссылается <replaceable>path</"
"replaceable>, не существует. Как и с операторами, рассчитанными на пути, "
"отрицательные числа в пути (<replaceable>path</replaceable>) обозначают "
"отсчёт от конца массивов JSON."

#: func.xml:11025(literal)
msgid ""
"jsonb_set('[{\"f1\":1,\"f2\":null},2,null,3]', '{0,f1}','[2,3,4]', false)"
msgstr ""
"jsonb_set('[{\"f1\":1,\"f2\":null},2,null,3]', '{0,f1}','[2,3,4]', false)"

#: func.xml:11026(literal)
msgid "jsonb_set('[{\"f1\":1,\"f2\":null},2]', '{0,f3}','[2,3,4]')"
msgstr "jsonb_set('[{\"f1\":1,\"f2\":null},2]', '{0,f3}','[2,3,4]')"

#: func.xml:11028(literal)
msgid "[{\"f1\":[2,3,4],\"f2\":null},2,null,3]"
msgstr "[{\"f1\":[2,3,4],\"f2\":null},2,null,3]"

#: func.xml:11029(literal)
msgid "[{\"f1\": 1, \"f2\": null, \"f3\": [2, 3, 4]}, 2]"
msgstr "[{\"f1\": 1, \"f2\": null, \"f3\": [2, 3, 4]}, 2]"

#: func.xml:11035(parameter)
#, fuzzy
msgid "insert_after"
msgstr "insert"

#: func.xml:11034(literal)
#, fuzzy
msgid ""
"jsonb_insert(target jsonb, path text[], new_value jsonb, "
"<optional><placeholder-1/> <placeholder-2/></optional>)"
msgstr "jsonb_set(target jsonb, path text[], new_value jsonb<placeholder-1/>)"

#: func.xml:11039(entry)
#, fuzzy
msgid ""
"Returns <replaceable>target</replaceable> with <replaceable>new_value</"
"replaceable> inserted. If <replaceable>target</replaceable> section "
"designated by <replaceable>path</replaceable> is in a JSONB array, "
"<replaceable>new_value</replaceable> will be inserted before target or after "
"if <replaceable>insert_after</replaceable> is true (default is "
"<literal>false</literal>). If <replaceable>target</replaceable> section "
"designated by <replaceable>path</replaceable> is in JSONB object, "
"<replaceable>new_value</replaceable> will be inserted only if "
"<replaceable>target</replaceable> does not exist. As with the path "
"orientated operators, negative integers that appear in <replaceable>path</"
"replaceable> count from the end of JSON arrays."
msgstr ""
"Возвращает значение <replaceable>target</replaceable>, в котором раздел с "
"заданным путём (<replaceable>path</replaceable>) заменяется новым значением "
"(<replaceable>new_value</replaceable>), либо в него добавляется значение "
"<replaceable>new_value</replaceable>, если аргумент "
"<replaceable>create_missing</replaceable> равен <literal>true</literal> (это "
"значение по умолчанию) и элемент, на который ссылается <replaceable>path</"
"replaceable>, не существует. Как и с операторами, рассчитанными на пути, "
"отрицательные числа в пути (<replaceable>path</replaceable>) обозначают "
"отсчёт от конца массивов JSON."

#: func.xml:11054(literal)
msgid "jsonb_insert('{\"a\": [0,1,2]}', '{a, 1}', '\"new_value\"')"
msgstr ""

#: func.xml:11057(literal)
msgid "jsonb_insert('{\"a\": [0,1,2]}', '{a, 1}', '\"new_value\"', true)"
msgstr ""

#: func.xml:11061(literal)
msgid "{\"a\": [0, \"new_value\", 1, 2]}"
msgstr ""

#: func.xml:11062(literal)
msgid "{\"a\": [0, 1, \"new_value\", 2]}"
msgstr ""

#: func.xml:11066(literal)
msgid "jsonb_pretty(from_json jsonb)"
msgstr "jsonb_pretty(from_json jsonb)"

#: func.xml:11069(entry)
msgid "Returns <replaceable>from_json</replaceable> as indented JSON text."
msgstr ""
"Возвращает значение <replaceable>from_json</replaceable> в виде текста JSON "
"с отступами."

#: func.xml:11073(literal)
msgid "jsonb_pretty('[{\"f1\":1,\"f2\":null},2,null,3]')"
msgstr "jsonb_pretty('[{\"f1\":1,\"f2\":null},2,null,3]')"

#: func.xml:11075(programlisting)
#, no-wrap
msgid ""
"[\n"
"    {\n"
"        \"f1\": 1,\n"
"        \"f2\": null\n"
"    },\n"
"    2,\n"
"    null,\n"
"    3\n"
"]"
msgstr ""
"[\n"
"    {\n"
"        \"f1\": 1,\n"
"        \"f2\": null\n"
"    },\n"
"    2,\n"
"    null,\n"
"    3\n"
"]"

#: func.xml:11091(para)
msgid ""
"Many of these functions and operators will convert Unicode escapes in JSON "
"strings to the appropriate single character. This is a non-issue if the "
"input is type <type>jsonb</type>, because the conversion was already done; "
"but for <type>json</type> input, this may result in throwing an error, as "
"noted in <xref linkend=\"datatype-json\"/>."
msgstr ""
"Многие из этих функций и операторов преобразуют спецпоследовательности "
"Unicode в JSON-строках в соответствующие одиночные символы. Для входных "
"данных типа <type>jsonb</type> это ничем не грозит, так как преобразование "
"уже выполнено; однако для типа <type>json</type> в результате может "
"произойти ошибка, как отмечено в <xref remap=\"6\" linkend=\"datatype-json\"/"
">."

#: func.xml:11101(para)
msgid ""
"In <function>json_populate_record</function>, "
"<function>json_populate_recordset</function>, <function>json_to_record</"
"function> and <function>json_to_recordset</function>, type coercion from the "
"JSON is <quote>best effort</quote> and may not result in desired values for "
"some types. JSON keys are matched to identical column names in the target "
"row type. JSON fields that do not appear in the target row type will be "
"omitted from the output, and target columns that do not match any JSON field "
"will simply be NULL."
msgstr ""
"В <function>json_populate_record</function>, "
"<function>json_populate_recordset</function>, <function>json_to_record</"
"function> и <function>json_to_recordset</function> приведение типов из JSON "
"выполняется <quote>насколько это возможно</quote> и его результаты могут "
"быть не вполне ожидаемыми для некоторых типов. Ключи JSON сопоставляются с "
"идентичными именами столбцов в целевом типе записей. Поля JSON, "
"отсутствующие в целевом типе, в выходные данные не попадают, а целевые "
"столбцы, для которых нет соответствующих полей JSON, будут просто содержать "
"NULL."

#: func.xml:11113(para)
#, fuzzy
msgid ""
"All the items of the <literal>path</literal> parameter of "
"<literal>jsonb_set</literal> as well as <literal>jsonb_insert</literal> "
"except the last item must be present in the <literal>target</literal>. If "
"<literal>create_missing</literal> is false, all items of the <literal>path</"
"literal> parameter of <literal>jsonb_set</literal> must be present. If these "
"conditions are not met the <literal>target</literal> is returned unchanged."
msgstr ""
"В <literal>target</literal> должны присутствовать все элементы пути, "
"заданного параметром <literal>path</literal> функции <literal>jsonb_set</"
"literal>, если только <literal>create_missing</literal> не равно true — в "
"этом случае должны присутствовать все элементы, кроме последнего. Если это "
"условие не выполняется, значение <literal>target</literal> возвращается "
"неизменённым."

#: func.xml:11121(para)
msgid ""
"If the last path item is an object key, it will be created if it is absent "
"and given the new value. If the last path item is an array index, if it is "
"positive the item to set is found by counting from the left, and if negative "
"by counting from the right - <literal>-1</literal> designates the rightmost "
"element, and so on. If the item is out of the range -array_length .. "
"array_length -1, and create_missing is true, the new value is added at the "
"beginning of the array if the item is negative, and at the end of the array "
"if it is positive."
msgstr ""
"Если последним элементом пути оказывается ключ объекта, он будет создан в "
"случае отсутствия и получит новое значение. Если последний элемент пути — "
"позиция в массиве, то когда она положительна, целевой элемент отсчитывается "
"слева, а когда отрицательна — справа, то есть <literal>-1</literal> "
"указывает на самый правый элемент и т. д. Если позиция лежит вне диапазона -"
"длина_массива .. длина_массива -1, и параметр create_missing равен true, "
"новое значение добавляется в начало массива, если позиция отрицательна, и в "
"конец, если положительна."

#: func.xml:11135(para)
msgid ""
"The <literal>json_typeof</literal> function's <literal>null</literal> return "
"value should not be confused with a SQL NULL. While calling "
"<literal>json_typeof('null'::json)</literal> will return <literal>null</"
"literal>, calling <literal>json_typeof(NULL::json)</literal> will return a "
"SQL NULL."
msgstr ""
"Значение <literal>null</literal>, возвращаемое функцией "
"<literal>json_typeof</literal>, не следует путать с SQL NULL. Тогда как при "
"вызове <literal>json_typeof('null'::json)</literal> возвращается "
"<literal>null</literal>, при вызове <literal>json_typeof(NULL::json)</"
"literal> будет возвращено значение SQL NULL."

#: func.xml:11145(para)
msgid ""
"If the argument to <literal>json_strip_nulls</literal> contains duplicate "
"field names in any object, the result could be semantically somewhat "
"different, depending on the order in which they occur. This is not an issue "
"for <literal>jsonb_strip_nulls</literal> since <type>jsonb</type> values "
"never have duplicate object field names."
msgstr ""
"Если аргумент функции <literal>json_strip_nulls</literal> содержит "
"повторяющиеся имена полей в любом объекте, в результате могут проявиться "
"семантические различия, в зависимости от порядка этих полей. Это не проблема "
"для функции <literal>jsonb_strip_nulls</literal>, так как в значениях "
"<type>jsonb</type> имена полей не могут дублироваться."

#: func.xml:11154(para)
msgid ""
"See also <xref linkend=\"functions-aggregate\"/> for the aggregate function "
"<function>json_agg</function> which aggregates record values as JSON, and "
"the aggregate function <function>json_object_agg</function> which aggregates "
"pairs of values into a JSON object, and their <type>jsonb</type> "
"equivalents, <function>jsonb_agg</function> and <function>jsonb_object_agg</"
"function>."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-aggregate\"/> вы также можете узнать "
"об агрегатной функции <function>json_agg</function>, которая агрегирует "
"значения записи в виде JSON, и агрегатной функции <function>json_object_agg</"
"function>, агрегирующей пары значений в объект JSON, а также их аналогах для "
"<type>jsonb</type>, функциях <function>jsonb_agg</function> и "
"<function>jsonb_object_agg</function>."

#: func.xml:11166(title)
msgid "Sequence Manipulation Functions"
msgstr "Функции для работы с последовательностями"

#: func.xml:11168(indexterm)
msgid "<primary>sequence</primary>"
msgstr "<primary>последовательность</primary>"

#: func.xml:11171(indexterm)
msgid "<primary>nextval</primary>"
msgstr "<primary>nextval</primary>"

#: func.xml:11174(indexterm)
msgid "<primary>currval</primary>"
msgstr "<primary>currval</primary>"

#: func.xml:11177(indexterm)
msgid "<primary>lastval</primary>"
msgstr "<primary>lastval</primary>"

#: func.xml:11180(indexterm)
msgid "<primary>setval</primary>"
msgstr "<primary>setval</primary>"

#: func.xml:11184(para)
msgid ""
"This section describes functions for operating on <firstterm>sequence "
"objects</firstterm>, also called sequence generators or just sequences. "
"Sequence objects are special single-row tables created with <xref linkend="
"\"sql-createsequence\"/>. Sequence objects are commonly used to generate "
"unique identifiers for rows of a table. The sequence functions, listed in "
"<xref linkend=\"functions-sequence-table\"/>, provide simple, multiuser-safe "
"methods for obtaining successive sequence values from sequence objects."
msgstr ""
"В этом разделе описаны функции для работы с объектами, представляющими "
"<firstterm>последовательности</firstterm>. Такие объекты (также называемыми "
"генераторами последовательностей или просто последовательностями) являются "
"специальными таблицами из одной строки и создаются командой <xref linkend="
"\"sql-createsequence\"/>. Используются они обычно для получения уникальных "
"идентификаторов строк таблицы. Функции, перечисленные в <xref remap=\"6\" "
"linkend=\"functions-sequence-table\"/>, предоставляют простые и безопасные "
"для параллельного использования методы получения очередных значений таких "
"последовательностей."

#: func.xml:11197(title)
msgid "Sequence Functions"
msgstr "Функции для работы с последовательностями"

#: func.xml:11205(type) func.xml:11217(type) func.xml:11222(type)
#: func.xml:11227(type) func.xml:16078(type) func.xml:18179(type)
#: func.xml:18188(type) func.xml:18199(type) func.xml:18237(type)
#: func.xml:18261(type) func.xml:18410(type) func.xml:18419(type)
#: func.xml:18430(type) func.xml:18496(type) func.xml:18503(type)
msgid "regclass"
msgstr "regclass"

#: func.xml:11205(function)
msgid "currval(<placeholder-1/>)"
msgstr "currval(<placeholder-1/>)"

#: func.xml:11207(entry)
msgid ""
"Return value most recently obtained with <function>nextval</function> for "
"specified sequence"
msgstr ""
"Выдаёт значение заданной последовательности, которое было возвращено при "
"последнем вызове функции <function>nextval</function>"

#: func.xml:11211(function)
msgid "lastval()"
msgstr "lastval()"

#: func.xml:11213(entry)
msgid ""
"Return value most recently obtained with <function>nextval</function> for "
"any sequence"
msgstr ""
"Выдаёт значение любой последовательности, которое было возвращено при "
"последнем вызове функции <function>nextval</function>"

#: func.xml:11217(function)
msgid "nextval(<placeholder-1/>)"
msgstr "nextval(<placeholder-1/>)"

#: func.xml:11219(entry)
msgid "Advance sequence and return new value"
msgstr "Продвигает последовательность к следующему значению и возвращает его"

#: func.xml:11222(function)
msgid "setval(<placeholder-1/>, <placeholder-2/>)"
msgstr "setval(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:11224(entry)
msgid "Set sequence's current value"
msgstr "Устанавливает текущее значение последовательности"

#: func.xml:11227(function)
msgid "setval(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "setval(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:11229(entry)
msgid "Set sequence's current value and <literal>is_called</literal> flag"
msgstr ""
"Устанавливает текущее значение последовательности и флаг <literal>is_called</"
"literal>, указывающий на то, что это значение использовалось"

#: func.xml:11245(programlisting)
#, no-wrap
msgid ""
"nextval('foo')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>\n"
"nextval('FOO')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>\n"
"nextval('\"Foo\"')    <lineannotation>operates on sequence <literal>Foo</literal></lineannotation>"
msgstr ""
"nextval('foo')      <lineannotation>обращается к последовательности <literal>foo</literal></lineannotation>\n"
"nextval('FOO')      <lineannotation>обращается к последовательности <literal>foo</literal></lineannotation>\n"
"nextval('\"Foo\"')    <lineannotation>обращается к последовательности <literal>Foo</literal></lineannotation>"

#: func.xml:11249(programlisting)
#, no-wrap
msgid ""
"nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></lineannotation>\n"
"nextval('\"myschema\".foo')   <lineannotation>same as above</lineannotation>\n"
"nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></lineannotation>"
msgstr ""
"nextval('myschema.foo')     <lineannotation>обращается к <literal>myschema.foo</literal></lineannotation>\n"
"nextval('\"myschema\".foo')   <lineannotation>то же самое</lineannotation>\n"
"nextval('foo')              <lineannotation>ищет <literal>foo</literal> в пути поиска</lineannotation>"

#: func.xml:11235(para)
msgid ""
"The sequence to be operated on by a sequence function is specified by a "
"<type>regclass</type> argument, which is simply the OID of the sequence in "
"the <structname>pg_class</structname> system catalog. You do not have to "
"look up the OID by hand, however, since the <type>regclass</type> data "
"type's input converter will do the work for you. Just write the sequence "
"name enclosed in single quotes so that it looks like a literal constant. For "
"compatibility with the handling of ordinary <acronym>SQL</acronym> names, "
"the string will be converted to lower case unless it contains double quotes "
"around the sequence name. Thus: <placeholder-1/> The sequence name can be "
"schema-qualified if necessary: <placeholder-2/> See <xref linkend=\"datatype-"
"oid\"/> for more information about <type>regclass</type>."
msgstr ""
"Последовательность, к которой будет обращаться одна из этих функций, "
"определяется аргументом <type>regclass</type>, задающим просто OID "
"последовательности в системном каталоге <structname>pg_class</structname>. "
"Вычислять этот OID вручную не нужно, так как процедура ввода данных "
"<type>regclass</type> автоматически выполнит эту работу за вас. Просто "
"запишите имя последовательности в апострофах, чтобы оно выглядело как "
"строковая константа. Для совместимости с обычными именами <acronym>SQL</"
"acronym> эта строка будет переведена в нижний регистр, если только она не "
"заключена в кавычки. Например: <placeholder-1/> При необходимости имя "
"последовательности можно дополнить именем схемы: <placeholder-2/> Подробнее "
"тип <type>regclass</type> описан в <xref remap=\"6\" linkend=\"datatype-oid"
"\"/>."

#: func.xml:11257(para)
msgid ""
"Before <productname>PostgreSQL</productname> 8.1, the arguments of the "
"sequence functions were of type <type>text</type>, not <type>regclass</"
"type>, and the above-described conversion from a text string to an OID value "
"would happen at run time during each call. For backward compatibility, this "
"facility still exists, but internally it is now handled as an implicit "
"coercion from <type>text</type> to <type>regclass</type> before the function "
"is invoked."
msgstr ""
"В <productname>PostgreSQL</productname> до версии 8.1 аргументы этих функций "
"имели тип <type>text</type>, а не <type>regclass</type>, и поэтому описанное "
"выше преобразование текстовой строки в OID имело место при каждом вызове "
"функции. Это поведение сохраняется и сейчас для обратной совместимости, но "
"сейчас оно реализовано как неявное приведение типа <type>text</type> к типу "
"<type>regclass</type> перед вызовом функции."

#: func.xml:11277(programlisting)
#, no-wrap
msgid "nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>"
msgstr "nextval('foo'::text)      <lineannotation><literal>foo</literal> распознаётся во время выполнения</lineannotation>"

#: func.xml:11267(para)
msgid ""
"When you write the argument of a sequence function as an unadorned literal "
"string, it becomes a constant of type <type>regclass</type>. Since this is "
"really just an OID, it will track the originally identified sequence despite "
"later renaming, schema reassignment, etc. This <quote>early binding</quote> "
"behavior is usually desirable for sequence references in column defaults and "
"views. But sometimes you might want <quote>late binding</quote> where the "
"sequence reference is resolved at run time. To get late-binding behavior, "
"force the constant to be stored as a <type>text</type> constant instead of "
"<type>regclass</type>: <placeholder-1/> Note that late binding was the only "
"behavior supported in <productname>PostgreSQL</productname> releases before "
"8.1, so you might need to do this to preserve the semantics of old "
"applications."
msgstr ""
"Когда вы записываете аргумент функции, работающей с последовательностью, как "
"текстовую строку в чистом виде, она становится константой типа "
"<type>regclass</type>. Так как фактически это будет просто значение OID, оно "
"будет привязано к изначально идентифицированной последовательности, несмотря "
"на то, что она может быть переименована, перенесена в другую схему и т. д. "
"Такое <quote>раннее связывание</quote> обычно желательно для ссылок на "
"последовательности в значениях столбцов по умолчанию и представлениях. Но "
"иногда возникает необходимость в <quote>позднем связывании</quote>, когда "
"ссылки на последовательности распознаются в процессе выполнения. Чтобы "
"получить такое поведение, нужно принудительно изменить тип константы с "
"<type>regclass</type> на <type>text</type>: <placeholder-1/> Заметьте, что "
"версии <productname>PostgreSQL</productname> до 8.1 поддерживали только "
"позднее связывание, так что это может быть полезно и для совместимости со "
"старыми приложениями."

#: func.xml:11283(para)
msgid ""
"Of course, the argument of a sequence function can be an expression as well "
"as a constant. If it is a text expression then the implicit coercion will "
"result in a run-time lookup."
msgstr ""
"Конечно же, аргументом таких функций может быть не только константа, но и "
"выражение. Если это выражение текстового типа, неявное приведение типов "
"повлечёт разрешение имени во время выполнения."

#: func.xml:11295(function)
msgid "nextval"
msgstr "nextval"

#: func.xml:11297(para)
msgid ""
"Advance the sequence object to its next value and return that value. This is "
"done atomically: even if multiple sessions execute <function>nextval</"
"function> concurrently, each will safely receive a distinct sequence value."
msgstr ""
"Продвигает последовательность к следующему значению и возвращает его. Это "
"атомарная операция: если <function>nextval</function> вызывается "
"одновременно в нескольких сеансах, в результате каждого вызова будут "
"гарантированно получены разные значения."

#: func.xml:11304(para)
msgid ""
"If a sequence object has been created with default parameters, successive "
"<function>nextval</function> calls will return successive values beginning "
"with 1. Other behaviors can be obtained by using special parameters in the "
"<xref linkend=\"sql-createsequence\"/> command; see its command reference "
"page for more information."
msgstr ""
"Если последовательность создаётся с параметрами по умолчанию, успешные "
"вызовы <function>nextval</function> получают очередные значения по "
"возрастанию, начиная с 1. Другое поведение можно получить с помощью "
"специальных параметров в команде <xref linkend=\"sql-createsequence\"/>; "
"подробнее это описано на странице описания команды."

#: func.xml:11313(para)
msgid ""
"To avoid blocking concurrent transactions that obtain numbers from the same "
"sequence, a <function>nextval</function> operation is never rolled back; "
"that is, once a value has been fetched it is considered used and will not be "
"returned again. This is true even if the surrounding transaction later "
"aborts, or if the calling query ends up not using the value. For example an "
"<command>INSERT</command> with an <literal>ON CONFLICT</literal> clause will "
"compute the to-be-inserted tuple, including doing any required "
"<function>nextval</function> calls, before detecting any conflict that would "
"cause it to follow the <literal>ON CONFLICT</literal> rule instead. Such "
"cases will leave unused <quote>holes</quote> in the sequence of assigned "
"values. Thus, <productname>PostgreSQL</productname> sequence objects "
"<emphasis>cannot be used to obtain <quote>gapless</quote> sequences</"
"emphasis>."
msgstr ""
"Во избежание блокирования параллельных транзакций, пытающихся получить "
"значения одной последовательности, операция <function>nextval</function> "
"никогда не откатывается; то есть, как только значение было выбрано, оно "
"считается использованным и не будет возвращено снова. Это утверждение верно, "
"даже когда окружающая транзакция впоследствии прерывается или вызывающий "
"запрос никак не использует это значение. Например, команда <command>INSERT</"
"command> с предложением <literal>ON CONFLICT</literal> вычислит кортеж, "
"претендующий на добавление, произведя все требуемые вызовы "
"<function>nextval</function>, прежде чем выявит конфликты, которые могут "
"привести к отработке правил <literal>ON CONFLICT</literal> вместо "
"добавления. В таких ситуациях в последовательности задействованных значений "
"могут образовываться <quote>дыры</quote>. Таким образом, объекты "
"последовательностей <productname>PostgreSQL</productname> <emphasis>не "
"годятся для получения непрерывных последовательностей</emphasis>."

#: func.xml:11334(function)
msgid "currval"
msgstr "currval"

#: func.xml:11336(para)
msgid ""
"Return the value most recently obtained by <function>nextval</function> for "
"this sequence in the current session. (An error is reported if "
"<function>nextval</function> has never been called for this sequence in this "
"session.) Because this is returning a session-local value, it gives a "
"predictable answer whether or not other sessions have executed "
"<function>nextval</function> since the current session did."
msgstr ""
"Возвращает значение, выданное при последнем вызове <function>nextval</"
"function> для этой последовательности в текущем сеансе. (Если в данном "
"сеансе <function>nextval</function> ни разу не вызывалась для данной "
"последовательности, возвращается ошибка.) Так как это значение ограничено "
"рамками сеанса, эта функция выдаёт предсказуемый результат вне зависимости "
"от того, вызвалась ли впоследствии <function>nextval</function> в других "
"сеансах или нет."

#: func.xml:11349(function)
msgid "lastval"
msgstr "lastval"

#: func.xml:11351(para)
msgid ""
"Return the value most recently returned by <function>nextval</function> in "
"the current session. This function is identical to <function>currval</"
"function>, except that instead of taking the sequence name as an argument it "
"refers to whichever sequence <function>nextval</function> was most recently "
"applied to in the current session. It is an error to call <function>lastval</"
"function> if <function>nextval</function> has not yet been called in the "
"current session."
msgstr ""
"Возвращает значение, выданное при последнем вызове <function>nextval</"
"function> в текущем сеансе. Эта функция подобна <function>currval</"
"function>, но она не принимает в параметрах имя последовательности, а "
"обращается к той последовательности, для которой вызывалась "
"<function>nextval</function> в последний раз в текущем сеансе. Если в "
"текущем сеансе функция <function>nextval</function> ещё не вызывалась, при "
"вызове <function>lastval</function> произойдёт ошибка."

#: func.xml:11365(function)
msgid "setval"
msgstr "setval"

#: func.xml:11367(para)
msgid ""
"Reset the sequence object's counter value. The two-parameter form sets the "
"sequence's <literal>last_value</literal> field to the specified value and "
"sets its <literal>is_called</literal> field to <literal>true</literal>, "
"meaning that the next <function>nextval</function> will advance the sequence "
"before returning a value. The value reported by <function>currval</function> "
"is also set to the specified value. In the three-parameter form, "
"<literal>is_called</literal> can be set to either <literal>true</literal> or "
"<literal>false</literal>. <literal>true</literal> has the same effect as the "
"two-parameter form. If it is set to <literal>false</literal>, the next "
"<function>nextval</function> will return exactly the specified value, and "
"sequence advancement commences with the following <function>nextval</"
"function>. Furthermore, the value reported by <function>currval</function> "
"is not changed in this case. For example, <screen>SELECT setval('foo', "
"42);           <lineannotation>Next <function>nextval</function> will return "
"43</lineannotation>\n"
"SELECT setval('foo', 42, true);     <lineannotation>Same as above</"
"lineannotation>\n"
"SELECT setval('foo', 42, false);    <lineannotation>Next <function>nextval</"
"function> will return 42</lineannotation></screen> The result returned by "
"<function>setval</function> is just the value of its second argument."
msgstr ""
"Сбрасывает счётчик последовательности. В форме с двумя параметрами "
"устанавливает для последовательности заданное значение поля "
"<literal>last_value</literal> и значение <literal>true</literal> для флага "
"<literal>is_called</literal>, показывающего, что при следующем вызове "
"<function>nextval</function> последовательность должна сначала продвинуться "
"к очередному значению, которое будет возвращено. При этом <function>currval</"
"function> также возвратит заданное значение. В форме с тремя параметрами "
"флагу <literal>is_called</literal> можно присвоить <literal>true</literal> "
"или <literal>false</literal>. Со значением <literal>true</literal> она "
"действует так же, как и форма с двумя параметрами. Если же присвоить этому "
"флагу значение <literal>false</literal>, первый вызов <function>nextval</"
"function> после этого вернёт именно заданное значение, а продвижение "
"последовательности произойдёт при последующем вызове <function>nextval</"
"function>. Кроме того, значение, возвращаемое <function>currval</function> в "
"этом случае, не меняется. Например, <screen>SELECT setval('foo', "
"42);           <lineannotation>Следующий вызов <function>nextval</function> "
"вернёт 43</lineannotation>\n"
"SELECT setval('foo', 42, true);     <lineannotation>То же самое</"
"lineannotation>\n"
"SELECT setval('foo', 42, false);    <lineannotation>Следующий вызов "
"<function>nextval</function> вернёт 42</lineannotation></screen> Результатом "
"самой функции <function>setval</function> будет просто значение её второго "
"аргумента."

#: func.xml:11391(para)
msgid ""
"Because sequences are non-transactional, changes made by <function>setval</"
"function> are not undone if the transaction rolls back."
msgstr ""
"Так как значения последовательностей изменяются вне транзакций, действие "
"функции <function>setval</function> не отменяется при откате транзакции."

#: func.xml:11290(para)
msgid "The available sequence functions are: <placeholder-1/>"
msgstr ""
"Ниже описаны все функции, предназначенные для работы с последовательностями: "
"<placeholder-1/>"

#: func.xml:11406(title)
msgid "Conditional Expressions"
msgstr "Условные выражения"

#: func.xml:11408(indexterm)
msgid "<primary>CASE</primary>"
msgstr "<primary>CASE</primary>"

#: func.xml:11412(indexterm)
msgid "<primary>conditional expression</primary>"
msgstr "<primary>условное выражение</primary>"

#: func.xml:11416(para)
msgid ""
"This section describes the <acronym>SQL</acronym>-compliant conditional "
"expressions available in <productname>PostgreSQL</productname>."
msgstr ""
"В этом разделе описаны <acronym>SQL</acronym>-совместимые условные "
"выражения, которые поддерживаются в <productname>PostgreSQL</productname>."

#: func.xml:11422(para)
msgid ""
"If your needs go beyond the capabilities of these conditional expressions, "
"you might want to consider writing a stored procedure in a more expressive "
"programming language."
msgstr ""
"Если возможностей этих условных выражений оказывается недостаточно, "
"вероятно, имеет смысл перейти к написанию хранимых процедур на более мощном "
"языке программирования."

#: func.xml:11430(literal)
msgid "CASE"
msgstr "CASE"

#: func.xml:11432(para)
msgid ""
"The <acronym>SQL</acronym> <token>CASE</token> expression is a generic "
"conditional expression, similar to if/else statements in other programming "
"languages: <synopsis>CASE WHEN <replaceable>condition</replaceable> THEN "
"<replaceable>result</replaceable>\n"
"     <optional>WHEN ...</optional>\n"
"     <optional>ELSE <replaceable>result</replaceable></optional>\n"
"END</synopsis>\n"
"\n"
"   <token>CASE</token> clauses can be used wherever an expression is valid. "
"Each <replaceable>condition</replaceable> is an expression that returns a "
"<type>boolean</type> result. If the condition's result is true, the value of "
"the <token>CASE</token> expression is the <replaceable>result</replaceable> "
"that follows the condition, and the remainder of the <token>CASE</token> "
"expression is not processed. If the condition's result is not true, any "
"subsequent <token>WHEN</token> clauses are examined in the same manner. If "
"no <token>WHEN</token>\n"
"   <replaceable>condition</replaceable> yields true, the value of the "
"<token>CASE</token> expression is the <replaceable>result</replaceable> of "
"the <token>ELSE</token> clause. If the <token>ELSE</token> clause is omitted "
"and no condition is true, the result is null."
msgstr ""
"Выражение <token>CASE</token> в <acronym>SQL</acronym> представляет собой "
"общее условное выражение, напоминающее операторы if/else в других языках "
"программирования: <synopsis>CASE WHEN <replaceable>условие</replaceable> "
"THEN <replaceable>результат</replaceable>\n"
"     <optional>WHEN ...</optional>\n"
"     <optional>ELSE <replaceable>результат</replaceable></optional>\n"
"END</synopsis>\n"
"\n"
"Предложения <token>CASE</token> можно использовать везде, где допускаются "
"выражения. Каждое <replaceable>условие</replaceable> в нём представляет "
"собой выражение, возвращающее результат типа <type>boolean</type>. Если "
"результатом выражения оказывается true, значением выражения <token>CASE</"
"token> становится <replaceable>результат</replaceable>, следующий за "
"условием, а остальная часть выражения <token>CASE</token> не вычисляется. "
"Если же условие не выполняется, за ним таким же образом проверяются все "
"последующие предложения <token>WHEN</token>. Если не выполняется ни одно из "
"<replaceable>условий</replaceable> <token>WHEN</token>, значением "
"<token>CASE</token> становится <replaceable>результат</replaceable>, "
"записанный в предложении <token>ELSE</token>. Если при этом предложение "
"<token>ELSE</token> отсутствует, результатом выражения будет NULL."

#: func.xml:11456(para)
msgid ""
"An example: <screen>SELECT * FROM test;\n"
"\n"
" a\n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"\n"
"SELECT a,\n"
"       CASE WHEN a=1 THEN 'one'\n"
"            WHEN a=2 THEN 'two'\n"
"            ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other</screen>"
msgstr ""
"Пример: <screen>SELECT * FROM test;\n"
"\n"
" a\n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"\n"
"SELECT a,\n"
"       CASE WHEN a=1 THEN 'one'\n"
"            WHEN a=2 THEN 'two'\n"
"            ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other</screen>"

#: func.xml:11481(para)
msgid ""
"The data types of all the <replaceable>result</replaceable> expressions must "
"be convertible to a single output type. See <xref linkend=\"typeconv-union-"
"case\"/> for more details."
msgstr ""
"Типы данных всех выражений <replaceable>результатов</replaceable> должны "
"приводиться к одному выходному типу. Подробнее это описано в <xref remap="
"\"6\" linkend=\"typeconv-union-case\"/>."

#: func.xml:11487(para)
msgid ""
"There is a <quote>simple</quote> form of <token>CASE</token> expression that "
"is a variant of the general form above: <synopsis>CASE "
"<replaceable>expression</replaceable>\n"
"    WHEN <replaceable>value</replaceable> THEN <replaceable>result</"
"replaceable>\n"
"    <optional>WHEN ...</optional>\n"
"    <optional>ELSE <replaceable>result</replaceable></optional>\n"
"END</synopsis> The first <replaceable>expression</replaceable> is computed, "
"then compared to each of the <replaceable>value</replaceable> expressions in "
"the <token>WHEN</token> clauses until one is found that is equal to it. If "
"no match is found, the <replaceable>result</replaceable> of the <token>ELSE</"
"token> clause (or a null value) is returned. This is similar to the "
"<function>switch</function> statement in C."
msgstr ""
"Существует также <quote>простая</quote> форма выражения <token>CASE</token>, "
"разновидность вышеприведённой общей формы: <synopsis>CASE "
"<replaceable>выражение</replaceable>\n"
"    WHEN <replaceable>значение</replaceable> THEN <replaceable>результат</"
"replaceable>\n"
"    <optional>WHEN ...</optional>\n"
"    <optional>ELSE <replaceable>результат</replaceable></optional>\n"
"END</synopsis> В такой форме сначала вычисляется первое "
"<replaceable>выражение</replaceable>, а затем его результат сравнивается с "
"выражениями <replaceable>значений</replaceable> в предложениях <token>WHEN</"
"token>, пока не будет найдено равное ему. Если такого не значения не "
"находится, возвращается <replaceable>результат</replaceable> предложения "
"<token>ELSE</token> (или NULL). Эта форма больше похожа на оператор "
"<function>switch</function>, существующий в языке C."

#: func.xml:11506(para)
msgid ""
"The example above can be written using the simple <token>CASE</token> "
"syntax: <screen>SELECT a,\n"
"       CASE a WHEN 1 THEN 'one'\n"
"              WHEN 2 THEN 'two'\n"
"              ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other</screen>"
msgstr ""
"Показанный ранее пример можно записать по-другому, используя простую форму "
"<token>CASE</token>: <screen>SELECT a,\n"
"       CASE a WHEN 1 THEN 'one'\n"
"              WHEN 2 THEN 'two'\n"
"              ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other</screen>"

#: func.xml:11527(programlisting)
#, no-wrap
msgid "SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;"
msgstr "SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;"

#: func.xml:11523(para)
msgid ""
"A <token>CASE</token> expression does not evaluate any subexpressions that "
"are not needed to determine the result. For example, this is a possible way "
"of avoiding a division-by-zero failure: <placeholder-1/>"
msgstr ""
"В выражении <token>CASE</token> вычисляются только те подвыражения, которые "
"необходимы для получения результата. Например, так можно избежать ошибки "
"деления на ноль: <placeholder-1/>"

#: func.xml:11531(para)
msgid ""
"As described in <xref linkend=\"syntax-express-eval\"/>, there are various "
"situations in which subexpressions of an expression are evaluated at "
"different times, so that the principle that <quote><token>CASE</token> "
"evaluates only necessary subexpressions</quote> is not ironclad. For example "
"a constant <literal>1/0</literal> subexpression will usually result in a "
"division-by-zero failure at planning time, even if it's within a "
"<token>CASE</token> arm that would never be entered at run time."
msgstr ""
"Как было описано в <xref remap=\"6\" linkend=\"syntax-express-eval\"/>, всё "
"же возможны ситуации, когда подвыражения вычисляются на разных этапах, так "
"что железной гарантии, что в <quote><token>CASE</token> вычисляются только "
"необходимые подвыражения</quote>, в принципе нет. Например, константное "
"подвыражение <literal>1/0</literal> обычно вызывает ошибку деления на ноль "
"на этапе планирования, хотя эта ветвь <token>CASE</token> может вовсе не "
"вычисляться во время выполнения."

#: func.xml:11544(literal)
msgctxt "literal"
msgid "COALESCE"
msgstr "COALESCE"

#: func.xml:11546(indexterm)
msgid "<primary>COALESCE</primary>"
msgstr "<primary>COALESCE</primary>"

#: func.xml:11550(indexterm)
msgid "<primary>NVL</primary>"
msgstr "<primary>NVL</primary>"

#: func.xml:11554(indexterm)
msgid "<primary>IFNULL</primary>"
msgstr "<primary>IFNULL</primary>"

#: func.xml:11558(function)
msgctxt "function"
msgid "COALESCE"
msgstr "COALESCE"

#: func.xml:11558(synopsis) func.xml:11615(synopsis) func.xml:11616(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/> <placeholder-3/>)"

#: func.xml:11565(programlisting)
#, no-wrap
msgid "SELECT COALESCE(description, short_description, '(none)') ..."
msgstr "SELECT COALESCE(description, short_description, '(none)') ..."

#: func.xml:11560(para)
msgid ""
"The <function>COALESCE</function> function returns the first of its "
"arguments that is not null. Null is returned only if all arguments are null. "
"It is often used to substitute a default value for null values when data is "
"retrieved for display, for example: <placeholder-1/> This returns "
"<varname>description</varname> if it is not null, otherwise "
"<varname>short_description</varname> if it is not null, otherwise "
"<literal>(none)</literal>."
msgstr ""
"Функция <function>COALESCE</function> возвращает первый попавшийся аргумент, "
"отличный от NULL. Если же все аргументы равны NULL, результатом тоже будет "
"NULL. Это часто используется при отображении данных для подстановки "
"некоторого значения по умолчанию вместо значений NULL: <placeholder-1/> Этот "
"запрос вернёт значение <varname>description</varname>, если оно не равно "
"NULL, либо <varname>short_description</varname>, если оно не NULL, и строку "
"<literal>(none)</literal>, если оба эти значения равны NULL."

#: func.xml:11570(para)
msgid ""
"Like a <token>CASE</token> expression, <function>COALESCE</function> only "
"evaluates the arguments that are needed to determine the result; that is, "
"arguments to the right of the first non-null argument are not evaluated. "
"This SQL-standard function provides capabilities similar to <function>NVL</"
"function> and <function>IFNULL</function>, which are used in some other "
"database systems."
msgstr ""
"Как и выражение <token>CASE</token>, <function>COALESCE</function> вычисляет "
"только те аргументы, которые необходимы для получения результата; то есть, "
"аргументы правее первого отличного от NULL аргумента не вычисляются. Эта "
"функция соответствует стандарту SQL, а в некоторых других СУБД её аналоги "
"называются <function>NVL</function> и <function>IFNULL</function>."

#: func.xml:11581(literal)
msgctxt "literal"
msgid "NULLIF"
msgstr "NULLIF"

#: func.xml:11583(indexterm)
msgid "<primary>NULLIF</primary>"
msgstr "<primary>NULLIF</primary>"

#: func.xml:11587(function)
msgctxt "function"
msgid "NULLIF"
msgstr "NULLIF"

#: func.xml:11587(replaceable)
msgid "value1"
msgstr "значение1"

#: func.xml:11587(replaceable)
msgid "value2"
msgstr "значение2"

#: func.xml:11587(synopsis)
#, no-wrap
msgctxt "synopsis"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"

#: func.xml:11595(programlisting)
#, no-wrap
msgid "SELECT NULLIF(value, '(none)') ..."
msgstr "SELECT NULLIF(value, '(none)') ..."

#: func.xml:11589(para)
msgid ""
"The <function>NULLIF</function> function returns a null value if "
"<replaceable>value1</replaceable> equals <replaceable>value2</replaceable>; "
"otherwise it returns <replaceable>value1</replaceable>. This can be used to "
"perform the inverse operation of the <function>COALESCE</function> example "
"given above: <placeholder-1/>"
msgstr ""
"Функция <function>NULLIF</function> возвращает значение NULL, если "
"<replaceable>значение1</replaceable> равно <replaceable>значение2</"
"replaceable>; в противном случае она возвращает <replaceable>значение1</"
"replaceable>. Это может быть полезно для реализации обратной операции к "
"<function>COALESCE</function>. В частности, для примера, показанного выше: "
"<placeholder-1/>"

#: func.xml:11597(para)
msgid ""
"In this example, if <literal>value</literal> is <literal>(none)</literal>, "
"null is returned, otherwise the value of <literal>value</literal> is "
"returned."
msgstr ""
"Если аргумент <literal>value</literal> равен <literal>(none)</literal>, "
"результатом выражения будет NULL, а в противном случае &mdash; значение "
"аргумента <literal>value</literal>."

#: func.xml:11606(title)
msgid "<literal>GREATEST</literal> and <literal>LEAST</literal>"
msgstr "<literal>GREATEST</literal> и <literal>LEAST</literal>"

#: func.xml:11608(indexterm)
msgid "<primary>GREATEST</primary>"
msgstr "<primary>GREATEST</primary>"

#: func.xml:11611(indexterm)
msgid "<primary>LEAST</primary>"
msgstr "<primary>LEAST</primary>"

#: func.xml:11615(function)
msgid "GREATEST"
msgstr "GREATEST"

#: func.xml:11616(function)
msgid "LEAST"
msgstr "LEAST"

#: func.xml:11618(para)
msgid ""
"The <function>GREATEST</function> and <function>LEAST</function> functions "
"select the largest or smallest value from a list of any number of "
"expressions. The expressions must all be convertible to a common data type, "
"which will be the type of the result (see <xref linkend=\"typeconv-union-case"
"\"/> for details). NULL values in the list are ignored. The result will be "
"NULL only if all the expressions evaluate to NULL."
msgstr ""
"Функции <function>GREATEST</function> и <function>LEAST</function> выбирают "
"наибольшее или наименьшее значение из списка выражений. Все эти выражения "
"должны приводиться к общему типу данных, который станет типом результата "
"(подробнее об этом в <xref remap=\"6\" linkend=\"typeconv-union-case\"/>). "
"Значения NULL в этом списке игнорируются, так что результат выражения будет "
"равен NULL, только если все его аргументы равны NULL."

#: func.xml:11628(para)
msgid ""
"Note that <function>GREATEST</function> and <function>LEAST</function> are "
"not in the SQL standard, but are a common extension. Some other databases "
"make them return NULL if any argument is NULL, rather than only when all are "
"NULL."
msgstr ""
"Заметьте, что функции <function>GREATEST</function> и <function>LEAST</"
"function> не описаны в стандарте SQL, но часто реализуются в СУБД как "
"расширения. В некоторых других СУБД они могут возвращать NULL, когда не все, "
"а любой из аргументов равен NULL."

#: func.xml:11638(title)
msgid "Array Functions and Operators"
msgstr "Функции и операторы для работы с массивами"

#: func.xml:11640(para)
msgid ""
"<xref linkend=\"array-operators-table\"/> shows the operators available for "
"array types."
msgstr ""
"В <xref remap=\"6\" linkend=\"array-operators-table\"/> показаны операторы, "
"предназначенные для работы с массивами."

#: func.xml:11646(title)
msgid "Array Operators"
msgstr "Операторы для работы с массивами"

#: func.xml:11660(literal)
msgid "ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]"
msgstr "ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]"

#: func.xml:11667(literal)
msgid "ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]"
msgstr "ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]"

#: func.xml:11674(literal)
msgid "ARRAY[1,2,3] &lt; ARRAY[1,2,4]"
msgstr "ARRAY[1,2,3] &lt; ARRAY[1,2,4]"

#: func.xml:11681(literal)
msgid "ARRAY[1,4,3] &gt; ARRAY[1,2,4]"
msgstr "ARRAY[1,4,3] &gt; ARRAY[1,2,4]"

#: func.xml:11687(entry) func.xml:12162(entry)
msgid "less than or equal"
msgstr "меньше или равно"

#: func.xml:11688(literal)
msgid "ARRAY[1,2,3] &lt;= ARRAY[1,2,3]"
msgstr "ARRAY[1,2,3] &lt;= ARRAY[1,2,3]"

#: func.xml:11694(entry) func.xml:12169(entry)
msgid "greater than or equal"
msgstr "больше или равно"

#: func.xml:11695(literal)
msgid "ARRAY[1,4,3] &gt;= ARRAY[1,4,3]"
msgstr "ARRAY[1,4,3] &gt;= ARRAY[1,4,3]"

#: func.xml:11702(literal)
msgid "ARRAY[1,4,3] @&gt; ARRAY[3,1]"
msgstr "ARRAY[1,4,3] @&gt; ARRAY[3,1]"

#: func.xml:11709(literal)
msgid "ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6]"
msgstr "ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6]"

#: func.xml:11715(entry)
msgid "overlap (have elements in common)"
msgstr "пересечение (есть общие элементы)"

#: func.xml:11716(literal)
msgid "ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]"
msgstr "ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]"

#: func.xml:11722(entry) func.xml:11729(entry)
msgid "array-to-array concatenation"
msgstr "соединение массива с массивом"

#: func.xml:11723(literal)
msgid "ARRAY[1,2,3] || ARRAY[4,5,6]"
msgstr "ARRAY[1,2,3] || ARRAY[4,5,6]"

#: func.xml:11724(literal)
msgid "{1,2,3,4,5,6}"
msgstr "{1,2,3,4,5,6}"

#: func.xml:11730(literal)
msgid "ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]"
msgstr "ARRAY[1,2,3] || ARRAY[[4,5,6], [7,8,9]]"

#: func.xml:11731(literal)
msgid "{{1,2,3},{4,5,6},{7,8,9}}"
msgstr "{{1,2,3},{4,5,6},{7,8,9}}"

#: func.xml:11736(entry)
msgid "element-to-array concatenation"
msgstr "соединение элемента с массивом"

#: func.xml:11737(literal)
msgid "3 || ARRAY[4,5,6]"
msgstr "3 || ARRAY[4,5,6]"

#: func.xml:11738(literal)
msgid "{3,4,5,6}"
msgstr "{3,4,5,6}"

#: func.xml:11743(entry)
msgid "array-to-element concatenation"
msgstr "соединение массива с элементом"

#: func.xml:11744(literal)
msgid "ARRAY[4,5,6] || 7"
msgstr "ARRAY[4,5,6] || 7"

#: func.xml:11745(literal)
msgid "{4,5,6,7}"
msgstr "{4,5,6,7}"

#: func.xml:11751(para)
msgid ""
"Array comparisons compare the array contents element-by-element, using the "
"default B-tree comparison function for the element data type. In "
"multidimensional arrays the elements are visited in row-major order (last "
"subscript varies most rapidly). If the contents of two arrays are equal but "
"the dimensionality is different, the first difference in the dimensionality "
"information determines the sort order. (This is a change from versions of "
"<productname>PostgreSQL</productname> prior to 8.2: older versions would "
"claim that two arrays with the same contents were equal, even if the number "
"of dimensions or subscript ranges were different.)"
msgstr ""
"Операторы сравнения массивов сравнивают содержимое массивов по элементам, "
"используя при этом функцию сравнения для B-дерева, определённую для типа "
"данного элемента по умолчанию. В многомерных массивах элементы "
"просматриваются по строкам (индекс последней размерности меняется в первую "
"очередь). Если содержимое двух массивов совпадает, а размерности "
"различаются, результат их сравнения будет определяться первым отличием в "
"размерностях. (В <productname>PostgreSQL</productname> до версии 8.2 "
"поведение было другим: два массива с одинаковым содержимом считались "
"одинаковыми, даже если число их размерностей и границы индексов различались.)"

#: func.xml:11764(para)
msgid ""
"See <xref linkend=\"arrays\"/> for more details about array operator "
"behavior. See <xref linkend=\"indexes-types\"/> for more details about which "
"operators support indexed operations."
msgstr ""
"Подробнее поведение операторов с массивами описано в <xref remap=\"6\" "
"linkend=\"arrays\"/>. За дополнительными сведениями об операторах, "
"поддерживающих индексы, обратитесь к <xref remap=\"3\" linkend=\"indexes-"
"types\"/>."

#: func.xml:11770(para)
msgid ""
"<xref linkend=\"array-functions-table\"/> shows the functions available for "
"use with array types. See <xref linkend=\"arrays\"/> for more information "
"and examples of the use of these functions."
msgstr ""
"В <xref remap=\"6\" linkend=\"array-functions-table\"/> перечислены функции, "
"предназначенные для работы с массивами. Дополнительная информация о них и "
"примеры использования приведены в <xref remap=\"6\" linkend=\"arrays\"/>."

#: func.xml:11776(indexterm)
msgid "<primary>array_append</primary>"
msgstr "<primary>array_append</primary>"

#: func.xml:11779(indexterm)
msgid "<primary>array_cat</primary>"
msgstr "<primary>array_cat</primary>"

#: func.xml:11782(indexterm)
msgid "<primary>array_ndims</primary>"
msgstr "<primary>array_ndims</primary>"

#: func.xml:11785(indexterm)
msgid "<primary>array_dims</primary>"
msgstr "<primary>array_dims</primary>"

#: func.xml:11788(indexterm)
msgid "<primary>array_fill</primary>"
msgstr "<primary>array_fill</primary>"

#: func.xml:11791(indexterm)
msgid "<primary>array_length</primary>"
msgstr "<primary>array_length</primary>"

#: func.xml:11794(indexterm)
msgid "<primary>array_lower</primary>"
msgstr "<primary>array_lower</primary>"

#: func.xml:11797(indexterm)
msgid "<primary>array_position</primary>"
msgstr "<primary>array_position</primary>"

#: func.xml:11800(indexterm)
msgid "<primary>array_positions</primary>"
msgstr "<primary>array_positions</primary>"

#: func.xml:11803(indexterm)
msgid "<primary>array_prepend</primary>"
msgstr "<primary>array_prepend</primary>"

#: func.xml:11806(indexterm)
msgid "<primary>array_remove</primary>"
msgstr "<primary>array_remove</primary>"

#: func.xml:11809(indexterm)
msgid "<primary>array_replace</primary>"
msgstr "<primary>array_replace</primary>"

#: func.xml:11812(indexterm)
msgid "<primary>array_to_string</primary>"
msgstr "<primary>array_to_string</primary>"

#: func.xml:11815(indexterm)
msgid "<primary>array_upper</primary>"
msgstr "<primary>array_upper</primary>"

#: func.xml:11818(indexterm)
msgid "<primary>cardinality</primary>"
msgstr "<primary>cardinality</primary>"

#: func.xml:11821(indexterm)
msgid "<primary>string_to_array</primary>"
msgstr "<primary>string_to_array</primary>"

#: func.xml:11824(indexterm)
msgid "<primary>unnest</primary>"
msgstr "<primary>unnest</primary>"

#: func.xml:11829(title)
msgid "Array Functions"
msgstr "Функции для работы с массивами"

#: func.xml:11844(function)
msgid "array_append"
msgstr "array_append"

#: func.xml:11848(entry)
msgid "append an element to the end of an array"
msgstr "добавляет элемент в конец массива"

#: func.xml:11849(literal)
msgid "array_append(ARRAY[1,2], 3)"
msgstr "array_append(ARRAY[1,2], 3)"

#: func.xml:11850(literal) func.xml:11955(literal)
msgid "{1,2,3}"
msgstr "{1,2,3}"

#: func.xml:11855(function)
msgid "array_cat"
msgstr "array_cat"

#: func.xml:11859(entry)
msgid "concatenate two arrays"
msgstr "соединяет два массива"

#: func.xml:11860(literal)
msgid "array_cat(ARRAY[1,2,3], ARRAY[4,5])"
msgstr "array_cat(ARRAY[1,2,3], ARRAY[4,5])"

#: func.xml:11861(literal)
msgid "{1,2,3,4,5}"
msgstr "{1,2,3,4,5}"

#: func.xml:11866(function)
msgid "array_ndims"
msgstr "array_ndims"

#: func.xml:11865(literal) func.xml:11876(literal) func.xml:12005(literal)
#: func.xml:12028(literal) func.xml:12332(literal) func.xml:12343(literal)
#: func.xml:12354(literal) func.xml:12365(literal) func.xml:12376(literal)
#: func.xml:12387(literal) func.xml:12398(literal) func.xml:15434(literal)
msgctxt "literal"
msgid "<placeholder-1/>(<placeholder-2/>)"
msgstr "<placeholder-1/>(<placeholder-2/>)"

#: func.xml:11870(entry)
msgid "returns the number of dimensions of the array"
msgstr "возвращает число размерностей массива"

#: func.xml:11871(literal)
msgid "array_ndims(ARRAY[[1,2,3], [4,5,6]])"
msgstr "array_ndims(ARRAY[[1,2,3], [4,5,6]])"

#: func.xml:11877(function)
msgid "array_dims"
msgstr "array_dims"

#: func.xml:11881(entry)
msgid "returns a text representation of array's dimensions"
msgstr "возвращает текстовое представление размерностей массива"

#: func.xml:11882(literal)
msgid "array_dims(ARRAY[[1,2,3], [4,5,6]])"
msgstr "array_dims(ARRAY[[1,2,3], [4,5,6]])"

#: func.xml:11883(literal)
msgid "[1:2][1:3]"
msgstr "[1:2][1:3]"

#: func.xml:11888(function)
msgid "array_fill"
msgstr "array_fill"

#: func.xml:11888(type) func.xml:11889(type) func.xml:11939(type)
#: func.xml:14948(type)
msgid "int[]"
msgstr "int[]"

#: func.xml:11887(literal) func.xml:11971(literal) func.xml:15252(literal)
#: func.xml:15276(literal) func.xml:15284(literal) func.xml:15299(literal)
#: func.xml:15314(literal) func.xml:15329(literal) func.xml:15344(literal)
#: func.xml:15359(literal) func.xml:15374(literal) func.xml:15389(literal)
#: func.xml:15404(literal) func.xml:15419(literal)
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>)"

#: func.xml:11893(entry)
msgid ""
"returns an array initialized with supplied value and dimensions, optionally "
"with lower bounds other than 1"
msgstr ""
"возвращает массив, заполненный заданным значением и имеющий указанные "
"размерности, в которых нижняя граница может быть отлична от 1"

#: func.xml:11895(literal)
msgid "array_fill(7, ARRAY[3], ARRAY[2])"
msgstr "array_fill(7, ARRAY[3], ARRAY[2])"

#: func.xml:11896(literal)
msgid "[2:4]={7,7,7}"
msgstr "[2:4]={7,7,7}"

#: func.xml:11901(function)
msgid "array_length"
msgstr "array_length"

#: func.xml:11905(entry)
msgid "returns the length of the requested array dimension"
msgstr "возвращает длину указанной размерности массива"

#: func.xml:11906(literal)
msgid "array_length(array[1,2,3], 1)"
msgstr "array_length(array[1,2,3], 1)"

#: func.xml:11912(function)
msgid "array_lower"
msgstr "array_lower"

#: func.xml:11916(entry)
msgid "returns lower bound of the requested array dimension"
msgstr "возвращает нижнюю границу указанной размерности массива"

#: func.xml:11917(literal)
msgid "array_lower('[0:2]={1,2,3}'::int[], 1)"
msgstr "array_lower('[0:2]=&zwsp;{1,2,3}'::int[], 1)"

#: func.xml:11923(function)
msgid "array_position"
msgstr "array_position"

#: func.xml:11922(literal) func.xml:11982(literal) func.xml:12016(literal)
msgctxt "literal"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:11927(entry)
msgid ""
"returns the subscript of the first occurrence of the second argument in the "
"array, starting at the element indicated by the third argument or at the "
"first element (array must be one-dimensional)"
msgstr ""
"возвращает позицию первого вхождения второго аргумента в массиве, начиная с "
"элемента, выбираемого третьим аргументом, либо с первого элемента (массив "
"должен быть одномерным)"

#: func.xml:11930(literal)
msgid "array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon')"
msgstr ""
"array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon')"

#: func.xml:11936(function)
msgid "array_positions"
msgstr "array_positions"

#: func.xml:11940(entry)
msgid ""
"returns an array of subscripts of all occurrences of the second argument in "
"the array given as first argument (array must be one-dimensional)"
msgstr ""
"возвращает массив с позициями всех вхождений второго аргумента в массиве, "
"задаваемым первым аргументом (массив должен быть одномерным)"

#: func.xml:11943(literal)
msgid "array_positions(ARRAY['A','A','B','A'], 'A')"
msgstr "array_positions(ARRAY['A','A','B','A'], 'A')"

#: func.xml:11944(literal)
msgid "{1,2,4}"
msgstr "{1,2,4}"

#: func.xml:11949(function)
msgid "array_prepend"
msgstr "array_prepend"

#: func.xml:11953(entry)
msgid "append an element to the beginning of an array"
msgstr "вставляет элемент в начало массива"

#: func.xml:11954(literal)
msgid "array_prepend(1, ARRAY[2,3])"
msgstr "array_prepend(1, ARRAY[2,3])"

#: func.xml:11960(function)
msgid "array_remove"
msgstr "array_remove"

#: func.xml:11964(entry)
msgid ""
"remove all elements equal to the given value from the array (array must be "
"one-dimensional)"
msgstr ""
"удаляет из массива все элементы, равные заданному значению (массив должен "
"быть одномерным)"

#: func.xml:11966(literal)
msgid "array_remove(ARRAY[1,2,3,2], 2)"
msgstr "array_remove(ARRAY[1,2,3,2], 2)"

#: func.xml:11967(literal)
msgid "{1,3}"
msgstr "{1,3}"

#: func.xml:11972(function)
msgid "array_replace"
msgstr "array_replace"

#: func.xml:11976(entry)
msgid "replace each array element equal to the given value with a new value"
msgstr ""
"заменяет в массиве все элементы, равные заданному значению, другим значением"

#: func.xml:11977(literal)
msgid "array_replace(ARRAY[1,2,5,4], 5, 3)"
msgstr "array_replace(ARRAY[1,2,5,4], 5, 3)"

#: func.xml:11978(literal)
msgid "{1,2,3,4}"
msgstr "{1,2,3,4}"

#: func.xml:11983(function)
msgid "array_to_string"
msgstr "array_to_string"

#: func.xml:11987(entry)
msgid ""
"concatenates array elements using supplied delimiter and optional null string"
msgstr ""
"выводит элементы массива через заданный разделитель и позволяет определить "
"замену для значения NULL"

#: func.xml:11989(literal)
msgid "array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')"
msgstr "array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')"

#: func.xml:11990(literal)
msgid "1,2,3,*,5"
msgstr "1,2,3,*,5"

#: func.xml:11995(function)
msgid "array_upper"
msgstr "array_upper"

#: func.xml:11999(entry)
msgid "returns upper bound of the requested array dimension"
msgstr "возвращает верхнюю границу указанной размерности массива"

#: func.xml:12000(literal)
msgid "array_upper(ARRAY[1,8,3,7], 1)"
msgstr "array_upper(ARRAY[1,8,3,7], 1)"

#: func.xml:12006(function)
msgid "cardinality"
msgstr "cardinality"

#: func.xml:12010(entry)
msgid ""
"returns the total number of elements in the array, or 0 if the array is empty"
msgstr "возвращает общее число элементов в массиве, либо 0, если массив пуст"

#: func.xml:12011(literal)
msgid "cardinality(ARRAY[[1,2],[3,4]])"
msgstr "cardinality(ARRAY[[1,2],[3,4]])"

#: func.xml:12017(function)
msgid "string_to_array"
msgstr "string_to_array"

#: func.xml:12021(entry)
msgid ""
"splits string into array elements using supplied delimiter and optional null "
"string"
msgstr ""
"разбивает строку на элементы массива, используя заданный разделитель и, "
"возможно, замену для значений NULL"

#: func.xml:12023(literal)
msgid "string_to_array('xx~^~yy~^~zz', '~^~', 'yy')"
msgstr "string_to_array('xx~^~yy~&zwsp;^~zz', '~^~', 'yy')"

#: func.xml:12024(literal)
msgid "{xx,NULL,zz}"
msgstr "{xx,NULL,zz}"

#: func.xml:12029(function) func.xml:12041(function)
msgid "unnest"
msgstr "unnest"

#: func.xml:12033(entry)
msgid "expand an array to a set of rows"
msgstr "разворачивает массив в набор строк"

#: func.xml:12034(literal)
msgid "unnest(ARRAY[1,2])"
msgstr "unnest(ARRAY[1,2])"

#: func.xml:12035(entry)
msgid ""
"<literallayout class=\"monospaced\">1\n"
"2</literallayout>(2 rows)"
msgstr ""
"<literallayout class=\"monospaced\">1\n"
"2</literallayout>(2 строки)"

#: func.xml:12040(literal)
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> [, ...])"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> [, ...])"

#: func.xml:12044(type)
msgid "setof anyelement, anyelement [, ...]"
msgstr "setof anyelement, anyelement [, ...]"

#: func.xml:12045(entry)
msgid ""
"expand multiple arrays (possibly of different types) to a set of rows. This "
"is only allowed in the FROM clause; see <xref linkend=\"queries-"
"tablefunctions\"/>"
msgstr ""
"разворачивает массивы (возможно разных типов) в набор строк. Это допускается "
"только в предложении FROM; см. <xref remap=\"4\" linkend=\"queries-"
"tablefunctions\"/>"

#: func.xml:12048(literal)
msgid "unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])"
msgstr "unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])"

#: func.xml:12049(entry)
msgid ""
"<literallayout class=\"monospaced\">1    foo\n"
"2    bar\n"
"NULL baz</literallayout>(3 rows)"
msgstr ""
"<literallayout class=\"monospaced\">1    foo\n"
"2    bar\n"
"NULL baz</literallayout>(3 строки)"

#: func.xml:12057(para)
msgid ""
"In <function>array_position</function> and <function>array_positions</"
"function>, each array element is compared to the searched value using "
"<literal>IS NOT DISTINCT FROM</literal> semantics."
msgstr ""
"В функциях <function>array_position</function> и <function>array_positions</"
"function> каждый элемент массива сравнивается с искомым значением по "
"принципу <literal>IS NOT DISTINCT FROM</literal>."

#: func.xml:12063(para)
msgid ""
"In <function>array_position</function>, <literal>NULL</literal> is returned "
"if the value is not found."
msgstr ""
"Функция <function>array_position</function> возвращает <literal>NULL</"
"literal>, если искомое значение не находится."

#: func.xml:12068(para)
msgid ""
"In <function>array_positions</function>, <literal>NULL</literal> is returned "
"only if the array is <literal>NULL</literal>; if the value is not found in "
"the array, an empty array is returned instead."
msgstr ""
"Функция <function>array_positions</function> возвращает <literal>NULL</"
"literal>, только если в качестве массива передаётся <literal>NULL</literal>; "
"если же в массиве не находится значение, она возвращает пустой массив."

#: func.xml:12074(para)
msgid ""
"In <function>string_to_array</function>, if the delimiter parameter is NULL, "
"each character in the input string will become a separate element in the "
"resulting array. If the delimiter is an empty string, then the entire input "
"string is returned as a one-element array. Otherwise the input string is "
"split at each occurrence of the delimiter string."
msgstr ""
"Если для функции <function>string_to_array</function> в качестве разделителя "
"задан NULL, каждый символ входной строки станет отдельным элементов в "
"полученном массиве. Если разделитель пустая строка, строка будет возвращена "
"целиком в массиве из одного элемента. В противном случае входная строка "
"разбивается по вхождениям подстроки, указанной в качестве разделителя."

#: func.xml:12082(para)
msgid ""
"In <function>string_to_array</function>, if the null-string parameter is "
"omitted or NULL, none of the substrings of the input will be replaced by "
"NULL. In <function>array_to_string</function>, if the null-string parameter "
"is omitted or NULL, any null elements in the array are simply skipped and "
"not represented in the output string."
msgstr ""
"Если для функции <function>string_to_array</function> параметр замены "
"значения NULL опущен или равен NULL, никакие подстроки во входных данных не "
"будут заменяться на NULL. Если же параметр замены NULL опущен или равен NULL "
"для функции <function>array_to_string</function>, все значения NULL просто "
"пропускаются и никак не представляются в выходной строке."

#: func.xml:12092(para)
msgid ""
"There are two differences in the behavior of <function>string_to_array</"
"function> from pre-9.1 versions of <productname>PostgreSQL</productname>. "
"First, it will return an empty (zero-element) array rather than NULL when "
"the input string is of zero length. Second, if the delimiter string is NULL, "
"the function splits the input into individual characters, rather than "
"returning NULL as before."
msgstr ""
"В поведении <function>string_to_array</function> по сравнению с "
"<productname>PostgreSQL</productname> версий до 9.1 произошли два изменения. "
"Во-первых, эта функция возвращает пустой массив (содержащий 0 элементов), а "
"не NULL, когда входная строка имеет нулевую длину. Во-вторых, если в "
"качестве разделителя задан NULL, эта функция разбивает строку по символам, а "
"не просто возвращает NULL, как было раньше."

#: func.xml:12102(para)
msgid ""
"See also <xref linkend=\"functions-aggregate\"/> about the aggregate "
"function <function>array_agg</function> for use with arrays."
msgstr ""
"Вы также можете узнать об агрегатной функции, работающей с массивами, "
"<function>array_agg</function> в <xref remap=\"6\" linkend=\"functions-"
"aggregate\"/>."

#: func.xml:12109(title)
msgid "Range Functions and Operators"
msgstr "Диапазонные функции и операторы"

#: func.xml:12111(para)
msgid "See <xref linkend=\"rangetypes\"/> for an overview of range types."
msgstr ""
"Диапазонные типы данных рассматриваются в <xref remap=\"6\" linkend="
"\"rangetypes\"/>."

#: func.xml:12115(para)
msgid ""
"<xref linkend=\"range-operators-table\"/> shows the operators available for "
"range types."
msgstr ""
"В <xref remap=\"6\" linkend=\"range-operators-table\"/> показаны операторы, "
"предназначенные для работы с диапазонами."

#: func.xml:12121(title)
msgid "Range Operators"
msgstr "Диапазонные операторы"

#: func.xml:12135(literal)
msgid "int4range(1,5) = '[1,4]'::int4range"
msgstr "int4range(1,5) = '[1,4]'::int4range"

#: func.xml:12142(literal)
msgid "numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)"
msgstr "numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)"

#: func.xml:12149(literal)
msgid "int4range(1,10) &lt; int4range(2,3)"
msgstr "int4range(1,10) &lt; int4range(2,3)"

#: func.xml:12156(literal)
msgid "int4range(1,10) &gt; int4range(1,5)"
msgstr "int4range(1,10) &gt; int4range(1,5)"

#: func.xml:12163(literal)
msgid "numrange(1.1,2.2) &lt;= numrange(1.1,2.2)"
msgstr "numrange(1.1,2.2) &lt;= numrange(1.1,2.2)"

#: func.xml:12170(literal)
msgid "numrange(1.1,2.2) &gt;= numrange(1.1,2.0)"
msgstr "numrange(1.1,2.2) &gt;= numrange(1.1,2.0)"

#: func.xml:12176(entry)
msgid "contains range"
msgstr "содержит диапазон"

#: func.xml:12177(literal)
msgid "int4range(2,4) @&gt; int4range(2,3)"
msgstr "int4range(2,4) @&gt; int4range(2,3)"

#: func.xml:12183(entry)
msgid "contains element"
msgstr "содержит элемент"

#: func.xml:12184(literal)
msgid "'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp"
msgstr "'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp"

#: func.xml:12190(entry)
msgid "range is contained by"
msgstr "диапазон содержится в"

#: func.xml:12191(literal)
msgid "int4range(2,4) &lt;@ int4range(1,7)"
msgstr "int4range(2,4) &lt;@ int4range(1,7)"

#: func.xml:12197(entry)
msgid "element is contained by"
msgstr "элемент содержится в"

#: func.xml:12198(literal)
msgid "42 &lt;@ int4range(1,7)"
msgstr "42 &lt;@ int4range(1,7)"

#: func.xml:12204(entry)
msgid "overlap (have points in common)"
msgstr "пересекает (есть общие точки)"

#: func.xml:12205(literal)
msgid "int8range(3,7) &amp;&amp; int8range(4,12)"
msgstr "int8range(3,7) &amp;&amp; int8range(4,12)"

#: func.xml:12211(entry)
msgid "strictly left of"
msgstr "строго слева от"

#: func.xml:12212(literal)
msgid "int8range(1,10) &lt;&lt; int8range(100,110)"
msgstr "int8range(1,10) &lt;&lt; int8range(100,110)"

#: func.xml:12218(entry)
msgid "strictly right of"
msgstr "строго справа от"

#: func.xml:12219(literal)
msgid "int8range(50,60) &gt;&gt; int8range(20,30)"
msgstr "int8range(50,60) &gt;&gt; int8range(20,30)"

#: func.xml:12225(entry)
msgid "does not extend to the right of"
msgstr "не простирается правее"

#: func.xml:12226(literal)
msgid "int8range(1,20) &amp;&lt; int8range(18,20)"
msgstr "int8range(1,20) &amp;&lt; int8range(18,20)"

#: func.xml:12232(entry)
msgid "does not extend to the left of"
msgstr "не простирается левее"

#: func.xml:12233(literal)
msgid "int8range(7,20) &amp;&gt; int8range(5,10)"
msgstr "int8range(7,20) &amp;&gt; int8range(5,10)"

#: func.xml:12238(literal)
msgid "-|-"
msgstr "-|-"

#: func.xml:12239(entry)
msgid "is adjacent to"
msgstr "примыкает к"

#: func.xml:12240(literal)
msgid "numrange(1.1,2.2) -|- numrange(2.2,3.3)"
msgstr "numrange(1.1,2.2) -|- numrange(2.2,3.3)"

#: func.xml:12246(entry)
msgid "union"
msgstr "union"

#: func.xml:12247(literal)
msgid "numrange(5,15) + numrange(10,20)"
msgstr "numrange(5,15) + numrange(10,20)"

#: func.xml:12248(literal)
msgid "[5,20)"
msgstr "[5,20)"

#: func.xml:12253(entry)
msgid "intersection"
msgstr "пересечение"

#: func.xml:12254(literal)
msgid "int8range(5,15) * int8range(10,20)"
msgstr "int8range(5,15) * int8range(10,20)"

#: func.xml:12255(literal)
msgid "[10,15)"
msgstr "[10,15)"

#: func.xml:12260(entry)
msgid "difference"
msgstr "вычитание"

#: func.xml:12261(literal)
msgid "int8range(5,15) - int8range(10,20)"
msgstr "int8range(5,15) - int8range(10,20)"

#: func.xml:12262(literal)
msgid "[5,10)"
msgstr "[5,10)"

#: func.xml:12269(para)
msgid ""
"The simple comparison operators <literal>&lt;</literal>, <literal>&gt;</"
"literal>, <literal>&lt;=</literal>, and <literal>&gt;=</literal> compare the "
"lower bounds first, and only if those are equal, compare the upper bounds. "
"These comparisons are not usually very useful for ranges, but are provided "
"to allow B-tree indexes to be constructed on ranges."
msgstr ""
"Простые операторы сравнения <literal>&lt;</literal>, <literal>&gt;</"
"literal>, <literal>&lt;=</literal> и <literal>&gt;=</literal> сначала "
"сравнивают нижние границы, и только если они равны, сравнивают верхние. Эти "
"операторы сравнения обычно не очень полезны для диапазонов; основное их "
"предназначение &mdash; сделать возможным построение индексов-B-деревьев по "
"диапазонам."

#: func.xml:12278(para)
msgid ""
"The left-of/right-of/adjacent operators always return false when an empty "
"range is involved; that is, an empty range is not considered to be either "
"before or after any other range."
msgstr ""
"Операторы слева/справа/примыкает всегда возвращают false, если один из "
"диапазонов пуст; то есть, считается, что пустой диапазон находится не слева "
"и не справа от какого-либо другого диапазона."

#: func.xml:12284(para)
msgid ""
"The union and difference operators will fail if the resulting range would "
"need to contain two disjoint sub-ranges, as such a range cannot be "
"represented."
msgstr ""
"Операторы сложения и вычитания вызывают ошибку, если получающийся в "
"результате диапазон оказывается состоящим из двух разделённых поддиапазонов, "
"так как его нельзя представить в этом типе данных."

#: func.xml:12290(para)
msgid ""
"<xref linkend=\"range-functions-table\"/> shows the functions available for "
"use with range types."
msgstr ""
"В <xref remap=\"6\" linkend=\"range-functions-table\"/> перечислены функции, "
"предназначенные для работы с диапазонными типами."

#: func.xml:12301(indexterm)
msgid "<primary>isempty</primary>"
msgstr "<primary>isempty</primary>"

#: func.xml:12304(indexterm)
msgid "<primary>lower_inc</primary>"
msgstr "<primary>lower_inc</primary>"

#: func.xml:12307(indexterm)
msgid "<primary>upper_inc</primary>"
msgstr "<primary>upper_inc</primary>"

#: func.xml:12310(indexterm)
msgid "<primary>lower_inf</primary>"
msgstr "<primary>lower_inf</primary>"

#: func.xml:12313(indexterm)
msgid "<primary>upper_inf</primary>"
msgstr "<primary>upper_inf</primary>"

#: func.xml:12318(title)
msgid "Range Functions"
msgstr "Диапазонные функции"

#: func.xml:12333(function)
msgid "lower"
msgstr "lower"

#: func.xml:12333(type) func.xml:12344(type) func.xml:12355(type)
#: func.xml:12366(type) func.xml:12377(type) func.xml:12388(type)
#: func.xml:12399(type) func.xml:12410(type) func.xml:12413(type)
msgid "anyrange"
msgstr "anyrange"

#: func.xml:12336(entry) func.xml:12347(entry)
msgid "range's element type"
msgstr "тип элемента диапазона"

#: func.xml:12337(entry)
msgid "lower bound of range"
msgstr "нижняя граница диапазона"

#: func.xml:12338(literal)
msgid "lower(numrange(1.1,2.2))"
msgstr "lower(numrange(1.1, 2.2))"

#: func.xml:12339(literal)
msgid "1.1"
msgstr "1.1"

#: func.xml:12344(function)
msgid "upper"
msgstr "upper"

#: func.xml:12348(entry)
msgid "upper bound of range"
msgstr "верхняя граница диапазона"

#: func.xml:12349(literal)
msgid "upper(numrange(1.1,2.2))"
msgstr "upper(numrange(1.1, 2.2))"

#: func.xml:12350(literal)
msgid "2.2"
msgstr "2.2"

#: func.xml:12355(function)
msgid "isempty"
msgstr "isempty"

#: func.xml:12359(entry)
msgid "is the range empty?"
msgstr "диапазон пуст?"

#: func.xml:12360(literal)
msgid "isempty(numrange(1.1,2.2))"
msgstr "isempty(numrange(1.1,2.2))"

#: func.xml:12366(function)
msgid "lower_inc"
msgstr "lower_inc"

#: func.xml:12370(entry)
msgid "is the lower bound inclusive?"
msgstr "нижняя граница включается?"

#: func.xml:12371(literal)
msgid "lower_inc(numrange(1.1,2.2))"
msgstr "lower_inc(numrange(1.1, 2.2))"

#: func.xml:12377(function)
msgid "upper_inc"
msgstr "upper_inc"

#: func.xml:12381(entry)
msgid "is the upper bound inclusive?"
msgstr "верхняя граница включается?"

#: func.xml:12382(literal)
msgid "upper_inc(numrange(1.1,2.2))"
msgstr "upper_inc(numrange(1.1, 2.2))"

#: func.xml:12388(function)
msgid "lower_inf"
msgstr "lower_inf"

#: func.xml:12392(entry)
msgid "is the lower bound infinite?"
msgstr "нижняя граница равна бесконечности?"

#: func.xml:12393(literal)
msgid "lower_inf('(,)'::daterange)"
msgstr "lower_inf('(,)'::daterange)"

#: func.xml:12399(function)
msgid "upper_inf"
msgstr "upper_inf"

#: func.xml:12403(entry)
msgid "is the upper bound infinite?"
msgstr "верхняя граница равна бесконечности?"

#: func.xml:12404(literal)
msgid "upper_inf('(,)'::daterange)"
msgstr "upper_inf('(,)'::daterange)"

#: func.xml:12410(function)
msgid "range_merge"
msgstr "range_merge"

#: func.xml:12414(entry)
msgid "the smallest range which includes both of the given ranges"
msgstr "наименьший диапазон, включающий оба заданных диапазона"

#: func.xml:12415(literal)
msgid "range_merge('[1,2)'::int4range, '[3,4)'::int4range)"
msgstr "range_merge('[1,2)'::int4range, '[3,4)'::int4range)"

#: func.xml:12416(literal)
msgid "[1,4)"
msgstr "[1,4)"

#: func.xml:12422(para)
msgid ""
"The <function>lower</function> and <function>upper</function> functions "
"return null if the range is empty or the requested bound is infinite. The "
"<function>lower_inc</function>, <function>upper_inc</function>, "
"<function>lower_inf</function>, and <function>upper_inf</function> functions "
"all return false for an empty range."
msgstr ""
"Функции <function>lower</function> и <function>upper</function> возвращают "
"NULL, если диапазон пуст или указанная граница равна бесконечности. Если же "
"пустой диапазон передаётся функциям <function>lower_inc</function>, "
"<function>upper_inc</function>, <function>lower_inf</function> и "
"<function>upper_inf</function>, все они возвращают false."

#: func.xml:12432(title)
msgid "Aggregate Functions"
msgstr "Агрегатные функции"

#: func.xml:12434(indexterm)
msgid "<primary>aggregate function</primary><secondary>built-in</secondary>"
msgstr "<primary>агрегатные функции</primary><secondary>встроенные</secondary>"

#: func.xml:12438(para)
msgid ""
"<firstterm>Aggregate functions</firstterm> compute a single result from a "
"set of input values. The built-in normal aggregate functions are listed in "
"<xref linkend=\"functions-aggregate-table\"/> and <xref linkend=\"functions-"
"aggregate-statistics-table\"/>. The built-in ordered-set aggregate functions "
"are listed in <xref linkend=\"functions-orderedset-table\"/> and <xref "
"linkend=\"functions-hypothetical-table\"/>. Grouping operations, which are "
"closely related to aggregate functions, are listed in <xref linkend="
"\"functions-grouping-table\"/>. The special syntax considerations for "
"aggregate functions are explained in <xref linkend=\"syntax-aggregates\"/>. "
"Consult <xref linkend=\"tutorial-agg\"/> for additional introductory "
"information."
msgstr ""
"<firstterm>Агрегатные функции</firstterm> получают единственный результат из "
"набора входных значений. Встроенные обычные агрегатные функции перечислены в "
"<xref remap=\"6\" linkend=\"functions-aggregate-table\"/> и <xref remap="
"\"6\" linkend=\"functions-aggregate-statistics-table\"/>, а сортирующие "
"агрегатные функции &mdash; в <xref remap=\"6\" linkend=\"functions-"
"orderedset-table\"/> и <xref remap=\"6\" linkend=\"functions-hypothetical-"
"table\"/>. Операции группирования, тесно связанные с агрегатными функциями, "
"перечислены в <xref remap=\"6\" linkend=\"functions-grouping-table\"/>. "
"Особенности синтаксиса агрегатных функций разъясняются в <xref remap=\"6\" "
"linkend=\"syntax-aggregates\"/>. За дополнительной вводной информацией "
"обратитесь к <xref remap=\"3\" linkend=\"tutorial-agg\"/>."

#: func.xml:12456(title)
msgid "General-Purpose Aggregate Functions"
msgstr "Агрегатные функции общего назначения"

#: func.xml:12462(entry)
msgid "Argument Type(s)"
msgstr "Типы аргумента"

#: func.xml:12464(entry) func.xml:12907(entry) func.xml:13317(entry)
#: func.xml:13475(entry)
#, fuzzy
msgid "Partial Mode"
msgstr "Частичные индексы"

#: func.xml:12472(indexterm)
msgid "<primary>array_agg</primary>"
msgstr "<primary>array_agg</primary>"

#: func.xml:12475(replaceable) func.xml:12489(replaceable)
#: func.xml:12511(replaceable) func.xml:12532(replaceable)
#: func.xml:12550(replaceable) func.xml:12568(replaceable)
#: func.xml:12585(replaceable) func.xml:12611(replaceable)
#: func.xml:12626(replaceable) func.xml:12643(replaceable)
#: func.xml:12660(replaceable) func.xml:12711(replaceable)
#: func.xml:12729(replaceable) func.xml:12748(replaceable)
#: func.xml:12767(replaceable) func.xml:12790(replaceable)
#: func.xml:13163(replaceable) func.xml:13186(replaceable)
#: func.xml:13209(replaceable) func.xml:14023(replaceable)
#: func.xml:14075(replaceable) func.xml:14127(replaceable)
#: func.xml:14128(replaceable) func.xml:14188(replaceable)
#: func.xml:14326(replaceable) func.xml:14353(replaceable)
#: func.xml:14390(replaceable) func.xml:14391(replaceable)
#: func.xml:14425(replaceable)
msgid "expression"
msgstr "выражение"

#: func.xml:12475(function) func.xml:12489(function)
msgid "array_agg(<placeholder-1/>)"
msgstr "array_agg(<placeholder-1/>)"

#: func.xml:12477(entry)
msgid "any non-array type"
msgstr "любой тип не массива"

#: func.xml:12480(entry)
msgid "array of the argument type"
msgstr "массив элементов с типом аргумента"

#: func.xml:12483(entry) func.xml:12497(entry) func.xml:12651(entry)
#: func.xml:12668(entry) func.xml:12685(entry) func.xml:12702(entry)
#: func.xml:12758(entry) func.xml:12798(entry) func.xml:13339(entry)
#: func.xml:13365(entry) func.xml:13386(entry) func.xml:13410(entry)
#: func.xml:13430(entry) func.xml:13498(entry) func.xml:13520(entry)
#: func.xml:13542(entry) func.xml:13564(entry)
msgid "No"
msgstr "Нет"

#: func.xml:12484(entry)
msgid "input values, including nulls, concatenated into an array"
msgstr "входные значения, включая NULL, объединяются в массив"

#: func.xml:12491(entry)
msgid "any array type"
msgstr "любой тип массива"

#: func.xml:12494(entry) func.xml:12538(entry) func.xml:12556(entry)
msgid "same as argument data type"
msgstr "тот же, что и тип аргумента"

#: func.xml:12498(entry)
msgid ""
"input arrays concatenated into array of one higher dimension (inputs must "
"all have same dimensionality, and cannot be empty or NULL)"
msgstr ""
"входные массивы собираются в массив большей размерности (они должны иметь "
"одну размерность и не могут быть пустыми или равны NULL)"

#: func.xml:12505(indexterm)
msgid "<primary>average</primary>"
msgstr "<primary>среднее</primary>"

#: func.xml:12508(indexterm)
msgid "<primary>avg</primary>"
msgstr "<primary>avg</primary>"

#: func.xml:12511(function)
msgid "avg(<placeholder-1/>)"
msgstr "avg(<placeholder-1/>)"

#: func.xml:12513(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type>, or "
"<type>interval</type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type> или "
"<type>interval</type>"

#: func.xml:12518(entry)
msgid ""
"<type>numeric</type> for any integer-type argument, <type>double precision</"
"type> for a floating-point argument, otherwise the same as the argument data "
"type"
msgstr ""
"<type>numeric</type> для любых целочисленных аргументов, <type>double "
"precision</type> для аргументов с плавающей точкой, в противном случае тип "
"данных аргумента"

#: func.xml:12523(entry) func.xml:12541(entry) func.xml:12559(entry)
#: func.xml:12576(entry) func.xml:12593(entry) func.xml:12606(entry)
#: func.xml:12614(entry) func.xml:12634(entry) func.xml:12716(entry)
#: func.xml:12734(entry) func.xml:12781(entry) func.xml:12930(entry)
#: func.xml:12950(entry) func.xml:12970(entry) func.xml:12987(entry)
#: func.xml:13005(entry) func.xml:13023(entry) func.xml:13043(entry)
#: func.xml:13063(entry) func.xml:13083(entry) func.xml:13102(entry)
#: func.xml:13123(entry) func.xml:13147(entry) func.xml:13174(entry)
#: func.xml:13197(entry) func.xml:13220(entry) func.xml:13240(entry)
#: func.xml:13263(entry) func.xml:13286(entry)
msgid "Yes"
msgstr "Да"

#: func.xml:12524(entry)
msgid "the average (arithmetic mean) of all input values"
msgstr "арифметическое среднее для всех входных значений"

#: func.xml:12529(indexterm)
msgid "<primary>bit_and</primary>"
msgstr "<primary>bit_and</primary>"

#: func.xml:12532(function)
msgid "bit_and(<placeholder-1/>)"
msgstr "bit_and(<placeholder-1/>)"

#: func.xml:12534(entry) func.xml:12552(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, or <type>bit</"
"type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type> или <type>bit</"
"type>"

#: func.xml:12542(entry)
msgid "the bitwise AND of all non-null input values, or null if none"
msgstr ""
"побитовое И для всех входных значений, не равных NULL, или NULL, если таких "
"нет"

#: func.xml:12547(indexterm)
msgid "<primary>bit_or</primary>"
msgstr "<primary>bit_or</primary>"

#: func.xml:12550(function)
msgid "bit_or(<placeholder-1/>)"
msgstr "bit_or(<placeholder-1/>)"

#: func.xml:12560(entry)
msgid "the bitwise OR of all non-null input values, or null if none"
msgstr ""
"побитовое ИЛИ для всех входных значений, не равных NULL, или NULL, если "
"таких нет"

#: func.xml:12565(indexterm)
msgid "<primary>bool_and</primary>"
msgstr "<primary>bool_and</primary>"

#: func.xml:12568(function)
msgid "bool_and(<placeholder-1/>)"
msgstr "bool_and(<placeholder-1/>)"

#: func.xml:12571(type) func.xml:12574(type) func.xml:12588(type)
#: func.xml:12591(type) func.xml:12629(type) func.xml:12632(type)
#: func.xml:17315(type) func.xml:17505(type) func.xml:17585(type)
#: func.xml:17968(type) func.xml:17980(type) func.xml:18052(type)
#: func.xml:18070(type) func.xml:18089(type) func.xml:19078(type)
#: func.xml:19139(type) func.xml:19144(type) func.xml:19152(type)
msgid "bool"
msgstr "bool"

#: func.xml:12577(entry)
msgid "true if all input values are true, otherwise false"
msgstr "true, если все входные значения равны true, и false в противном случае"

#: func.xml:12582(indexterm)
msgid "<primary>bool_or</primary>"
msgstr "<primary>bool_or</primary>"

#: func.xml:12585(function)
msgid "bool_or(<placeholder-1/>)"
msgstr "bool_or(<placeholder-1/>)"

#: func.xml:12594(entry)
msgid "true if at least one input value is true, otherwise false"
msgstr ""
"true, если хотя бы одно входное значение равно true, и false в противном "
"случае"

#: func.xml:12599(indexterm)
msgid "<primary>count</primary>"
msgstr "<primary>count</primary>"

#: func.xml:12602(function)
msgid "count(*)"
msgstr "count(*)"

#: func.xml:12607(entry)
msgid "number of input rows"
msgstr "количество входных строк"

#: func.xml:12611(function)
msgid "count(<placeholder-1/>)"
msgstr "count(<placeholder-1/>)"

#: func.xml:12612(entry)
msgctxt "entry"
msgid "any"
msgstr "any"

#: func.xml:12615(entry)
msgid ""
"number of input rows for which the value of <replaceable class=\"parameter"
"\">expression</replaceable> is not null"
msgstr ""
"количество входных строк, для которых значение <replaceable class=\"parameter"
"\">выражения</replaceable> не равно NULL"

#: func.xml:12623(indexterm)
msgid "<primary>every</primary>"
msgstr "<primary>every</primary>"

#: func.xml:12626(function)
msgid "every(<placeholder-1/>)"
msgstr "every(<placeholder-1/>)"

#: func.xml:12635(entry)
msgid "equivalent to <function>bool_and</function>"
msgstr "синоним <function>bool_and</function>"

#: func.xml:12640(indexterm)
msgid "<primary>json_agg</primary>"
msgstr "<primary>json_agg</primary>"

#: func.xml:12643(function)
msgid "json_agg(<placeholder-1/>)"
msgstr "json_agg(<placeholder-1/>)"

#: func.xml:12646(type) func.xml:12663(type) func.xml:13836(type)
#: func.xml:13852(type) func.xml:13869(type) func.xml:18159(type)
msgctxt "type"
msgid "any"
msgstr "any"

#: func.xml:12652(entry) func.xml:12669(entry)
msgid "aggregates values as a JSON array"
msgstr "агрегирует значения в виде массива JSON"

#: func.xml:12657(indexterm)
msgid "<primary>jsonb_agg</primary>"
msgstr "<primary>jsonb_agg</primary>"

#: func.xml:12660(function)
msgid "jsonb_agg(<placeholder-1/>)"
msgstr "jsonb_agg(<placeholder-1/>)"

#: func.xml:12674(indexterm)
msgid "<primary>json_object_agg</primary>"
msgstr "<primary>json_object_agg</primary>"

#: func.xml:12677(function)
msgid "json_object_agg(<placeholder-1/>, <placeholder-2/>)"
msgstr "json_object_agg(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:12680(type) func.xml:12697(type)
msgid "(any, any)"
msgstr "(any, any)"

#: func.xml:12686(entry) func.xml:12703(entry)
msgid "aggregates name/value pairs as a JSON object"
msgstr "агрегирует пары имя/значение в виде объекта JSON"

#: func.xml:12691(indexterm)
msgid "<primary>jsonb_object_agg</primary>"
msgstr "<primary>jsonb_object_agg</primary>"

#: func.xml:12694(function)
msgid "jsonb_object_agg(<placeholder-1/>, <placeholder-2/>)"
msgstr "jsonb_object_agg(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:12708(indexterm)
msgid "<primary>max</primary>"
msgstr "<primary>max</primary>"

#: func.xml:12711(function)
msgid "max(<placeholder-1/>)"
msgstr "max(<placeholder-1/>)"

#: func.xml:12713(entry) func.xml:12731(entry)
msgid ""
"any numeric, string, date/time, network, or enum type, or arrays of these "
"types"
msgstr ""
"любой числовой, строковый, сетевой тип или тип даты/времени, либо массив "
"этих типов"

#: func.xml:12715(entry) func.xml:12733(entry)
msgid "same as argument type"
msgstr "тот же, что и тип аргумента"

#: func.xml:12717(entry)
msgid ""
"maximum value of <replaceable class=\"parameter\">expression</replaceable> "
"across all input values"
msgstr ""
"максимальное значение <replaceable class=\"parameter\">выражения</"
"replaceable> среди всех входных данных"

#: func.xml:12726(indexterm)
msgid "<primary>min</primary>"
msgstr "<primary>min</primary>"

#: func.xml:12729(function)
msgid "min(<placeholder-1/>)"
msgstr "min(<placeholder-1/>)"

#: func.xml:12735(entry)
msgid ""
"minimum value of <replaceable class=\"parameter\">expression</replaceable> "
"across all input values"
msgstr ""
"минимальное значение <replaceable class=\"parameter\">выражения</"
"replaceable> среди всех входных данных"

#: func.xml:12744(indexterm)
msgid "<primary>string_agg</primary>"
msgstr "<primary>string_agg</primary>"

#: func.xml:12749(replaceable)
msgctxt "replaceable"
msgid "delimiter"
msgstr "разделитель"

#: func.xml:12747(function)
msgid "string_agg(<placeholder-1/>, <placeholder-2/>)"
msgstr "string_agg(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:12752(entry)
msgid ""
"(<type>text</type>, <type>text</type>) or (<type>bytea</type>, <type>bytea</"
"type>)"
msgstr ""
"(<type>text</type>, <type>text</type>) или (<type>bytea</type>, <type>bytea</"
"type>)"

#: func.xml:12755(entry)
msgid "same as argument types"
msgstr "тот же, что и типы аргументов"

#: func.xml:12759(entry)
msgid "input values concatenated into a string, separated by delimiter"
msgstr "входные данные складываются в строку через заданный разделитель"

#: func.xml:12764(indexterm)
msgid "<primary>sum</primary>"
msgstr "<primary>sum</primary>"

#: func.xml:12767(function)
msgid "sum(<placeholder-1/>)"
msgstr "sum(<placeholder-1/>)"

#: func.xml:12769(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type>, <type>interval</"
"type>, or <type>money</type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type>, <type>interval</"
"type> или <type>money</type>"

#: func.xml:12775(entry)
msgid ""
"<type>bigint</type> for <type>smallint</type> or <type>int</type> arguments, "
"<type>numeric</type> for <type>bigint</type> arguments, otherwise the same "
"as the argument data type"
msgstr ""
"<type>bigint</type> для аргументов <type>smallint</type> или <type>int</"
"type>, <type>numeric</type> для аргументов <type>bigint</type>, и тип "
"аргумента в остальных случаях"

#: func.xml:12782(entry)
msgid ""
"sum of <replaceable class=\"parameter\">expression</replaceable> across all "
"input values"
msgstr ""
"сумма значений <replaceable class=\"parameter\">выражения</replaceable> по "
"всем входным данным"

#: func.xml:12790(function)
msgid "xmlagg(<placeholder-1/>)"
msgstr "xmlagg(<placeholder-1/>)"

#: func.xml:12793(type) func.xml:12796(type)
msgctxt "type"
msgid "xml"
msgstr "xml"

#: func.xml:12799(entry)
msgid ""
"concatenation of XML values (see also <xref linkend=\"functions-xml-xmlagg\"/"
">)"
msgstr ""
"соединение XML-значений (см. также <xref remap=\"4\" linkend=\"functions-xml-"
"xmlagg\"/>)"

#: func.xml:12805(para)
msgid ""
"It should be noted that except for <function>count</function>, these "
"functions return a null value when no rows are selected. In particular, "
"<function>sum</function> of no rows returns null, not zero as one might "
"expect, and <function>array_agg</function> returns null rather than an empty "
"array when there are no input rows. The <function>coalesce</function> "
"function can be used to substitute zero or an empty array for null when "
"necessary."
msgstr ""
"Следует заметить, что за исключением <function>count</function>, все эти "
"функции возвращают NULL, если для них не была выбрана ни одна строка. В "
"частности, функция <function>sum</function>, не получив строк, возвращает "
"NULL, а не 0, как можно было бы ожидать, и <function>array_agg</function> в "
"этом случае возвращает NULL, а не пустой массив. Если необходимо, подставить "
"в результат 0 или пустой массив вместо NULL можно с помощью функции "
"<function>coalesce</function>."

#: func.xml:12815(para)
msgid ""
"Aggregate functions which support <firstterm>Partial Mode</firstterm> are "
"eligible to participate in various optimizations, such as parallel "
"aggregation."
msgstr ""

#: func.xml:12822(indexterm) func.xml:13951(indexterm)
#: func.xml:14275(indexterm)
msgid "<primary>ANY</primary>"
msgstr "<primary>ANY</primary>"

#: func.xml:12825(indexterm) func.xml:13959(indexterm)
#: func.xml:14283(indexterm)
msgid "<primary>SOME</primary>"
msgstr "<primary>SOME</primary>"

#: func.xml:12835(programlisting)
#, no-wrap
msgid "SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;"
msgstr "SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;"

#: func.xml:12828(para)
msgid ""
"Boolean aggregates <function>bool_and</function> and <function>bool_or</"
"function> correspond to standard SQL aggregates <function>every</function> "
"and <function>any</function> or <function>some</function>. As for "
"<function>any</function> and <function>some</function>, it seems that there "
"is an ambiguity built into the standard syntax: <placeholder-1/> Here "
"<function>ANY</function> can be considered either as introducing a subquery, "
"or as being an aggregate function, if the subquery returns one row with a "
"Boolean value. Thus the standard name cannot be given to these aggregates."
msgstr ""
"Булевы агрегатные функции <function>bool_and</function> и <function>bool_or</"
"function> соответствуют стандартным SQL-агрегатам <function>every</function> "
"и <function>any</function> или <function>some</function>. Что касается "
"<function>any</function> и <function>some</function>, по стандарту их "
"синтаксис допускает некоторую неоднозначность: <placeholder-1/> Здесь "
"<function>ANY</function> можно рассматривать и как объявление подзапроса, и "
"как агрегатную функцию, если этот подзапрос возвращает одну строку с булевым "
"значением. Таким образом, этим агрегатным функциям нельзя было дать "
"стандартные имена."

#: func.xml:12849(programlisting)
#, no-wrap
msgid "SELECT count(*) FROM sometable;"
msgstr "SELECT count(*) FROM sometable;"

#: func.xml:12844(para)
msgid ""
"Users accustomed to working with other SQL database management systems might "
"be disappointed by the performance of the <function>count</function> "
"aggregate when it is applied to the entire table. A query like: "
"<placeholder-1/> will require effort proportional to the size of the table: "
"<productname>PostgreSQL</productname> will need to scan either the entire "
"table or the entirety of an index which includes all rows in the table."
msgstr ""
"Пользователи с опытом использования других СУБД SQL могут быть недовольны "
"скоростью агрегатной функции <function>count</function>, когда она "
"применяется ко всей таблице. Подобный запрос: <placeholder-1/> потребует "
"затрат в количестве, пропорциональном размеру таблицы: "
"<productname>PostgreSQL</productname> придётся полностью просканировать либо "
"всю таблицу, либо один из индексов, включающий все её строки."

#: func.xml:12857(para)
#, fuzzy
msgid ""
"The aggregate functions <function>array_agg</function>, <function>json_agg</"
"function>, <function>jsonb_agg</function>, <function>json_object_agg</"
"function>, <function>jsonb_object_agg</function>, <function>string_agg</"
"function>, and <function>xmlagg</function>, as well as similar user-defined "
"aggregate functions, produce meaningfully different result values depending "
"on the order of the input values. This ordering is unspecified by default, "
"but can be controlled by writing an <literal>ORDER BY</literal> clause "
"within the aggregate call, as shown in <xref linkend=\"syntax-aggregates\"/"
">. Alternatively, supplying the input values from a sorted subquery will "
"usually work. For example: <screen><![CDATA[\n"
"SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;\n"
"]]></screen> Beware that this approach can fail if the outer query level "
"contains additional processing, such as a join, because that might cause the "
"subquery's output to be reordered before the aggregate is computed."
msgstr ""
"Агрегатные функции <function>array_agg</function>, <function>json_agg</"
"function>, <function>jsonb_agg</function>, <function>json_object_agg</"
"function>, <function>jsonb_object_agg</function>, <function>string_agg</"
"function> и <function>xmlagg</function> так же, как и подобные "
"пользовательские агрегатные функции, выдают разные по содержанию результаты "
"в зависимости от порядка входных данных. По умолчанию порядок не определён, "
"но его можно задать, дополнив вызов агрегатной функции предложением "
"<literal>ORDER BY</literal>, как описано в <xref remap=\"6\" linkend="
"\"syntax-aggregates\"/>. Нужного результата также можно добиться, передав "
"агрегатной функции результат подзапроса с сортировкой. Например: "
"<screen>SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;</"
"screen> Но учтите, что этот синтаксис не соответствует стандарту SQL и не "
"будет работать в других СУБД."

#: func.xml:12880(para)
msgid ""
"<xref linkend=\"functions-aggregate-statistics-table\"/> shows aggregate "
"functions typically used in statistical analysis. (These are separated out "
"merely to avoid cluttering the listing of more-commonly-used aggregates.) "
"Where the description mentions <replaceable class=\"parameter\">N</"
"replaceable>, it means the number of input rows for which all the input "
"expressions are non-null. In all cases, null is returned if the computation "
"is meaningless, for example when <replaceable class=\"parameter\">N</"
"replaceable> is zero."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-aggregate-statistics-table\"/> "
"перечислены агрегатные функции, обычно применяемые в статистическом анализе. "
"(Они выделены просто для того, чтобы не загромождать список наиболее "
"популярных агрегатных функций.) В их описании под <replaceable class="
"\"parameter\">N</replaceable> подразумевается число входных строк, для "
"которых входные выражения не равны NULL. Все эти функции возвращают NULL во "
"всех случаях, когда вычисление бессмысленно, например, когда <replaceable "
"class=\"parameter\">N</replaceable> равно 0."

#: func.xml:12891(indexterm)
msgid "<primary>statistics</primary>"
msgstr "<primary>статистика</primary>"

#: func.xml:12894(indexterm)
msgid "<primary>linear regression</primary>"
msgstr "<primary>линейная регрессия</primary>"

#: func.xml:12899(title)
msgid "Aggregate Functions for Statistics"
msgstr "Агрегатные функции для статистических вычислений"

#: func.xml:12905(entry) func.xml:14619(entry)
msgid "Argument Type"
msgstr "Тип аргумента"

#: func.xml:12916(indexterm)
msgid "<primary>correlation</primary>"
msgstr "<primary>корреляция</primary>"

#: func.xml:12919(indexterm)
msgid "<primary>corr</primary>"
msgstr "<primary>corr</primary>"

#: func.xml:12922(replaceable) func.xml:12942(replaceable)
#: func.xml:12962(replaceable) func.xml:12979(replaceable)
#: func.xml:12997(replaceable) func.xml:13015(replaceable)
#: func.xml:13035(replaceable) func.xml:13055(replaceable)
#: func.xml:13075(replaceable) func.xml:13094(replaceable)
#: func.xml:13115(replaceable) func.xml:13139(replaceable)
msgctxt "replaceable"
msgid "Y"
msgstr "Y"

#: func.xml:12922(function)
msgid "corr(<placeholder-1/>, <placeholder-2/>)"
msgstr "corr(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:12931(entry)
msgid "correlation coefficient"
msgstr "коэффициент корреляции"

#: func.xml:12936(indexterm)
msgid "<primary>covariance</primary><secondary>population</secondary>"
msgstr "<primary>ковариация</primary><secondary>совокупности</secondary>"

#: func.xml:12939(indexterm)
msgid "<primary>covar_pop</primary>"
msgstr "<primary>covar_pop</primary>"

#: func.xml:12942(function)
msgid "covar_pop(<placeholder-1/>, <placeholder-2/>)"
msgstr "covar_pop(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:12951(entry)
msgid "population covariance"
msgstr "ковариация совокупности"

#: func.xml:12956(indexterm)
msgid "<primary>covariance</primary><secondary>sample</secondary>"
msgstr "<primary>ковариация</primary><secondary>выборки</secondary>"

#: func.xml:12959(indexterm)
msgid "<primary>covar_samp</primary>"
msgstr "<primary>covar_samp</primary>"

#: func.xml:12962(function)
msgid "covar_samp(<placeholder-1/>, <placeholder-2/>)"
msgstr "covar_samp(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:12971(entry)
msgid "sample covariance"
msgstr "ковариация выборки"

#: func.xml:12976(indexterm)
msgid "<primary>regr_avgx</primary>"
msgstr "<primary>regr_avgx</primary>"

#: func.xml:12979(function)
msgid "regr_avgx(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_avgx(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:12988(entry)
msgid ""
"average of the independent variable (<literal>sum(<replaceable class="
"\"parameter\">X</replaceable>)/<replaceable class=\"parameter\">N</"
"replaceable></literal>)"
msgstr ""
"среднее независимой переменной (<literal>sum(<replaceable class=\"parameter"
"\">X</replaceable>)/<replaceable class=\"parameter\">N</replaceable></"
"literal>)"

#: func.xml:12994(indexterm)
msgid "<primary>regr_avgy</primary>"
msgstr "<primary>regr_avgy</primary>"

#: func.xml:12997(function)
msgid "regr_avgy(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_avgy(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13006(entry)
msgid ""
"average of the dependent variable (<literal>sum(<replaceable class="
"\"parameter\">Y</replaceable>)/<replaceable class=\"parameter\">N</"
"replaceable></literal>)"
msgstr ""
"среднее зависимой переменной (<literal>sum(<replaceable class=\"parameter"
"\">Y</replaceable>)/<replaceable class=\"parameter\">N</replaceable></"
"literal>)"

#: func.xml:13012(indexterm)
msgid "<primary>regr_count</primary>"
msgstr "<primary>regr_count</primary>"

#: func.xml:13015(function)
msgid "regr_count(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_count(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13024(entry)
msgid "number of input rows in which both expressions are nonnull"
msgstr "число входных строк, в которых оба выражения не NULL"

#: func.xml:13029(indexterm)
msgid "<primary>regression intercept</primary>"
msgstr "<primary>пересечение линии регрессии</primary>"

#: func.xml:13032(indexterm)
msgid "<primary>regr_intercept</primary>"
msgstr "<primary>regr_intercept</primary>"

#: func.xml:13035(function)
msgid "regr_intercept(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_intercept(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13044(entry)
msgid ""
"y-intercept of the least-squares-fit linear equation determined by the "
"(<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>) pairs"
msgstr ""
"пересечение с осью OY линии, полученной методом наименьших квадратов по "
"данным (<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>)"

#: func.xml:13052(indexterm)
msgid "<primary>regr_r2</primary>"
msgstr "<primary>regr_r2</primary>"

#: func.xml:13055(function)
msgid "regr_r2(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_r2(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13064(entry)
msgid "square of the correlation coefficient"
msgstr "квадрат коэффициента корреляции"

#: func.xml:13069(indexterm)
msgid "<primary>regression slope</primary>"
msgstr "<primary>наклон линии регрессии</primary>"

#: func.xml:13072(indexterm)
msgid "<primary>regr_slope</primary>"
msgstr "<primary>regr_slope</primary>"

#: func.xml:13075(function)
msgid "regr_slope(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_slope(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13084(entry)
msgid ""
"slope of the least-squares-fit linear equation determined by the "
"(<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>) pairs"
msgstr ""
"наклон линии, полученной методом наименьших квадратов по данным "
"(<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>)"

#: func.xml:13091(indexterm)
msgid "<primary>regr_sxx</primary>"
msgstr "<primary>regr_sxx</primary>"

#: func.xml:13094(function)
msgid "regr_sxx(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_sxx(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13103(entry)
msgid ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">X</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>sum of squares</quote> of "
"the independent variable)"
msgstr ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">X</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>сумма квадратов</quote> "
"независимой переменной)"

#: func.xml:13112(indexterm)
msgid "<primary>regr_sxy</primary>"
msgstr "<primary>regr_sxy</primary>"

#: func.xml:13115(function)
msgid "regr_sxy(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_sxy(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13124(entry)
msgid ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>*<replaceable "
"class=\"parameter\">Y</replaceable>) - sum(<replaceable class=\"parameter"
"\">X</replaceable>) * sum(<replaceable class=\"parameter\">Y</replaceable>)/"
"<replaceable class=\"parameter\">N</replaceable></literal> (<quote>sum of "
"products</quote> of independent times dependent variable)"
msgstr ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>*<replaceable "
"class=\"parameter\">Y</replaceable>) - sum(<replaceable class=\"parameter"
"\">X</replaceable>) * sum(<replaceable class=\"parameter\">Y</replaceable>)/"
"<replaceable class=\"parameter\">N</replaceable></literal> (<quote>сумма "
"произведений</quote> независимых и зависимых переменных)"

#: func.xml:13136(indexterm)
msgid "<primary>regr_syy</primary>"
msgstr "<primary>regr_syy</primary>"

#: func.xml:13139(function)
msgid "regr_syy(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_syy(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13148(entry)
msgid ""
"<literal>sum(<replaceable class=\"parameter\">Y</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">Y</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>sum of squares</quote> of "
"the dependent variable)"
msgstr ""
"<literal>sum(<replaceable class=\"parameter\">Y</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">Y</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>сумма квадратов</quote> "
"зависимой переменной)"

#: func.xml:13157(indexterm)
msgid "<primary>standard deviation</primary>"
msgstr "<primary>стандартное отклонение</primary>"

#: func.xml:13160(indexterm)
msgid "<primary>stddev</primary>"
msgstr "<primary>stddev</primary>"

#: func.xml:13163(function)
msgid "stddev(<placeholder-1/>)"
msgstr "stddev(<placeholder-1/>)"

#: func.xml:13165(entry) func.xml:13188(entry) func.xml:13211(entry)
#: func.xml:13231(entry) func.xml:13254(entry) func.xml:13277(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, or <type>numeric</type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type> или <type>numeric</type>"

#: func.xml:13170(entry) func.xml:13193(entry) func.xml:13216(entry)
#: func.xml:13236(entry) func.xml:13259(entry) func.xml:13282(entry)
msgid ""
"<type>double precision</type> for floating-point arguments, otherwise "
"<type>numeric</type>"
msgstr ""
"<type>double precision</type> для аргументов с плавающей точкой, "
"<type>numeric</type> для остальных"

#: func.xml:13175(entry)
msgid "historical alias for <function>stddev_samp</function>"
msgstr "сохранившийся синоним <function>stddev_samp</function>"

#: func.xml:13180(indexterm)
msgid "<primary>standard deviation</primary><secondary>population</secondary>"
msgstr ""
"<primary>стандартное отклонение</primary><secondary>по совокупности</"
"secondary>"

#: func.xml:13183(indexterm)
msgid "<primary>stddev_pop</primary>"
msgstr "<primary>stddev_pop</primary>"

#: func.xml:13186(function)
msgid "stddev_pop(<placeholder-1/>)"
msgstr "stddev_pop(<placeholder-1/>)"

#: func.xml:13198(entry)
msgid "population standard deviation of the input values"
msgstr "стандартное отклонение по генеральной совокупности входных значений"

#: func.xml:13203(indexterm)
msgid "<primary>standard deviation</primary><secondary>sample</secondary>"
msgstr ""
"<primary>стандартное отклонение</primary><secondary>по выборке</secondary>"

#: func.xml:13206(indexterm)
msgid "<primary>stddev_samp</primary>"
msgstr "<primary>stddev_samp</primary>"

#: func.xml:13209(function)
msgid "stddev_samp(<placeholder-1/>)"
msgstr "stddev_samp(<placeholder-1/>)"

#: func.xml:13221(entry)
msgid "sample standard deviation of the input values"
msgstr "стандартное отклонение по выборке входных значений"

#: func.xml:13226(indexterm)
msgid "<primary>variance</primary>"
msgstr "<primary>дисперсия</primary>"

#: func.xml:13225(entry)
msgid ""
"<placeholder-1/>\n"
"       <function>variance</function>(<replaceable class=\"parameter"
"\">expression</replaceable>)"
msgstr ""
"<placeholder-1/>\n"
"       <function>variance</function>(<replaceable class=\"parameter"
"\">выражение</replaceable>)"

#: func.xml:13241(entry)
msgid "historical alias for <function>var_samp</function>"
msgstr "сохранившийся синоним <function>var_samp</function>"

#: func.xml:13246(indexterm)
msgid "<primary>variance</primary><secondary>population</secondary>"
msgstr "<primary>дисперсия</primary><secondary>для совокупности</secondary>"

#: func.xml:13249(indexterm)
msgid "<primary>var_pop</primary>"
msgstr "<primary>var_pop</primary>"

#: func.xml:13245(entry)
msgid ""
"<placeholder-1/>\n"
"       <placeholder-2/>\n"
"       <function>var_pop</function>(<replaceable class=\"parameter"
"\">expression</replaceable>)"
msgstr ""
"<placeholder-1/>\n"
"       <placeholder-2/>\n"
"       <function>var_pop</function>(<replaceable class=\"parameter"
"\">выражение</replaceable>)"

#: func.xml:13264(entry)
msgid ""
"population variance of the input values (square of the population standard "
"deviation)"
msgstr ""
"дисперсия для генеральной совокупности входных значений (квадрат "
"стандартного отклонения)"

#: func.xml:13269(indexterm)
msgid "<primary>variance</primary><secondary>sample</secondary>"
msgstr "<primary>дисперсия</primary><secondary>по выборке</secondary>"

#: func.xml:13272(indexterm)
msgid "<primary>var_samp</primary>"
msgstr "<primary>var_samp</primary>"

#: func.xml:13268(entry)
msgid ""
"<placeholder-1/>\n"
"       <placeholder-2/>\n"
"       <function>var_samp</function>(<replaceable class=\"parameter"
"\">expression</replaceable>)"
msgstr ""
"<placeholder-1/>\n"
"       <placeholder-2/>\n"
"       <function>var_samp</function>(<replaceable class=\"parameter"
"\">выражение</replaceable>)"

#: func.xml:13287(entry)
msgid ""
"sample variance of the input values (square of the sample standard deviation)"
msgstr ""
"дисперсия по выборке для входных значений (квадрат отклонения по выборке)"

#: func.xml:13293(para)
msgid ""
"<xref linkend=\"functions-orderedset-table\"/> shows some aggregate "
"functions that use the <firstterm>ordered-set aggregate</firstterm> syntax. "
"These functions are sometimes referred to as <quote>inverse distribution</"
"quote> functions."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-orderedset-table\"/> показаны "
"некоторые агрегатные функции, использующие синтаксис <firstterm>сортирующих "
"агрегатных функций</firstterm>. Иногда такие функции функциями называют "
"функциями <quote>обратного распределения</quote>."

#: func.xml:13300(indexterm)
msgid "<primary>ordered-set aggregate</primary><secondary>built-in</secondary>"
msgstr ""
"<primary>сортирующие агрегатные функции</primary><secondary>встроенные</"
"secondary>"

#: func.xml:13303(indexterm)
msgid "<primary>inverse distribution</primary>"
msgstr "<primary>обратное распределение</primary>"

#: func.xml:13308(title)
msgid "Ordered-Set Aggregate Functions"
msgstr "Сортирующие агрегатные функции"

#: func.xml:13314(entry) func.xml:13472(entry)
msgid "Direct Argument Type(s)"
msgstr "Тип непосредственного аргумента"

#: func.xml:13315(entry) func.xml:13473(entry)
msgid "Aggregated Argument Type(s)"
msgstr "Тип агрегированного аргумента"

#: func.xml:13326(indexterm)
msgid "<primary>mode</primary><secondary>statistical</secondary>"
msgstr "<primary>мода</primary><secondary>статистическая функция</secondary>"

#: func.xml:13329(replaceable) func.xml:13354(replaceable)
#: func.xml:13375(replaceable) func.xml:13399(replaceable)
#: func.xml:13419(replaceable)
msgid "sort_expression"
msgstr "выражение_сортировки"

#: func.xml:13329(function)
msgid "mode() WITHIN GROUP (ORDER BY <placeholder-1/>)"
msgstr "mode() WITHIN GROUP (ORDER BY <placeholder-1/>)"

#: func.xml:13333(entry) func.xml:13404(entry) func.xml:13424(entry)
msgid "any sortable type"
msgstr "любой сортируемый тип"

#: func.xml:13336(entry) func.xml:13362(entry) func.xml:13407(entry)
msgid "same as sort expression"
msgstr "тот же, что у выражения сортировки"

#: func.xml:13340(entry)
msgid ""
"returns the most frequent input value (arbitrarily choosing the first one if "
"there are multiple equally-frequent results)"
msgstr ""
"возвращает значение, наиболее часто встречающееся во входных данных (если "
"одинаково часто встречаются несколько значений, произвольно выбирается "
"первое из них)"

#: func.xml:13348(indexterm)
msgid "<primary>percentile</primary><secondary>continuous</secondary>"
msgstr "<primary>перцентиль</primary><secondary>непрерывный</secondary>"

#: func.xml:13351(indexterm)
msgid "<primary>median</primary>"
msgstr "<primary>медиана</primary>"

#: func.xml:13354(replaceable) func.xml:13399(replaceable)
msgid "fraction"
msgstr "дробь"

#: func.xml:13354(function) func.xml:13375(function)
msgid ""
"percentile_cont(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr ""
"percentile_cont(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13359(entry) func.xml:13380(entry)
msgid "<type>double precision</type> or <type>interval</type>"
msgstr "<type>double precision</type> или <type>interval</type>"

#: func.xml:13366(entry)
msgid ""
"continuous percentile: returns a value corresponding to the specified "
"fraction in the ordering, interpolating between adjacent input items if "
"needed"
msgstr ""
"непрерывный перцентиль: возвращает значение, соответствующее заданной дроби "
"по порядку, интерполируя соседние входные значения, если необходимо"

#: func.xml:13375(replaceable) func.xml:13419(replaceable)
msgid "fractions"
msgstr "дроби"

#: func.xml:13378(type) func.xml:13422(type)
msgid "double precision[]"
msgstr "double precision[]"

#: func.xml:13383(entry) func.xml:13427(entry)
msgid "array of sort expression's type"
msgstr "массив типа выражения сортировки"

#: func.xml:13387(entry)
msgid ""
"multiple continuous percentile: returns an array of results matching the "
"shape of the <literal>fractions</literal> parameter, with each non-null "
"element replaced by the value corresponding to that percentile"
msgstr ""
"множественный непрерывный перцентиль: возвращает массив результатов, "
"соответствующих значениям в параметре <literal>дроби</literal> (для каждого "
"элемента не NULL подставляется значение, соответствующее данному перцентилю)"

#: func.xml:13396(indexterm)
msgid "<primary>percentile</primary><secondary>discrete</secondary>"
msgstr "<primary>перцентиль</primary><secondary>дискретный</secondary>"

#: func.xml:13399(function) func.xml:13419(function)
msgid ""
"percentile_disc(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr ""
"percentile_disc(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13411(entry)
msgid ""
"discrete percentile: returns the first input value whose position in the "
"ordering equals or exceeds the specified fraction"
msgstr ""
"дискретный перцентиль: возвращает первое значение из входных данных, позиция "
"которого по порядку равна или превосходит указанную дробь"

#: func.xml:13431(entry)
msgid ""
"multiple discrete percentile: returns an array of results matching the shape "
"of the <literal>fractions</literal> parameter, with each non-null element "
"replaced by the input value corresponding to that percentile"
msgstr ""
"множественный дискретный перцентиль: возвращает массив результатов, "
"соответствующих значениям в параметре <literal>дроби</literal> (для каждого "
"элемента не NULL подставляется входное значение, соответствующее данному "
"перцентилю)"

#: func.xml:13442(para)
msgid ""
"All the aggregates listed in <xref linkend=\"functions-orderedset-table\"/> "
"ignore null values in their sorted input. For those that take a "
"<replaceable>fraction</replaceable> parameter, the fraction value must be "
"between 0 and 1; an error is thrown if not. However, a null fraction value "
"simply produces a null result."
msgstr ""
"Все агрегатные функции, перечисленные в <xref remap=\"6\" linkend="
"\"functions-orderedset-table\"/>, игнорируют значения NULL при сортировке "
"данных. Для функций, принимающих параметр <replaceable>дробь</replaceable>, "
"значение этого параметра должно быть от 0 до 1; в противном случае возникает "
"ошибка. Однако, если в этом параметре передаётся NULL, эти функции просто "
"выдают NULL."

#: func.xml:13450(indexterm)
msgid ""
"<primary>hypothetical-set aggregate</primary><secondary>built-in</secondary>"
msgstr ""
"<primary>гипотезирующие агрегатные функции</primary><secondary>встроенные</"
"secondary>"

#: func.xml:13454(para)
msgid ""
"Each of the aggregates listed in <xref linkend=\"functions-hypothetical-table"
"\"/> is associated with a window function of the same name defined in <xref "
"linkend=\"functions-window\"/>. In each case, the aggregate result is the "
"value that the associated window function would have returned for the "
"<quote>hypothetical</quote> row constructed from <replaceable>args</"
"replaceable>, if such a row had been added to the sorted group of rows "
"computed from the <replaceable>sorted_args</replaceable>."
msgstr ""
"Все агрегатные функции, перечисленные в <xref remap=\"6\" linkend="
"\"functions-hypothetical-table\"/>, связаны с одноимёнными оконными "
"функциями, определёнными в <xref remap=\"6\" linkend=\"functions-window\"/>. "
"В каждом случае их результат &mdash; значение, которое вернула бы связанная "
"оконная функция для <quote>гипотетической</quote> строки, полученной из "
"<replaceable>аргументов</replaceable>, если бы такая строка была добавлена в "
"сортированную группу строк, которую образуют "
"<replaceable>сортированные_аргументы</replaceable>."

#: func.xml:13466(title)
msgid "Hypothetical-Set Aggregate Functions"
msgstr "Гипотезирующие агрегатные функции"

#: func.xml:13484(indexterm)
msgid "<primary>rank</primary><secondary>hypothetical</secondary>"
msgstr "<primary>rank</primary><secondary>гипотезирующая функция</secondary>"

#: func.xml:13487(replaceable) func.xml:13509(replaceable)
#: func.xml:13531(replaceable) func.xml:13553(replaceable)
msgctxt "replaceable"
msgid "args"
msgstr "аргументы"

#: func.xml:13487(replaceable) func.xml:13509(replaceable)
#: func.xml:13531(replaceable) func.xml:13553(replaceable)
msgid "sorted_args"
msgstr "сортированные_аргументы"

#: func.xml:13487(function)
msgid "rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr "rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13490(literal) func.xml:13493(literal) func.xml:13512(literal)
#: func.xml:13515(literal) func.xml:13534(literal) func.xml:13537(literal)
#: func.xml:13556(literal) func.xml:13559(literal)
msgid "VARIADIC"
msgstr "VARIADIC"

#: func.xml:13499(entry)
msgid "rank of the hypothetical row, with gaps for duplicate rows"
msgstr "ранг гипотетической строки, с пропусками повторяющихся строк"

#: func.xml:13506(indexterm)
msgid "<primary>dense_rank</primary><secondary>hypothetical</secondary>"
msgstr ""
"<primary>dense_rank</primary><secondary>гипотезирующая функция</secondary>"

#: func.xml:13509(function)
msgid "dense_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr "dense_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13521(entry)
msgid "rank of the hypothetical row, without gaps"
msgstr "ранг гипотетической строки, без пропусков"

#: func.xml:13528(indexterm)
msgid "<primary>percent_rank</primary><secondary>hypothetical</secondary>"
msgstr ""
"<primary>percent_rank</primary><secondary>гипотезирующая функция</secondary>"

#: func.xml:13531(function)
msgid "percent_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr ""
"percent_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13543(entry)
msgid "relative rank of the hypothetical row, ranging from 0 to 1"
msgstr "относительный ранг гипотетической строки, от 0 до 1"

#: func.xml:13550(indexterm)
msgid "<primary>cume_dist</primary><secondary>hypothetical</secondary>"
msgstr ""
"<primary>cume_dist</primary><secondary>гипотезирующая функция</secondary>"

#: func.xml:13553(function)
msgid "cume_dist(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr "cume_dist(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13565(entry)
msgid ""
"relative rank of the hypothetical row, ranging from 1/<replaceable>N</"
"replaceable> to 1"
msgstr ""
"относительный ранг гипотетической строки, от 1/<replaceable>N</replaceable> "
"до 1"

#: func.xml:13575(para)
msgid ""
"For each of these hypothetical-set aggregates, the list of direct arguments "
"given in <replaceable>args</replaceable> must match the number and types of "
"the aggregated arguments given in <replaceable>sorted_args</replaceable>. "
"Unlike most built-in aggregates, these aggregates are not strict, that is "
"they do not drop input rows containing nulls. Null values sort according to "
"the rule specified in the <literal>ORDER BY</literal> clause."
msgstr ""
"Для всех этих гипотезирующих агрегатных функций непосредственные "
"<replaceable>аргументы</replaceable> должны соответствовать (по количеству и "
"типу) <replaceable>сортированным_аргументам</replaceable>. В отличие от "
"встроенных агрегатных функций, они не являются строгими, то есть не "
"отбрасывают входные строки, содержащие NULL. Значения NULL сортируются "
"согласно правилу, указанному в предложении <literal>ORDER BY</literal>."

#: func.xml:13585(title)
msgid "Grouping Operations"
msgstr "Операции группировки"

#: func.xml:13600(indexterm)
msgid "<primary>GROUPING</primary>"
msgstr "<primary>GROUPING</primary>"

#: func.xml:13603(replaceable)
msgid "args..."
msgstr "аргументы..."

#: func.xml:13603(function)
msgid "GROUPING(<placeholder-1/>)"
msgstr "GROUPING(<placeholder-1/>)"

#: func.xml:13608(entry)
msgid ""
"Integer bit mask indicating which arguments are not being included in the "
"current grouping set"
msgstr ""
"Целочисленная битовая маска, показывающая, какие аргументы не вошли в "
"текущий набор группирования"

#: func.xml:13617(para)
msgid ""
"Grouping operations are used in conjunction with grouping sets (see <xref "
"linkend=\"queries-grouping-sets\"/>) to distinguish result rows. The "
"arguments to the <literal>GROUPING</literal> operation are not actually "
"evaluated, but they must match exactly expressions given in the "
"<literal>GROUP BY</literal> clause of the associated query level. Bits are "
"assigned with the rightmost argument being the least-significant bit; each "
"bit is 0 if the corresponding expression is included in the grouping "
"criteria of the grouping set generating the result row, and 1 if it is not. "
"For example: <screen><prompt>=&gt;</prompt> <userinput>SELECT * FROM "
"items_sold;</userinput>\n"
" make  | model | sales\n"
"-------+-------+-------\n"
" Foo   | GT    |  10\n"
" Foo   | Tour  |  20\n"
" Bar   | City  |  15\n"
" Bar   | Sport |  5\n"
"(4 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), "
"sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>\n"
" make  | model | grouping | sum\n"
"-------+-------+----------+-----\n"
" Foo   | GT    |        0 | 10\n"
" Foo   | Tour  |        0 | 20\n"
" Bar   | City  |        0 | 15\n"
" Bar   | Sport |        0 | 5\n"
" Foo   |       |        1 | 30\n"
" Bar   |       |        1 | 20\n"
"       |       |        3 | 50\n"
"(7 rows)</screen>"
msgstr ""
"Операции группировки применяются в сочетании с наборами группирования (см. "
"<xref remap=\"4\" linkend=\"queries-grouping-sets\"/>) для различения "
"результирующих строк. Аргументы операции <literal>GROUPING</literal> на "
"самом деле не вычисляются, но они должны в точности соответствовать "
"выражениям, заданным в предложении <literal>GROUP BY</literal> на их уровне "
"запроса. Биты назначаются справа налево (правый аргумент отражается в "
"младшем бите); бит равен 0, если соответствующее выражение вошло в критерий "
"группировки набора группирования, для которого сформирована строка "
"результата, или 1 в противном случае. Например: <screen><prompt>=&gt;</"
"prompt> <userinput>SELECT * FROM items_sold;</userinput>\n"
" make  | model | sales\n"
"-------+-------+-------\n"
" Foo   | GT    |  10\n"
" Foo   | Tour  |  20\n"
" Bar   | City  |  15\n"
" Bar   | Sport |  5\n"
"(4 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), "
"sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>\n"
" make  | model | grouping | sum\n"
"-------+-------+----------+-----\n"
" Foo   | GT    |        0 | 10\n"
" Foo   | Tour  |        0 | 20\n"
" Bar   | City  |        0 | 15\n"
" Bar   | Sport |        0 | 5\n"
" Foo   |       |        1 | 30\n"
" Bar   |       |        1 | 20\n"
"       |       |        3 | 50\n"
"(7 rows)</screen>"

#: func.xml:13651(title)
msgid "Window Functions"
msgstr "Оконные функции"

#: func.xml:13653(indexterm)
msgid "<primary>window function</primary><secondary>built-in</secondary>"
msgstr "<primary>оконные функции</primary><secondary>встроенные</secondary>"

#: func.xml:13657(para)
msgid ""
"<firstterm>Window functions</firstterm> provide the ability to perform "
"calculations across sets of rows that are related to the current query row. "
"See <xref linkend=\"tutorial-window\"/> for an introduction to this feature, "
"and <xref linkend=\"syntax-window-functions\"/> for syntax details."
msgstr ""
"<firstterm>Оконные функции</firstterm> дают возможность выполнять вычисления "
"с набором строк, каким-либо образом связанным с текущей строкой запроса. "
"Вводную информацию об этом можно получить в <xref remap=\"6\" linkend="
"\"tutorial-window\"/>, а подробнее узнать о синтаксисе можно в <xref remap="
"\"6\" linkend=\"syntax-window-functions\"/>."

#: func.xml:13665(para)
msgid ""
"The built-in window functions are listed in <xref linkend=\"functions-window-"
"table\"/>. Note that these functions <emphasis>must</emphasis> be invoked "
"using window function syntax; that is an <literal>OVER</literal> clause is "
"required."
msgstr ""
"Встроенные оконные функции перечислены в <xref remap=\"6\" linkend="
"\"functions-window-table\"/>. Заметьте, что эти функции <emphasis>должны</"
"emphasis> вызываться именно как оконные, т. е. при вызове необходимо "
"использовать предложение <literal>OVER</literal>."

#: func.xml:13672(para)
msgid ""
"In addition to these functions, any built-in or user-defined normal "
"aggregate function (but not ordered-set or hypothetical-set aggregates) can "
"be used as a window function; see <xref linkend=\"functions-aggregate\"/> "
"for a list of the built-in aggregates. Aggregate functions act as window "
"functions only when an <literal>OVER</literal> clause follows the call; "
"otherwise they act as regular aggregates."
msgstr ""
"В дополнение к этим функциям в качестве оконных можно использовать любые "
"встроенные или пользовательские обычные (но не сортирующие и не "
"гипотезирующие) агрегатные функции (встроенные функции перечислены в <xref "
"remap=\"6\" linkend=\"functions-aggregate\"/>). Агрегатные функции работают "
"как оконные, только когда за их вызовом следует предложение <literal>OVER</"
"literal>; в противном случае они останутся обычными агрегатными."

#: func.xml:13682(title)
msgid "General-Purpose Window Functions"
msgstr "Оконные функции общего назначения"

#: func.xml:13696(indexterm)
msgid "<primary>row_number</primary>"
msgstr "<primary>row_number</primary>"

#: func.xml:13699(function)
msgid "row_number()"
msgstr "row_number()"

#: func.xml:13704(entry)
msgid "number of the current row within its partition, counting from 1"
msgstr "номер текущей строки в её разделе, начиная с 1"

#: func.xml:13709(indexterm)
msgid "<primary>rank</primary>"
msgstr "<primary>rank</primary>"

#: func.xml:13712(function)
msgid "rank()"
msgstr "rank()"

#: func.xml:13717(entry)
msgid ""
"rank of the current row with gaps; same as <function>row_number</function> "
"of its first peer"
msgstr ""
"ранг текущей строки с пропусками; то же, что и <function>row_number</"
"function> для первой родственной ей строки"

#: func.xml:13722(indexterm)
msgid "<primary>dense_rank</primary>"
msgstr "<primary>dense_rank</primary>"

#: func.xml:13725(function)
msgid "dense_rank()"
msgstr "dense_rank()"

#: func.xml:13730(entry)
msgid "rank of the current row without gaps; this function counts peer groups"
msgstr ""
"ранг текущей строки без пропусков; эта функция считает группы родственных "
"строк"

#: func.xml:13735(indexterm)
msgid "<primary>percent_rank</primary>"
msgstr "<primary>percent_rank</primary>"

#: func.xml:13738(function)
msgid "percent_rank()"
msgstr "percent_rank()"

#: func.xml:13743(entry)
msgid ""
"relative rank of the current row: (<function>rank</function> - 1) / (total "
"rows - 1)"
msgstr ""
"относительный ранг текущей строки: (<function>rank</function> - 1) / (общее "
"число строк - 1)"

#: func.xml:13748(indexterm)
msgid "<primary>cume_dist</primary>"
msgstr "<primary>cume_dist</primary>"

#: func.xml:13751(function)
msgid "cume_dist()"
msgstr "cume_dist()"

#: func.xml:13756(entry)
msgid ""
"relative rank of the current row: (number of rows preceding or peer with "
"current row) / (total rows)"
msgstr ""
"относительный ранг текущей строки: (число строк, предшествующих или "
"родственных текущей) / (общее число строк)"

#: func.xml:13761(indexterm)
msgid "<primary>ntile</primary>"
msgstr "<primary>ntile</primary>"

#: func.xml:13764(replaceable)
msgid "num_buckets"
msgstr "число_групп"

#: func.xml:13764(function)
msgid "ntile(<placeholder-1/> <placeholder-2/>)"
msgstr "ntile(<placeholder-1/> <placeholder-2/>)"

#: func.xml:13769(entry)
msgid ""
"integer ranging from 1 to the argument value, dividing the partition as "
"equally as possible"
msgstr ""
"ранжирование по целым числам от 1 до значения аргумента так, чтобы размеры "
"групп были максимально близки"

#: func.xml:13775(indexterm)
msgid "<primary>lag</primary>"
msgstr "<primary>lag</primary>"

#: func.xml:13780(replaceable) func.xml:13809(replaceable)
msgctxt "replaceable"
msgid "offset"
msgstr "смещение"

#: func.xml:13781(replaceable) func.xml:13810(replaceable)
msgid "default"
msgstr "по_умолчанию"

#: func.xml:13778(function)
msgid ""
"lag(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"
msgstr ""
"lag(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"

#: func.xml:13785(type) func.xml:13814(type) func.xml:13839(type)
#: func.xml:13855(type) func.xml:13873(type)
msgid "same type as <placeholder-1/>"
msgstr "тип аргумента <placeholder-1/>"

#: func.xml:13787(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is <replaceable class=\"parameter\">offset</replaceable> rows "
"before the current row within the partition; if there is no such row, "
"instead return <replaceable class=\"parameter\">default</replaceable> (which "
"must be of the same type as <replaceable class=\"parameter\">value</"
"replaceable>). Both <replaceable class=\"parameter\">offset</replaceable> "
"and <replaceable class=\"parameter\">default</replaceable> are evaluated "
"with respect to the current row. If omitted, <replaceable class=\"parameter"
"\">offset</replaceable> defaults to 1 and <replaceable class=\"parameter"
"\">default</replaceable> to null"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable> для "
"строки, положение которой задаётся <replaceable class=\"parameter"
"\">смещением</replaceable> от текущей строки к началу раздела; если такой "
"строки нет, возвращается значение <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> (оно должно иметь тот же тип, что и "
"<replaceable class=\"parameter\">значение</replaceable>). Оба параметра "
"<replaceable class=\"parameter\">смещение</replaceable> и <replaceable class="
"\"parameter\">по_умолчанию</replaceable> вычисляются для текущей строки. "
"Если они не указываются, то <replaceable class=\"parameter\">смещение</"
"replaceable> считается равным 1, а <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> &mdash; NULL"

#: func.xml:13804(indexterm)
msgid "<primary>lead</primary>"
msgstr "<primary>lead</primary>"

#: func.xml:13807(function)
msgid ""
"lead(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"
msgstr ""
"lead(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"

#: func.xml:13816(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is <replaceable class=\"parameter\">offset</replaceable> rows "
"after the current row within the partition; if there is no such row, instead "
"return <replaceable class=\"parameter\">default</replaceable> (which must be "
"of the same type as <replaceable class=\"parameter\">value</replaceable>). "
"Both <replaceable class=\"parameter\">offset</replaceable> and <replaceable "
"class=\"parameter\">default</replaceable> are evaluated with respect to the "
"current row. If omitted, <replaceable class=\"parameter\">offset</"
"replaceable> defaults to 1 and <replaceable class=\"parameter\">default</"
"replaceable> to null"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable> для "
"строки, положение которой задаётся <replaceable class=\"parameter"
"\">смещением</replaceable> от текущей строки к концу раздела; если такой "
"строки нет, возвращается значение <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> (оно должно иметь тот же тип, что и "
"<replaceable class=\"parameter\">значение</replaceable>). Оба параметра "
"<replaceable class=\"parameter\">смещение</replaceable> и <replaceable class="
"\"parameter\">по_умолчанию</replaceable> вычисляются для текущей строки. "
"Если они не указываются, то <replaceable class=\"parameter\">смещение</"
"replaceable> считается равным 1, а <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> &mdash; NULL"

#: func.xml:13833(indexterm)
msgid "<primary>first_value</primary>"
msgstr "<primary>first_value</primary>"

#: func.xml:13836(function)
msgid "first_value(<placeholder-1/> <placeholder-2/>)"
msgstr "first_value(<placeholder-1/> <placeholder-2/>)"

#: func.xml:13841(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is the first row of the window frame"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable>, "
"вычисленное для первой строки в рамке окна"

#: func.xml:13849(indexterm)
msgid "<primary>last_value</primary>"
msgstr "<primary>last_value</primary>"

#: func.xml:13852(function)
msgid "last_value(<placeholder-1/> <placeholder-2/>)"
msgstr "last_value(<placeholder-1/> <placeholder-2/>)"

#: func.xml:13857(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is the last row of the window frame"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable>, "
"вычисленное для последней строки в рамке окна"

#: func.xml:13865(indexterm)
msgid "<primary>nth_value</primary>"
msgstr "<primary>nth_value</primary>"

#: func.xml:13869(replaceable)
msgid "nth"
msgstr "n"

#: func.xml:13868(function)
msgid ""
"nth_value(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"nth_value(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#: func.xml:13875(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is the <replaceable class=\"parameter\">nth</replaceable> row "
"of the window frame (counting from 1); null if no such row"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable>, "
"вычисленное в <replaceable class=\"parameter\">н-ой</replaceable> строке в "
"рамке окна (считая с 1), или NULL, если такой строки нет"

#: func.xml:13885(para)
msgid ""
"All of the functions listed in <xref linkend=\"functions-window-table\"/> "
"depend on the sort ordering specified by the <literal>ORDER BY</literal> "
"clause of the associated window definition. Rows that are not distinct in "
"the <literal>ORDER BY</literal> ordering are said to be <firstterm>peers</"
"firstterm>; the four ranking functions are defined so that they give the "
"same answer for any two peer rows."
msgstr ""
"Результат всех функций, перечисленных в <xref remap=\"6\" linkend="
"\"functions-window-table\"/>, зависит от порядка сортировки, заданного "
"предложением <literal>ORDER BY</literal> в определении соответствующего "
"окна. Строки, которые являются одинаковыми с точки зрения сортировки "
"<literal>ORDER BY</literal>, считаются <firstterm>родственными</firstterm>; "
"четыре функции, вычисляющие ранг, реализованы так, что их результат будет "
"одинаковым для любых двух родственных строк."

#: func.xml:13894(para)
msgid ""
"Note that <function>first_value</function>, <function>last_value</function>, "
"and <function>nth_value</function> consider only the rows within the "
"<quote>window frame</quote>, which by default contains the rows from the "
"start of the partition through the last peer of the current row. This is "
"likely to give unhelpful results for <function>last_value</function> and "
"sometimes also <function>nth_value</function>. You can redefine the frame by "
"adding a suitable frame specification (<literal>RANGE</literal> or "
"<literal>ROWS</literal>) to the <literal>OVER</literal> clause. See <xref "
"linkend=\"syntax-window-functions\"/> for more information about frame "
"specifications."
msgstr ""
"Заметьте, что функции <function>first_value</function>, "
"<function>last_value</function> и <function>nth_value</function> "
"рассматривают только строки в <quote>рамке окна</quote>, которая по "
"умолчанию содержит строки от начала раздела до последней родственной строки "
"для текущей. Поэтому результаты <function>last_value</function> и иногда "
"<function>nth_value</function> могут быть не очень полезны. В таких случаях "
"можно переопределить рамку, добавив в предложение <literal>OVER</literal> "
"подходящее указание (<literal>RANGE</literal> или <literal>ROWS</literal>). "
"Подробнее эти указания описаны в <xref remap=\"6\" linkend=\"syntax-window-"
"functions\"/>."

#: func.xml:13907(para)
msgid ""
"When an aggregate function is used as a window function, it aggregates over "
"the rows within the current row's window frame. An aggregate used with "
"<literal>ORDER BY</literal> and the default window frame definition produces "
"a <quote>running sum</quote> type of behavior, which may or may not be "
"what's wanted. To obtain aggregation over the whole partition, omit "
"<literal>ORDER BY</literal> or use <literal>ROWS BETWEEN UNBOUNDED PRECEDING "
"AND UNBOUNDED FOLLOWING</literal>. Other frame specifications can be used to "
"obtain other effects."
msgstr ""
"Когда в качестве оконной функции используется агрегатная, она обрабатывает "
"строки в рамке текущей строки. Агрегатная функция с <literal>ORDER BY</"
"literal> и определением рамки окна по умолчанию будет вычисляться как "
"<quote>бегущая сумма</quote>, что может не соответствовать желаемому "
"результату. Чтобы агрегатная функция работала со всем разделом, следует "
"опустить <literal>ORDER BY</literal> или использовать <literal>ROWS BETWEEN "
"UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>. Используя другие "
"указания в определении рамки, можно получить и другие эффекты."

#: func.xml:13919(para)
msgid ""
"The SQL standard defines a <literal>RESPECT NULLS</literal> or "
"<literal>IGNORE NULLS</literal> option for <function>lead</function>, "
"<function>lag</function>, <function>first_value</function>, "
"<function>last_value</function>, and <function>nth_value</function>. This is "
"not implemented in <productname>PostgreSQL</productname>: the behavior is "
"always the same as the standard's default, namely <literal>RESPECT NULLS</"
"literal>. Likewise, the standard's <literal>FROM FIRST</literal> or "
"<literal>FROM LAST</literal> option for <function>nth_value</function> is "
"not implemented: only the default <literal>FROM FIRST</literal> behavior is "
"supported. (You can achieve the result of <literal>FROM LAST</literal> by "
"reversing the <literal>ORDER BY</literal> ordering.)"
msgstr ""
"В стандарте SQL определены параметры <literal>RESPECT NULLS</literal> или "
"<literal>IGNORE NULLS</literal> для функций <function>lead</function>, "
"<function>lag</function>, <function>first_value</function>, "
"<function>last_value</function> и <function>nth_value</function>. В "
"<productname>PostgreSQL</productname> такие параметры не реализованы: эти "
"функции ведут себя так, как положено в стандарте по умолчанию (или с "
"подразумеваемым параметром <literal>RESPECT NULLS</literal>). Также функция "
"<function>nth_value</function> не поддерживает предусмотренные стандартом "
"параметры <literal>FROM FIRST</literal> и <literal>FROM LAST</literal>: "
"реализовано только поведение по умолчанию (с подразумеваемым параметром "
"<literal>FROM FIRST</literal>). (Получить эффект параметра <literal>FROM "
"LAST</literal> можно, изменив порядок <literal>ORDER BY</literal> на "
"обратный.)"

#: func.xml:13937(title)
msgid "Subquery Expressions"
msgstr "Выражения подзапросов"

#: func.xml:13939(indexterm)
msgid "<primary>EXISTS</primary>"
msgstr "<primary>EXISTS</primary>"

#: func.xml:13943(indexterm) func.xml:14267(indexterm)
msgid "<primary>IN</primary>"
msgstr "<primary>IN</primary>"

#: func.xml:13947(indexterm) func.xml:14271(indexterm)
msgid "<primary>NOT IN</primary>"
msgstr "<primary>NOT IN</primary>"

#: func.xml:13955(indexterm) func.xml:14279(indexterm)
msgid "<primary>ALL</primary>"
msgstr "<primary>ALL</primary>"

#: func.xml:13963(indexterm)
msgid "<primary>subquery</primary>"
msgstr "<primary>подзапрос</primary>"

#: func.xml:13967(para)
msgid ""
"This section describes the <acronym>SQL</acronym>-compliant subquery "
"expressions available in <productname>PostgreSQL</productname>. All of the "
"expression forms documented in this section return Boolean (true/false) "
"results."
msgstr ""
"В этом разделе описаны выражения подзапросов, которые реализованы в "
"<productname>PostgreSQL</productname> в соответствии со стандартом "
"<acronym>SQL</acronym>. Все рассмотренные здесь формы выражений возвращает "
"булевы значения (true/false)."

#: func.xml:13975(literal)
msgid "EXISTS"
msgstr "EXISTS"

#: func.xml:13977(replaceable) func.xml:14023(replaceable)
#: func.xml:14047(replaceable) func.xml:14075(replaceable)
#: func.xml:14099(replaceable) func.xml:14127(replaceable)
#: func.xml:14128(replaceable) func.xml:14159(replaceable)
#: func.xml:14160(replaceable) func.xml:14188(replaceable)
#: func.xml:14212(replaceable) func.xml:14244(replaceable)
msgid "subquery"
msgstr "подзапрос"

#: func.xml:13977(synopsis)
#, no-wrap
msgid "EXISTS (<placeholder-1/>)"
msgstr "EXISTS (<placeholder-1/>)"

#: func.xml:13979(para)
msgid ""
"The argument of <token>EXISTS</token> is an arbitrary <command>SELECT</"
"command> statement, or <firstterm>subquery</firstterm>. The subquery is "
"evaluated to determine whether it returns any rows. If it returns at least "
"one row, the result of <token>EXISTS</token> is <quote>true</quote>; if the "
"subquery returns no rows, the result of <token>EXISTS</token> is "
"<quote>false</quote>."
msgstr ""
"Аргументом <token>EXISTS</token> является обычный оператор <command>SELECT</"
"command>, т. е. <firstterm>подзапрос</firstterm>. Выполнив запрос, система "
"проверяет, возвращает ли он строки в результате. Если он возвращает минимум "
"одну строку, результатом <token>EXISTS</token> будет <quote>true</quote>, а "
"если не возвращает ни одной &mdash; <quote>false</quote>."

#: func.xml:13988(para)
msgid ""
"The subquery can refer to variables from the surrounding query, which will "
"act as constants during any one evaluation of the subquery."
msgstr ""
"Подзапрос может обращаться к переменным внешнего запроса, которые в рамках "
"одного вычисления подзапроса считаются константами."

#: func.xml:13993(para)
msgid ""
"The subquery will generally only be executed long enough to determine "
"whether at least one row is returned, not all the way to completion. It is "
"unwise to write a subquery that has side effects (such as calling sequence "
"functions); whether the side effects occur might be unpredictable."
msgstr ""
"Вообще говоря, подзапрос может выполняться не полностью, а завершаться, как "
"только будет возвращена хотя бы одна строка. Поэтому в подзапросах следует "
"избегать побочных эффектов (например, обращений к генераторам "
"последовательностей); проявление побочного эффекта может быть "
"непредсказуемым."

#: func.xml:14001(para)
msgid ""
"Since the result depends only on whether any rows are returned, and not on "
"the contents of those rows, the output list of the subquery is normally "
"unimportant. A common coding convention is to write all <literal>EXISTS</"
"literal> tests in the form <literal>EXISTS(SELECT 1 WHERE ...)</literal>. "
"There are exceptions to this rule however, such as subqueries that use "
"<token>INTERSECT</token>."
msgstr ""
"Так как результат этого выражения зависит только от того, возвращаются "
"строки или нет, но не от их содержимого, список выходных значений подзапроса "
"обычно не имеет значения. Как следствие, широко распространена практика, "
"когда проверки <literal>EXISTS</literal> записываются в форме "
"<literal>EXISTS(SELECT 1 WHERE ...)</literal>. Однако из этого правила есть "
"и исключения, например с подзапросами с предложением <token>INTERSECT</"
"token>."

#: func.xml:14010(para)
msgid ""
"This simple example is like an inner join on <literal>col2</literal>, but it "
"produces at most one output row for each <literal>tab1</literal> row, even "
"if there are several matching <literal>tab2</literal> rows: <screen>SELECT "
"col1\n"
"FROM tab1\n"
"WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);</screen>"
msgstr ""
"Этот простой пример похож на внутреннее соединение по столбцу <literal>col2</"
"literal>, но он выдаёт максимум одну строку для каждой строки в "
"<literal>tab1</literal>, даже если в <literal>tab2</literal> ей "
"соответствуют несколько строк: <screen>SELECT col1\n"
"FROM tab1\n"
"WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);</screen>"

#: func.xml:14021(literal) func.xml:14324(literal)
msgid "IN"
msgstr "IN"

#: func.xml:14023(synopsis) func.xml:14047(synopsis)
#, no-wrap
msgid "<placeholder-1/> IN (<placeholder-2/>)"
msgstr "<placeholder-1/> IN (<placeholder-2/>)"

#: func.xml:14025(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result. The result of <token>IN</token> is <quote>true</"
"quote> if any equal subquery row is found. The result is <quote>false</"
"quote> if no equal row is found (including the case where the subquery "
"returns no rows)."
msgstr ""
"В правой стороне этого выражения в скобках задаётся подзапрос, который "
"должен возвращать ровно один столбец. Вычисленное значение левого выражения "
"сравнивается со значениями во всех строках, возвращённых подзапросом. "
"Результатом всего выражения <token>IN</token> будет <quote>true</quote>, "
"если строка с таким значением находится, и <quote>false</quote> в противном "
"случае (в том числе, когда подзапрос вообще не возвращает строк)."

#: func.xml:14034(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand row yields null, the result of "
"the <token>IN</token> construct will be null, not false. This is in "
"accordance with SQL's normal rules for Boolean combinations of null values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>IN</token> возвращает NULL, а не false. Это соответствует "
"принятым в SQL правилам сравнения переменных со значениями NULL."

#: func.xml:14042(para) func.xml:14094(para) func.xml:14154(para)
#: func.xml:14207(para)
msgid ""
"As with <token>EXISTS</token>, it's unwise to assume that the subquery will "
"be evaluated completely."
msgstr ""
"Так же, как и с <token>EXISTS</token>, здесь не следует рассчитывать на то, "
"что подзапрос будет всегда выполняться полностью."

#: func.xml:14047(replaceable) func.xml:14099(replaceable)
#: func.xml:14159(replaceable) func.xml:14160(replaceable)
#: func.xml:14212(replaceable) func.xml:14244(replaceable)
#: func.xml:14455(replaceable) func.xml:14513(replaceable)
#: func.xml:14523(replaceable)
msgid "row_constructor"
msgstr "конструктор_строки"

#: func.xml:14049(para)
msgid ""
"The left-hand side of this form of <token>IN</token> is a row constructor, "
"as described in <xref linkend=\"sql-syntax-row-constructors\"/>. The right-"
"hand side is a parenthesized subquery, which must return exactly as many "
"columns as there are expressions in the left-hand row. The left-hand "
"expressions are evaluated and compared row-wise to each row of the subquery "
"result. The result of <token>IN</token> is <quote>true</quote> if any equal "
"subquery row is found. The result is <quote>false</quote> if no equal row is "
"found (including the case where the subquery returns no rows)."
msgstr ""
"В левой части этой формы <token>IN</token> записывается конструктор строки "
"(подробнее они рассматриваются в <xref remap=\"6\" linkend=\"sql-syntax-row-"
"constructors\"/>). Справа в скобках записывается подзапрос, который должен "
"вернуть ровно столько столбцов, сколько содержит строка в выражении слева. "
"Вычисленные значения левого выражения сравниваются построчно со значениями "
"во всех строках, возвращённых подзапросом. Результатом всего выражения "
"<token>IN</token> будет <quote>true</quote>, если строка с такими значениями "
"находится, и <quote>false</quote> в противном случае (в том числе, когда "
"подзапрос вообще не возвращает строк)."

#: func.xml:14061(para)
msgid ""
"As usual, null values in the rows are combined per the normal rules of SQL "
"Boolean expressions. Two rows are considered equal if all their "
"corresponding members are non-null and equal; the rows are unequal if any "
"corresponding members are non-null and unequal; otherwise the result of that "
"row comparison is unknown (null). If all the per-row results are either "
"unequal or null, with at least one null, then the result of <token>IN</"
"token> is null."
msgstr ""
"Как обычно, значения NULL в строках обрабатываются при этом по принятым в "
"SQL правилам сравнения. Две строки считаются равными, если все их "
"соответствующие элементы не равны NULL, но равны между собой; неравными они "
"считаются, когда в них находятся элементы, не равные NULL, и не равные друг "
"другу; в противном случае результат сравнения строк не определён (равен "
"NULL). Если в результатах сравнения строк нет ни одного положительного, но "
"есть хотя бы один NULL, результатом <token>IN</token> будет NULL."

#: func.xml:14073(literal) func.xml:14351(literal)
msgid "NOT IN"
msgstr "NOT IN"

#: func.xml:14075(synopsis) func.xml:14099(synopsis)
#, no-wrap
msgid "<placeholder-1/> NOT IN (<placeholder-2/>)"
msgstr "<placeholder-1/> NOT IN (<placeholder-2/>)"

#: func.xml:14077(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result. The result of <token>NOT IN</token> is <quote>true</"
"quote> if only unequal subquery rows are found (including the case where the "
"subquery returns no rows). The result is <quote>false</quote> if any equal "
"row is found."
msgstr ""
"Справа в скобках записывается подзапрос, который должен возвращать ровно "
"один столбец. Вычисленное значение левого выражения сравнивается со "
"значением во всех строках, возвращённых подзапросом. Результатом всего "
"выражения <token>NOT IN</token> будет <quote>true</quote>, если находятся "
"только несовпадающие строки (в том числе, когда подзапрос вообще не "
"возвращает строк). Если же находится хотя бы одна подходящая строка, "
"результатом будет <quote>false</quote>."

#: func.xml:14086(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand row yields null, the result of "
"the <token>NOT IN</token> construct will be null, not true. This is in "
"accordance with SQL's normal rules for Boolean combinations of null values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>NOT IN</token> возвращает NULL, а не true. Это "
"соответствует принятым в SQL правилам сравнения переменных со значениями "
"NULL."

#: func.xml:14101(para)
msgid ""
"The left-hand side of this form of <token>NOT IN</token> is a row "
"constructor, as described in <xref linkend=\"sql-syntax-row-constructors\"/"
">. The right-hand side is a parenthesized subquery, which must return "
"exactly as many columns as there are expressions in the left-hand row. The "
"left-hand expressions are evaluated and compared row-wise to each row of the "
"subquery result. The result of <token>NOT IN</token> is <quote>true</quote> "
"if only unequal subquery rows are found (including the case where the "
"subquery returns no rows). The result is <quote>false</quote> if any equal "
"row is found."
msgstr ""
"В левой части этой формы <token>NOT IN</token> записывается конструктор "
"строки (подробнее они описываются в <xref remap=\"6\" linkend=\"sql-syntax-"
"row-constructors\"/>). Справа в скобках записывается подзапрос, который "
"должен вернуть ровно столько столбцов, сколько содержит строка в выражении "
"слева. Вычисленные значения левого выражения сравниваются построчно со "
"значениями во всех строках, возвращённых подзапросом. Результатом всего "
"выражения <token>NOT IN</token> будет <quote>true</quote>, если равных строк "
"не найдётся (в том числе, и когда подзапрос не возвращает строк), и "
"<quote>false</quote>, если такие строки есть."

#: func.xml:14113(para)
msgid ""
"As usual, null values in the rows are combined per the normal rules of SQL "
"Boolean expressions. Two rows are considered equal if all their "
"corresponding members are non-null and equal; the rows are unequal if any "
"corresponding members are non-null and unequal; otherwise the result of that "
"row comparison is unknown (null). If all the per-row results are either "
"unequal or null, with at least one null, then the result of <token>NOT IN</"
"token> is null."
msgstr ""
"Как обычно, значения NULL в строках обрабатываются при этом по принятым в "
"SQL правилам сравнения. Две строки считаются равными, если все их "
"соответствующие элементы не равны NULL, но равны между собой; неравными они "
"считаются, когда в них находятся элементы, не равные NULL, и не равные друг "
"другу; в противном случае результат сравнения строк не определён (равен "
"NULL). Если в результатах сравнения строк нет ни одного положительного, но "
"есть хотя бы один NULL, результатом <token>NOT IN</token> будет NULL."

#: func.xml:14125(title)
msgid "<literal>ANY</literal>/<literal>SOME</literal>"
msgstr "<literal>ANY</literal>/<literal>SOME</literal>"

#: func.xml:14127(replaceable) func.xml:14128(replaceable)
#: func.xml:14159(replaceable) func.xml:14160(replaceable)
#: func.xml:14188(replaceable) func.xml:14212(replaceable)
#: func.xml:14244(replaceable) func.xml:14390(replaceable)
#: func.xml:14391(replaceable) func.xml:14425(replaceable)
#: func.xml:14455(replaceable) func.xml:14538(replaceable)
msgid "operator"
msgstr "оператор"

#: func.xml:14127(synopsis) func.xml:14159(synopsis) func.xml:14390(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> <placeholder-2/> ANY (<placeholder-3/>)\n"
"<placeholder-4/> <placeholder-5/> SOME (<placeholder-6/>)"
msgstr ""
"<placeholder-1/> <placeholder-2/> ANY (<placeholder-3/>)\n"
"<placeholder-4/> <placeholder-5/> SOME (<placeholder-6/>)"

#: func.xml:14130(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result using the given <replaceable>operator</replaceable>, "
"which must yield a Boolean result. The result of <token>ANY</token> is "
"<quote>true</quote> if any true result is obtained. The result is "
"<quote>false</quote> if no true result is found (including the case where "
"the subquery returns no rows)."
msgstr ""
"В правой части конструкции в скобках записывается подзапрос, который должен "
"возвращать ровно один столбец. Вычисленное значение левого выражения "
"сравнивается со значением в каждой строке результата подзапроса с помощью "
"заданного <replaceable>оператора</replaceable> условия, который должен "
"выдавать логическое значение. Результатом <token>ANY</token> будет "
"<quote>true</quote>, если хотя бы для одной строки условие истинно, и "
"<quote>false</quote> в противном случае (в том числе, и когда подзапрос не "
"возвращает строк)."

#: func.xml:14141(para)
msgid ""
"<token>SOME</token> is a synonym for <token>ANY</token>. <token>IN</token> "
"is equivalent to <literal>= ANY</literal>."
msgstr ""
"Ключевое слово <token>SOME</token> является синонимом <token>ANY</token>. "
"Конструкцию <token>IN</token> можно записать также записать как <literal>= "
"ANY</literal>."

#: func.xml:14146(para)
msgid ""
"Note that if there are no successes and at least one right-hand row yields "
"null for the operator's result, the result of the <token>ANY</token> "
"construct will be null, not false. This is in accordance with SQL's normal "
"rules for Boolean combinations of null values."
msgstr ""
"Заметьте, что если условие не выполняется ни для одной из строк, а хотя бы "
"для одной строки условный оператор выдаёт NULL, конструкция <token>ANY</"
"token> возвращает NULL, а не false. Это соответствует принятым в SQL "
"правилам сравнения переменных со значениями NULL."

#: func.xml:14162(para)
msgid ""
"The left-hand side of this form of <token>ANY</token> is a row constructor, "
"as described in <xref linkend=\"sql-syntax-row-constructors\"/>. The right-"
"hand side is a parenthesized subquery, which must return exactly as many "
"columns as there are expressions in the left-hand row. The left-hand "
"expressions are evaluated and compared row-wise to each row of the subquery "
"result, using the given <replaceable>operator</replaceable>. The result of "
"<token>ANY</token> is <quote>true</quote> if the comparison returns true for "
"any subquery row. The result is <quote>false</quote> if the comparison "
"returns false for every subquery row (including the case where the subquery "
"returns no rows). The result is NULL if the comparison does not return true "
"for any row, and it returns NULL for at least one row."
msgstr ""
"В левой части этой формы <token>ANY</token> записывается конструктор строки "
"(подробнее они описываются в <xref remap=\"6\" linkend=\"sql-syntax-row-"
"constructors\"/>). Справа в скобках записывается подзапрос, который должен "
"возвращать ровно столько столбцов, сколько содержит строка в выражении "
"слева. Вычисленные значения левого выражения сравниваются построчно со "
"значениями во всех строках, возвращённых подзапросом, с применением "
"заданного <replaceable>оператора</replaceable>. Результатом всего выражения "
"<token>ANY</token> будет <quote>true</quote>, если для какой-либо из строк "
"результатом сравнения будет true, и <quote>false</quote>, если для всех "
"строк результатом сравнения оказывается false (в том числе, и когда "
"подзапрос не возвращает строк). Результат будет равен NULL, если сравнение "
"не возвращает true ни для одной из строк, но как минимум для одной результат "
"сравнения NULL."

#: func.xml:14179(para) func.xml:14231(para) func.xml:14256(para)
msgid ""
"See <xref linkend=\"row-wise-comparison\"/> for details about the meaning of "
"a row constructor comparison."
msgstr ""
"Подробнее логика сравнения конструкторов строк описана в <xref remap=\"6\" "
"linkend=\"row-wise-comparison\"/>."

#: func.xml:14186(literal)
msgid "ALL"
msgstr "ALL"

#: func.xml:14188(synopsis) func.xml:14212(synopsis) func.xml:14425(synopsis)
#, no-wrap
msgid "<placeholder-1/> <placeholder-2/> ALL (<placeholder-3/>)"
msgstr "<placeholder-1/> <placeholder-2/> ALL (<placeholder-3/>)"

#: func.xml:14190(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result using the given <replaceable>operator</replaceable>, "
"which must yield a Boolean result. The result of <token>ALL</token> is "
"<quote>true</quote> if all rows yield true (including the case where the "
"subquery returns no rows). The result is <quote>false</quote> if any false "
"result is found. The result is NULL if the comparison does not return false "
"for any row, and it returns NULL for at least one row."
msgstr ""
"В правой части конструкции в скобках записывается подзапрос, который должен "
"возвращать ровно один столбец. Вычисленное значение левого выражения "
"сравнивается со значением в каждой строке результата подзапроса с помощью "
"заданного <replaceable>оператора</replaceable> условия, который должен "
"выдавать логическое значение. Результатом <token>ALL</token> будет "
"<quote>true</quote>, если условие истинно для всех строк (и когда подзапрос "
"не возвращает строк), и <quote>false</quote>, если находятся строки, для "
"которых оно ложно. Результат будет равен NULL, если сравнение не возвращает "
"false ни для одной из строк, но как минимум для одной результат сравнения "
"NULL."

#: func.xml:14203(para)
msgid "<token>NOT IN</token> is equivalent to <literal>&lt;&gt; ALL</literal>."
msgstr ""
"Конструкция <token>NOT IN</token> равнозначна <literal>&lt;&gt; ALL</"
"literal>."

#: func.xml:14214(para)
msgid ""
"The left-hand side of this form of <token>ALL</token> is a row constructor, "
"as described in <xref linkend=\"sql-syntax-row-constructors\"/>. The right-"
"hand side is a parenthesized subquery, which must return exactly as many "
"columns as there are expressions in the left-hand row. The left-hand "
"expressions are evaluated and compared row-wise to each row of the subquery "
"result, using the given <replaceable>operator</replaceable>. The result of "
"<token>ALL</token> is <quote>true</quote> if the comparison returns true for "
"all subquery rows (including the case where the subquery returns no rows). "
"The result is <quote>false</quote> if the comparison returns false for any "
"subquery row. The result is NULL if the comparison does not return false for "
"any subquery row, and it returns NULL for at least one row."
msgstr ""
"В левой части этой формы <token>ALL</token> записывается конструктор строки "
"(подробнее они описываются в <xref remap=\"6\" linkend=\"sql-syntax-row-"
"constructors\"/>). Справа в скобках записывается подзапрос, который должен "
"возвращать ровно столько столбцов, сколько содержит строка в выражении "
"слева. Вычисленные значения левого выражения сравниваются построчно со "
"значениями во всех строках, возвращённых подзапросом, с применением "
"заданного <replaceable>оператора</replaceable>. Результатом всего выражения "
"<token>ALL</token> будет <quote>true</quote>, если для всех строк подзапроса "
"результатом сравнения будет true (или если подзапрос не возвращает строк), и "
"<quote>false</quote>, если результат сравнения равен false для любой из "
"строк подзапроса. Результат будет равен NULL, если сравнение не возвращает "
"false ни для одной из строк, но как минимум для одной результат сравнения "
"NULL."

#: func.xml:14238(title)
msgid "Single-row Comparison"
msgstr "Сравнение единичных строк"

#: func.xml:14240(indexterm)
msgid "<primary>comparison</primary><secondary>subquery result row</secondary>"
msgstr ""
"<primary>сравнение</primary><secondary>со строкой-результатом подзапроса</"
"secondary>"

#: func.xml:14244(synopsis)
#, no-wrap
msgid "<placeholder-1/> <placeholder-2/> (<placeholder-3/>)"
msgstr "<placeholder-1/> <placeholder-2/> (<placeholder-3/>)"

#: func.xml:14246(para)
msgid ""
"The left-hand side is a row constructor, as described in <xref linkend=\"sql-"
"syntax-row-constructors\"/>. The right-hand side is a parenthesized "
"subquery, which must return exactly as many columns as there are expressions "
"in the left-hand row. Furthermore, the subquery cannot return more than one "
"row. (If it returns zero rows, the result is taken to be null.) The left-"
"hand side is evaluated and compared row-wise to the single subquery result "
"row."
msgstr ""
"В левой части конструкции записывается конструктор строки (подробнее они "
"описываются в <xref remap=\"6\" linkend=\"sql-syntax-row-constructors\"/>). "
"Справа в скобках записывается подзапрос, который должен возвращать ровно "
"столько столбцов, сколько содержит строка в выражении слева. Более того, "
"подзапрос может вернуть максимум одну строку. (Если он не вернёт строк, "
"результатом будет NULL.) Конструкция возвращает результат сравнения строки "
"слева с этой одной строкой результата подзапроса."

#: func.xml:14265(title)
msgid "Row and Array Comparisons"
msgstr "Сравнение табличных строк и массивов"

#: func.xml:14287(indexterm)
msgid "<primary>composite type</primary><secondary>comparison</secondary>"
msgstr "<primary>составной тип</primary><secondary>сравнение</secondary>"

#: func.xml:14291(indexterm)
msgid "<primary>row-wise comparison</primary>"
msgstr "<primary>сравнение табличных строк</primary>"

#: func.xml:14295(indexterm)
msgid "<primary>comparison</primary><secondary>composite type</secondary>"
msgstr "<primary>сравнение</primary><secondary>составных типов</secondary>"

#: func.xml:14299(indexterm)
msgid "<primary>comparison</primary><secondary>row constructor</secondary>"
msgstr "<primary>сравнение</primary><secondary>конструкторов строк</secondary>"

#: func.xml:14311(para)
msgid ""
"This section describes several specialized constructs for making multiple "
"comparisons between groups of values. These forms are syntactically related "
"to the subquery forms of the previous section, but do not involve "
"subqueries. The forms involving array subexpressions are "
"<productname>PostgreSQL</productname> extensions; the rest are <acronym>SQL</"
"acronym>-compliant. All of the expression forms documented in this section "
"return Boolean (true/false) results."
msgstr ""
"В этом разделе описываются несколько специальных конструкций, позволяющих "
"сравнивать группы значений. Синтаксис этих конструкций связан с формами "
"выражений с подзапросами, описанными в предыдущем разделе, а отличаются они "
"отсутствием подзапросов. Конструкции, в которых в качестве подвыражений "
"используются массивы, являются расширениями <productname>PostgreSQL</"
"productname>; все остальные формы соответствуют стандарту <acronym>SQL</"
"acronym>. Все описанные здесь выражения возвращают логические значения (true/"
"false)."

#: func.xml:14326(synopsis)
#, no-wrap
msgid "<placeholder-1/> IN (<placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/> IN (<placeholder-2/> <placeholder-3/>)"

#: func.xml:14328(para)
msgid ""
"The right-hand side is a parenthesized list of scalar expressions. The "
"result is <quote>true</quote> if the left-hand expression's result is equal "
"to any of the right-hand expressions. This is a shorthand notation for "
"<synopsis><replaceable>expression</replaceable> = <replaceable>value1</"
"replaceable>\n"
"OR\n"
"<replaceable>expression</replaceable> = <replaceable>value2</replaceable>\n"
"OR\n"
"...</synopsis>"
msgstr ""
"Справа в скобках записывается список скалярных выражений. Результатом будет "
"<quote>true</quote>, если значение левого выражения равняется одному из "
"значений выражений в правой части. Эту конструкцию можно считать краткой "
"записью условия <synopsis><replaceable>выражение</replaceable> = "
"<replaceable>значение1</replaceable>\n"
"OR\n"
"<replaceable>выражение</replaceable> = <replaceable>значение2</replaceable>\n"
"OR\n"
"...</synopsis>"

#: func.xml:14341(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand expression yields null, the "
"result of the <token>IN</token> construct will be null, not false. This is "
"in accordance with SQL's normal rules for Boolean combinations of null "
"values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>IN</token> возвращает NULL, а не false. Это соответствует "
"принятым в SQL правилам сравнения переменных со значениями NULL."

#: func.xml:14353(synopsis)
#, no-wrap
msgid "<placeholder-1/> NOT IN (<placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/> NOT IN (<placeholder-2/> <placeholder-3/>)"

#: func.xml:14355(para)
msgid ""
"The right-hand side is a parenthesized list of scalar expressions. The "
"result is <quote>true</quote> if the left-hand expression's result is "
"unequal to all of the right-hand expressions. This is a shorthand notation "
"for <synopsis><replaceable>expression</replaceable> &lt;&gt; "
"<replaceable>value1</replaceable>\n"
"AND\n"
"<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</"
"replaceable>\n"
"AND\n"
"...</synopsis>"
msgstr ""
"Справа в скобках записывается список скалярных выражений. Результатом будет "
"<quote>true</quote>, если значение левого выражения не равно ни одному из "
"значений выражений в правой части. Эту конструкцию можно считать краткой "
"записью условия <synopsis><replaceable>выражение</replaceable> &lt;&gt; "
"<replaceable>значение1</replaceable>\n"
"AND\n"
"<replaceable>выражение</replaceable> &lt;&gt; <replaceable>значение2</"
"replaceable>\n"
"AND\n"
"...</synopsis>"

#: func.xml:14368(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand expression yields null, the "
"result of the <token>NOT IN</token> construct will be null, not true as one "
"might naively expect. This is in accordance with SQL's normal rules for "
"Boolean combinations of null values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>NOT IN</token> возвращает NULL, а не true, как можно было "
"бы наивно полагать. Это соответствует принятым в SQL правилам сравнения "
"переменных со значениями NULL."

#: func.xml:14378(para)
msgid ""
"<literal>x NOT IN y</literal> is equivalent to <literal>NOT (x IN y)</"
"literal> in all cases. However, null values are much more likely to trip up "
"the novice when working with <token>NOT IN</token> than when working with "
"<token>IN</token>. It is best to express your condition positively if "
"possible."
msgstr ""
"Выражения <literal>x NOT IN y</literal> и <literal>NOT (x IN y)</literal> "
"полностью равнозначны. Учитывая, что значения NULL могут ввести в "
"заблуждение начинающих скорее в конструкции <token>NOT IN</token>, чем в "
"<token>IN</token>, лучше формулировать условия так, чтобы в них было как "
"можно меньше отрицаний."

#: func.xml:14388(title)
msgid "<literal>ANY</literal>/<literal>SOME</literal> (array)"
msgstr "<literal>ANY</literal>/<literal>SOME</literal> (с массивом)"

#: func.xml:14390(replaceable) func.xml:14391(replaceable)
#: func.xml:14425(replaceable)
msgid "array expression"
msgstr "выражение массива"

#: func.xml:14393(para)
msgid ""
"The right-hand side is a parenthesized expression, which must yield an array "
"value. The left-hand expression is evaluated and compared to each element of "
"the array using the given <replaceable>operator</replaceable>, which must "
"yield a Boolean result. The result of <token>ANY</token> is <quote>true</"
"quote> if any true result is obtained. The result is <quote>false</quote> if "
"no true result is found (including the case where the array has zero "
"elements)."
msgstr ""
"Справа в скобках записывается выражение, результатом которого является "
"массив. Вычисленное значение левого выражения сравнивается с каждым "
"элементом этого массива с применением заданного <replaceable>оператора</"
"replaceable> условия, который должен выдавать логическое значение. "
"Результатом <token>ANY</token> будет <quote>true</quote>, если для какого-"
"либо элемента условие истинно, и <quote>false</quote> в противном случае (в "
"том числе, и когда массив оказывается пустым)."

#: func.xml:14405(para)
msgid ""
"If the array expression yields a null array, the result of <token>ANY</"
"token> will be null. If the left-hand expression yields null, the result of "
"<token>ANY</token> is ordinarily null (though a non-strict comparison "
"operator could possibly yield a different result). Also, if the right-hand "
"array contains any null elements and no true comparison result is obtained, "
"the result of <token>ANY</token> will be null, not false (again, assuming a "
"strict comparison operator). This is in accordance with SQL's normal rules "
"for Boolean combinations of null values."
msgstr ""
"Если значением массива оказывается NULL, результатом <token>ANY</token> "
"также будет NULL. Если NULL получен в левой части, результатом <token>ANY</"
"token> обычно тоже будет NULL (хотя оператор нестрогого сравнения может "
"выдать другой результат). Кроме того, если массив в правой части содержит "
"элементы NULL и ни c одним из элементов условие не выполняется, результатом "
"<token>ANY</token> будет NULL, а не false (опять же, если используется "
"оператор строгого сравнения). Это соответствует принятым в SQL правилам "
"сравнения переменных со значениями NULL."

#: func.xml:14417(para)
msgid "<token>SOME</token> is a synonym for <token>ANY</token>."
msgstr ""
"Ключевое слово <token>SOME</token> является синонимом <token>ANY</token>."

#: func.xml:14423(title)
msgid "<literal>ALL</literal> (array)"
msgstr "<literal>ALL</literal> (с массивом)"

#: func.xml:14427(para)
msgid ""
"The right-hand side is a parenthesized expression, which must yield an array "
"value. The left-hand expression is evaluated and compared to each element of "
"the array using the given <replaceable>operator</replaceable>, which must "
"yield a Boolean result. The result of <token>ALL</token> is <quote>true</"
"quote> if all comparisons yield true (including the case where the array has "
"zero elements). The result is <quote>false</quote> if any false result is "
"found."
msgstr ""
"Справа в скобках записывается выражение, результатом которого является "
"массив. Вычисленное значение левого выражения сравнивается с каждым "
"элементом этого массива с применением заданного <replaceable>оператора</"
"replaceable> условия, который должен выдавать логическое значение. "
"Результатом <token>ALL</token> будет <quote>true</quote>, если для всех "
"элементов условие истинно (или массив не содержит элементов), и "
"<quote>false</quote>, если находятся строки, для которых оно ложно."

#: func.xml:14439(para)
msgid ""
"If the array expression yields a null array, the result of <token>ALL</"
"token> will be null. If the left-hand expression yields null, the result of "
"<token>ALL</token> is ordinarily null (though a non-strict comparison "
"operator could possibly yield a different result). Also, if the right-hand "
"array contains any null elements and no false comparison result is obtained, "
"the result of <token>ALL</token> will be null, not true (again, assuming a "
"strict comparison operator). This is in accordance with SQL's normal rules "
"for Boolean combinations of null values."
msgstr ""
"Если значением массива оказывается NULL, результатом <token>ALL</token> "
"также будет NULL. Если NULL получен в левой части, результатом <token>ALL</"
"token> обычно тоже будет NULL (хотя оператор нестрогого сравнения может "
"выдать другой результат). Кроме того, если массив в правой части содержит "
"элементы NULL и при этом нет элементов, с которыми условие не выполняется, "
"результатом <token>ALL</token> будет NULL, а не true (опять же, если "
"используется оператор строгого сравнения). Это соответствует принятым в SQL "
"правилам сравнения переменных со значениями NULL."

#: func.xml:14453(title)
msgid "Row Constructor Comparison"
msgstr "Сравнение конструкторов строк"

#: func.xml:14457(para)
msgid ""
"Each side is a row constructor, as described in <xref linkend=\"sql-syntax-"
"row-constructors\"/>. The two row values must have the same number of "
"fields. Each side is evaluated and they are compared row-wise. Row "
"constructor comparisons are allowed when the <replaceable>operator</"
"replaceable> is <literal>=</literal>, <literal>&lt;&gt;</literal>, "
"<literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> "
"or <literal>&gt;=</literal>. Every row element must be of a type which has a "
"default B-tree operator class or the attempted comparison may generate an "
"error."
msgstr ""
"С обеих сторон представлены конструкторы строк (они описываются в <xref "
"remap=\"6\" linkend=\"sql-syntax-row-constructors\"/>). При этом данные "
"строки должны содержать одинаковое число полей. После вычисления каждой "
"стороны они сравниваются по строкам. Сравнения конструкторов строк возможны "
"с <replaceable>оператором</replaceable> <literal>=</literal>, <literal>&lt;"
"&gt;</literal>, <literal>&lt;</literal>, <literal>&lt;=</literal>, "
"<literal>&gt;</literal> или <literal>&gt;=</literal>. Каждый элемент строки "
"должен иметь тип, для которого определён класс операторов B-дерева; в "
"противном случае при попытке сравнения может возникнуть ошибка."

#: func.xml:14474(para)
msgid ""
"Errors related to the number or types of elements might not occur if the "
"comparison is resolved using earlier columns."
msgstr ""
"Ошибок, связанных с числом или типов элементов, не должно быть, если "
"сравнение выполняется с ранее полученными столбцами."

#: func.xml:14480(para)
msgid ""
"The <literal>=</literal> and <literal>&lt;&gt;</literal> cases work slightly "
"differently from the others. Two rows are considered equal if all their "
"corresponding members are non-null and equal; the rows are unequal if any "
"corresponding members are non-null and unequal; otherwise the result of the "
"row comparison is unknown (null)."
msgstr ""
"Сравнения <literal>=</literal> и <literal>&lt;&gt;</literal> несколько "
"отличаются от других. С этими операторами две строки считаются равными, если "
"все их соответствующие поля не равны NULL и равны между собой, и неравными, "
"если какие-либо соответствующие их поля не NULL и не равны между собой. В "
"противном случае результатом сравнения будет неопределённость (NULL)."

#: func.xml:14488(para)
msgid ""
"For the <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</"
"literal> and <literal>&gt;=</literal> cases, the row elements are compared "
"left-to-right, stopping as soon as an unequal or null pair of elements is "
"found. If either of this pair of elements is null, the result of the row "
"comparison is unknown (null); otherwise comparison of this pair of elements "
"determines the result. For example, <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</"
"literal> yields true, not null, because the third pair of elements are not "
"considered."
msgstr ""
"С операторами <literal>&lt;</literal>, <literal>&lt;=</literal>, "
"<literal>&gt;</literal> и <literal>&gt;=</literal> элементы строк "
"сравниваются слева направо до тех пор, пока не будет найдена пара неравных "
"элементов или значений NULL. Если любым из элементов пары оказывается NULL, "
"результатом сравнения будет неопределённость (NULL), в противном случае "
"результат всего выражения определяется результатом сравнения этих двух "
"элементов. Например, результатом <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</"
"literal> будет true, а не NULL, так как третья пара элементов не принимается "
"в рассмотрение."

#: func.xml:14501(para)
msgid ""
"Prior to <productname>PostgreSQL</productname> 8.2, the <literal>&lt;</"
"literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> and <literal>&gt;"
"=</literal> cases were not handled per SQL specification. A comparison like "
"<literal>ROW(a,b) &lt; ROW(c,d)</literal> was implemented as <literal>a &lt; "
"c AND b &lt; d</literal> whereas the correct behavior is equivalent to "
"<literal>a &lt; c OR (a = c AND b &lt; d)</literal>."
msgstr ""
"До версии 8.2 <productname>PostgreSQL</productname> обрабатывал условия "
"<literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> и "
"<literal>&gt;=</literal> не так, как это описано в стандарте SQL. Сравнение "
"<literal>ROW(a,b) &lt; ROW(c,d)</literal> выполнялось как <literal>a &lt; c "
"AND b &lt; d</literal>, тогда как по стандарту должно быть <literal>a &lt; c "
"OR (a = c AND b &lt; d)</literal>."

#: func.xml:14513(synopsis)
#, no-wrap
msgid "<placeholder-1/> IS DISTINCT FROM <placeholder-2/>"
msgstr "<placeholder-1/> IS DISTINCT FROM <placeholder-2/>"

#: func.xml:14515(para)
msgid ""
"This construct is similar to a <literal>&lt;&gt;</literal> row comparison, "
"but it does not yield null for null inputs. Instead, any null value is "
"considered unequal to (distinct from) any non-null value, and any two nulls "
"are considered equal (not distinct). Thus the result will either be true or "
"false, never null."
msgstr ""
"Эта конструкция похожа на сравнение строк с оператором <literal>&lt;&gt;</"
"literal>, но со значениями NULL она выдаёт не NULL. Любое значение NULL для "
"неё считается неравным (отличным от) любому значению не NULL, а два NULL "
"считаются равными (не различными). Таким образом, результатом такого "
"выражения будет true или false, но не NULL."

#: func.xml:14523(synopsis)
#, no-wrap
msgid "<placeholder-1/> IS NOT DISTINCT FROM <placeholder-2/>"
msgstr "<placeholder-1/> IS NOT DISTINCT FROM <placeholder-2/>"

#: func.xml:14525(para)
msgid ""
"This construct is similar to a <literal>=</literal> row comparison, but it "
"does not yield null for null inputs. Instead, any null value is considered "
"unequal to (distinct from) any non-null value, and any two nulls are "
"considered equal (not distinct). Thus the result will always be either true "
"or false, never null."
msgstr ""
"Эта конструкция похожа на сравнение строк с оператором <literal>=</literal>, "
"но со значениями NULL она выдаёт не NULL. Любое значение NULL для неё "
"считается неравным (отличным от) любому значению не NULL, а два NULL "
"считаются равными (не различными). Таким образом, результатом такого "
"выражения всегда будет true или false, но не NULL."

#: func.xml:14536(title)
msgid "Composite Type Comparison"
msgstr "Сравнение составных типов"

#: func.xml:14538(replaceable)
msgctxt "replaceable"
msgid "record"
msgstr "запись"

#: func.xml:14540(para)
msgid ""
"The SQL specification requires row-wise comparison to return NULL if the "
"result depends on comparing two NULL values or a NULL and a non-NULL. "
"<productname>PostgreSQL</productname> does this only when comparing the "
"results of two row constructors (as in <xref linkend=\"row-wise-comparison\"/"
">) or comparing a row constructor to the output of a subquery (as in <xref "
"linkend=\"functions-subquery\"/>). In other contexts where two composite-"
"type values are compared, two NULL field values are considered equal, and a "
"NULL is considered larger than a non-NULL. This is necessary in order to "
"have consistent sorting and indexing behavior for composite types."
msgstr ""
"Стандарт SQL требует, чтобы при сравнении строк возвращался NULL, если "
"результат зависит от сравнения двух значений NULL или значения NULL и не "
"NULL. <productname>PostgreSQL</productname> выполняет это требование только "
"при сравнении строк, созданных конструкторами (как описано в <xref remap="
"\"6\" linkend=\"row-wise-comparison\"/>), или строки, созданной "
"конструктором, со строкой результата подзапроса (как было описано в <xref "
"remap=\"6\" linkend=\"functions-subquery\"/>). В других контекстах при "
"сравнении полей составных типов два значения NULL считаются равными, а любое "
"значение не NULL полагается меньшим NULL. Это отклонение от правила "
"необходимо для полноценной реализации сортировки и индексирования составных "
"типов."

#: func.xml:14553(para)
msgid ""
"Each side is evaluated and they are compared row-wise. Composite type "
"comparisons are allowed when the <replaceable>operator</replaceable> is "
"<literal>=</literal>, <literal>&lt;&gt;</literal>, <literal>&lt;</literal>, "
"<literal>&lt;=</literal>, <literal>&gt;</literal> or <literal>&gt;=</"
"literal>, or has semantics similar to one of these. (To be specific, an "
"operator can be a row comparison operator if it is a member of a B-tree "
"operator class, or is the negator of the <literal>=</literal> member of a B-"
"tree operator class.) The default behavior of the above operators is the "
"same as for <literal>IS [ NOT ] DISTINCT FROM</literal> for row constructors "
"(see <xref linkend=\"row-wise-comparison\"/>)."
msgstr ""
"После вычисления каждой стороны они сравниваются по строкам. Сравнения "
"составных типов возможны с <replaceable>оператором</replaceable> <literal>=</"
"literal>, <literal>&lt;&gt;</literal>, <literal>&lt;</literal>, <literal>&lt;"
"=</literal>, <literal>&gt;</literal> или <literal>&gt;=</literal>, либо "
"другим подобным. (Точнее, оператором сравнения строк может быть любой "
"оператор, входящий в класс операторов B-дерева, либо обратный к оператору "
"<literal>=</literal>, входящему в класс операторов B-дерева.) По умолчанию "
"вышеперечисленные операторы действуют так же, как выражение <literal>IS "
"[ NOT ] DISTINCT FROM</literal> для конструкторов строк (см. <xref remap="
"\"4\" linkend=\"row-wise-comparison\"/>)."

#: func.xml:14570(para)
msgid ""
"To support matching of rows which include elements without a default B-tree "
"operator class, the following operators are defined for composite type "
"comparison: <literal>*=</literal>, <literal>*&lt;&gt;</literal>, "
"<literal>*&lt;</literal>, <literal>*&lt;=</literal>, <literal>*&gt;</"
"literal>, and <literal>*&gt;=</literal>. These operators compare the "
"internal binary representation of the two rows. Two rows might have a "
"different binary representation even though comparisons of the two rows with "
"the equality operator is true. The ordering of rows under these comparison "
"operators is deterministic but not otherwise meaningful. These operators are "
"used internally for materialized views and might be useful for other "
"specialized purposes such as replication but are not intended to be "
"generally useful for writing queries."
msgstr ""
"Для поддержки сравнения строк с элементами, для которых не определён класс "
"операторов B-дерева по умолчанию, введены следующие операторы: <literal>*=</"
"literal>, <literal>*&lt;&gt;</literal>, <literal>*&lt;</literal>, "
"<literal>*&lt;=</literal>, <literal>*&gt;</literal> и <literal>*&gt;=</"
"literal>. Эти операторы сравнивают внутреннее двоичное представление двух "
"строк. Учтите, что две строки могут иметь различное двоичное представление, "
"даже когда при сравнении оператором равенства считаются равными. Порядок "
"строк с такими операторами детерминирован, но не несёт смысловой нагрузки. "
"Данные операторы применяются внутри системы для материализованных "
"представлений и могут быть полезны для других специальных целей (например, "
"репликации), но, вообще говоря, не предназначены для использования в обычных "
"запросах."

#: func.xml:14593(title)
msgid "Set Returning Functions"
msgstr "Функции, возвращающие множества"

#: func.xml:14595(indexterm)
msgid ""
"<primary>set returning functions</primary><secondary>functions</secondary>"
msgstr ""
"<primary>функции, возвращающие множества</primary><secondary>множества</"
"secondary>"

#: func.xml:14599(indexterm)
msgid "<primary>generate_series</primary>"
msgstr "<primary>generate_series</primary>"

#: func.xml:14603(para)
msgid ""
"This section describes functions that possibly return more than one row. The "
"most widely used functions in this class are series generating functions, as "
"detailed in <xref linkend=\"functions-srf-series\"/> and <xref linkend="
"\"functions-srf-subscripts\"/>. Other, more specialized set-returning "
"functions are described elsewhere in this manual. See <xref linkend="
"\"queries-tablefunctions\"/> for ways to combine multiple set-returning "
"functions."
msgstr ""
"В этом разделе описаны функции, которые могут возвращать не одну, а "
"множество строк. Чаще всего из их числа используются функции, генерирующие "
"ряды значений, которые перечислены в <xref remap=\"6\" linkend=\"functions-"
"srf-series\"/> и <xref remap=\"6\" linkend=\"functions-srf-subscripts\"/>. "
"Другие, более специализированные функции множеств описаны в других разделах "
"этой документации. Варианты комбинирования нескольких функций, возвращающих "
"множества строк, описаны в <xref remap=\"6\" linkend=\"queries-tablefunctions"
"\"/>."

#: func.xml:14614(title)
msgid "Series Generating Functions"
msgstr "Функции, генерирующие ряды значений"

#: func.xml:14627(parameter) func.xml:14637(parameter)
#: func.xml:14647(parameter)
msgid "start"
msgstr "start"

#: func.xml:14627(parameter) func.xml:14637(parameter)
#: func.xml:14647(parameter)
msgid "stop"
msgstr "stop"

#: func.xml:14627(function)
msgid "generate_series(<placeholder-1/>, <placeholder-2/>)"
msgstr "generate_series(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:14628(entry) func.xml:14638(entry)
msgid "<type>int</type>, <type>bigint</type> or <type>numeric</type>"
msgstr "<type>int</type>, <type>bigint</type> или <type>numeric</type>"

#: func.xml:14629(entry)
msgid ""
"<type>setof int</type>, <type>setof bigint</type>, or <type>setof numeric</"
"type> (same as argument type)"
msgstr ""
"<type>setof int</type>, <type>setof bigint</type> или <type>setof numeric</"
"type> (определяется типом аргумента)"

#: func.xml:14630(entry)
msgid ""
"Generate a series of values, from <parameter>start</parameter> to "
"<parameter>stop</parameter> with a step size of one"
msgstr ""
"Выдаёт ряд целых чисел от <parameter>start</parameter> до <parameter>stop</"
"parameter> с шагом 1"

#: func.xml:14637(parameter) func.xml:14647(parameter)
msgid "step"
msgstr "step"

#: func.xml:14637(function)
msgid "generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:14639(entry)
msgid ""
"<type>setof int</type>, <type>setof bigint</type> or <type>setof numeric</"
"type> (same as argument type)"
msgstr ""
"<type>setof int</type>, <type>setof bigint</type> или <type>setof numeric</"
"type> (определяется типом аргумента)"

#: func.xml:14640(entry) func.xml:14650(entry)
msgid ""
"Generate a series of values, from <parameter>start</parameter> to "
"<parameter>stop</parameter> with a step size of <parameter>step</parameter>"
msgstr ""
"Выдаёт ряд значений от <parameter>start</parameter> до <parameter>stop</"
"parameter> с заданным шагом (<parameter>step</parameter>)"

#: func.xml:14647(function)
msgid ""
"generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:14648(entry)
msgid "<type>timestamp</type> or <type>timestamp with time zone</type>"
msgstr "<type>timestamp</type> или <type>timestamp with time zone</type>"

#: func.xml:14649(entry)
msgid ""
"<type>setof timestamp</type> or <type>setof timestamp with time zone</type> "
"(same as argument type)"
msgstr ""
"<type>setof timestamp</type> или <type>setof timestamp with time zone</type> "
"(определяется типом аргумента)"

#: func.xml:14667(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM generate_series(2,4);\n"
" generate_series\n"
"-----------------\n"
"               2\n"
"               3\n"
"               4\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(5,1,-2);\n"
" generate_series\n"
"-----------------\n"
"               5\n"
"               3\n"
"               1\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(4,3);\n"
" generate_series\n"
"-----------------\n"
"(0 rows)\n"
"\n"
"SELECT generate_series(1.1, 4, 1.3);\n"
" generate_series \n"
"-----------------\n"
"             1.1\n"
"             2.4\n"
"             3.7\n"
"(3 rows)\n"
"\n"
"-- this example relies on the date-plus-integer operator\n"
"SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);\n"
"   dates\n"
"------------\n"
" 2004-02-05\n"
" 2004-02-12\n"
" 2004-02-19\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,\n"
"                              '2008-03-04 12:00', '10 hours');\n"
"   generate_series   \n"
"---------------------\n"
" 2008-03-01 00:00:00\n"
" 2008-03-01 10:00:00\n"
" 2008-03-01 20:00:00\n"
" 2008-03-02 06:00:00\n"
" 2008-03-02 16:00:00\n"
" 2008-03-03 02:00:00\n"
" 2008-03-03 12:00:00\n"
" 2008-03-03 22:00:00\n"
" 2008-03-04 08:00:00\n"
"(9 rows)"
msgstr ""
"SELECT * FROM generate_series(2,4);\n"
" generate_series\n"
"-----------------\n"
"               2\n"
"               3\n"
"               4\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(5,1,-2);\n"
" generate_series\n"
"-----------------\n"
"               5\n"
"               3\n"
"               1\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(4,3);\n"
" generate_series\n"
"-----------------\n"
"(0 rows)\n"
"\n"
"SELECT generate_series(1.1, 4, 1.3);\n"
" generate_series \n"
"-----------------\n"
"             1.1\n"
"             2.4\n"
"             3.7\n"
"(3 rows)\n"
"\n"
"-- этот пример задействует оператор прибавления к дате целого числа\n"
"SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);\n"
"   dates\n"
"------------\n"
" 2004-02-05\n"
" 2004-02-12\n"
" 2004-02-19\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,\n"
"                              '2008-03-04 12:00', '10 hours');\n"
"   generate_series   \n"
"---------------------\n"
" 2008-03-01 00:00:00\n"
" 2008-03-01 10:00:00\n"
" 2008-03-01 20:00:00\n"
" 2008-03-02 06:00:00\n"
" 2008-03-02 16:00:00\n"
" 2008-03-03 02:00:00\n"
" 2008-03-03 12:00:00\n"
" 2008-03-03 22:00:00\n"
" 2008-03-04 08:00:00\n"
"(9 rows)"

#: func.xml:14660(para)
msgid ""
"When <parameter>step</parameter> is positive, zero rows are returned if "
"<parameter>start</parameter> is greater than <parameter>stop</parameter>. "
"Conversely, when <parameter>step</parameter> is negative, zero rows are "
"returned if <parameter>start</parameter> is less than <parameter>stop</"
"parameter>. Zero rows are also returned for <literal>NULL</literal> inputs. "
"It is an error for <parameter>step</parameter> to be zero. Some examples "
"follow: <placeholder-1/>"
msgstr ""
"Если заданный шаг (<parameter>step</parameter>) положительный, а "
"<parameter>start</parameter> оказывается больше <parameter>stop</parameter>, "
"эти функции возвращают 0 строк. Тот же результат будет, если "
"<parameter>step</parameter> меньше 0, а <parameter>start</parameter> меньше "
"<parameter>stop</parameter>, или если какой-либо аргумент равен "
"<literal>NULL</literal>. Если же <parameter>step</parameter> будет равен 0, "
"произойдёт ошибка. Несколько примеров: <placeholder-1/>"

#: func.xml:14722(title)
msgid "Subscript Generating Functions"
msgstr "Функции, генерирующие индексы массивов"

#: func.xml:14734(parameter) func.xml:14742(parameter)
msgid "array anyarray"
msgstr "array anyarray"

#: func.xml:14734(parameter) func.xml:14742(parameter)
msgid "dim int"
msgstr "dim int"

#: func.xml:14734(function)
msgid "generate_subscripts(<placeholder-1/>, <placeholder-2/>)"
msgstr "generate_subscripts(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:14735(type) func.xml:14743(type)
msgid "setof int"
msgstr "setof int"

#: func.xml:14736(entry)
msgid "Generate a series comprising the given array's subscripts."
msgstr ""
"Выдаёт ряд значений для использования в качестве индекса данного массива."

#: func.xml:14742(parameter)
msgid "reverse boolean"
msgstr "reverse boolean"

#: func.xml:14742(function)
msgid ""
"generate_subscripts(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr ""
"generate_subscripts(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:14744(entry)
msgid ""
"Generate a series comprising the given array's subscripts. When "
"<parameter>reverse</parameter> is true, the series is returned in reverse "
"order."
msgstr ""
"Выдаёт ряд значений для использования в качестве индекса данного массива. "
"Если параметр <parameter>reverse</parameter> равен true, значения выдаются "
"от большего к меньшему."

#: func.xml:14755(indexterm)
msgid "<primary>generate_subscripts</primary>"
msgstr "<primary>generate_subscripts</primary>"

#: func.xml:14766(programlisting)
#, no-wrap
msgid ""
"-- basic usage\n"
"SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;\n"
" s \n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
" 4\n"
"(4 rows)\n"
"\n"
"-- presenting an array, the subscript and the subscripted\n"
"-- value requires a subquery\n"
"SELECT * FROM arrays;\n"
"         a          \n"
"--------------------\n"
" {-1,-2}\n"
" {100,200,300}\n"
"(2 rows)\n"
"\n"
"SELECT a AS array, s AS subscript, a[s] AS value\n"
"FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;\n"
"     array     | subscript | value\n"
"---------------+-----------+-------\n"
" {-1,-2}       |         1 |    -1\n"
" {-1,-2}       |         2 |    -2\n"
" {100,200,300} |         1 |   100\n"
" {100,200,300} |         2 |   200\n"
" {100,200,300} |         3 |   300\n"
"(5 rows)\n"
"\n"
"-- unnest a 2D array\n"
"CREATE OR REPLACE FUNCTION unnest2(anyarray)\n"
"RETURNS SETOF anyelement AS $$\n"
"select $1[i][j]\n"
"   from generate_subscripts($1,1) g1(i),\n"
"        generate_subscripts($1,2) g2(j);\n"
"$$ LANGUAGE sql IMMUTABLE;\n"
"CREATE FUNCTION\n"
"SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);\n"
" unnest2 \n"
"---------\n"
"       1\n"
"       2\n"
"       3\n"
"       4\n"
"(4 rows)"
msgstr ""
"-- простой пример использования\n"
"SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;\n"
" s \n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
" 4\n"
"(4 rows)\n"
"\n"
"-- для показанного массива получение индекса и обращение\n"
"-- к элементу по индексу выполняется с помощью подзапроса\n"
"SELECT * FROM arrays;\n"
"         a          \n"
"--------------------\n"
" {-1,-2}\n"
" {100,200,300}\n"
"(2 rows)\n"
"\n"
"SELECT a AS array, s AS subscript, a[s] AS value\n"
"FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;\n"
"     array     | subscript | value\n"
"---------------+-----------+-------\n"
" {-1,-2}       |         1 |    -1\n"
" {-1,-2}       |         2 |    -2\n"
" {100,200,300} |         1 |   100\n"
" {100,200,300} |         2 |   200\n"
" {100,200,300} |         3 |   300\n"
"(5 rows)\n"
"\n"
"-- разворачивание двумерного массива\n"
"CREATE OR REPLACE FUNCTION unnest2(anyarray)\n"
"RETURNS SETOF anyelement AS $$\n"
"select $1[i][j]\n"
"   from generate_subscripts($1,1) g1(i),\n"
"        generate_subscripts($1,2) g2(j);\n"
"$$ LANGUAGE sql IMMUTABLE;\n"
"CREATE FUNCTION\n"
"SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);\n"
" unnest2 \n"
"---------\n"
"       1\n"
"       2\n"
"       3\n"
"       4\n"
"(4 rows)"

#: func.xml:14759(para)
msgid ""
"<function>generate_subscripts</function> is a convenience function that "
"generates the set of valid subscripts for the specified dimension of the "
"given array. Zero rows are returned for arrays that do not have the "
"requested dimension, or for NULL arrays (but valid subscripts are returned "
"for NULL array elements). Some examples follow: <placeholder-1/>"
msgstr ""
"Функция <function>generate_subscripts</function> позволяет упростить "
"получение всего набора индексов для указанной размерности заданного массива. "
"Она выдаёт 0 строк, если в массиве нет указанной размерности или сам массив "
"равен NULL (хотя для элементов, равных NULL, индексы будут выданы, как и для "
"любых других). Взгляните на следующие примеры: <placeholder-1/>"

#: func.xml:14814(indexterm)
msgid "<primary>ordinality</primary>"
msgstr "<primary>ordinality</primary>"

#: func.xml:14825(programlisting)
#, no-wrap
msgid ""
"-- set returning function WITH ORDINALITY\n"
"SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);\n"
"       ls        | n\n"
"-----------------+----\n"
" pg_serial       |  1\n"
" pg_twophase     |  2\n"
" postmaster.opts |  3\n"
" pg_notify       |  4\n"
" postgresql.conf |  5\n"
" pg_tblspc       |  6\n"
" logfile         |  7\n"
" base            |  8\n"
" postmaster.pid  |  9\n"
" pg_ident.conf   | 10\n"
" global          | 11\n"
" pg_clog         | 12\n"
" pg_snapshots    | 13\n"
" pg_multixact    | 14\n"
" PG_VERSION      | 15\n"
" pg_xlog         | 16\n"
" pg_hba.conf     | 17\n"
" pg_stat_tmp     | 18\n"
" pg_subtrans     | 19\n"
"(19 rows)"
msgstr ""
"-- функция, возвращающая множество, с нумерацией\n"
"SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);\n"
"       ls        | n\n"
"-----------------+----\n"
" pg_serial       |  1\n"
" pg_twophase     |  2\n"
" postmaster.opts |  3\n"
" pg_notify       |  4\n"
" postgresql.conf |  5\n"
" pg_tblspc       |  6\n"
" logfile         |  7\n"
" base            |  8\n"
" postmaster.pid  |  9\n"
" pg_ident.conf   | 10\n"
" global          | 11\n"
" pg_clog         | 12\n"
" pg_snapshots    | 13\n"
" pg_multixact    | 14\n"
" PG_VERSION      | 15\n"
" pg_xlog         | 16\n"
" pg_hba.conf     | 17\n"
" pg_stat_tmp     | 18\n"
" pg_subtrans     | 19\n"
"(19 строк)"

#: func.xml:14818(para)
msgid ""
"When a function in the <literal>FROM</literal> clause is suffixed by "
"<literal>WITH ORDINALITY</literal>, a <type>bigint</type> column is appended "
"to the output which starts from 1 and increments by 1 for each row of the "
"function's output. This is most useful in the case of set returning "
"functions such as <function>unnest()</function>. <placeholder-1/>"
msgstr ""
"Когда после функции в предложении <literal>FROM</literal> добавляется "
"<literal>WITH ORDINALITY</literal>, в выходные данные добавляется столбец "
"типа <type>bigint</type>, числа в котором начинаются с 1 и увеличиваются на "
"1 для каждой строки, выданной функцией. В первую очередь это полезно для "
"функций, возвращающих множества, например, <function>unnest()</function>. "
"<placeholder-1/>"

#: func.xml:14854(title)
msgid "System Information Functions"
msgstr "Системные информационные функции"

#: func.xml:14856(para)
msgid ""
"<xref linkend=\"functions-info-session-table\"/> shows several functions "
"that extract session and system information."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-session-table\"/> перечислен "
"ряд функций, предназначенных для получения информации о текущем сеансе и "
"системе."

#: func.xml:14861(para)
msgid ""
"In addition to the functions listed in this section, there are a number of "
"functions related to the statistics system that also provide system "
"information. See <xref linkend=\"monitoring-stats-views\"/> for more "
"information."
msgstr ""
"В дополнение к перечисленным здесь функциям существуют также функции, "
"связанные с подсистемой статистики, которые тоже предоставляют системную "
"информацию. Подробнее они рассматриваются в <xref remap=\"6\" linkend="
"\"monitoring-stats-views\"/>."

#: func.xml:14869(title)
msgid "Session Information Functions"
msgstr "Функции получения информации о сеансе"

#: func.xml:14872(entry) func.xml:15247(entry) func.xml:15668(entry)
#: func.xml:15925(entry) func.xml:16294(entry) func.xml:16402(entry)
#: func.xml:16492(entry) func.xml:16546(entry) func.xml:16608(entry)
#: func.xml:16648(entry) func.xml:17011(entry) func.xml:17122(entry)
#: func.xml:17257(entry) func.xml:17496(entry) func.xml:17576(entry)
#: func.xml:17667(entry) func.xml:18153(entry) func.xml:18403(entry)
#: func.xml:18490(entry) func.xml:18552(entry) func.xml:18672(entry)
#: func.xml:19028(entry) func.xml:19115(entry) func.xml:19250(entry)
msgid "Name"
msgstr "Имя"

#: func.xml:14877(function)
msgid "current_catalog"
msgstr "current_catalog"

#: func.xml:14879(entry)
msgid ""
"name of current database (called <quote>catalog</quote> in the SQL standard)"
msgstr ""
"имя текущей базы данных (в стандарте SQL она называется <quote>каталогом</"
"quote>)"

#: func.xml:14883(function)
msgid "current_database()"
msgstr "current_database()"

#: func.xml:14885(entry)
msgid "name of current database"
msgstr "имя текущей базы данных"

#: func.xml:14889(function)
msgid "current_query()"
msgstr "current_query()"

#: func.xml:14891(entry)
msgid ""
"text of the currently executing query, as submitted by the client (might "
"contain more than one statement)"
msgstr ""
"текст запроса, выполняемого в данный момент, в том виде, в каком его передал "
"клиент (может состоять из нескольких операторов)"

#: func.xml:14896(function)
msgid "current_schema"
msgstr "current_schema"

#: func.xml:14896(literal)
msgid "<placeholder-1/>[()]"
msgstr "<placeholder-1/>[()]"

#: func.xml:14898(entry)
msgid "name of current schema"
msgstr "имя текущей схемы"

#: func.xml:14902(function)
msgid "current_schemas(<placeholder-1/>)"
msgstr "current_schemas(<placeholder-1/>)"

#: func.xml:14903(type)
msgid "name[]"
msgstr "name[]"

#: func.xml:14904(entry)
msgid "names of schemas in search path, optionally including implicit schemas"
msgstr ""
"имена схем в пути поиска, возможно включая схемы, добавляемые в него неявно"

#: func.xml:14908(function)
msgid "current_user"
msgstr "current_user"

#: func.xml:14910(entry)
msgid "user name of current execution context"
msgstr "имя пользователя в текущем контексте выполнения"

#: func.xml:14914(function)
msgid "inet_client_addr()"
msgstr "inet_client_addr()"

#: func.xml:14916(entry)
msgid "address of the remote connection"
msgstr "адрес удалённой стороны соединения"

#: func.xml:14920(function)
msgid "inet_client_port()"
msgstr "inet_client_port()"

#: func.xml:14922(entry)
msgid "port of the remote connection"
msgstr "порт удалённой стороны соединения"

#: func.xml:14926(function)
msgid "inet_server_addr()"
msgstr "inet_server_addr()"

#: func.xml:14928(entry)
msgid "address of the local connection"
msgstr "адрес локальной стороны соединения"

#: func.xml:14932(function)
msgid "inet_server_port()"
msgstr "inet_server_port()"

#: func.xml:14934(entry)
msgid "port of the local connection"
msgstr "порт локальной стороны соединения"

#: func.xml:14939(function)
msgid "pg_backend_pid()"
msgstr "pg_backend_pid()"

#: func.xml:14941(entry)
msgid "Process ID of the server process attached to the current session"
msgstr "код серверного процесса, обслуживающего текущий сеанс"

#: func.xml:14947(function)
#, fuzzy
msgid "pg_blocking_pids(<placeholder-1/>)"
msgstr "npoints(<placeholder-1/>)"

#: func.xml:14949(entry)
#, fuzzy
msgid "Process ID(s) that are blocking specified server process ID"
msgstr "Идентификатор обслуживающего процесса или процесса, передающего WAL"

#: func.xml:14953(function)
msgid "pg_conf_load_time()"
msgstr "pg_conf_load_time()"

#: func.xml:14955(entry)
msgid "configuration load time"
msgstr "время загрузки конфигурации"

#: func.xml:14959(function)
msgid "pg_my_temp_schema()"
msgstr "pg_my_temp_schema()"

#: func.xml:14961(entry)
msgid "OID of session's temporary schema, or 0 if none"
msgstr "OID временной схемы этого сеанса или 0, если её нет"

#: func.xml:14965(function)
msgid "pg_is_other_temp_schema(<placeholder-1/>)"
msgstr "pg_is_other_temp_schema(<placeholder-1/>)"

#: func.xml:14967(entry)
msgid "is schema another session's temporary schema?"
msgstr "является ли заданная схема временной в другом сеансе?"

#: func.xml:14971(function)
msgid "pg_listening_channels()"
msgstr "pg_listening_channels()"

#: func.xml:14973(entry)
msgid "channel names that the session is currently listening on"
msgstr "имена каналов, по которым текущий сеанс принимает сигналы"

#: func.xml:14977(function)
#, fuzzy
msgid "pg_notification_queue_usage()"
msgstr "NotificationResponse (B)"

#: func.xml:14978(type)
msgid "double"
msgstr "double"

#: func.xml:14979(entry)
msgid ""
"fraction of the asynchronous notification queue currently occupied (0-1)"
msgstr ""

#: func.xml:14983(function)
msgid "pg_postmaster_start_time()"
msgstr "pg_postmaster_start_time()"

#: func.xml:14985(entry)
msgid "server start time"
msgstr "время запуска сервера"

#: func.xml:14989(function)
msgid "pg_trigger_depth()"
msgstr "pg_trigger_depth()"

#: func.xml:14991(entry)
msgid ""
"current nesting level of <productname>PostgreSQL</productname> triggers (0 "
"if not called, directly or indirectly, from inside a trigger)"
msgstr ""
"текущий уровень вложенности в триггерах <productname>PostgreSQL</"
"productname> (0, если эта функция вызывается (прямо или косвенно) не из тела "
"триггера)"

#: func.xml:14996(function)
msgid "session_user"
msgstr "session_user"

#: func.xml:14998(entry)
msgid "session user name"
msgstr "имя пользователя сеанса"

#: func.xml:15002(function)
msgctxt "function"
msgid "user"
msgstr "user"

#: func.xml:15004(entry)
msgid "equivalent to <function>current_user</function>"
msgstr "синоним <function>current_user</function>"

#: func.xml:15008(function)
msgid "version()"
msgstr "version()"

#: func.xml:15010(entry)
msgid ""
"<productname>PostgreSQL</productname> version information. See also <xref "
"linkend=\"guc-server-version-num\"/> for a machine-readable version."
msgstr ""
"информация о версии <productname>PostgreSQL</productname>. Также можно "
"прочитать версию в машинно-ориентированном виде, обратившись к переменной "
"<xref linkend=\"guc-server-version-num\"/>."

#: func.xml:15017(para)
msgid ""
"<function>current_catalog</function>, <function>current_schema</function>, "
"<function>current_user</function>, <function>session_user</function>, and "
"<function>user</function> have special syntactic status in <acronym>SQL</"
"acronym>: they must be called without trailing parentheses. (In PostgreSQL, "
"parentheses can optionally be used with <function>current_schema</function>, "
"but not with the others.)"
msgstr ""
"Функции <function>current_catalog</function>, <function>current_schema</"
"function>, <function>current_user</function>, <function>session_user</"
"function> и <function>user</function> имеют особый синтаксический статус в "
"<acronym>SQL</acronym>: они должны вызываться без скобок после имени. "
"(PostgreSQL позволяет добавить скобки в вызове <function>current_schema</"
"function>, но не других функций.)"

#: func.xml:15027(indexterm)
msgid "<primary>current_catalog</primary>"
msgstr "<primary>current_catalog</primary>"

#: func.xml:15031(indexterm)
msgid "<primary>current_database</primary>"
msgstr "<primary>current_database</primary>"

#: func.xml:15035(indexterm)
msgid "<primary>current_query</primary>"
msgstr "<primary>current_query</primary>"

#: func.xml:15039(indexterm)
msgid "<primary>current_schema</primary>"
msgstr "<primary>current_schema</primary>"

#: func.xml:15043(indexterm)
msgid "<primary>current_schemas</primary>"
msgstr "<primary>current_schemas</primary>"

#: func.xml:15047(indexterm)
msgid "<primary>current_user</primary>"
msgstr "<primary>current_user</primary>"

#: func.xml:15051(indexterm)
msgid "<primary>pg_backend_pid</primary>"
msgstr "<primary>pg_backend_pid</primary>"

#: func.xml:15055(indexterm)
msgid "<primary>schema</primary><secondary>current</secondary>"
msgstr "<primary>схема</primary><secondary>текущая</secondary>"

#: func.xml:15059(indexterm)
msgid "<primary>search path</primary><secondary>current</secondary>"
msgstr "<primary>путь поиска</primary><secondary>текущий</secondary>"

#: func.xml:15063(indexterm)
msgid "<primary>session_user</primary>"
msgstr "<primary>session_user</primary>"

#: func.xml:15067(indexterm)
msgid "<primary>user</primary><secondary>current</secondary>"
msgstr "<primary>пользователь</primary><secondary>текущий</secondary>"

#: func.xml:15071(indexterm)
msgid "<primary>user</primary>"
msgstr "<primary>пользователь</primary>"

#: func.xml:15075(para)
msgid ""
"The <function>session_user</function> is normally the user who initiated the "
"current database connection; but superusers can change this setting with "
"<xref linkend=\"sql-set-session-authorization\"/>. The "
"<function>current_user</function> is the user identifier that is applicable "
"for permission checking. Normally it is equal to the session user, but it "
"can be changed with <xref linkend=\"sql-set-role\"/>. It also changes during "
"the execution of functions with the attribute <literal>SECURITY DEFINER</"
"literal>. In Unix parlance, the session user is the <quote>real user</quote> "
"and the current user is the <quote>effective user</quote>."
msgstr ""
"Функция <function>session_user</function> обычно возвращает имя "
"пользователя, установившего текущее соединение с базой данных, но "
"суперпользователи могут изменить это имя, выполнив команду <xref linkend="
"\"sql-set-session-authorization\"/>. Функция <function>current_user</"
"function> возвращает идентификатор пользователя, по которому будут "
"проверяться его права. Обычно это тот же пользователь, что и пользователь "
"сеанса, но его можно сменить с помощью <xref linkend=\"sql-set-role\"/>. "
"Этот идентификатор также меняется при выполнении функций с атрибутом "
"<literal>SECURITY DEFINER</literal>. На языке Unix пользователь сеанса "
"называется <quote>реальным</quote>, а текущий &mdash; <quote>эффективным</"
"quote>."

#: func.xml:15089(para)
msgid ""
"<function>current_schema</function> returns the name of the schema that is "
"first in the search path (or a null value if the search path is empty). This "
"is the schema that will be used for any tables or other named objects that "
"are created without specifying a target schema. "
"<function>current_schemas(boolean)</function> returns an array of the names "
"of all schemas presently in the search path. The Boolean option determines "
"whether or not implicitly included system schemas such as "
"<literal>pg_catalog</literal> are included in the returned search path."
msgstr ""
"Функция <function>current_schema</function> возвращает имя схемы, которая "
"стоит первой в пути поиска (или NULL, если путь поиска пуст). Эта схема "
"будет задействована при создании таблиц или других именованных объектов, "
"если целевая схема не указана явно. Функция "
"<function>current_schemas(boolean)</function> возвращает массив имён всех "
"схем, находящихся в пути поиска. Её логический параметр определяет, будут ли "
"включаться в результат неявно добавляемые в путь поиска системные схемы, "
"такие как <literal>pg_catalog</literal>."

#: func.xml:15103(programlisting)
#, no-wrap
msgid "SET search_path TO <replaceable>schema</replaceable> <optional>, <replaceable>schema</replaceable>, ...</optional>"
msgstr "SET search_path TO <replaceable>схема</replaceable> <optional>, <replaceable>схема</replaceable>, ...</optional>"

#: func.xml:15101(para)
msgid ""
"The search path can be altered at run time. The command is: <placeholder-1/>"
msgstr ""
"Путь поиска можно изменить во время выполнения следующей командой: "
"<placeholder-1/>"

#: func.xml:15107(indexterm)
msgid "<primary>inet_client_addr</primary>"
msgstr "<primary>inet_client_addr</primary>"

#: func.xml:15111(indexterm)
msgid "<primary>inet_client_port</primary>"
msgstr "<primary>inet_client_port</primary>"

#: func.xml:15115(indexterm)
msgid "<primary>inet_server_addr</primary>"
msgstr "<primary>inet_server_addr</primary>"

#: func.xml:15119(indexterm)
msgid "<primary>inet_server_port</primary>"
msgstr "<primary>inet_server_port</primary>"

#: func.xml:15123(para)
msgid ""
"<function>inet_client_addr</function> returns the IP address of the current "
"client, and <function>inet_client_port</function> returns the port number. "
"<function>inet_server_addr</function> returns the IP address on which the "
"server accepted the current connection, and <function>inet_server_port</"
"function> returns the port number. All these functions return NULL if the "
"current connection is via a Unix-domain socket."
msgstr ""
"Функция <function>inet_client_addr</function> возвращает IP-адрес текущего "
"клиента, <function>inet_client_port</function> &mdash; номер его порта, "
"<function>inet_server_addr</function> &mdash; IP-адрес сервера, по которому "
"он принял подключение клиента, а <function>inet_server_port</function> "
"&mdash; соответствующий номер порта. Все эти функции возвращают NULL, если "
"текущее соединение устанавливается через доменный сокет Unix."

#: func.xml:15134(indexterm)
#, fuzzy
msgid "<primary>pg_blocking_pids</primary>"
msgstr "<primary>pg_backend_pid</primary>"

#: func.xml:15138(para)
msgid ""
"<function>pg_blocking_pids</function> returns an array of the process IDs of "
"the sessions that are blocking the server process with the specified process "
"ID, or an empty array if there is no such server process or it is not "
"blocked. One server process blocks another if it either holds a lock that "
"conflicts with the blocked process's lock request (hard block), or is "
"waiting for a lock that would conflict with the blocked process's lock "
"request and is ahead of it in the wait queue (soft block). When using "
"parallel queries the result always lists client-visible process IDs (that "
"is, <function>pg_backend_pid</function> results) even if the actual lock is "
"held or awaited by a child worker process. As a result of that, there may be "
"duplicated PIDs in the result. Also note that when a prepared transaction "
"holds a conflicting lock, it will be represented by a zero process ID in the "
"result of this function. Frequent calls to this function could have some "
"impact on database performance, because it needs exclusive access to the "
"lock manager's shared state for a short time."
msgstr ""

#: func.xml:15157(indexterm)
msgid "<primary>pg_conf_load_time</primary>"
msgstr "<primary>pg_conf_load_time</primary>"

#: func.xml:15161(para)
msgid ""
"<function>pg_conf_load_time</function> returns the <type>timestamp with time "
"zone</type> when the server configuration files were last loaded. (If the "
"current session was alive at the time, this will be the time when the "
"session itself re-read the configuration files, so the reading will vary a "
"little in different sessions. Otherwise it is the time when the postmaster "
"process re-read the configuration files.)"
msgstr ""
"Функция <function>pg_conf_load_time</function> возвращает время "
"(<type>timestamp with time zone</type>), когда в последний раз сервер "
"загружал файлы конфигурации. (Если текущий сеанс начался раньше, она "
"возвращает время, когда эти файлы были перезагружены для данного сеанса, так "
"что в разных сеансах это значение может немного различаться. В противном "
"случае это будет время, когда файлы конфигурации считал главный процесс.)"

#: func.xml:15171(indexterm)
msgid "<primary>pg_my_temp_schema</primary>"
msgstr "<primary>pg_my_temp_schema</primary>"

#: func.xml:15175(indexterm)
msgid "<primary>pg_is_other_temp_schema</primary>"
msgstr "<primary>pg_is_other_temp_schema</primary>"

#: func.xml:15179(para)
msgid ""
"<function>pg_my_temp_schema</function> returns the OID of the current "
"session's temporary schema, or zero if it has none (because it has not "
"created any temporary tables). <function>pg_is_other_temp_schema</function> "
"returns true if the given OID is the OID of another session's temporary "
"schema. (This can be useful, for example, to exclude other sessions' "
"temporary tables from a catalog display.)"
msgstr ""
"<function>pg_my_temp_schema</function> возвращает OID временной схемы "
"текущего сеанса или 0, если такой нет (в рамках сеанса не создавались "
"временные таблицы). <function>pg_is_other_temp_schema</function> возвращает "
"true, если заданный OID относится к временной схеме другого сеанса. (Это "
"может быть полезно, например для исключения временных таблиц других сеансов "
"из общего списка при просмотре таблиц базы данных.)"

#: func.xml:15189(indexterm)
msgid "<primary>pg_listening_channels</primary>"
msgstr "<primary>pg_listening_channels</primary>"

#: func.xml:15193(indexterm)
#, fuzzy
msgid "<primary>pg_notification_queue_usage</primary>"
msgstr "<primary>pg_statio_user_tables</primary>"

#: func.xml:15197(para)
msgid ""
"<function>pg_listening_channels</function> returns a set of names of "
"asynchronous notification channels that the current session is listening to. "
"<function>pg_notification_queue_usage</function> returns the fraction of the "
"total available space for notifications currently occupied by notifications "
"that are waiting to be processed, as a <type>double</type> in the range 0-1. "
"See <xref linkend=\"sql-listen\"/> and <xref linkend=\"sql-notify\"/> for "
"more information."
msgstr ""

#: func.xml:15208(indexterm)
msgid "<primary>pg_postmaster_start_time</primary>"
msgstr "<primary>pg_postmaster_start_time</primary>"

#: func.xml:15212(para)
msgid ""
"<function>pg_postmaster_start_time</function> returns the <type>timestamp "
"with time zone</type> when the server started."
msgstr ""
"<function>pg_postmaster_start_time</function> возвращает время "
"(<type>timestamp with time zone</type>), когда был запущен сервер."

#: func.xml:15218(indexterm)
msgid "<primary>version</primary>"
msgstr "<primary>версия</primary>"

#: func.xml:15222(para)
msgid ""
"<function>version</function> returns a string describing the "
"<productname>PostgreSQL</productname> server's version. You can also get "
"this information from <xref linkend=\"guc-server-version\"/> or for a "
"machine-readable version, <xref linkend=\"guc-server-version-num\"/>. "
"Software developers should use <literal>server_version_num</literal> "
"(available since 8.2) or <xref linkend=\"libpq-pqserverversion\"/> instead "
"of parsing the text version."
msgstr ""
"Функция <function>version</function> возвращает строку, описывающую версию "
"сервера <productname>PostgreSQL</productname>. Эту информацию также можно "
"получить из переменной <xref linkend=\"guc-server-version\"/> или, в более "
"машинно-ориентированном формате, из переменной <xref linkend=\"guc-server-"
"version-num\"/>. При разработке программ следует использовать "
"<literal>server_version_num</literal> (она появилась в версии 8.2) либо "
"<xref linkend=\"libpq-pqserverversion\"/>, а не разбирать текстовую версию."

#: func.xml:15232(indexterm)
msgid "<primary>privilege</primary><secondary>querying</secondary>"
msgstr "<primary>права</primary><secondary>проверка</secondary>"

#: func.xml:15236(para)
msgid ""
"<xref linkend=\"functions-info-access-table\"/> lists functions that allow "
"the user to query object access privileges programmatically. See <xref "
"linkend=\"ddl-priv\"/> for more information about privileges."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-access-table\"/> перечислены "
"функции, позволяющую пользователю программно проверить свои права доступа к "
"объектам. Подробнее о правах можно узнать в <xref remap=\"6\" linkend=\"ddl-"
"priv\"/>."

#: func.xml:15244(title)
msgid "Access Privilege Inquiry Functions"
msgstr "Функции для проверки прав доступа"

#: func.xml:15252(function) func.xml:15260(function)
msgid "has_any_column_privilege"
msgstr "has_any_column_privilege"

#: func.xml:15252(parameter) func.xml:15267(parameter)
#: func.xml:15284(parameter) func.xml:15299(parameter)
#: func.xml:15314(parameter) func.xml:15329(parameter)
#: func.xml:15344(parameter) func.xml:15359(parameter)
#: func.xml:15374(parameter) func.xml:15389(parameter)
#: func.xml:15404(parameter) func.xml:15419(parameter)
msgctxt "parameter"
msgid "user"
msgstr "user"

#: func.xml:15253(parameter) func.xml:15260(parameter)
#: func.xml:15268(parameter) func.xml:15276(parameter)
#: func.xml:15390(parameter) func.xml:15397(parameter)
#: func.xml:15434(parameter)
msgid "table"
msgstr "table"

#: func.xml:15254(parameter) func.xml:15261(parameter)
#: func.xml:15270(parameter) func.xml:15278(parameter)
#: func.xml:15286(parameter) func.xml:15293(parameter)
#: func.xml:15301(parameter) func.xml:15308(parameter)
#: func.xml:15316(parameter) func.xml:15323(parameter)
#: func.xml:15331(parameter) func.xml:15338(parameter)
#: func.xml:15346(parameter) func.xml:15353(parameter)
#: func.xml:15361(parameter) func.xml:15368(parameter)
#: func.xml:15376(parameter) func.xml:15383(parameter)
#: func.xml:15391(parameter) func.xml:15398(parameter)
#: func.xml:15406(parameter) func.xml:15413(parameter)
#: func.xml:15421(parameter) func.xml:15428(parameter)
msgid "privilege"
msgstr "privilege"

#: func.xml:15257(entry)
msgid "does user have privilege for any column of table"
msgstr "имеет ли пользователь указанное право для какого-либо столбца таблицы"

#: func.xml:15264(entry)
msgid "does current user have privilege for any column of table"
msgstr ""
"имеет ли текущий пользователь указанное право для какого-либо столбца таблицы"

#: func.xml:15267(function) func.xml:15276(function)
msgid "has_column_privilege"
msgstr "has_column_privilege"

#: func.xml:15269(parameter) func.xml:15277(parameter)
msgid "column"
msgstr "column"

#: func.xml:15267(literal)
msgid ""
"<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>, "
"<placeholder-5/>)"
msgstr ""
"<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>, "
"<placeholder-5/>)"

#: func.xml:15273(entry)
msgid "does user have privilege for column"
msgstr "имеет ли пользователь указанное право для столбца"

#: func.xml:15281(entry)
msgid "does current user have privilege for column"
msgstr "имеет ли текущий пользователь указанное право для столбца"

#: func.xml:15284(function) func.xml:15292(function)
msgid "has_database_privilege"
msgstr "has_database_privilege"

#: func.xml:15285(parameter) func.xml:15292(parameter)
msgid "database"
msgstr "database"

#: func.xml:15289(entry)
msgid "does user have privilege for database"
msgstr "имеет ли пользователь указанное право для базы данных"

#: func.xml:15296(entry)
msgid "does current user have privilege for database"
msgstr "имеет ли текущий пользователь указанное право для базы данных"

#: func.xml:15299(function) func.xml:15307(function)
msgid "has_foreign_data_wrapper_privilege"
msgstr "has_foreign_data_wrapper_privilege"

#: func.xml:15300(parameter) func.xml:15307(parameter)
msgid "fdw"
msgstr "fdw"

#: func.xml:15304(entry)
msgid "does user have privilege for foreign-data wrapper"
msgstr "имеет ли пользователь указанное право для обёртки сторонних данных"

#: func.xml:15311(entry)
msgid "does current user have privilege for foreign-data wrapper"
msgstr ""
"имеет ли текущий пользователь указанное право для обёртки сторонних данных"

#: func.xml:15314(function) func.xml:15322(function)
msgid "has_function_privilege"
msgstr "has_function_privilege"

#: func.xml:15315(parameter) func.xml:15322(parameter)
msgid "function"
msgstr "function"

#: func.xml:15319(entry)
msgid "does user have privilege for function"
msgstr "имеет ли пользователь указанное право для функции"

#: func.xml:15326(entry)
msgid "does current user have privilege for function"
msgstr "имеет ли текущий пользователь указанное право для функции"

#: func.xml:15329(function) func.xml:15337(function)
msgid "has_language_privilege"
msgstr "has_language_privilege"

#: func.xml:15330(parameter) func.xml:15337(parameter)
msgid "language"
msgstr "language"

#: func.xml:15334(entry)
msgid "does user have privilege for language"
msgstr "имеет ли пользователь указанное право для языка"

#: func.xml:15341(entry)
msgid "does current user have privilege for language"
msgstr "имеет ли текущий пользователь указанное право для языка"

#: func.xml:15344(function) func.xml:15352(function)
msgid "has_schema_privilege"
msgstr "has_schema_privilege"

#: func.xml:15345(parameter) func.xml:15352(parameter)
msgid "schema"
msgstr "schema"

#: func.xml:15349(entry)
msgid "does user have privilege for schema"
msgstr "имеет ли пользователь указанное право для схемы"

#: func.xml:15356(entry)
msgid "does current user have privilege for schema"
msgstr "имеет ли текущий пользователь указанное право для схемы"

#: func.xml:15359(function) func.xml:15367(function)
msgid "has_sequence_privilege"
msgstr "has_sequence_privilege"

#: func.xml:15360(parameter) func.xml:15367(parameter)
msgid "sequence"
msgstr "sequence"

#: func.xml:15364(entry)
msgid "does user have privilege for sequence"
msgstr "имеет ли пользователь указанное право для последовательности"

#: func.xml:15371(entry)
msgid "does current user have privilege for sequence"
msgstr "имеет ли текущий пользователь указанное право для последовательности"

#: func.xml:15374(function) func.xml:15382(function)
msgid "has_server_privilege"
msgstr "has_server_privilege"

#: func.xml:15375(parameter) func.xml:15382(parameter)
msgid "server"
msgstr "server"

#: func.xml:15379(entry)
msgid "does user have privilege for foreign server"
msgstr "имеет ли пользователь указанное право для стороннего сервера"

#: func.xml:15386(entry)
msgid "does current user have privilege for foreign server"
msgstr "имеет ли текущий пользователь указанное право для стороннего сервера"

#: func.xml:15389(function) func.xml:15397(function)
msgid "has_table_privilege"
msgstr "has_table_privilege"

#: func.xml:15394(entry)
msgid "does user have privilege for table"
msgstr "имеет ли пользователь указанное право для таблицы"

#: func.xml:15401(entry)
msgid "does current user have privilege for table"
msgstr "имеет ли текущий пользователь указанное право для таблицы"

#: func.xml:15404(function) func.xml:15412(function)
msgid "has_tablespace_privilege"
msgstr "has_tablespace_privilege"

#: func.xml:15405(parameter) func.xml:15412(parameter)
#: func.xml:18428(parameter)
msgid "tablespace"
msgstr "tablespace"

#: func.xml:15409(entry)
msgid "does user have privilege for tablespace"
msgstr "имеет ли пользователь указанное право для табличного пространства"

#: func.xml:15416(entry)
msgid "does current user have privilege for tablespace"
msgstr ""
"имеет ли текущий пользователь указанное право для табличного пространства"

#: func.xml:15419(function) func.xml:15427(function)
msgid "pg_has_role"
msgstr "pg_has_role"

#: func.xml:15420(parameter) func.xml:15427(parameter)
msgid "role"
msgstr "role"

#: func.xml:15424(entry)
msgid "does user have privilege for role"
msgstr "имеет ли пользователь указанное право для роли"

#: func.xml:15431(entry)
msgid "does current user have privilege for role"
msgstr "имеет ли текущий пользователь указанное право для роли"

#: func.xml:15434(function)
msgid "row_security_active"
msgstr "row_security_active"

#: func.xml:15437(entry)
msgid "does current user have row level security active for table"
msgstr ""
"включена ли для текущего пользователя защита на уровне строк для таблицы"

#: func.xml:15443(indexterm)
msgid "<primary>has_any_column_privilege</primary>"
msgstr "<primary>has_any_column_privilege</primary>"

#: func.xml:15446(indexterm)
msgid "<primary>has_column_privilege</primary>"
msgstr "<primary>has_column_privilege</primary>"

#: func.xml:15449(indexterm)
msgid "<primary>has_database_privilege</primary>"
msgstr "<primary>has_database_privilege</primary>"

#: func.xml:15452(indexterm)
msgid "<primary>has_function_privilege</primary>"
msgstr "<primary>has_function_privilege</primary>"

#: func.xml:15455(indexterm)
msgid "<primary>has_foreign_data_wrapper_privilege</primary>"
msgstr "<primary>has_foreign_data_wrapper_privilege</primary>"

#: func.xml:15458(indexterm)
msgid "<primary>has_language_privilege</primary>"
msgstr "<primary>has_language_privilege</primary>"

#: func.xml:15461(indexterm)
msgid "<primary>has_schema_privilege</primary>"
msgstr "<primary>has_schema_privilege</primary>"

#: func.xml:15464(indexterm)
msgid "<primary>has_server_privilege</primary>"
msgstr "<primary>has_server_privilege</primary>"

#: func.xml:15467(indexterm)
msgid "<primary>has_sequence_privilege</primary>"
msgstr "<primary>has_sequence_privilege</primary>"

#: func.xml:15470(indexterm)
msgid "<primary>has_table_privilege</primary>"
msgstr "<primary>has_table_privilege</primary>"

#: func.xml:15473(indexterm)
msgid "<primary>has_tablespace_privilege</primary>"
msgstr "<primary>has_tablespace_privilege</primary>"

#: func.xml:15476(indexterm)
msgid "<primary>pg_has_role</primary>"
msgstr "<primary>pg_has_role</primary>"

#: func.xml:15479(indexterm)
msgid "<primary>row_security_active</primary>"
msgstr "<primary>row_security_active</primary>"

#: func.xml:15506(programlisting)
#, no-wrap
msgid ""
"SELECT has_table_privilege('myschema.mytable', 'select');\n"
"SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');"
msgstr ""
"SELECT has_table_privilege('myschema.mytable', 'select');\n"
"SELECT has_table_privilege('joe', 'mytable',\n"
"  'INSERT, SELECT WITH GRANT OPTION');"

#: func.xml:15483(para)
msgid ""
"<function>has_table_privilege</function> checks whether a user can access a "
"table in a particular way. The user can be specified by name, by OID "
"(<literal>pg_authid.oid</literal>), <literal>public</literal> to indicate "
"the PUBLIC pseudo-role, or if the argument is omitted "
"<function>current_user</function> is assumed. The table can be specified by "
"name or by OID. (Thus, there are actually six variants of "
"<function>has_table_privilege</function>, which can be distinguished by the "
"number and types of their arguments.) When specifying by name, the name can "
"be schema-qualified if necessary. The desired access privilege type is "
"specified by a text string, which must evaluate to one of the values "
"<literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</"
"literal>, <literal>DELETE</literal>, <literal>TRUNCATE</literal>, "
"<literal>REFERENCES</literal>, or <literal>TRIGGER</literal>. Optionally, "
"<literal>WITH GRANT OPTION</literal> can be added to a privilege type to "
"test whether the privilege is held with grant option. Also, multiple "
"privilege types can be listed separated by commas, in which case the result "
"will be <literal>true</literal> if any of the listed privileges is held. "
"(Case of the privilege string is not significant, and extra whitespace is "
"allowed between but not within privilege names.) Some examples: "
"<placeholder-1/>"
msgstr ""
"<function>has_table_privilege</function> проверяет, может ли пользователь "
"выполнять с таблицей заданные действия. В качестве идентификатора "
"пользователя можно задать его имя, OID (<literal>pg_authid.oid</literal>) "
"или <literal>public</literal> (это будет указывать на псевдороль PUBLIC). "
"Если этот аргумент опущен, подразумевается текущий пользователь "
"(<function>current_user</function>). Таблицу можно указать по имени или по "
"OID. (Таким образом, фактически есть шесть вариантов функции "
"<function>has_table_privilege</function>, различающихся по числу и типу "
"аргументов.) Когда указывается имя объекта, его можно дополнить именем "
"схемы, если это необходимо. Интересующее право доступа записывается в виде "
"текста и может быть одним из следующих: <literal>SELECT</literal>, "
"<literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</"
"literal>, <literal>TRUNCATE</literal>, <literal>REFERENCES</literal> и "
"<literal>TRIGGER</literal>. Дополнительно к названию права можно добавить "
"<literal>WITH GRANT OPTION</literal> и проверить, разрешено ли пользователю "
"передавать это право другим. Кроме того, в одном параметре можно перечислить "
"несколько названий прав через запятую, и тогда функция возвратит "
"<literal>true</literal>, если пользователь имеет одно из этих прав. (Регистр "
"в названии прав не имеет значения, а между ними (но не внутри) разрешены "
"пробельные символы.) Пара примеров: <placeholder-1/>"

#: func.xml:15510(para)
msgid ""
"<function>has_sequence_privilege</function> checks whether a user can access "
"a sequence in a particular way. The possibilities for its arguments are "
"analogous to <function>has_table_privilege</function>. The desired access "
"privilege type must evaluate to one of <literal>USAGE</literal>, "
"<literal>SELECT</literal>, or <literal>UPDATE</literal>."
msgstr ""
"<function>has_sequence_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия с последовательностью. В определении аргументов "
"эта функция аналогична <function>has_table_privilege</function>. Допустимые "
"для неё права складываются из <literal>USAGE</literal>, <literal>SELECT</"
"literal> и <literal>UPDATE</literal>."

#: func.xml:15520(para)
msgid ""
"<function>has_any_column_privilege</function> checks whether a user can "
"access any column of a table in a particular way. Its argument possibilities "
"are analogous to <function>has_table_privilege</function>, except that the "
"desired access privilege type must evaluate to some combination of "
"<literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</"
"literal>, or <literal>REFERENCES</literal>. Note that having any of these "
"privileges at the table level implicitly grants it for each column of the "
"table, so <function>has_any_column_privilege</function> will always return "
"<literal>true</literal> if <function>has_table_privilege</function> does for "
"the same arguments. But <function>has_any_column_privilege</function> also "
"succeeds if there is a column-level grant of the privilege for at least one "
"column."
msgstr ""
"<function>has_any_column_privilege</function> проверяет, может ли "
"пользователь выполнять заданные действия с каким-либо столбцом таблицы. В "
"определении аргументов эта функция аналогична <function>has_table_privilege</"
"function>, а допустимые права складываются из <literal>SELECT</literal>, "
"<literal>INSERT</literal>, <literal>UPDATE</literal> и <literal>REFERENCES</"
"literal>. Заметьте, что любое из этих прав, назначенное на уровне таблицы, "
"автоматически распространяется на все её столбцы, так что "
"<function>has_any_column_privilege</function> всегда возвращает "
"<literal>true</literal>, если <function>has_table_privilege</function> даёт "
"положительный ответ для тех же аргументов. Но "
"<function>has_any_column_privilege</function> возвращает <literal>true</"
"literal> ещё и тогда, когда право назначено только для некоторых столбцов."

#: func.xml:15538(para)
msgid ""
"<function>has_column_privilege</function> checks whether a user can access a "
"column in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>, with the addition that the column "
"can be specified either by name or attribute number. The desired access "
"privilege type must evaluate to some combination of <literal>SELECT</"
"literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>, or "
"<literal>REFERENCES</literal>. Note that having any of these privileges at "
"the table level implicitly grants it for each column of the table."
msgstr ""
"<function>has_column_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия со столбцом таблицы. В определении аргументов "
"эта функция аналогична <function>has_table_privilege</function>, с небольшим "
"дополнением: столбец можно задать по имени или номеру атрибута. Для неё "
"допустимые права складываются из <literal>SELECT</literal>, <literal>INSERT</"
"literal>, <literal>UPDATE</literal> и <literal>REFERENCES</literal>. "
"Заметьте, что любое из этих прав, назначенное на уровне таблицы, "
"автоматически распространяется на все столбцы таблицы."

#: func.xml:15553(para)
msgid ""
"<function>has_database_privilege</function> checks whether a user can access "
"a database in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>. The desired access privilege type "
"must evaluate to some combination of <literal>CREATE</literal>, "
"<literal>CONNECT</literal>, <literal>TEMPORARY</literal>, or <literal>TEMP</"
"literal> (which is equivalent to <literal>TEMPORARY</literal>)."
msgstr ""
"<function>has_database_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия с базой данных. В определении аргументов эта "
"функция аналогична <function>has_table_privilege</function>. Для неё "
"допустимые права складываются из <literal>CREATE</literal>, "
"<literal>CONNECT</literal> и <literal>TEMPORARY</literal> (или "
"<literal>TEMP</literal>, что равносильно <literal>TEMPORARY</literal>)."

#: func.xml:15577(programlisting)
#, no-wrap
msgid "SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');"
msgstr "SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');"

#: func.xml:15566(para)
msgid ""
"<function>has_function_privilege</function> checks whether a user can access "
"a function in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>. When specifying a function by a "
"text string rather than by OID, the allowed input is the same as for the "
"<type>regprocedure</type> data type (see <xref linkend=\"datatype-oid\"/>). "
"The desired access privilege type must evaluate to <literal>EXECUTE</"
"literal>. An example is: <placeholder-1/>"
msgstr ""
"<function>has_function_privilege</function> проверяет, может ли пользователь "
"обратиться к заданной функции. В определении аргументов эта функция "
"аналогична <function>has_table_privilege</function>. Когда функция "
"определяется не своим OID, а текстовой строкой, эта строка должна быть "
"допустимой для вводимого значения типа <type>regprocedure</type> (см. <xref "
"remap=\"4\" linkend=\"datatype-oid\"/>). Для этой функции допустимо только "
"право <literal>EXECUTE</literal>. Например: <placeholder-1/>"

#: func.xml:15580(para)
msgid ""
"<function>has_foreign_data_wrapper_privilege</function> checks whether a "
"user can access a foreign-data wrapper in a particular way. Its argument "
"possibilities are analogous to <function>has_table_privilege</function>. The "
"desired access privilege type must evaluate to <literal>USAGE</literal>."
msgstr ""
"<function>has_foreign_data_wrapper_privilege</function> проверяет, может ли "
"пользователь обращаться к обёртке сторонних данных. В определении аргументов "
"она аналогична <function>has_table_privilege</function>. Для неё допустимо "
"только право <literal>USAGE</literal>."

#: func.xml:15589(para)
msgid ""
"<function>has_language_privilege</function> checks whether a user can access "
"a procedural language in a particular way. Its argument possibilities are "
"analogous to <function>has_table_privilege</function>. The desired access "
"privilege type must evaluate to <literal>USAGE</literal>."
msgstr ""
"<function>has_language_privilege</function> проверяет, может ли пользователь "
"обращаться к процедурному языку. В определении аргументов эта функция "
"аналогична <function>has_table_privilege</function>. Для неё допустимо "
"только право <literal>USAGE</literal>."

#: func.xml:15598(para)
msgid ""
"<function>has_schema_privilege</function> checks whether a user can access a "
"schema in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>. The desired access privilege type "
"must evaluate to some combination of <literal>CREATE</literal> or "
"<literal>USAGE</literal>."
msgstr ""
"<function>has_schema_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия со схемой. В определении аргументов эта функция "
"аналогична <function>has_table_privilege</function>. Для неё допустимые "
"права складываются из <literal>CREATE</literal> и <literal>USAGE</literal>."

#: func.xml:15608(para)
msgid ""
"<function>has_server_privilege</function> checks whether a user can access a "
"foreign server in a particular way. Its argument possibilities are analogous "
"to <function>has_table_privilege</function>. The desired access privilege "
"type must evaluate to <literal>USAGE</literal>."
msgstr ""
"<function>has_server_privilege</function> проверяет, может ли пользователь "
"обращаться к стороннему серверу. В определении аргументов она аналогична "
"<function>has_table_privilege</function>. Для неё допустимо только право "
"<literal>USAGE</literal>."

#: func.xml:15617(para)
msgid ""
"<function>has_tablespace_privilege</function> checks whether a user can "
"access a tablespace in a particular way. Its argument possibilities are "
"analogous to <function>has_table_privilege</function>. The desired access "
"privilege type must evaluate to <literal>CREATE</literal>."
msgstr ""
"<function>has_tablespace_privilege</function> проверяет, может ли "
"пользователь выполнять заданное действие в табличном пространстве. В "
"определении аргументов эта функция аналогична <function>has_table_privilege</"
"function>. Для неё допустимо только право <literal>CREATE</literal>."

#: func.xml:15626(para)
msgid ""
"<function>pg_has_role</function> checks whether a user can access a role in "
"a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>, except that <literal>public</"
"literal> is not allowed as a user name. The desired access privilege type "
"must evaluate to some combination of <literal>MEMBER</literal> or "
"<literal>USAGE</literal>. <literal>MEMBER</literal> denotes direct or "
"indirect membership in the role (that is, the right to do <command>SET ROLE</"
"command>), while <literal>USAGE</literal> denotes whether the privileges of "
"the role are immediately available without doing <command>SET ROLE</command>."
msgstr ""
"<function>pg_has_role</function> проверяет, может ли пользователь выполнять "
"заданные действия с ролью. В определении аргументов эта функция аналогична "
"<function>has_table_privilege</function>, за исключением того, что именем "
"пользователя не может быть <literal>public</literal>. Для неё допустимые "
"права складываются из <literal>MEMBER</literal> и <literal>USAGE</literal>. "
"<literal>MEMBER</literal> обозначает прямое или косвенное членство в данной "
"роли (то есть наличие права выполнить команду <command>SET ROLE</command>), "
"тогда как <literal>USAGE</literal> показывает, что пользователь получает все "
"права роли сразу, без <command>SET ROLE</command>."

#: func.xml:15641(para)
msgid ""
"<function>row_security_active</function> checks whether row level security "
"is active for the specified table in the context of the "
"<function>current_user</function> and environment. The table can be "
"specified by name or by OID."
msgstr ""
"<function>row_security_active</function> проверяет, включена ли защита на "
"уровне строк для указанной таблицы в контексте и окружении текущего "
"пользователя (<function>current_user</function>). Таблицу можно задать по "
"имени или OID."

#: func.xml:15657(programlisting)
#, no-wrap
msgid "SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);"
msgstr "SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);"

#: func.xml:15648(para)
msgid ""
"<xref linkend=\"functions-info-schema-table\"/> shows functions that "
"determine whether a certain object is <firstterm>visible</firstterm> in the "
"current schema search path. For example, a table is said to be visible if "
"its containing schema is in the search path and no table of the same name "
"appears earlier in the search path. This is equivalent to the statement that "
"the table can be referenced by name without explicit schema qualification. "
"To list the names of all visible tables: <placeholder-1/>"
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-schema-table\"/> перечислены "
"функции, определяющие <firstterm>видимость</firstterm> объекта с текущим "
"путём поиска схем. К примеру, таблица считается видимой, если содержащая её "
"схема включена в путь поиска и нет другой таблицы с тем же именем, которая "
"была бы найдена по пути поиска раньше. Другими словами, к этой таблице можно "
"будет обратиться просто по её имени, без явного указания схемы. Просмотреть "
"список всех видимых таблиц можно так: <placeholder-1/>"

#: func.xml:15660(indexterm)
msgid "<primary>search path</primary><secondary>object visibility</secondary>"
msgstr ""
"<primary>путь поиска</primary><secondary>видимость объектов</secondary>"

#: func.xml:15665(title)
msgid "Schema Visibility Inquiry Functions"
msgstr "Функции для определения видимости"

#: func.xml:15673(parameter)
msgid "collation_oid"
msgstr "collation_oid"

#: func.xml:15673(function)
msgid "pg_collation_is_visible(<placeholder-1/>)"
msgstr "pg_collation_is_visible(<placeholder-1/>)"

#: func.xml:15676(entry)
msgid "is collation visible in search path"
msgstr "видимо ли правило сортировки"

#: func.xml:15679(parameter)
msgid "conversion_oid"
msgstr "conversion_oid"

#: func.xml:15679(function)
msgid "pg_conversion_is_visible(<placeholder-1/>)"
msgstr "pg_conversion_is_visible(<placeholder-1/>)"

#: func.xml:15682(entry)
msgid "is conversion visible in search path"
msgstr "видимо ли преобразование"

#: func.xml:15685(parameter)
msgid "function_oid"
msgstr "function_oid"

#: func.xml:15685(function)
msgid "pg_function_is_visible(<placeholder-1/>)"
msgstr "pg_function_is_visible(<placeholder-1/>)"

#: func.xml:15688(entry)
msgid "is function visible in search path"
msgstr "видима ли функция"

#: func.xml:15691(parameter) func.xml:15703(parameter)
msgid "opclass_oid"
msgstr "opclass_oid"

#: func.xml:15691(function)
msgid "pg_opclass_is_visible(<placeholder-1/>)"
msgstr "pg_opclass_is_visible(<placeholder-1/>)"

#: func.xml:15694(entry)
msgid "is operator class visible in search path"
msgstr "видим ли класс операторов"

#: func.xml:15697(parameter)
msgid "operator_oid"
msgstr "operator_oid"

#: func.xml:15697(function)
msgid "pg_operator_is_visible(<placeholder-1/>)"
msgstr "pg_operator_is_visible(<placeholder-1/>)"

#: func.xml:15700(entry)
msgid "is operator visible in search path"
msgstr "видим ли оператор"

#: func.xml:15703(function)
msgid "pg_opfamily_is_visible(<placeholder-1/>)"
msgstr "pg_opfamily_is_visible(<placeholder-1/>)"

#: func.xml:15706(entry)
msgid "is operator family visible in search path"
msgstr "видимо ли семейство операторов"

#: func.xml:15709(parameter) func.xml:16407(parameter)
msgid "table_oid"
msgstr "table_oid"

#: func.xml:15709(function)
msgid "pg_table_is_visible(<placeholder-1/>)"
msgstr "pg_table_is_visible(<placeholder-1/>)"

#: func.xml:15712(entry)
msgid "is table visible in search path"
msgstr "видима ли таблица"

#: func.xml:15715(parameter)
msgid "config_oid"
msgstr "config_oid"

#: func.xml:15715(function)
msgid "pg_ts_config_is_visible(<placeholder-1/>)"
msgstr "pg_ts_config_is_visible(<placeholder-1/>)"

#: func.xml:15718(entry)
msgid "is text search configuration visible in search path"
msgstr "видима ли конфигурация текстового поиска"

#: func.xml:15721(parameter)
msgid "dict_oid"
msgstr "dict_oid"

#: func.xml:15721(function)
msgid "pg_ts_dict_is_visible(<placeholder-1/>)"
msgstr "pg_ts_dict_is_visible(<placeholder-1/>)"

#: func.xml:15724(entry)
msgid "is text search dictionary visible in search path"
msgstr "видим ли словарь текстового поиска"

#: func.xml:15727(parameter)
msgctxt "parameter"
msgid "parser_oid"
msgstr "parser_oid"

#: func.xml:15727(function)
msgid "pg_ts_parser_is_visible(<placeholder-1/>)"
msgstr "pg_ts_parser_is_visible(<placeholder-1/>)"

#: func.xml:15730(entry)
msgid "is text search parser visible in search path"
msgstr "видим ли анализатор текстового поиска"

#: func.xml:15733(parameter)
msgid "template_oid"
msgstr "template_oid"

#: func.xml:15733(function)
msgid "pg_ts_template_is_visible(<placeholder-1/>)"
msgstr "pg_ts_template_is_visible(<placeholder-1/>)"

#: func.xml:15736(entry)
msgid "is text search template visible in search path"
msgstr "видим ли шаблон текстового поиска"

#: func.xml:15739(parameter) func.xml:15930(parameter)
msgid "type_oid"
msgstr "type_oid"

#: func.xml:15739(function)
msgid "pg_type_is_visible(<placeholder-1/>)"
msgstr "pg_type_is_visible(<placeholder-1/>)"

#: func.xml:15742(entry)
msgid "is type (or domain) visible in search path"
msgstr "видим ли тип (или домен)"

#: func.xml:15748(indexterm)
msgid "<primary>pg_collation_is_visible</primary>"
msgstr "<primary>pg_collation_is_visible</primary>"

#: func.xml:15751(indexterm)
msgid "<primary>pg_conversion_is_visible</primary>"
msgstr "<primary>pg_conversion_is_visible</primary>"

#: func.xml:15754(indexterm)
msgid "<primary>pg_function_is_visible</primary>"
msgstr "<primary>pg_function_is_visible</primary>"

#: func.xml:15757(indexterm)
msgid "<primary>pg_opclass_is_visible</primary>"
msgstr "<primary>pg_opclass_is_visible</primary>"

#: func.xml:15760(indexterm)
msgid "<primary>pg_operator_is_visible</primary>"
msgstr "<primary>pg_operator_is_visible</primary>"

#: func.xml:15763(indexterm)
msgid "<primary>pg_opfamily_is_visible</primary>"
msgstr "<primary>pg_opfamily_is_visible</primary>"

#: func.xml:15766(indexterm)
msgid "<primary>pg_table_is_visible</primary>"
msgstr "<primary>pg_table_is_visible</primary>"

#: func.xml:15769(indexterm)
msgid "<primary>pg_ts_config_is_visible</primary>"
msgstr "<primary>pg_ts_config_is_visible</primary>"

#: func.xml:15772(indexterm)
msgid "<primary>pg_ts_dict_is_visible</primary>"
msgstr "<primary>pg_ts_dict_is_visible</primary>"

#: func.xml:15775(indexterm)
msgid "<primary>pg_ts_parser_is_visible</primary>"
msgstr "<primary>pg_ts_parser_is_visible</primary>"

#: func.xml:15778(indexterm)
msgid "<primary>pg_ts_template_is_visible</primary>"
msgstr "<primary>pg_ts_template_is_visible</primary>"

#: func.xml:15781(indexterm)
msgid "<primary>pg_type_is_visible</primary>"
msgstr "<primary>pg_type_is_visible</primary>"

#: func.xml:15785(para)
msgid ""
"Each function performs the visibility check for one type of database object. "
"Note that <function>pg_table_is_visible</function> can also be used with "
"views, materialized views, indexes, sequences and foreign tables; "
"<function>pg_type_is_visible</function> can also be used with domains. For "
"functions and operators, an object in the search path is visible if there is "
"no object of the same name <emphasis>and argument data type(s)</emphasis> "
"earlier in the path. For operator classes, both name and associated index "
"access method are considered."
msgstr ""
"Каждая из этих функций проверяет видимость объектов определённого типа. "
"Заметьте, что <function>pg_table_is_visible</function> можно также "
"использовать для представлений, материализованных представлений, индексов, "
"последовательностей и сторонних таблиц; <function>pg_type_is_visible</"
"function> можно также использовать и для доменов. Для функций и операторов "
"объект считается видимым в пути поиска, если при просмотре пути не находится "
"предшествующий ему другой объект с тем же именем <emphasis>и типами "
"аргументов</emphasis>. Для классов операторов во внимание принимается и имя "
"оператора, и связанный с ним метод доступа к индексу."

#: func.xml:15803(programlisting)
#, no-wrap
msgid "SELECT pg_type_is_visible('myschema.widget'::regtype);"
msgstr "SELECT pg_type_is_visible('myschema.widget'::regtype);"

#: func.xml:15796(para)
msgid ""
"All these functions require object OIDs to identify the object to be "
"checked. If you want to test an object by name, it is convenient to use the "
"OID alias types (<type>regclass</type>, <type>regtype</type>, "
"<type>regprocedure</type>, <type>regoperator</type>, <type>regconfig</type>, "
"or <type>regdictionary</type>), for example: <placeholder-1/> Note that it "
"would not make much sense to test a non-schema-qualified type name in this "
"way &mdash; if the name can be recognized at all, it must be visible."
msgstr ""
"Всем этим функциям должен передаваться OID проверяемого объекта. Если вы "
"хотите проверить объект по имени, удобнее использовать типы-псевдонимы OID "
"(<type>regclass</type>, <type>regtype</type>, <type>regprocedure</type>, "
"<type>regoperator</type>, <type>regconfig</type> или <type>regdictionary</"
"type>), например: <placeholder-1/> Заметьте, что проверять таким способом "
"имена без указания схемы не имеет большого смысла &mdash; если имя удастся "
"распознать, значит и объект будет видимым."

#: func.xml:15808(indexterm)
msgid "<primary>format_type</primary>"
msgstr "<primary>format_type</primary>"

#: func.xml:15812(indexterm)
msgid "<primary>pg_get_constraintdef</primary>"
msgstr "<primary>pg_get_constraintdef</primary>"

#: func.xml:15816(indexterm)
msgid "<primary>pg_get_expr</primary>"
msgstr "<primary>pg_get_expr</primary>"

#: func.xml:15820(indexterm)
msgid "<primary>pg_get_functiondef</primary>"
msgstr "<primary>pg_get_functiondef</primary>"

#: func.xml:15824(indexterm)
msgid "<primary>pg_get_function_arguments</primary>"
msgstr "<primary>pg_get_function_arguments</primary>"

#: func.xml:15828(indexterm)
msgid "<primary>pg_get_function_identity_arguments</primary>"
msgstr "<primary>pg_get_function_identity_arguments</primary>"

#: func.xml:15832(indexterm)
msgid "<primary>pg_get_function_result</primary>"
msgstr "<primary>pg_get_function_result</primary>"

#: func.xml:15836(indexterm)
msgid "<primary>pg_get_indexdef</primary>"
msgstr "<primary>pg_get_indexdef</primary>"

#: func.xml:15840(indexterm)
msgid "<primary>pg_get_keywords</primary>"
msgstr "<primary>pg_get_keywords</primary>"

#: func.xml:15844(indexterm)
msgid "<primary>pg_get_ruledef</primary>"
msgstr "<primary>pg_get_ruledef</primary>"

#: func.xml:15848(indexterm)
msgid "<primary>pg_get_serial_sequence</primary>"
msgstr "<primary>pg_get_serial_sequence</primary>"

#: func.xml:15852(indexterm)
msgid "<primary>pg_get_triggerdef</primary>"
msgstr "<primary>pg_get_triggerdef</primary>"

#: func.xml:15856(indexterm)
msgid "<primary>pg_get_userbyid</primary>"
msgstr "<primary>pg_get_userbyid</primary>"

#: func.xml:15860(indexterm)
msgid "<primary>pg_get_viewdef</primary>"
msgstr "<primary>pg_get_viewdef</primary>"

#: func.xml:15864(indexterm)
msgid "<primary>pg_options_to_table</primary>"
msgstr "<primary>pg_options_to_table</primary>"

#: func.xml:15868(indexterm)
msgid "<primary>pg_tablespace_databases</primary>"
msgstr "<primary>pg_tablespace_databases</primary>"

#: func.xml:15872(indexterm)
msgid "<primary>pg_tablespace_location</primary>"
msgstr "<primary>pg_tablespace_location</primary>"

#: func.xml:15876(indexterm)
msgid "<primary>pg_typeof</primary>"
msgstr "<primary>pg_typeof</primary>"

#: func.xml:15880(indexterm)
msgid "<primary>collation for</primary>"
msgstr "<primary>collation for</primary>"

#: func.xml:15884(indexterm)
msgid "<primary>to_regclass</primary>"
msgstr "<primary>to_regclass</primary>"

#: func.xml:15888(indexterm)
msgid "<primary>to_regproc</primary>"
msgstr "<primary>to_regproc</primary>"

#: func.xml:15892(indexterm)
msgid "<primary>to_regprocedure</primary>"
msgstr "<primary>to_regprocedure</primary>"

#: func.xml:15896(indexterm)
msgid "<primary>to_regoper</primary>"
msgstr "<primary>to_regoper</primary>"

#: func.xml:15900(indexterm)
msgid "<primary>to_regoperator</primary>"
msgstr "<primary>to_regoperator</primary>"

#: func.xml:15904(indexterm)
msgid "<primary>to_regtype</primary>"
msgstr "<primary>to_regtype</primary>"

#: func.xml:15908(indexterm)
msgid "<primary>to_regnamespace</primary>"
msgstr "<primary>to_regnamespace</primary>"

#: func.xml:15912(indexterm)
msgid "<primary>to_regrole</primary>"
msgstr "<primary>to_regrole</primary>"

#: func.xml:15916(para)
msgid ""
"<xref linkend=\"functions-info-catalog-table\"/> lists functions that "
"extract information from the system catalogs."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-catalog-table\"/> перечислены "
"функции, извлекающие информацию из системных каталогов."

#: func.xml:15922(title)
msgid "System Catalog Information Functions"
msgstr "Функции для обращения к системным каталогам"

#: func.xml:15930(parameter)
msgid "typemod"
msgstr "typemod"

#: func.xml:15930(function)
msgid "format_type(<placeholder-1/>, <placeholder-2/>)"
msgstr "format_type(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:15932(entry)
msgid "get SQL name of a data type"
msgstr "получает имя типа данных в формате SQL"

#: func.xml:15935(parameter) func.xml:15940(parameter)
msgid "constraint_oid"
msgstr "constraint_oid"

#: func.xml:15935(function)
msgid "pg_get_constraintdef(<placeholder-1/>)"
msgstr "pg_get_constraintdef(<placeholder-1/>)"

#: func.xml:15937(entry) func.xml:15942(entry)
msgid "get definition of a constraint"
msgstr "получает определение ограничения"

#: func.xml:15940(parameter) func.xml:15951(parameter)
#: func.xml:15982(parameter) func.xml:15999(parameter)
#: func.xml:16030(parameter) func.xml:16040(parameter)
msgid "pretty_bool"
msgstr "pretty_bool"

#: func.xml:15940(function)
msgid "pg_get_constraintdef(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_constraintdef(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:15945(parameter) func.xml:15951(parameter)
msgid "pg_node_tree"
msgstr "pg_node_tree"

#: func.xml:15945(parameter) func.xml:15951(parameter)
msgid "relation_oid"
msgstr "relation_oid"

#: func.xml:15945(function)
msgid "pg_get_expr(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_expr(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:15947(entry) func.xml:15953(entry)
msgid ""
"decompile internal form of an expression, assuming that any Vars in it refer "
"to the relation indicated by the second parameter"
msgstr ""
"декомпилирует внутреннюю форму выражения, в предположении, что все "
"переменные в нём ссылаются на таблицу или отношение, указанное вторым "
"параметром"

#: func.xml:15951(function)
msgid "pg_get_expr(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "pg_get_expr(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:15957(parameter) func.xml:15962(parameter)
#: func.xml:15967(parameter) func.xml:15972(parameter)
msgid "func_oid"
msgstr "func_oid"

#: func.xml:15957(function)
msgid "pg_get_functiondef(<placeholder-1/>)"
msgstr "pg_get_functiondef(<placeholder-1/>)"

#: func.xml:15959(entry)
msgid "get definition of a function"
msgstr "получает определение функции"

#: func.xml:15962(function)
msgid "pg_get_function_arguments(<placeholder-1/>)"
msgstr "pg_get_function_arguments(<placeholder-1/>)"

#: func.xml:15964(entry)
msgid "get argument list of function's definition (with default values)"
msgstr ""
"получает список аргументов из определения функции (со значениями по "
"умолчанию)"

#: func.xml:15967(function)
msgid "pg_get_function_identity_arguments(<placeholder-1/>)"
msgstr "pg_get_function_identity_arguments(<placeholder-1/>)"

#: func.xml:15969(entry)
msgid "get argument list to identify a function (without default values)"
msgstr ""
"получает список аргументов, идентифицирующий функцию (без значений по "
"умолчанию)"

#: func.xml:15972(function)
msgid "pg_get_function_result(<placeholder-1/>)"
msgstr "pg_get_function_result(<placeholder-1/>)"

#: func.xml:15974(entry)
msgid "get <literal>RETURNS</literal> clause for function"
msgstr "получает предложение <literal>RETURNS</literal> для функции"

#: func.xml:15977(parameter) func.xml:15982(parameter)
#: func.xml:18496(parameter)
msgid "index_oid"
msgstr "index_oid"

#: func.xml:15977(function)
msgid "pg_get_indexdef(<placeholder-1/>)"
msgstr "pg_get_indexdef(<placeholder-1/>)"

#: func.xml:15979(entry)
msgid "get <command>CREATE INDEX</command> command for index"
msgstr "получает команду <command>CREATE INDEX</command> для индекса"

#: func.xml:15982(parameter)
msgid "column_no"
msgstr "column_no"

#: func.xml:15982(function)
msgid "pg_get_indexdef(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "pg_get_indexdef(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:15984(entry)
msgid ""
"get <command>CREATE INDEX</command> command for index, or definition of just "
"one index column when <parameter>column_no</parameter> is not zero"
msgstr ""
"получает команду <command>CREATE INDEX</command> для индекса или определение "
"одного индексированного столбца, когда <parameter>column_no</parameter> не "
"равен 0"

#: func.xml:15989(function)
msgid "pg_get_keywords()"
msgstr "pg_get_keywords()"

#: func.xml:15991(entry)
msgid "get list of SQL keywords and their categories"
msgstr "получает список ключевых слов SQL по категориям"

#: func.xml:15994(parameter) func.xml:15999(parameter)
msgid "rule_oid"
msgstr "rule_oid"

#: func.xml:15994(function)
msgid "pg_get_ruledef(<placeholder-1/>)"
msgstr "pg_get_ruledef(<placeholder-1/>)"

#: func.xml:15996(entry) func.xml:16001(entry)
msgid "get <command>CREATE RULE</command> command for rule"
msgstr "получает команду <command>CREATE RULE</command> для правила"

#: func.xml:15999(function)
msgid "pg_get_ruledef(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_ruledef(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16004(parameter)
msgid "table_name"
msgstr "table_name"

#: func.xml:16004(parameter)
msgid "column_name"
msgstr "column_name"

#: func.xml:16004(function)
msgid "pg_get_serial_sequence(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_serial_sequence(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16006(entry)
msgid ""
"get name of the sequence that a <type>serial</type>, <type>smallserial</"
"type> or <type>bigserial</type> column uses"
msgstr ""
"получает имя последовательности, связанной со столбцом типа <type>serial</"
"type>, <type>smallserial</type> или <type>bigserial</type>"

#: func.xml:16010(entry)
msgid ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)"
msgstr ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)"

#: func.xml:16012(entry) func.xml:16017(entry)
msgid ""
"get <command>CREATE [ CONSTRAINT ] TRIGGER</command> command for trigger"
msgstr ""
"получает команду <command>CREATE [ CONSTRAINT ] TRIGGER</command> для "
"триггера"

#: func.xml:16015(entry)
msgid ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, "
"<parameter>pretty_bool</parameter>)"
msgstr ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, "
"<parameter>pretty_bool</parameter>)"

#: func.xml:16020(parameter)
msgid "role_oid"
msgstr "role_oid"

#: func.xml:16020(function)
msgid "pg_get_userbyid(<placeholder-1/>)"
msgstr "pg_get_userbyid(<placeholder-1/>)"

#: func.xml:16022(entry)
msgid "get role name with given OID"
msgstr "получает имя роли по заданному OID"

#: func.xml:16025(parameter) func.xml:16030(parameter)
msgid "view_name"
msgstr "view_name"

#: func.xml:16025(function) func.xml:16035(function)
msgid "pg_get_viewdef(<placeholder-1/>)"
msgstr "pg_get_viewdef(<placeholder-1/>)"

#: func.xml:16027(entry) func.xml:16032(entry)
msgid ""
"get underlying <command>SELECT</command> command for view or materialized "
"view (<emphasis>deprecated</emphasis>)"
msgstr ""
"получает команду <command>SELECT</command>, определяющую представление или "
"материализованное представление (<emphasis>устаревшая</emphasis> функция)"

#: func.xml:16030(function) func.xml:16040(function) func.xml:16045(function)
msgid "pg_get_viewdef(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_viewdef(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16035(parameter) func.xml:16040(parameter)
#: func.xml:16045(parameter)
msgid "view_oid"
msgstr "view_oid"

#: func.xml:16037(entry) func.xml:16042(entry)
msgid ""
"get underlying <command>SELECT</command> command for view or materialized "
"view"
msgstr ""
"получает команду <command>SELECT</command>, определяющую представление или "
"материализованное представление"

#: func.xml:16045(parameter)
msgid "wrap_column_int"
msgstr "wrap_column_int"

#: func.xml:16047(entry)
msgid ""
"get underlying <command>SELECT</command> command for view or materialized "
"view; lines with fields are wrapped to specified number of columns, pretty-"
"printing is implied"
msgstr ""
"получает команду <command>SELECT</command>, определяющую представление или "
"материализованное представление; при необходимости разбивает строки с "
"полями, выходящие за wrap_int символов, подразумевая форматированный вывод"

#: func.xml:16052(parameter)
msgid "reloptions"
msgstr "reloptions"

#: func.xml:16052(function)
msgid "pg_options_to_table(<placeholder-1/>)"
msgstr "pg_options_to_table(<placeholder-1/>)"

#: func.xml:16054(entry)
msgid "get the set of storage option name/value pairs"
msgstr "получает набор параметров хранилища в виде имя/значение"

#: func.xml:16057(parameter) func.xml:16062(parameter)
msgid "tablespace_oid"
msgstr "tablespace_oid"

#: func.xml:16057(function)
msgid "pg_tablespace_databases(<placeholder-1/>)"
msgstr "pg_tablespace_databases(<placeholder-1/>)"

#: func.xml:16058(type)
msgid "setof oid"
msgstr "setof oid"

#: func.xml:16059(entry)
msgid "get the set of database OIDs that have objects in the tablespace"
msgstr ""
"получает или устанавливает OID баз данных, объекты которых содержатся в "
"заданном табличном пространстве"

#: func.xml:16062(function)
msgid "pg_tablespace_location(<placeholder-1/>)"
msgstr "pg_tablespace_location(<placeholder-1/>)"

#: func.xml:16064(entry)
msgid "get the path in the file system that this tablespace is located in"
msgstr ""
"получает путь в файловой системе к местоположению заданного табличного "
"пространства"

#: func.xml:16067(parameter) func.xml:16072(parameter)
msgctxt "parameter"
msgid "any"
msgstr "any"

#: func.xml:16067(function)
msgid "pg_typeof(<placeholder-1/>)"
msgstr "pg_typeof(<placeholder-1/>)"

#: func.xml:16068(type) func.xml:16103(type)
msgid "regtype"
msgstr "regtype"

#: func.xml:16069(entry)
msgid "get the data type of any value"
msgstr "получает тип данных любого значения"

#: func.xml:16072(function)
msgid "collation for (<placeholder-1/>)"
msgstr "collation for (<placeholder-1/>)"

#: func.xml:16074(entry)
msgid "get the collation of the argument"
msgstr "получает правило сортировки для аргумента"

#: func.xml:16077(parameter)
msgid "rel_name"
msgstr "rel_name"

#: func.xml:16077(function)
msgid "to_regclass(<placeholder-1/>)"
msgstr "to_regclass(<placeholder-1/>)"

#: func.xml:16079(entry)
msgid "get the OID of the named relation"
msgstr "получает OID указанного отношения"

#: func.xml:16082(parameter) func.xml:16087(parameter)
msgid "func_name"
msgstr "func_name"

#: func.xml:16082(function)
msgid "to_regproc(<placeholder-1/>)"
msgstr "to_regproc(<placeholder-1/>)"

#: func.xml:16083(type)
msgid "regproc"
msgstr "regproc"

#: func.xml:16084(entry) func.xml:16089(entry)
msgid "get the OID of the named function"
msgstr "получает OID указанной функции"

#: func.xml:16087(function)
msgid "to_regprocedure(<placeholder-1/>)"
msgstr "to_regprocedure(<placeholder-1/>)"

#: func.xml:16088(type)
msgid "regprocedure"
msgstr "regprocedure"

#: func.xml:16092(parameter) func.xml:16097(parameter)
msgid "operator_name"
msgstr "имя_оператора"

#: func.xml:16092(function)
msgid "to_regoper(<placeholder-1/>)"
msgstr "to_regoper(<placeholder-1/>)"

#: func.xml:16093(type)
msgid "regoper"
msgstr "regoper"

#: func.xml:16094(entry) func.xml:16099(entry)
msgid "get the OID of the named operator"
msgstr "получает OID указанного оператора"

#: func.xml:16097(function)
msgid "to_regoperator(<placeholder-1/>)"
msgstr "to_regoperator(<placeholder-1/>)"

#: func.xml:16098(type)
msgid "regoperator"
msgstr "regoperator"

#: func.xml:16102(parameter)
msgid "type_name"
msgstr "type_name"

#: func.xml:16102(function)
msgid "to_regtype(<placeholder-1/>)"
msgstr "to_regtype(<placeholder-1/>)"

#: func.xml:16104(entry)
msgid "get the OID of the named type"
msgstr "получает OID указанного типа"

#: func.xml:16107(parameter)
msgctxt "parameter"
msgid "schema_name"
msgstr "schema_name"

#: func.xml:16107(function)
msgid "to_regnamespace(<placeholder-1/>)"
msgstr "to_regnamespace(<placeholder-1/>)"

#: func.xml:16108(type)
msgid "regnamespace"
msgstr "relnamespace"

#: func.xml:16109(entry)
msgid "get the OID of the named schema"
msgstr "получает OID указанной схемы"

#: func.xml:16112(parameter)
msgid "role_name"
msgstr "role_name"

#: func.xml:16112(function)
msgid "to_regrole(<placeholder-1/>)"
msgstr "to_regrole(<placeholder-1/>)"

#: func.xml:16113(type)
msgid "regrole"
msgstr "role"

#: func.xml:16114(entry)
msgid "get the OID of the named role"
msgstr "получает OID указанной роли"

#: func.xml:16120(para)
msgid ""
"<function>format_type</function> returns the SQL name of a data type that is "
"identified by its type OID and possibly a type modifier. Pass NULL for the "
"type modifier if no specific modifier is known."
msgstr ""
"<function>format_type</function> возвращает в формате SQL имя типа данных, "
"определяемого по OID и, возможно, модификатору типа. Если модификатор "
"неизвестен, вместо него можно передать NULL."

#: func.xml:16126(para)
msgid ""
"<function>pg_get_keywords</function> returns a set of records describing the "
"SQL keywords recognized by the server. The <structfield>word</structfield> "
"column contains the keyword. The <structfield>catcode</structfield> column "
"contains a category code: <literal>U</literal> for unreserved, <literal>C</"
"literal> for column name, <literal>T</literal> for type or function name, or "
"<literal>R</literal> for reserved. The <structfield>catdesc</structfield> "
"column contains a possibly-localized string describing the category."
msgstr ""
"<function>pg_get_keywords</function> возвращает таблицу с ключевыми словами "
"SQL, которые воспринимает сервер. Столбец <structfield>word</structfield> "
"содержит ключевое слово, а <structfield>catcode</structfield> &mdash; код "
"категории: <literal>U</literal> &mdash; не зарезервировано, <literal>C</"
"literal> &mdash; имя столбца, <literal>T</literal> &mdash; имя типа или "
"функции, <literal>R</literal> &mdash; зарезервировано. Столбец "
"<structfield>catdesc</structfield> содержит возможно локализованное описание "
"категории."

#: func.xml:16136(para)
msgid ""
"<function>pg_get_constraintdef</function>, <function>pg_get_indexdef</"
"function>, <function>pg_get_ruledef</function>, and "
"<function>pg_get_triggerdef</function>, respectively reconstruct the "
"creating command for a constraint, index, rule, or trigger. (Note that this "
"is a decompiled reconstruction, not the original text of the command.) "
"<function>pg_get_expr</function> decompiles the internal form of an "
"individual expression, such as the default value for a column. It can be "
"useful when examining the contents of system catalogs. If the expression "
"might contain Vars, specify the OID of the relation they refer to as the "
"second parameter; if no Vars are expected, zero is sufficient. "
"<function>pg_get_viewdef</function> reconstructs the <command>SELECT</"
"command> query that defines a view. Most of these functions come in two "
"variants, one of which can optionally <quote>pretty-print</quote> the "
"result. The pretty-printed format is more readable, but the default format "
"is more likely to be interpreted the same way by future versions of "
"<productname>PostgreSQL</productname>; avoid using pretty-printed output for "
"dump purposes. Passing <literal>false</literal> for the pretty-print "
"parameter yields the same result as the variant that does not have the "
"parameter at all."
msgstr ""
"<function>pg_get_constraintdef</function>, <function>pg_get_indexdef</"
"function>, <function>pg_get_ruledef</function> и "
"<function>pg_get_triggerdef</function> восстанавливают команду, создававшую "
"заданное ограничение, индекс, правило или триггер, соответственно. (Учтите, "
"что они возвращают не изначальный текст команды, а результат декомпиляции.) "
"<function>pg_get_expr</function> декомпилирует внутреннюю форму отдельного "
"выражения, например значения по умолчанию для столбца. Это может быть "
"полезно для изучения содержимого системных каталогов. Если выражение может "
"содержать переменные, укажите во втором параметре OID отношения, на который "
"они ссылаются; если таких переменных нет, вместо OID можно передать 0. "
"<function>pg_get_viewdef</function> восстанавливает запрос <command>SELECT</"
"command>, определяющий представление. Многие из этих функций имеют две "
"версии, одна из которых позволяет получить форматированный вывод (параметр "
"pretty_bool). Форматированный текст легче читается, но нет гарантии, что он "
"будет всегда восприниматься одинаково будущими версиями "
"<productname>PostgreSQL</productname>, поэтому не следует применять "
"форматирование при выгрузке метаданных. Если параметр pretty_bool равен "
"<literal>false</literal>, эта версия функции выдаёт тот же результат, что и "
"версия без параметров."

#: func.xml:16157(para)
msgid ""
"<function>pg_get_functiondef</function> returns a complete <command>CREATE "
"OR REPLACE FUNCTION</command> statement for a function. "
"<function>pg_get_function_arguments</function> returns the argument list of "
"a function, in the form it would need to appear in within <command>CREATE "
"FUNCTION</command>. <function>pg_get_function_result</function> similarly "
"returns the appropriate <literal>RETURNS</literal> clause for the function. "
"<function>pg_get_function_identity_arguments</function> returns the argument "
"list necessary to identify a function, in the form it would need to appear "
"in within <command>ALTER FUNCTION</command>, for instance. This form omits "
"default values."
msgstr ""
"<function>pg_get_functiondef</function> возвращает полный оператор "
"<command>CREATE OR REPLACE FUNCTION</command> для заданной функции. "
"<function>pg_get_function_arguments</function> возвращает список аргументов "
"функции, в виде достаточном для включения в команду <command>CREATE "
"FUNCTION</command>. <function>pg_get_function_result</function> в дополнение "
"возвращает готовое предложение <literal>RETURNS</literal> для функции. "
"<function>pg_get_function_identity_arguments</function> возвращает список "
"аргументов, достаточный для однозначной идентификации функции, в форме, "
"допустимой, например для команды <command>ALTER FUNCTION</command>. Значения "
"по умолчанию в этой форме опускаются."

#: func.xml:16171(para)
msgid ""
"<function>pg_get_serial_sequence</function> returns the name of the sequence "
"associated with a column, or NULL if no sequence is associated with the "
"column. The first input parameter is a table name with optional schema, and "
"the second parameter is a column name. Because the first parameter is "
"potentially a schema and table, it is not treated as a double-quoted "
"identifier, meaning it is lower cased by default, while the second "
"parameter, being just a column name, is treated as double-quoted and has its "
"case preserved. The function returns a value suitably formatted for passing "
"to sequence functions (see <xref linkend=\"functions-sequence\"/>). This "
"association can be modified or removed with <command>ALTER SEQUENCE OWNED "
"BY</command>. (The function probably should have been called "
"<function>pg_get_owned_sequence</function>; its current name reflects the "
"fact that it's typically used with <type>serial</type> or <type>bigserial</"
"type> columns.)"
msgstr ""
"<function>pg_get_serial_sequence</function> возвращает имя "
"последовательности, связанной со столбцом, и NULL, если такой "
"последовательности нет. В первом параметре функции указывается имя таблицы, "
"возможно дополненное схемой, а во втором имя столбца. Так как первый "
"параметр может содержать имя схемы и таблицы, он воспринимается не как "
"идентификатор в кавычках и поэтому по умолчанию приводится к нижнему "
"регистру, тогда как имя столбца воспринимается как заключённое в кавычки и в "
"нём регистр символов сохраняется. Это функция возвращает имя в виде, "
"пригодном для передачи функциям, работающим с последовательностями (см. "
"<xref remap=\"4\" linkend=\"functions-sequence\"/>). Связь "
"последовательности со столбцом можно изменить или удалить с помощью команды "
"<command>ALTER SEQUENCE OWNED BY</command>. (Данную функцию можно было бы "
"назвать <function>pg_get_owned_sequence</function>; настоящее её имя "
"отражает то, что она обычно используется со столбцами <type>serial</type> и "
"<type>bigserial</type>.)"

#: func.xml:16189(para)
msgid ""
"<function>pg_get_userbyid</function> extracts a role's name given its OID."
msgstr "<function>pg_get_userbyid</function> получает имя роли по её OID."

#: func.xml:16194(para)
msgid ""
"<function>pg_options_to_table</function> returns the set of storage option "
"name/value pairs (<literal>option_name</literal>/<literal>option_value</"
"literal>) when passed <structname>pg_class</structname>."
"<structfield>reloptions</structfield> or <structname>pg_attribute</"
"structname>.<structfield>attoptions</structfield>."
msgstr ""
"<function>pg_options_to_table</function> возвращает набор параметров "
"хранилища в виде (<literal>имя_параметра</literal>/"
"<literal>значение_параметра</literal>), когда ей передаётся "
"<structname>pg_class</structname>.<structfield>reloptions</structfield> или "
"<structname>pg_attribute</structname>.<structfield>attoptions</structfield>."

#: func.xml:16202(para)
msgid ""
"<function>pg_tablespace_databases</function> allows a tablespace to be "
"examined. It returns the set of OIDs of databases that have objects stored "
"in the tablespace. If this function returns any rows, the tablespace is not "
"empty and cannot be dropped. To display the specific objects populating the "
"tablespace, you will need to connect to the databases identified by "
"<function>pg_tablespace_databases</function> and query their "
"<structname>pg_class</structname> catalogs."
msgstr ""
"<function>pg_tablespace_databases</function> позволяет изучить содержимое "
"табличного пространства. Она возвращает набор OID баз данных, объекты "
"которых размещены в этом табличном пространстве. Если эта функция возвращает "
"строки, это означает, что табличное пространство не пустое и удалить его "
"нельзя. Какие именно объекты находятся в табличном пространстве, можно "
"узнать, подключаясь к базам данных, OID которых сообщила "
"<function>pg_tablespace_databases</function>, и анализируя их каталоги "
"<structname>pg_class</structname>."

#: func.xml:16219(programlisting)
#, no-wrap
msgid ""
"SELECT pg_typeof(33);\n"
"\n"
" pg_typeof \n"
"-----------\n"
" integer\n"
"(1 row)\n"
"\n"
"SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);\n"
" typlen \n"
"--------\n"
"      4\n"
"(1 row)"
msgstr ""
"SELECT pg_typeof(33);\n"
"\n"
" pg_typeof \n"
"-----------\n"
" integer\n"
"(1 row)\n"
"\n"
"SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);\n"
" typlen \n"
"--------\n"
"      4\n"
"(1 row)"

#: func.xml:16212(para)
msgid ""
"<function>pg_typeof</function> returns the OID of the data type of the value "
"that is passed to it. This can be helpful for troubleshooting or dynamically "
"constructing SQL queries. The function is declared as returning "
"<type>regtype</type>, which is an OID alias type (see <xref linkend="
"\"datatype-oid\"/>); this means that it is the same as an OID for comparison "
"purposes but displays as a type name. For example: <placeholder-1/>"
msgstr ""
"<function>pg_typeof</function> возвращает OID типа данных для переданного "
"значения. Это может быть полезно для разрешения проблем или динамического "
"создания SQL-запросов. Эта функция объявлена как возвращающая тип "
"<type>regtype</type>, который является псевдонимом типа OID (см. <xref remap="
"\"4\" linkend=\"datatype-oid\"/>); это означает, что значение этого типа "
"можно сравнивать как OID, но выводится оно как название типа. Например: "
"<placeholder-1/>"

#: func.xml:16236(programlisting)
#, no-wrap
msgid ""
"SELECT collation for (description) FROM pg_description LIMIT 1;\n"
" pg_collation_for \n"
"------------------\n"
" \"default\"\n"
"(1 row)\n"
"\n"
"SELECT collation for ('foo' COLLATE \"de_DE\");\n"
" pg_collation_for \n"
"------------------\n"
" \"de_DE\"\n"
"(1 row)"
msgstr ""
"SELECT collation for (description) FROM pg_description LIMIT 1;\n"
" pg_collation_for \n"
"------------------\n"
" \"default\"\n"
"(1 row)\n"
"\n"
"SELECT collation for ('foo' COLLATE \"de_DE\");\n"
" pg_collation_for \n"
"------------------\n"
" \"de_DE\"\n"
"(1 row)"

#: func.xml:16233(para)
msgid ""
"The expression <literal>collation for</literal> returns the collation of the "
"value that is passed to it. Example: <placeholder-1/> The value might be "
"quoted and schema-qualified. If no collation is derived for the argument "
"expression, then a null value is returned. If the argument is not of a "
"collatable data type, then an error is raised."
msgstr ""
"Выражение <literal>collation for</literal> возвращает правило сортировки для "
"переданного значения. Например: <placeholder-1/> Это значение может быть "
"заключено в кавычки и дополнено схемой. Если для выражения аргумента нет "
"правила сортировки, возвращается значение NULL. Если же правила сортировки "
"не применимы для типа аргумента, происходит ошибка."

#: func.xml:16252(para)
#, fuzzy
msgid ""
"The <function>to_regclass</function>, <function>to_regproc</function>, "
"<function>to_regprocedure</function>, <function>to_regoper</function>, "
"<function>to_regoperator</function>, <function>to_regtype</function>, "
"<function>to_regnamespace</function>, and <function>to_regrole</function> "
"functions translate relation, function, operator, type, schema, and role "
"names (given as <type>text</type>) to objects of type <type>regclass</type>, "
"<type>regproc</type>, <type>regprocedure</type>, <type>regoper</type>, "
"<type>regoperator</type>, <type>regtype</type>, <type>regnamespace</type>, "
"and <type>regrole</type> respectively. These functions differ from a cast "
"from text in that they don't accept a numeric OID, and that they return null "
"rather than throwing an error if the name is not found (or, for "
"<function>to_regproc</function> and <function>to_regoper</function>, if the "
"given name matches multiple objects)."
msgstr ""
"Функции <function>to_regclass</function>, <function>to_regproc</function>, "
"<function>to_regprocedure</function>, <function>to_regoper</function>, "
"<function>to_regoperator</function>, <function>to_regtype</function>, "
"<function>to_regnamespace</function> и <function>to_regrole</function> "
"преобразуют имена отношений, функций, операторов, типов, схем и ролей в "
"объекты типа <type>regclass</type>, <type>regproc</type>, "
"<type>regprocedure</type>, <type>regoper</type>, <type>regoperator</type>, "
"<type>regtype</type>, <type>regnamespace</type> и <type>regrole</type>, "
"соответственно. Перечисленные функции отличаются от явных приведений к этим "
"типам тем, что они не принимают числовые OID и возвращают NULL, вместо того "
"чтобы выдавать ошибку, если имя не найдено (или, в случае с "
"<function>to_regproc</function> и <function>to_regoper</function>, если "
"данному имени соответствуют несколько объектов)."

#: func.xml:16269(indexterm)
msgid "<primary>pg_describe_object</primary>"
msgstr "<primary>pg_describe_object</primary>"

#: func.xml:16273(indexterm)
msgid "<primary>pg_identify_object</primary>"
msgstr "<primary>pg_identify_object</primary>"

#: func.xml:16277(indexterm)
msgid "<primary>pg_identify_object_as_address</primary>"
msgstr "<primary>pg_identify_object_as_address</primary>"

#: func.xml:16281(indexterm)
msgid "<primary>pg_get_object_address</primary>"
msgstr "<primary>pg_get_object_address</primary>"

#: func.xml:16285(para)
msgid ""
"<xref linkend=\"functions-info-object-table\"/> lists functions related to "
"database object identification and addressing."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-object-table\"/> перечислены "
"функции, связанные с идентификацией и адресацией объектов баз данных."

#: func.xml:16291(title)
msgid "Object Information and Addressing Functions"
msgstr "Функции получения информации и адресации объектов"

#: func.xml:16299(parameter) func.xml:16304(parameter)
#: func.xml:16309(parameter)
msgid "catalog_id"
msgstr "catalog_id"

#: func.xml:16299(parameter) func.xml:16304(parameter)
#: func.xml:16309(parameter)
msgid "object_id"
msgstr "object_id"

#: func.xml:16299(parameter) func.xml:16304(parameter)
#: func.xml:16309(parameter)
msgid "object_sub_id"
msgstr "object_sub_id"

#: func.xml:16299(function)
msgid ""
"pg_describe_object(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr ""
"pg_describe_object(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:16301(entry)
msgid "get description of a database object"
msgstr "получает описание объекта базы данных"

#: func.xml:16304(function)
msgid ""
"pg_identify_object(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"pg_identify_object(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:16305(entry)
msgid ""
"<parameter>type</parameter> <type>text</type>, <parameter>schema</parameter> "
"<type>text</type>, <parameter>name</parameter> <type>text</type>, "
"<parameter>identity</parameter> <type>text</type>"
msgstr ""
"<parameter>type</parameter> <type>text</type>, <parameter>schema</parameter> "
"<type>text</type>, <parameter>name</parameter> <type>text</type>, "
"<parameter>identity</parameter> <type>text</type>"

#: func.xml:16306(entry)
msgid "get identity of a database object"
msgstr "получает идентификатор объекта базы данных"

#: func.xml:16309(function)
msgid ""
"pg_identify_object_as_address(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"pg_identify_object_as_address(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:16310(entry)
msgid ""
"<parameter>type</parameter> <type>text</type>, <parameter>name</parameter> "
"<type>text[]</type>, <parameter>args</parameter> <type>text[]</type>"
msgstr ""
"<parameter>type</parameter> <type>text</type>, <parameter>name</parameter> "
"<type>text[]</type>, <parameter>args</parameter> <type>text[]</type>"

#: func.xml:16311(entry)
msgid "get external representation of a database object's address"
msgstr "получает внешнее представление адреса объекта базы данных"

#: func.xml:16314(parameter)
msgid "type"
msgstr "type"

#: func.xml:16314(parameter) func.xml:17264(parameter)
msgctxt "parameter"
msgid "name"
msgstr "name"

#: func.xml:16314(parameter)
msgctxt "parameter"
msgid "args"
msgstr "аргументы"

#: func.xml:16314(function)
msgid ""
"pg_get_object_address(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"pg_get_object_address(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:16315(entry)
msgid ""
"<parameter>catalog_id</parameter> <type>oid</type>, <parameter>object_id</"
"parameter> <type>oid</type>, <parameter>object_sub_id</parameter> "
"<type>int32</type>"
msgstr ""
"<parameter>catalog_id</parameter> <type>oid</type>, <parameter>object_id</"
"parameter> <type>oid</type>, <parameter>object_sub_id</parameter> "
"<type>int32</type>"

#: func.xml:16316(entry)
msgid "get address of a database object, from its external representation"
msgstr "получает адрес объекта базы данных из его внешнего представления"

#: func.xml:16322(para)
msgid ""
"<function>pg_describe_object</function> returns a textual description of a "
"database object specified by catalog OID, object OID and a (possibly zero) "
"sub-object ID. This description is intended to be human-readable, and might "
"be translated, depending on server configuration. This is useful to "
"determine the identity of an object as stored in the <structname>pg_depend</"
"structname> catalog."
msgstr ""
"<function>pg_describe_object</function> возвращает текстовое описание "
"объекта БД, идентифицируемого по OID каталога, OID объекта и ID подобъекта "
"(может быть нулевым). Это описание предназначено для человека и может "
"переводиться, в зависимости от конфигурации сервера. С помощью этой функции, "
"например, можно узнать, что за объект хранится в каталоге "
"<structname>pg_depend</structname>."

#: func.xml:16331(para)
msgid ""
"<function>pg_identify_object</function> returns a row containing enough "
"information to uniquely identify the database object specified by catalog "
"OID, object OID and a (possibly zero) sub-object ID. This information is "
"intended to be machine-readable, and is never translated. <parameter>type</"
"parameter> identifies the type of database object; <parameter>schema</"
"parameter> is the schema name that the object belongs in, or <literal>NULL</"
"literal> for object types that do not belong to schemas; <parameter>name</"
"parameter> is the name of the object, quoted if necessary, only present if "
"it can be used (alongside schema name, if pertinent) as a unique identifier "
"of the object, otherwise <literal>NULL</literal>; <parameter>identity</"
"parameter> is the complete object identity, with the precise format "
"depending on object type, and each part within the format being schema-"
"qualified and quoted as necessary."
msgstr ""
"<function>pg_identify_object</function> возвращает запись, содержащую "
"достаточно информации для однозначной идентификации объекта БД по OID "
"каталога, OID объекта и ID подобъекта (может быть нулевым). Эта информация "
"предназначена для машины и поэтому никогда не переводится. Столбец "
"<parameter>type</parameter> содержит тип объекта БД; <parameter>schema</"
"parameter> &mdash; имя схемы, к которой относится объект (либо "
"<literal>NULL</literal> для объектов, не относящихся к схемам); "
"<parameter>name</parameter> &mdash; имя объекта, при необходимости в "
"кавычках, которое присутствует только если оно (возможно, вместе со схемой) "
"однозначно идентифицирует объект (в противном случае <literal>NULL</"
"literal>); <parameter>identity</parameter> &mdash; полный идентификатор "
"объекта, точный формат которого зависит от типа объекта, а каждая его часть "
"дополняется схемой и заключается в кавычки, если требуется."

#: func.xml:16347(para)
msgid ""
"<function>pg_identify_object_as_address</function> returns a row containing "
"enough information to uniquely identify the database object specified by "
"catalog OID, object OID and a (possibly zero) sub-object ID. The returned "
"information is independent of the current server, that is, it could be used "
"to identify an identically named object in another server. <parameter>type</"
"parameter> identifies the type of database object; <parameter>name</"
"parameter> and <parameter>args</parameter> are text arrays that together "
"form a reference to the object. These three columns can be passed to "
"<function>pg_get_object_address</function> to obtain the internal address of "
"the object. This function is the inverse of <function>pg_get_object_address</"
"function>."
msgstr ""
"<function>pg_identify_object_as_address</function> возвращает строку, "
"содержащую достаточно информации для однозначной идентификации объекта БД по "
"OID каталога, OID объекта и ID подобъекта (может быть нулевым). Выдаваемая "
"информация не зависит от текущего сервера, то есть по ней можно "
"идентифицировать одноимённый объект на другом сервере. Столбец "
"<parameter>type</parameter> содержит тип объекта БД, а <parameter>name</"
"parameter> и <parameter>args</parameter> — текстовые массивы, в совокупности "
"формирующие ссылку на объект. Эти три столбца можно передать функции "
"<function>pg_get_object_address</function>, чтобы получить внутренний адрес "
"объекта. Данная функция является обратной к <function>pg_get_object_address</"
"function>."

#: func.xml:16361(para)
msgid ""
"<function>pg_get_object_address</function> returns a row containing enough "
"information to uniquely identify the database object specified by its type "
"and object name and argument arrays. The returned values are the ones that "
"would be used in system catalogs such as <structname>pg_depend</structname> "
"and can be passed to other system functions such as "
"<function>pg_identify_object</function> or <function>pg_describe_object</"
"function>. <parameter>catalog_id</parameter> is the OID of the system "
"catalog containing the object; <parameter>object_id</parameter> is the OID "
"of the object itself, and <parameter>object_sub_id</parameter> is the object "
"sub-ID, or zero if none. This function is the inverse of "
"<function>pg_identify_object_as_address</function>."
msgstr ""
"<function>pg_get_object_address</function> возвращает запись, содержащую "
"достаточно информации для уникальной идентификации объекта БД по его типу и "
"массивам имён и аргументов. В ней возвращаются значения, которые "
"используются в системных каталогах, например <structname>pg_depend</"
"structname>, и могут передаваться в другие системные функции, например "
"<function>pg_identify_object</function> или <function>pg_describe_object</"
"function>. Столбец <parameter>catalog_id</parameter> содержит OID системного "
"каталога, к которому относится объект; <parameter>object_id</parameter> — "
"OID самого объекта, а <parameter>object_sub_id</parameter> — идентификатор "
"подобъекта, или 0 в случае его отсутствия. Эта функция является обратной к "
"<function>pg_identify_object_as_address</function>."

#: func.xml:16375(indexterm)
msgid "<primary>col_description</primary>"
msgstr "<primary>col_description</primary>"

#: func.xml:16379(indexterm)
msgid "<primary>obj_description</primary>"
msgstr "<primary>obj_description</primary>"

#: func.xml:16383(indexterm)
msgid "<primary>shobj_description</primary>"
msgstr "<primary>shobj_description</primary>"

#: func.xml:16387(indexterm)
msgid ""
"<primary>comment</primary><secondary sortas=\"database objects\">about "
"database objects</secondary>"
msgstr ""
"<primary>комментарии</primary><secondary sortas=\"database objects\">к "
"объектам баз данных</secondary>"

#: func.xml:16391(para)
msgid ""
"The functions shown in <xref linkend=\"functions-info-comment-table\"/> "
"extract comments previously stored with the <xref linkend=\"sql-comment\"/> "
"command. A null value is returned if no comment could be found for the "
"specified parameters."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-info-comment-"
"table\"/>, извлекают комментарии, заданные для объектов с помощью команды "
"<xref linkend=\"sql-comment\"/>. Если найти комментарий для заданных "
"параметров не удаётся, они возвращают NULL."

#: func.xml:16399(title)
msgid "Comment Information Functions"
msgstr "Функции получения комментариев"

#: func.xml:16407(parameter)
msgid "column_number"
msgstr "column_number"

#: func.xml:16407(function)
msgid "col_description(<placeholder-1/>, <placeholder-2/>)"
msgstr "col_description(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16409(entry)
msgid "get comment for a table column"
msgstr "получает комментарий для столбца таблицы"

#: func.xml:16412(parameter) func.xml:16417(parameter)
#: func.xml:16422(parameter)
msgid "object_oid"
msgstr "object_oid"

#: func.xml:16412(parameter) func.xml:16422(parameter)
msgid "catalog_name"
msgstr "catalog_name"

#: func.xml:16412(function)
msgid "obj_description(<placeholder-1/>, <placeholder-2/>)"
msgstr "obj_description(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16414(entry)
msgid "get comment for a database object"
msgstr "получает комментарий для объекта базы данных"

#: func.xml:16417(function)
msgid "obj_description(<placeholder-1/>)"
msgstr "obj_description(<placeholder-1/>)"

#: func.xml:16419(entry)
msgid "get comment for a database object (<emphasis>deprecated</emphasis>)"
msgstr ""
"получает комментарий для объекта базы данных (<emphasis>устаревшая</"
"emphasis> форма)"

#: func.xml:16422(function)
msgid "shobj_description(<placeholder-1/>, <placeholder-2/>)"
msgstr "shobj_description(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16424(entry)
msgid "get comment for a shared database object"
msgstr "получает комментарий для разделяемого объекта баз данных"

#: func.xml:16430(para)
msgid ""
"<function>col_description</function> returns the comment for a table column, "
"which is specified by the OID of its table and its column number. "
"(<function>obj_description</function> cannot be used for table columns since "
"columns do not have OIDs of their own.)"
msgstr ""
"<function>col_description</function> возвращает комментарий для столбца с "
"заданным номером в таблице с указанным OID. (<function>obj_description</"
"function> нельзя использовать для столбцов таблицы, так столбцы не имеют "
"собственных OID.)"

#: func.xml:16437(para)
msgid ""
"The two-parameter form of <function>obj_description</function> returns the "
"comment for a database object specified by its OID and the name of the "
"containing system catalog. For example, "
"<literal>obj_description(123456,'pg_class')</literal> would retrieve the "
"comment for the table with OID 123456. The one-parameter form of "
"<function>obj_description</function> requires only the object OID. It is "
"deprecated since there is no guarantee that OIDs are unique across different "
"system catalogs; therefore, the wrong comment might be returned."
msgstr ""
"Функция <function>obj_description</function> с двумя параметрами возвращает "
"комментарий для объекта, имеющего заданный OID и находящегося в указанном "
"системном каталоге. Например, <literal>obj_description(123456,'pg_class')</"
"literal> вернёт комментарий для таблицы с OID 123456. Форма "
"<function>obj_description</function> с одним параметром принимает только "
"OID. Она является устаревшей, так как значения OID могут повторяться в "
"разных системных каталогах, и поэтому она может возвращать комментарий для "
"другого объекта."

#: func.xml:16449(para)
msgid ""
"<function>shobj_description</function> is used just like "
"<function>obj_description</function> except it is used for retrieving "
"comments on shared objects. Some system catalogs are global to all databases "
"within each cluster, and the descriptions for objects in them are stored "
"globally as well."
msgstr ""
"<function>shobj_description</function> работает подобно "
"<function>obj_description</function>, но она получает комментарии для "
"разделяемых объектов. Некоторые системные каталоги являются глобальными для "
"всех баз данных в кластере и описания объектов в них также хранятся "
"глобально."

#: func.xml:16457(indexterm)
msgid "<primary>txid_current</primary>"
msgstr "<primary>txid_current</primary>"

#: func.xml:16461(indexterm)
msgid "<primary>txid_current_snapshot</primary>"
msgstr "<primary>txid_current_snapshot</primary>"

#: func.xml:16465(indexterm)
msgid "<primary>txid_snapshot_xip</primary>"
msgstr "<primary>txid_snapshot_xip</primary>"

#: func.xml:16469(indexterm)
msgid "<primary>txid_snapshot_xmax</primary>"
msgstr "<primary>txid_snapshot_xmax</primary>"

#: func.xml:16473(indexterm)
msgid "<primary>txid_snapshot_xmin</primary>"
msgstr "<primary>txid_snapshot_xmin</primary>"

#: func.xml:16477(indexterm)
msgid "<primary>txid_visible_in_snapshot</primary>"
msgstr "<primary>txid_visible_in_snapshot</primary>"

#: func.xml:16481(para)
msgid ""
"The functions shown in <xref linkend=\"functions-txid-snapshot\"/> provide "
"server transaction information in an exportable form. The main use of these "
"functions is to determine which transactions were committed between two "
"snapshots."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-txid-snapshot"
"\"/>, выдают информацию о транзакциях сервера в форме во внешнем "
"представлении. В основном эти функции используются, чтобы определить, какие "
"транзакции были зафиксированы между двумя снимками состояния."

#: func.xml:16489(title)
msgid "Transaction IDs and Snapshots"
msgstr "Идентификаторы транзакций и снимков состояния"

#: func.xml:16497(function)
msgid "txid_current()"
msgstr "txid_current()"

#: func.xml:16499(entry)
msgid ""
"get current transaction ID, assigning a new one if the current transaction "
"does not have one"
msgstr ""
"получает идентификатор текущей транзакции и присваивает новый, если текущая "
"транзакция его не имеет"

#: func.xml:16502(function)
msgid "txid_current_snapshot()"
msgstr "txid_current_snapshot()"

#: func.xml:16503(type)
msgctxt "type"
msgid "txid_snapshot"
msgstr "txid_snapshot"

#: func.xml:16504(entry)
msgid "get current snapshot"
msgstr "получает код текущего снимка"

#: func.xml:16507(parameter) func.xml:16512(parameter)
#: func.xml:16517(parameter) func.xml:16522(parameter)
msgctxt "parameter"
msgid "txid_snapshot"
msgstr "txid_snapshot"

#: func.xml:16507(function)
msgid "txid_snapshot_xip(<placeholder-1/>)"
msgstr "txid_snapshot_xip(<placeholder-1/>)"

#: func.xml:16508(type)
msgid "setof bigint"
msgstr "setof bigint"

#: func.xml:16509(entry)
msgid "get in-progress transaction IDs in snapshot"
msgstr "возвращает идентификаторы выполняющихся транзакций в снимке"

#: func.xml:16512(function)
msgid "txid_snapshot_xmax(<placeholder-1/>)"
msgstr "txid_snapshot_xmax(<placeholder-1/>)"

#: func.xml:16514(entry)
msgid "get <literal>xmax</literal> of snapshot"
msgstr "возвращает значение <literal>xmax</literal> для заданного снимка"

#: func.xml:16517(function)
msgid "txid_snapshot_xmin(<placeholder-1/>)"
msgstr "txid_snapshot_xmin(<placeholder-1/>)"

#: func.xml:16519(entry)
msgid "get <literal>xmin</literal> of snapshot"
msgstr "возвращает значение <literal>xmin</literal> для заданного снимка"

#: func.xml:16522(parameter)
msgctxt "parameter"
msgid "bigint"
msgstr "bigint"

#: func.xml:16522(function)
msgid "txid_visible_in_snapshot(<placeholder-1/>, <placeholder-2/>)"
msgstr "txid_visible_in_snapshot(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16524(entry)
msgid ""
"is transaction ID visible in snapshot? (do not use with subtransaction ids)"
msgstr ""
"видима ли транзакция с указанным идентификатором в данном снимке? (коды "
"подтранзакций не поддерживаются)"

#: func.xml:16530(para)
msgid ""
"The internal transaction ID type (<type>xid</type>) is 32 bits wide and "
"wraps around every 4 billion transactions. However, these functions export a "
"64-bit format that is extended with an <quote>epoch</quote> counter so it "
"will not wrap around during the life of an installation. The data type used "
"by these functions, <type>txid_snapshot</type>, stores information about "
"transaction ID visibility at a particular moment in time. Its components are "
"described in <xref linkend=\"functions-txid-snapshot-parts\"/>."
msgstr ""
"Внутренний тип идентификаторов транзакций (<type>xid</type>) имеет размер 32 "
"бита, поэтому они повторяются через 4 миллиарда транзакций. Однако эти "
"функции выдают 64-битные значения, дополненные счётчиком <quote>эпохи</"
"quote>, так что эти значения останутся уникальными на протяжении всей жизни "
"сервера. Используемый этими функциями тип данных <type>txid_snapshot</type> "
"сохраняет информацию о видимости транзакций в определённый момент времени. "
"Его состав описан в <xref remap=\"6\" linkend=\"functions-txid-snapshot-parts"
"\"/>."

#: func.xml:16542(title)
msgid "Snapshot Components"
msgstr "Состав информации о снимке"

#: func.xml:16554(type)
msgid "xmin"
msgstr "xmin"

#: func.xml:16555(entry)
msgid ""
"Earliest transaction ID (txid) that is still active. All earlier "
"transactions will either be committed and visible, or rolled back and dead."
msgstr ""
"Идентификатор самой ранней транзакции (txid) из активных. Все предыдущие "
"транзакции либо зафиксированы и видимы, либо отменены и мертвы."

#: func.xml:16563(type)
msgid "xmax"
msgstr "xmax"

#: func.xml:16564(entry)
msgid ""
"First as-yet-unassigned txid. All txids greater than or equal to this are "
"not yet started as of the time of the snapshot, and thus invisible."
msgstr ""
"Первый txid из ещё не назначенных. На момент снимка не было запущенных (а "
"значит и видимых) транзакций с идентификатором, большим или равным данному."

#: func.xml:16571(type)
msgid "xip_list"
msgstr "xip_list"

#: func.xml:16572(entry)
msgid ""
"Active txids at the time of the snapshot. The list includes only those "
"active txids between <literal>xmin</literal> and <literal>xmax</literal>; "
"there might be active txids higher than <literal>xmax</literal>. A txid that "
"is <literal>xmin &lt;= txid &lt; xmax</literal> and not in this list was "
"already completed at the time of the snapshot, and thus either visible or "
"dead according to its commit status. The list does not include txids of "
"subtransactions."
msgstr ""
"Список идентификаторов транзакций, активных в момент снимка. Он включает "
"только идентификаторы с номерами от <literal>xmin</literal> до "
"<literal>xmax</literal>; хотя уже могут быть транзакции с идентификаторами "
"больше <literal>xmax</literal>. Если в этом списке не оказывается "
"идентификатора транзакции <literal>xmin &lt;= txid &lt; xmax</literal>, это "
"означает, что она уже не выполнялась к моменту снимка и, таким образом, "
"видима или мертва, в зависимости от типа завершения. Идентификаторы "
"подтранзакций в этот список не включаются."

#: func.xml:16588(para)
msgid ""
"<type>txid_snapshot</type>'s textual representation is "
"<literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:"
"<replaceable>xip_list</replaceable></literal>. For example "
"<literal>10:20:10,14,15</literal> means <literal>xmin=10, xmax=20, "
"xip_list=10, 14, 15</literal>."
msgstr ""
"В текстовом виде <type>txid_snapshot</type> представляется как "
"<literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:"
"<replaceable>xip_list</replaceable></literal>. Например, "
"<literal>10:20:10,14,15</literal> означает <literal>xmin=10, xmax=20, "
"xip_list=10, 14, 15</literal>."

#: func.xml:16595(para)
msgid ""
"The functions shown in <xref linkend=\"functions-commit-timestamp\"/> "
"provide information about transactions that have been already committed. "
"These functions mainly provide information about when the transactions were "
"committed. They only provide useful data when <xref linkend=\"guc-track-"
"commit-timestamp\"/> configuration option is enabled and only for "
"transactions that were committed after it was enabled."
msgstr ""
"Функции, показанные в <xref remap=\"6\" linkend=\"functions-commit-timestamp"
"\"/>, выдают информацию об уже зафиксированных транзакциях. Они возвращают "
"полезные данные, только когда включён параметр конфигурации <xref linkend="
"\"guc-track-commit-timestamp\"/> и только для транзакций, зафиксированных "
"после его включения."

#: func.xml:16605(title)
msgid "Committed transaction information"
msgstr "Информация о фиксации транзакций"

#: func.xml:16614(indexterm)
msgid "<primary>pg_xact_commit_timestamp</primary>"
msgstr "<primary>pg_xact_commit_timestamp</primary>"

#: func.xml:16615(parameter)
msgctxt "parameter"
msgid "xid"
msgstr "xid"

#: func.xml:16615(function)
msgid "pg_xact_commit_timestamp(<placeholder-1/>)"
msgstr "pg_xact_commit_timestamp(<placeholder-1/>)"

#: func.xml:16618(entry)
msgid "get commit timestamp of a transaction"
msgstr "выдаёт время фиксации транзакции"

#: func.xml:16623(indexterm)
msgid "<primary>pg_last_committed_xact</primary>"
msgstr "<primary>pg_last_committed_xact</primary>"

#: func.xml:16624(function)
msgid "pg_last_committed_xact()"
msgstr "pg_last_committed_xact()"

#: func.xml:16626(entry)
msgid ""
"<parameter>xid</parameter> <type>xid</type>, <parameter>timestamp</"
"parameter> <type>timestamp with time zone</type>"
msgstr ""
"<parameter>xid</parameter> <type>xid</type>, <parameter>timestamp</"
"parameter> <type>timestamp with time zone</type>"

#: func.xml:16627(entry)
msgid "get transaction ID and commit timestamp of latest committed transaction"
msgstr ""
"выдаёт идентификатор и время фиксации транзакции, зафиксированной последней"

#: func.xml:16633(para)
#, fuzzy
msgid ""
"The functions shown in <xref linkend=\"functions-controldata\"/> print "
"information initialized during <command>initdb</command>, such as the "
"catalog version. They also show information about write-ahead logging and "
"checkpoint processing. This information is cluster-wide, and not specific to "
"any one database. They provide most of the same information, from the same "
"source, as <xref linkend=\"app-pgcontroldata\"/>, although in a form better "
"suited to <acronym>SQL</acronym> functions."
msgstr ""
"<command>pg_controldata</command> показывает свойства, установленные "
"командой <command>initdb</command>, например, версию каталога. Она также "
"выводит сведения о работе журнала упреждающей записи и контрольных точках. "
"Эта информация относится ко всему кластеру, а не к отдельной базе данных."

#: func.xml:16645(title)
#, fuzzy
msgid "Control Data Functions"
msgstr "Функции управления"

#: func.xml:16654(indexterm)
#, fuzzy
msgid "<primary>pg_control_checkpoint</primary>"
msgstr "<primary>контрольная точка</primary>"

#: func.xml:16655(function)
#, fuzzy
msgid "pg_control_checkpoint()"
msgstr "pg_client_encoding()"

#: func.xml:16658(entry)
#, fuzzy
msgid "Returns information about current checkpoint state."
msgstr "Возвращает информацию о файле."

#: func.xml:16665(indexterm)
#, fuzzy
msgid "<primary>pg_control_system</primary>"
msgstr "<primary>pg_controldata</primary>"

#: func.xml:16666(function)
#, fuzzy
msgid "pg_control_system()"
msgstr "pg_controldata"

#: func.xml:16669(entry)
#, fuzzy
msgid "Returns information about current controldata file state."
msgstr "Возвращает информацию о файле."

#: func.xml:16676(indexterm)
#, fuzzy
msgid "<primary>pg_control_init</primary>"
msgstr "<primary>pg_constraint</primary>"

#: func.xml:16677(function)
#, fuzzy
msgid "pg_control_init()"
msgstr "pg_constraint"

#: func.xml:16680(entry)
#, fuzzy
msgid "Returns information about cluster initialization state."
msgstr "Возвращает информацию о файле."

#: func.xml:16687(indexterm)
#, fuzzy
msgid "<primary>pg_control_recovery</primary>"
msgstr "<primary>pg_is_in_recovery</primary>"

#: func.xml:16688(function)
#, fuzzy
msgid "pg_control_recovery()"
msgstr "pg_is_in_recovery()"

#: func.xml:16691(entry)
#, fuzzy
msgid "Returns information about recovery state."
msgstr "Возвращает информацию о файле."

#: func.xml:16700(para)
#, fuzzy
msgid ""
"<function>pg_control_checkpoint</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-checkpoint\"/>"
msgstr ""
"Функция <function>char_length</function> рассматривается в <xref remap=\"6\" "
"linkend=\"functions-string\"/>."

#: func.xml:16706(title)
msgid "<function>pg_control_checkpoint</function> Columns"
msgstr "Столбцы результата <function>pg_control_checkpoint</function>"

#: func.xml:16710(entry) func.xml:16826(entry) func.xml:16867(entry)
#: func.xml:16953(entry)
#, fuzzy
msgid "Column Name"
msgstr "Имя столбца"

#: func.xml:16711(entry) func.xml:16827(entry) func.xml:16868(entry)
#: func.xml:16954(entry)
msgid "Data Type"
msgstr "Тип данных"

#: func.xml:16718(entry)
msgid "checkpoint_location"
msgstr "checkpoint_location"

#: func.xml:16719(type) func.xml:16724(type) func.xml:16729(type)
#: func.xml:16962(type) func.xml:16972(type) func.xml:16977(type)
#: func.xml:17266(type) func.xml:17273(type) func.xml:17280(type)
#: func.xml:17287(type) func.xml:17294(type) func.xml:17301(type)
#: func.xml:17329(type) func.xml:17334(type) func.xml:17341(type)
#: func.xml:17348(type) func.xml:17513(type) func.xml:17527(type)
#: func.xml:17804(type) func.xml:17829(type) func.xml:17847(type)
#: func.xml:17864(type) func.xml:17983(type) func.xml:17998(type)
#: func.xml:18033(type) func.xml:18055(type) func.xml:18073(type)
#: func.xml:18092(type)
msgid "pg_lsn"
msgstr "pg_lsn"

#: func.xml:16723(entry)
msgid "prior_location"
msgstr "prior_location"

#: func.xml:16728(entry)
msgid "redo_location"
msgstr "redo_location"

#: func.xml:16733(entry)
msgid "redo_wal_file"
msgstr "redo_wal_file"

#: func.xml:16738(entry)
msgid "timeline_id"
msgstr "timeline_id"

#: func.xml:16743(entry)
msgid "prev_timeline_id"
msgstr "prev_timeline_id"

#: func.xml:16748(entry)
msgid "full_page_writes"
msgstr "full_page_writes"

#: func.xml:16753(entry)
msgid "next_xid"
msgstr "next_xid"

#: func.xml:16758(entry)
msgid "next_oid"
msgstr "next_oid"

#: func.xml:16763(entry)
msgid "next_multixact_id"
msgstr "next_multixact_id"

#: func.xml:16764(type) func.xml:16769(type) func.xml:16774(type)
#: func.xml:16784(type) func.xml:16789(type) func.xml:16799(type)
#: func.xml:16804(type)
msgctxt "type"
msgid "xid"
msgstr "xid"

#: func.xml:16768(entry)
msgid "next_multi_offset"
msgstr "next_multi_offset"

#: func.xml:16773(entry)
msgid "oldest_xid"
msgstr "oldest_xid"

#: func.xml:16778(entry)
msgid "oldest_xid_dbid"
msgstr "oldest_xid_dbid"

#: func.xml:16783(entry)
msgid "oldest_active_xid"
msgstr "oldest_active_xid"

#: func.xml:16788(entry)
msgid "oldest_multi_xid"
msgstr "oldest_multi_xid"

#: func.xml:16793(entry)
msgid "oldest_multi_dbid"
msgstr "oldest_multi_dbid"

#: func.xml:16798(entry)
msgid "oldest_commit_ts_xid"
msgstr "oldest_commit_ts_xid"

#: func.xml:16803(entry)
msgid "newest_commit_ts_xid"
msgstr "newest_commit_ts_xid"

#: func.xml:16808(entry)
msgid "checkpoint_time"
msgstr "checkpoint_time"

#: func.xml:16816(para)
#, fuzzy
msgid ""
"<function>pg_control_system</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-system\"/>"
msgstr ""
"Функция <function>char_length</function> рассматривается в <xref remap=\"6\" "
"linkend=\"functions-string\"/>."

#: func.xml:16822(title)
#, fuzzy
msgid "<function>pg_control_system</function> Columns"
msgstr "Столбцы результата <function>pgrowlocks</function>"

#: func.xml:16834(entry)
#, fuzzy
msgid "pg_control_version"
msgstr "pg_conversion"

#: func.xml:16839(entry)
#, fuzzy
msgid "catalog_version_no"
msgstr "conversion_oid"

#: func.xml:16844(entry)
#, fuzzy
msgid "system_identifier"
msgstr "dtd_identifier"

#: func.xml:16849(entry)
#, fuzzy
msgid "pg_control_last_modified"
msgstr "pg_controldata"

#: func.xml:16857(para)
#, fuzzy
msgid ""
"<function>pg_control_init</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-init\"/>"
msgstr ""
"Функция <function>char_length</function> рассматривается в <xref remap=\"6\" "
"linkend=\"functions-string\"/>."

#: func.xml:16863(title)
#, fuzzy
msgid "<function>pg_control_init</function> Columns"
msgstr "Столбцы результата <function>pgrowlocks</function>"

#: func.xml:16875(entry)
#, fuzzy
msgid "max_data_alignment"
msgstr "выравнивание"

#: func.xml:16880(entry)
#, fuzzy
msgid "database_block_size"
msgstr "database_dropped"

#: func.xml:16885(entry)
msgid "blocks_per_segment"
msgstr ""

#: func.xml:16890(entry)
msgid "wal_block_size"
msgstr ""

#: func.xml:16895(entry)
msgid "bytes_per_wal_segment"
msgstr ""

#: func.xml:16900(entry)
#, fuzzy
msgid "max_identifier_length"
msgstr "dtd_identifier"

#: func.xml:16905(entry)
#, fuzzy
msgid "max_index_columns"
msgstr "имя_столбца_индекса"

#: func.xml:16910(entry)
msgid "max_toast_chunk_size"
msgstr ""

#: func.xml:16915(entry)
#, fuzzy
msgid "large_object_chunk_size"
msgstr "oid_большого_объекта"

#: func.xml:16920(entry)
#, fuzzy
msgid "bigint_timestamps"
msgstr "origin_timestamp"

#: func.xml:16925(entry)
msgid "float4_pass_by_value"
msgstr ""

#: func.xml:16930(entry)
msgid "float8_pass_by_value"
msgstr ""

#: func.xml:16935(entry)
#, fuzzy
msgid "data_page_checksum_version"
msgstr "pd_pagesize_version"

#: func.xml:16943(para)
#, fuzzy
msgid ""
"<function>pg_control_recovery</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-recovery\"/>"
msgstr ""
"Функция <function>char_length</function> рассматривается в <xref remap=\"6\" "
"linkend=\"functions-string\"/>."

#: func.xml:16949(title)
#, fuzzy
msgid "<function>pg_control_recovery</function> Columns"
msgstr "Столбцы результата <function>pgrowlocks</function>"

#: func.xml:16961(entry)
#, fuzzy
msgid "min_recovery_end_location"
msgstr "replay_location"

#: func.xml:16966(entry)
msgid "min_recovery_end_timeline"
msgstr ""

#: func.xml:16971(entry)
#, fuzzy
msgid "backup_start_location"
msgstr "pg_stat_replication"

#: func.xml:16976(entry)
#, fuzzy
msgid "backup_end_location"
msgstr "sent_location"

#: func.xml:16981(entry)
msgid "end_of_backup_record_required"
msgstr ""

#: func.xml:16992(title)
msgid "System Administration Functions"
msgstr "Функции для системного администрирования"

#: func.xml:16994(para)
msgid ""
"The functions described in this section are used to control and monitor a "
"<productname>PostgreSQL</productname> installation."
msgstr ""
"Функции, описанные в этом разделе, предназначены для контроля и управления "
"сервером <productname>PostgreSQL</productname>."

#: func.xml:17000(title) func.xml:17008(title)
msgid "Configuration Settings Functions"
msgstr "Функции для управления конфигурацией"

#: func.xml:17002(para)
msgid ""
"<xref linkend=\"functions-admin-set-table\"/> shows the functions available "
"to query and alter run-time configuration parameters."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-admin-set-table\"/> показаны "
"функции, позволяющие получить и изменить значения параметров конфигурации "
"выполнения."

#: func.xml:17017(indexterm)
msgid "<primary>current_setting</primary>"
msgstr "<primary>current_setting</primary>"

#: func.xml:17020(parameter) func.xml:17030(parameter)
msgid "setting_name"
msgstr "setting_name"

#: func.xml:17020(parameter) func.xml:18559(parameter)
#: func.xml:18568(parameter) func.xml:18577(parameter)
#: func.xml:18586(parameter)
msgid "missing_ok"
msgstr "missing_ok"

#: func.xml:17020(function)
#, fuzzy
msgid "current_setting(<placeholder-1/> [, <placeholder-2/> ])"
msgstr "set_masklen(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:17023(entry)
msgid "get current value of setting"
msgstr "получает текущее значение параметра"

#: func.xml:17027(indexterm)
msgid "<primary>set_config</primary>"
msgstr "<primary>set_config</primary>"

#: func.xml:17031(parameter)
msgid "new_value"
msgstr "new_value"

#: func.xml:17032(parameter)
msgid "is_local"
msgstr "is_local"

#: func.xml:17030(function)
msgid "set_config(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "set_config(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:17035(entry)
msgid "set parameter and return new value"
msgstr "устанавливает новое значение параметра и возвращает его"

#: func.xml:17041(indexterm)
msgid "<primary>SET</primary>"
msgstr "<primary>SET</primary>"

#: func.xml:17045(indexterm)
msgid "<primary>SHOW</primary>"
msgstr "<primary>SHOW</primary>"

#: func.xml:17049(indexterm)
msgid ""
"<primary>configuration</primary><secondary sortas=\"server\">of the server</"
"secondary><tertiary>functions</tertiary>"
msgstr ""
"<primary>конфигурация</primary><secondary sortas=\"сервера\">сервера</"
"secondary><tertiary>функции</tertiary>"

#: func.xml:17058(programlisting)
#, no-wrap
msgid ""
"SELECT current_setting('datestyle');\n"
"\n"
" current_setting\n"
"-----------------\n"
" ISO, MDY\n"
"(1 row)"
msgstr ""
"SELECT current_setting('datestyle');\n"
"\n"
" current_setting\n"
"-----------------\n"
" ISO, MDY\n"
"(1 row)"

#: func.xml:17053(para)
#, fuzzy
msgid ""
"The function <function>current_setting</function> yields the current value "
"of the setting <parameter>setting_name</parameter>. It corresponds to the "
"<acronym>SQL</acronym> command <command>SHOW</command>. An example: "
"<placeholder-1/> If there is no setting named <parameter>setting_name</"
"parameter>, <function>current_setting</function> throws an error unless "
"<parameter>missing_ok</parameter> is supplied and is <literal>true</literal>."
msgstr ""
"Функция <function>current_setting</function> выдаёт текущее значение "
"параметра <parameter>setting_name</parameter>. Она соответствует стандартной "
"<acronym>SQL</acronym>-команде <command>SHOW</command>. Пример "
"использования: <placeholder-1/>"

#: func.xml:17080(programlisting)
#, no-wrap
msgid ""
"SELECT set_config('log_statement_stats', 'off', false);\n"
"\n"
" set_config\n"
"------------\n"
" off\n"
"(1 row)"
msgstr ""
"SELECT set_config('log_statement_stats', 'off', false);\n"
"\n"
" set_config\n"
"------------\n"
" off\n"
"(1 row)"

#: func.xml:17071(para)
msgid ""
"<function>set_config</function> sets the parameter <parameter>setting_name</"
"parameter> to <parameter>new_value</parameter>. If <parameter>is_local</"
"parameter> is <literal>true</literal>, the new value will only apply to the "
"current transaction. If you want the new value to apply for the current "
"session, use <literal>false</literal> instead. The function corresponds to "
"the SQL command <command>SET</command>. An example: <placeholder-1/>"
msgstr ""
"<function>set_config</function> устанавливает для параметра "
"<parameter>setting_name</parameter> значение <parameter>new_value</"
"parameter>. Если параметр <parameter>is_local</parameter> равен "
"<literal>true</literal>, новое значение будет действовать только в рамках "
"текущей транзакции. Чтобы это значение действовало на протяжении текущего "
"сеанса, ему нужно присвоить <literal>false</literal>. Эта функция "
"соответствует SQL-команде <command>SET</command>. Пример использования: "
"<placeholder-1/>"

#: func.xml:17091(title) func.xml:17119(title)
msgid "Server Signaling Functions"
msgstr "Функции для передачи сигналов серверу"

#: func.xml:17093(indexterm)
msgid "<primary>pg_cancel_backend</primary>"
msgstr "<primary>pg_cancel_backend</primary>"

#: func.xml:17096(indexterm)
msgid "<primary>pg_reload_conf</primary>"
msgstr "<primary>pg_reload_conf</primary>"

#: func.xml:17099(indexterm)
msgid "<primary>pg_rotate_logfile</primary>"
msgstr "<primary>pg_rotate_logfile</primary>"

#: func.xml:17102(indexterm)
msgid "<primary>pg_terminate_backend</primary>"
msgstr "<primary>pg_terminate_backend</primary>"

#: func.xml:17106(indexterm)
msgid ""
"<primary>signal</primary><secondary sortas=\"backend\">backend processes</"
"secondary>"
msgstr ""
"<primary>сигнал</primary><secondary sortas=\"сервер\">серверные процессы</"
"secondary>"

#: func.xml:17110(para)
#, fuzzy
msgid ""
"The functions shown in <xref linkend=\"functions-admin-signal-table\"/> send "
"control signals to other server processes. Use of these functions is "
"restricted to superusers by default but access may be granted to others with "
"the <command>GRANT</command>, with noted exceptions."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-signal-"
"table\"/>, позволяют передавать управляющие сигналы другим серверным "
"процессам. Вызывать эти функции обычно могут только суперпользователи, кроме "
"явно отмеченных исключений."

#: func.xml:17129(parameter) func.xml:17154(parameter)
msgid "pid"
msgstr "pid"

#: func.xml:17129(function)
msgid "pg_cancel_backend(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_cancel_backend(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17132(entry)
#, fuzzy
msgid ""
"Cancel a backend's current query. This is also allowed if the calling role "
"is a member of the role whose backend is being canceled or the calling role "
"has been granted <literal>pg_signal_backend</literal>, however only "
"superusers can cancel superuser backends."
msgstr ""
"Отменяет текущий запрос в обслуживающем процессе. Это действие разрешается и "
"ролям, являющимся членами роли, обслуживающий процесс которой затрагивается; "
"однако только суперпользователям разрешено воздействовать на обслуживающие "
"процессы других суперпользователей."

#: func.xml:17140(function)
msgid "pg_reload_conf()"
msgstr "pg_reload_conf()"

#: func.xml:17143(entry)
msgid "Cause server processes to reload their configuration files"
msgstr "Даёт команду серверным процессам перегрузить конфигурацию"

#: func.xml:17147(function)
msgid "pg_rotate_logfile()"
msgstr "pg_rotate_logfile()"

#: func.xml:17150(entry)
msgid "Rotate server's log file"
msgstr "Прокручивает журнал сообщений сервера"

#: func.xml:17154(function)
msgid "pg_terminate_backend(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_terminate_backend(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17157(entry)
#, fuzzy
msgid ""
"Terminate a backend. This is also allowed if the calling role is a member of "
"the role whose backend is being terminated or the calling role has been "
"granted <literal>pg_signal_backend</literal>, however only superusers can "
"terminate superuser backends."
msgstr ""
"Завершает обслуживающий процесс. Это действие разрешается и ролям, "
"являющимся членами роли, обслуживающий процесс которой прерывается; однако "
"только суперпользователям разрешено прерывать обслуживающие процессы других "
"суперпользователей."

#: func.xml:17167(para)
msgid ""
"Each of these functions returns <literal>true</literal> if successful and "
"<literal>false</literal> otherwise."
msgstr ""
"Каждая из этих функций возвращает <literal>true</literal> при успешном "
"завершении и <literal>false</literal> в противном случае."

#: func.xml:17172(para)
msgid ""
"<function>pg_cancel_backend</function> and <function>pg_terminate_backend</"
"function> send signals (<systemitem>SIGINT</systemitem> or "
"<systemitem>SIGTERM</systemitem> respectively) to backend processes "
"identified by process ID. The process ID of an active backend can be found "
"from the <structfield>pid</structfield> column of the "
"<structname>pg_stat_activity</structname> view, or by listing the "
"<command>postgres</command> processes on the server (using <application>ps</"
"application> on Unix or the <application>Task Manager</application> on "
"<productname>Windows</productname>). The role of an active backend can be "
"found from the <structfield>usename</structfield> column of the "
"<structname>pg_stat_activity</structname> view."
msgstr ""
"<function>pg_cancel_backend</function> и <function>pg_terminate_backend</"
"function> передают сигналы (<systemitem>SIGINT</systemitem> и "
"<systemitem>SIGTERM</systemitem>, соответственно) серверному процессу с "
"заданным кодом PID. Код активного процесса можно получить из столбца "
"<structfield>pid</structfield> представления <structname>pg_stat_activity</"
"structname> или просмотрев на сервере процессы с именем <command>postgres</"
"command> (используя <application>ps</application> в Unix или "
"<application>Диспетчер задач</application> в <productname>Windows</"
"productname>). Роль пользователя активного процесса можно узнать в столбце "
"<structfield>usename</structfield> представления "
"<structname>pg_stat_activity</structname>."

#: func.xml:17187(para)
msgid ""
"<function>pg_reload_conf</function> sends a <systemitem>SIGHUP</systemitem> "
"signal to the server, causing configuration files to be reloaded by all "
"server processes."
msgstr ""
"<function>pg_reload_conf</function> отправляет сигнал <systemitem>SIGHUP</"
"systemitem> главному серверному процессу, который командует всем подчинённым "
"процессам перезагрузить файлы конфигурации."

#: func.xml:17193(para)
msgid ""
"<function>pg_rotate_logfile</function> signals the log-file manager to "
"switch to a new output file immediately. This works only when the built-in "
"log collector is running, since otherwise there is no log-file manager "
"subprocess."
msgstr ""
"<function>pg_rotate_logfile</function> указывает менеджеру журнала сообщений "
"немедленно переключиться на новый файл. Это имеет смысл, только когда "
"работает встроенный сборщик сообщений, так как без него подпроцесс менеджера "
"журнала не запускается."

#: func.xml:17203(title) func.xml:17254(title)
msgid "Backup Control Functions"
msgstr "Функции управления резервным копированием"

#: func.xml:17205(indexterm)
msgid "<primary>backup</primary>"
msgstr "<primary>резервная копия</primary>"

#: func.xml:17208(indexterm)
msgid "<primary>pg_create_restore_point</primary>"
msgstr "<primary>pg_create_restore_point</primary>"

#: func.xml:17211(indexterm)
#, fuzzy
msgid "<primary>pg_current_xlog_flush_location</primary>"
msgstr "<primary>pg_current_xlog_location</primary>"

#: func.xml:17214(indexterm)
msgid "<primary>pg_current_xlog_insert_location</primary>"
msgstr "<primary>pg_current_xlog_insert_location</primary>"

#: func.xml:17217(indexterm)
msgid "<primary>pg_current_xlog_location</primary>"
msgstr "<primary>pg_current_xlog_location</primary>"

#: func.xml:17220(indexterm)
msgid "<primary>pg_start_backup</primary>"
msgstr "<primary>pg_start_backup</primary>"

#: func.xml:17223(indexterm)
msgid "<primary>pg_stop_backup</primary>"
msgstr "<primary>pg_stop_backup</primary>"

#: func.xml:17226(indexterm)
msgid "<primary>pg_is_in_backup</primary>"
msgstr "<primary>pg_is_in_backup</primary>"

#: func.xml:17229(indexterm)
msgid "<primary>pg_backup_start_time</primary>"
msgstr "<primary>pg_backup_start_time</primary>"

#: func.xml:17232(indexterm)
msgid "<primary>pg_switch_xlog</primary>"
msgstr "<primary>pg_switch_xlog</primary>"

#: func.xml:17235(indexterm)
msgid "<primary>pg_xlogfile_name</primary>"
msgstr "<primary>pg_xlogfile_name</primary>"

#: func.xml:17238(indexterm)
msgid "<primary>pg_xlogfile_name_offset</primary>"
msgstr "<primary>pg_xlogfile_name_offset</primary>"

#: func.xml:17241(indexterm)
msgid "<primary>pg_xlog_location_diff</primary>"
msgstr "<primary>pg_xlog_location_diff</primary>"

#: func.xml:17245(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-backup-table\"/> "
"assist in making on-line backups. These functions cannot be executed during "
"recovery (except <function>pg_is_in_backup</function>, "
"<function>pg_backup_start_time</function> and "
"<function>pg_xlog_location_diff</function>)."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-backup-"
"table\"/>, предназначены для выполнения резервного копирования &laquo;на "
"ходу&raquo;. Эти функции нельзя выполнять во время восстановления (за "
"исключением <function>pg_is_in_backup</function>, "
"<function>pg_backup_start_time</function> и <function>pg_xlog_location_diff</"
"function>)."

#: func.xml:17264(function)
msgid "pg_create_restore_point(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_create_restore_point(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17267(entry)
#, fuzzy
msgid ""
"Create a named point for performing restore (restricted to superusers by "
"default, but other users can be granted EXECUTE to run the function)"
msgstr ""
"Создаёт именованную точку для восстановления (разрешено только "
"суперпользователям)"

#: func.xml:17271(function)
#, fuzzy
msgid "pg_current_xlog_flush_location()"
msgstr "pg_current_xlog_location()"

#: func.xml:17274(entry)
#, fuzzy
msgid "Get current transaction log flush location"
msgstr "Получает текущую позицию добавления в журнале транзакций"

#: func.xml:17278(function)
msgid "pg_current_xlog_insert_location()"
msgstr "pg_current_xlog_insert_location()"

#: func.xml:17281(entry)
msgid "Get current transaction log insert location"
msgstr "Получает текущую позицию добавления в журнале транзакций"

#: func.xml:17285(function)
msgid "pg_current_xlog_location()"
msgstr "pg_current_xlog_location()"

#: func.xml:17288(entry)
msgid "Get current transaction log write location"
msgstr "Получает текущую позицию записи в журнале транзакций"

#: func.xml:17292(parameter)
msgid "label"
msgstr "label"

#: func.xml:17292(parameter)
msgid "fast"
msgstr "fast"

#: func.xml:17292(parameter) func.xml:17306(parameter)
#, fuzzy
msgid "exclusive"
msgstr "indisexclusion"

#: func.xml:17292(optional)
#, fuzzy
msgid ", <placeholder-1/> <placeholder-2/> <placeholder-3/>"
msgstr "( <placeholder-1/> <placeholder-2/> <placeholder-3/> )"

#: func.xml:17292(function)
msgid "pg_start_backup(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "pg_start_backup(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:17295(entry)
#, fuzzy
msgid ""
"Prepare for performing on-line backup (restricted to superusers by default, "
"but other users can be granted EXECUTE to run the function)"
msgstr ""
"Подготавливает сервер к резервному копированию &laquo;на ходу&raquo; "
"(разрешено только суперпользователям и ролям репликации)"

#: func.xml:17299(function)
msgid "pg_stop_backup()"
msgstr "pg_stop_backup()"

#: func.xml:17302(entry)
#, fuzzy
msgid ""
"Finish performing exclusive on-line backup (restricted to superusers by "
"default, but other users can be granted EXECUTE to run the function)"
msgstr ""
"Сообщает об окончании резервного копирования (разрешено только "
"суперпользователям и ролям репликации)"

#: func.xml:17306(function)
#, fuzzy
msgid "pg_stop_backup(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_lock(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17309(entry)
msgid ""
"Finish performing exclusive or non-exclusive on-line backup (restricted to "
"superusers by default, but other users can be granted EXECUTE to run the "
"function)"
msgstr ""

#: func.xml:17313(function)
msgid "pg_is_in_backup()"
msgstr "pg_is_in_backup()"

#: func.xml:17316(entry)
msgid "True if an on-line exclusive backup is still in progress."
msgstr "Возвращает true в процессе исключительного резервного копирования"

#: func.xml:17320(function)
msgid "pg_backup_start_time()"
msgstr "pg_backup_start_time()"

#: func.xml:17323(entry)
msgid "Get start time of an on-line exclusive backup in progress."
msgstr ""
"Получает время запуска выполняющегося исключительного резервного копирования"

#: func.xml:17327(function)
msgid "pg_switch_xlog()"
msgstr "pg_switch_xlog()"

#: func.xml:17330(entry)
#, fuzzy
msgid ""
"Force switch to a new transaction log file (restricted to superusers by "
"default, but other users can be granted EXECUTE to run the function)"
msgstr ""
"Инициирует переключение на новый файл журнала транзакций (разрешено только "
"суперпользователям)"

#: func.xml:17334(parameter) func.xml:17341(parameter)
#: func.xml:17348(parameter)
msgid "location"
msgstr "location"

#: func.xml:17334(function)
msgid "pg_xlogfile_name(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_xlogfile_name(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17337(entry)
msgid "Convert transaction log location string to file name"
msgstr ""
"Получает из строки позиции в журнале транзакций имя соответствующего файла"

#: func.xml:17341(function)
msgid "pg_xlogfile_name_offset(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_xlogfile_name_offset(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17343(entry)
msgid "<type>text</type>, <type>integer</type>"
msgstr "<type>text</type>, <type>integer</type>"

#: func.xml:17344(entry)
msgid ""
"Convert transaction log location string to file name and decimal byte offset "
"within file"
msgstr ""
"Получает из строки позиции в журнале транзакций имя соответствующего файла и "
"десятичное смещение в нём"

#: func.xml:17348(function)
msgid ""
"pg_xlog_location_diff(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_xlog_location_diff(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:17351(entry)
msgid "Calculate the difference between two transaction log locations"
msgstr "Вычисляет разницу между двумя позициями в журнале транзакций"

#: func.xml:17371(programlisting)
#, no-wrap
msgid ""
"postgres=# select pg_start_backup('label_goes_here');\n"
" pg_start_backup\n"
"-----------------\n"
" 0/D4445B8\n"
"(1 row)"
msgstr ""
"postgres=# select pg_start_backup('label_goes_here');\n"
" pg_start_backup\n"
"-----------------\n"
" 0/D4445B8\n"
"(1 row)"

#: func.xml:17357(para)
#, fuzzy
msgid ""
"<function>pg_start_backup</function> accepts an arbitrary user-defined label "
"for the backup. (Typically this would be the name under which the backup "
"dump file will be stored.) When used in exclusive mode, the function writes "
"a backup label file (<filename>backup_label</filename>) and, if there are "
"any links in the <filename>pg_tblspc/</filename> directory, a tablespace map "
"file (<filename>tablespace_map</filename>) into the database cluster's data "
"directory, performs a checkpoint, and then returns the backup's starting "
"transaction log location as text. The user can ignore this result value, but "
"it is provided in case it is useful. When used in non-exclusive mode, the "
"contents of these files are instead returned by the "
"<function>pg_stop_backup</function> function, and should be written to the "
"backup by the caller. <placeholder-1/> There is an optional second parameter "
"of type <type>boolean</type>. If <literal>true</literal>, it specifies "
"executing <function>pg_start_backup</function> as quickly as possible. This "
"forces an immediate checkpoint which will cause a spike in I/O operations, "
"slowing any concurrently executing queries."
msgstr ""
"<function>pg_start_backup</function> принимает произвольную заданную "
"пользователем метку резервной копии. (Обычно это имя файла, в котором будет "
"сохранена резервная копия.) Эта функция записывает файл метки "
"(<filename>backup_label</filename>) и, если есть ссылки в каталоге "
"<filename>pg_tblspc/</filename>, файл карты табличных пространств "
"(<filename>tablespace_map</filename>), в каталог данных сервера, выполняет "
"процедуру контрольной точки, а затем возвращает в текстовом виде начальную "
"позицию в журнале транзакций для данной резервной копии. Результат этой "
"функции может быть полезен, но если он не нужен, его можно просто "
"игнорировать. <placeholder-1/> У этой функции есть также второй, "
"необязательный параметр типа <type>boolean</type>. Если он равен "
"<literal>true</literal>, <function>pg_start_backup</function> начнёт работу "
"максимально быстро. При этом будет немедленно выполнена процедура "
"контрольной точки, что может повлечь массу операций ввода/вывода и "
"затормозить параллельные запросы."

#: func.xml:17382(para)
msgid ""
"In an exclusive backup, <function>pg_stop_backup</function> removes the "
"label file and, if it exists, the <filename>tablespace_map</filename> file "
"created by <function>pg_start_backup</function>. In a non-exclusive backup, "
"the contents of the <filename>backup_label</filename> and "
"<filename>tablespace_map</filename> are returned in the result of the "
"function, and should be written to files in the backup (and not in the data "
"directory)."
msgstr ""

#: func.xml:17391(para)
#, fuzzy
msgid ""
"The function also creates a backup history file in the transaction log "
"archive area. The history file includes the label given to "
"<function>pg_start_backup</function>, the starting and ending transaction "
"log locations for the backup, and the starting and ending times of the "
"backup. The return value is the backup's ending transaction log location "
"(which again can be ignored). After recording the ending location, the "
"current transaction log insertion point is automatically advanced to the "
"next transaction log file, so that the ending transaction log file can be "
"archived immediately to complete the backup."
msgstr ""
"<function>pg_stop_backup</function> удаляет файл метки (и если существует, "
"<filename>tablespace_map</filename>), созданный функцией "
"<function>pg_start_backup</function>, и создаёт файл истории резервного "
"копирования в архивной области журнала транзакций. В этом файле для данной "
"резервной копии сохраняется метка, заданная при вызове "
"<function>pg_start_backup</function>, начальная и конечная позиция в журнале "
"транзакций, а также время начала и окончания. Возвращает данная функция "
"позицию окончания резервной копии в журнале транзакций (которую тоже можно "
"игнорировать). После записи конечной позиции текущая позиция записи "
"автоматически перемещается к следующему файлу журнала транзакций, чтобы файл "
"конечной позиции можно было немедленно архивировать для завершения "
"резервного копирования."

#: func.xml:17403(para)
msgid ""
"<function>pg_switch_xlog</function> moves to the next transaction log file, "
"allowing the current file to be archived (assuming you are using continuous "
"archiving). The return value is the ending transaction log location + 1 "
"within the just-completed transaction log file. If there has been no "
"transaction log activity since the last transaction log switch, "
"<function>pg_switch_xlog</function> does nothing and returns the start "
"location of the transaction log file currently in use."
msgstr ""
"<function>pg_switch_xlog</function> производит переключение на следующий "
"файл журнала транзакций, что позволяет архивировать текущий (в ситуации, "
"когда архивация выполняется непрерывно). Эта функция возвращает конечную "
"позицию + 1 в только что законченном файле журнала транзакций. Если с "
"момента последнего переключения файлов не было активности, отражающейся в "
"журнале транзакций, <function>pg_switch_xlog</function> ничего не делает и "
"возвращает начальную позицию в файле журнала транзакций, используемом в "
"данный момент."

#: func.xml:17412(para)
msgid ""
"<function>pg_create_restore_point</function> creates a named transaction log "
"record that can be used as recovery target, and returns the corresponding "
"transaction log location. The given name can then be used with <xref linkend="
"\"recovery-target-name\"/> to specify the point up to which recovery will "
"proceed. Avoid creating multiple restore points with the same name, since "
"recovery will stop at the first one whose name matches the recovery target."
msgstr ""
"<function>pg_create_restore_point</function> создаёт именованную запись в "
"журнале транзакций, которую можно использовать как цель при восстановлении, "
"и возвращает соответствующую позицию в журнале транзакций. Затем полученное "
"имя можно присвоить параметру <xref linkend=\"recovery-target-name\"/>, "
"указав тем самым точку, до которой будет выполняться восстановление. Учтите, "
"что если вы создадите несколько точек восстановления с одним именем, "
"восстановление будет остановлено на первой точке с этим именем."

#: func.xml:17422(para)
#, fuzzy
msgid ""
"<function>pg_current_xlog_location</function> displays the current "
"transaction log write location in the same format used by the above "
"functions. Similarly, <function>pg_current_xlog_insert_location</function> "
"displays the current transaction log insertion point and "
"<function>pg_current_xlog_flush_location</function> displays the current "
"transaction log flush point. The insertion point is the <quote>logical</"
"quote> end of the transaction log at any instant, while the write location "
"is the end of what has actually been written out from the server's internal "
"buffers and flush location is the location guaranteed to be written to "
"durable storage. The write location is the end of what can be examined from "
"outside the server, and is usually what you want if you are interested in "
"archiving partially-complete transaction log files. The insertion and flush "
"points are made available primarily for server debugging purposes. These are "
"both read-only operations and do not require superuser permissions."
msgstr ""
"<function>pg_current_xlog_location</function> выводит текущую позицию записи "
"в журнале транзакций в том же формате, что и вышеописанные функции. "
"<function>pg_current_xlog_insert_location</function> подобным образом "
"выводит текущую позицию добавления в журнале транзакций. Позицией добавления "
"называется <quote>логический</quote> конец журнала транзакций в любой момент "
"времени, тогда как позиция записи указывает на конец данных, фактически "
"перенесённых на диск из внутренних буферов сервера. Позиция записи отмечает "
"конец данных, которые может видеть снаружи внешний процесс, и именно она "
"представляет интерес при копировании частично заполненных файлов журнала "
"транзакций. Позиция добавления выводится в основном для отладки. Обе эти "
"функции работают в режиме &laquo;только чтение&raquo; и вызывать их можно "
"без прав суперпользователя."

#: func.xml:17442(programlisting)
#, no-wrap
msgid ""
"postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());\n"
"        file_name         | file_offset \n"
"--------------------------+-------------\n"
" 00000001000000000000000D |     4039624\n"
"(1 row)"
msgstr ""
"postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());\n"
"        file_name         | file_offset \n"
"--------------------------+-------------\n"
" 00000001000000000000000D |     4039624\n"
"(1 row)"

#: func.xml:17438(para)
msgid ""
"You can use <function>pg_xlogfile_name_offset</function> to extract the "
"corresponding transaction log file name and byte offset from the results of "
"any of the above functions. For example: <placeholder-1/> Similarly, "
"<function>pg_xlogfile_name</function> extracts just the transaction log file "
"name. When the given transaction log location is exactly at a transaction "
"log file boundary, both these functions return the name of the preceding "
"transaction log file. This is usually the desired behavior for managing "
"transaction log archiving behavior, since the preceding file is the last one "
"that currently needs to be archived."
msgstr ""
"Из результатов всех описанных выше функций можно получить соответствующее "
"имя файла журнала транзакций и смещение в нём, используя функцию "
"<function>pg_xlogfile_name_offset</function>. Например: <placeholder-1/> "
"Подобная ей функция <function>pg_xlogfile_name</function> извлекает только "
"имя файла журнала транзакций. Когда позиция в журнале транзакций находится "
"ровно на границе файлов, обе эти функции возвращают имя предыдущего файла. "
"Обычно это поведение предпочтительно при архивировании журнала, так как "
"именно предыдущий файл является последним подлежащим архивации."

#: func.xml:17455(para)
msgid ""
"<function>pg_xlog_location_diff</function> calculates the difference in "
"bytes between two transaction log locations. It can be used with "
"<structname>pg_stat_replication</structname> or some functions shown in "
"<xref linkend=\"functions-admin-backup-table\"/> to get the replication lag."
msgstr ""
"<function>pg_xlog_location_diff</function> вычисляет разницу в байтах между "
"двумя позициями в журнале транзакций. Полученный результат можно "
"использовать с <structname>pg_stat_replication</structname> или другими "
"функциями, перечисленными в <xref remap=\"6\" linkend=\"functions-admin-"
"backup-table\"/>, для определения задержки репликации."

#: func.xml:17462(para)
msgid ""
"For details about proper usage of these functions, see <xref linkend="
"\"continuous-archiving\"/>."
msgstr ""
"Подробнее практическое применение этих функций описывается в <xref remap="
"\"6\" linkend=\"continuous-archiving\"/>."

#: func.xml:17470(title) func.xml:17573(title)
msgid "Recovery Control Functions"
msgstr "Функции управления восстановлением"

#: func.xml:17472(indexterm)
msgid "<primary>pg_is_in_recovery</primary>"
msgstr "<primary>pg_is_in_recovery</primary>"

#: func.xml:17475(indexterm)
msgid "<primary>pg_last_xlog_receive_location</primary>"
msgstr "<primary>pg_last_xlog_receive_location</primary>"

#: func.xml:17478(indexterm)
msgid "<primary>pg_last_xlog_replay_location</primary>"
msgstr "<primary>pg_last_xlog_replay_location</primary>"

#: func.xml:17481(indexterm)
msgid "<primary>pg_last_xact_replay_timestamp</primary>"
msgstr "<primary>pg_last_xact_replay_timestamp</primary>"

#: func.xml:17485(para)
msgid ""
"The functions shown in <xref linkend=\"functions-recovery-info-table\"/> "
"provide information about the current status of the standby. These functions "
"may be executed both during recovery and in normal running."
msgstr ""
"Функции, приведённые в <xref remap=\"6\" linkend=\"functions-recovery-info-"
"table\"/>, предоставляют сведения о текущем состоянии резервного сервера. "
"Эти функции могут выполняться, как во время восстановления, так и в обычном "
"режиме работы."

#: func.xml:17493(title)
msgid "Recovery Information Functions"
msgstr "Функции для получения информации о восстановлении"

#: func.xml:17503(function)
msgid "pg_is_in_recovery()"
msgstr "pg_is_in_recovery()"

#: func.xml:17506(entry)
msgid "True if recovery is still in progress."
msgstr "Возвращает true в процессе восстановления."

#: func.xml:17511(function)
msgid "pg_last_xlog_receive_location()"
msgstr "pg_last_xlog_receive_location()"

#: func.xml:17514(entry)
msgid ""
"Get last transaction log location received and synced to disk by streaming "
"replication. While streaming replication is in progress this will increase "
"monotonically. If recovery has completed this will remain static at the "
"value of the last WAL record received and synced to disk during recovery. If "
"streaming replication is disabled, or if it has not yet started, the "
"function returns NULL."
msgstr ""
"Получает позицию последней записи журнала транзакций, полученной и "
"записанной на диск в процессе потоковой репликации. Пока выполняется "
"потоковая репликация, эта позиция постоянно увеличивается. По окончании "
"восстановления она останавливается на записи WAL, полученной и записанной на "
"диск последней. Если потоковая репликация отключена или ещё не запускалась, "
"функция возвращает NULL."

#: func.xml:17525(function)
msgid "pg_last_xlog_replay_location()"
msgstr "pg_last_xlog_replay_location()"

#: func.xml:17528(entry)
msgid ""
"Get last transaction log location replayed during recovery. If recovery is "
"still in progress this will increase monotonically. If recovery has "
"completed then this value will remain static at the value of the last WAL "
"record applied during that recovery. When the server has been started "
"normally without recovery the function returns NULL."
msgstr ""
"Получает позицию последней записи журнала транзакций, воспроизведённой при "
"восстановлении. В процессе восстановления эта позиция постоянно "
"увеличивается. По окончании восстановления она останавливается на записи "
"WAL, которая была восстановлена последней. Если сервер был запущен не в "
"режиме восстановления, эта функция возвращает NULL."

#: func.xml:17538(function)
msgid "pg_last_xact_replay_timestamp()"
msgstr "pg_last_xact_replay_timestamp()"

#: func.xml:17541(entry)
msgid ""
"Get time stamp of last transaction replayed during recovery. This is the "
"time at which the commit or abort WAL record for that transaction was "
"generated on the primary. If no transactions have been replayed during "
"recovery, this function returns NULL. Otherwise, if recovery is still in "
"progress this will increase monotonically. If recovery has completed then "
"this value will remain static at the value of the last transaction applied "
"during that recovery. When the server has been started normally without "
"recovery the function returns NULL."
msgstr ""
"Получает отметку времени последней транзакции, воспроизведённой при "
"восстановлении. Это время, когда на главном сервере произошла фиксация или "
"откат записи WAL для этой транзакции. Если в процессе восстановления не была "
"воспроизведена ни одна транзакция, эта функция возвращает NULL. В противном "
"случае это значение постоянно увеличивается в процессе восстановления. По "
"окончании восстановления оно останавливается на транзакции, которая была "
"восстановлена последней. Если сервер был запущен не в режиме восстановления, "
"эта функция возвращает NULL."

#: func.xml:17556(indexterm)
msgid "<primary>pg_is_xlog_replay_paused</primary>"
msgstr "<primary>pg_is_xlog_replay_paused</primary>"

#: func.xml:17559(indexterm)
msgid "<primary>pg_xlog_replay_pause</primary>"
msgstr "<primary>pg_xlog_replay_pause</primary>"

#: func.xml:17562(indexterm)
msgid "<primary>pg_xlog_replay_resume</primary>"
msgstr "<primary>pg_xlog_replay_resume</primary>"

#: func.xml:17566(para)
msgid ""
"The functions shown in <xref linkend=\"functions-recovery-control-table\"/> "
"control the progress of recovery. These functions may be executed only "
"during recovery."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-recovery-"
"control-table\"/> управляют процессом восстановления. Вызывать их в другое "
"время нельзя."

#: func.xml:17583(function)
msgid "pg_is_xlog_replay_paused()"
msgstr "pg_is_xlog_replay_paused()"

#: func.xml:17586(entry)
msgid "True if recovery is paused."
msgstr "Возвращает true, если восстановление приостановлено."

#: func.xml:17591(function)
msgid "pg_xlog_replay_pause()"
msgstr "pg_xlog_replay_pause()"

#: func.xml:17594(entry)
#, fuzzy
msgid ""
"Pauses recovery immediately (restricted to superusers by default, but other "
"users can be granted EXECUTE to run the function)."
msgstr ""
"Немедленно приостанавливает восстановление (разрешено только "
"суперпользователям)."

#: func.xml:17599(function)
msgid "pg_xlog_replay_resume()"
msgstr "pg_xlog_replay_resume()"

#: func.xml:17602(entry)
#, fuzzy
msgid ""
"Restarts recovery if it was paused (restricted to superusers by default, but "
"other users can be granted EXECUTE to run the function)."
msgstr ""
"Запускает восстановление, если оно было приостановлено (разрешено только "
"суперпользователям)."

#: func.xml:17609(para)
msgid ""
"While recovery is paused no further database changes are applied. If in hot "
"standby, all new queries will see the same consistent snapshot of the "
"database, and no further query conflicts will be generated until recovery is "
"resumed."
msgstr ""
"Когда восстановление приостановлено, запись изменений в базу не "
"производится. Если она находится в &laquo;горячем резерве&raquo;, все "
"последующие запросы будут видеть один согласованный снимок базы данных и до "
"продолжения восстановления конфликты запросов исключаются."

#: func.xml:17616(para)
msgid ""
"If streaming replication is disabled, the paused state may continue "
"indefinitely without problem. While streaming replication is in progress WAL "
"records will continue to be received, which will eventually fill available "
"disk space, depending upon the duration of the pause, the rate of WAL "
"generation and available disk space."
msgstr ""
"Когда потоковая репликация выключена, пауза при восстановлении может длиться "
"сколь угодно долго без каких-либо проблем. Если же запущена потоковая "
"репликация, новые записи WAL продолжат поступать и заполнят весь диск рано "
"или поздно, в зависимости от длительности паузы, интенсивности записи в WAL "
"и объёма свободного пространства."

#: func.xml:17627(title) func.xml:17664(title)
msgid "Snapshot Synchronization Functions"
msgstr "Функции синхронизации снимков"

#: func.xml:17629(indexterm)
msgid "<primary>pg_export_snapshot</primary>"
msgstr "<primary>pg_export_snapshot</primary>"

#: func.xml:17633(para)
msgid ""
"<productname>PostgreSQL</productname> allows database sessions to "
"synchronize their snapshots. A <firstterm>snapshot</firstterm> determines "
"which data is visible to the transaction that is using the snapshot. "
"Synchronized snapshots are necessary when two or more sessions need to see "
"identical content in the database. If two sessions just start their "
"transactions independently, there is always a possibility that some third "
"transaction commits between the executions of the two <command>START "
"TRANSACTION</command> commands, so that one session sees the effects of that "
"transaction and the other does not."
msgstr ""
"<productname>PostgreSQL</productname> позволяет синхронизировать снимки "
"состояния между сеансами баз данных. <firstterm>Снимок состояния</firstterm> "
"определяет, какие данные видны транзакции, работающей с этим снимком. "
"Синхронизация снимков необходима, когда в двух или более сеансах нужно "
"видеть одно и то же содержимое базы данных. Если в двух сеансах транзакции "
"запускаются независимо, всегда есть вероятность, что некая третья транзакция "
"будет зафиксирована между командами <command>START TRANSACTION</command> для "
"первых двух, и в результате в одном сеансе будет виден результат третьей, а "
"в другом &mdash; нет."

#: func.xml:17645(para)
msgid ""
"To solve this problem, <productname>PostgreSQL</productname> allows a "
"transaction to <firstterm>export</firstterm> the snapshot it is using. As "
"long as the exporting transaction remains open, other transactions can "
"<firstterm>import</firstterm> its snapshot, and thereby be guaranteed that "
"they see exactly the same view of the database that the first transaction "
"sees. But note that any database changes made by any one of these "
"transactions remain invisible to the other transactions, as is usual for "
"changes made by uncommitted transactions. So the transactions are "
"synchronized with respect to pre-existing data, but act normally for changes "
"they make themselves."
msgstr ""
"Для решения этой проблемы <productname>PostgreSQL</productname> позволяет "
"транзакции <firstterm>экспортировать</firstterm> снимок состояния, с которым "
"она работает. Пока экспортирующая этот снимок транзакция выполняется, другие "
"транзакции могут <firstterm>импортировать</firstterm> его и, таким образом, "
"увидеть абсолютно то же состояние базы данных, что видит первая транзакция. "
"Но учтите, что любые изменения, произведённые этими транзакциями, будут не "
"видны для других, как это и должно быть с изменениями в незафиксированных "
"транзакциях. Таким образом, транзакции синхронизируют только начальное "
"состояние данных, а последующие производимые в них изменения изолируются как "
"обычно."

#: func.xml:17657(para)
msgid ""
"Snapshots are exported with the <function>pg_export_snapshot</function> "
"function, shown in <xref linkend=\"functions-snapshot-synchronization-table"
"\"/>, and imported with the <xref linkend=\"sql-set-transaction\"/> command."
msgstr ""
"Снимки состояния экспортируются с помощью функции "
"<function>pg_export_snapshot</function>, показанной в <xref remap=\"6\" "
"linkend=\"functions-snapshot-synchronization-table\"/>, и импортируются "
"командой <xref linkend=\"sql-set-transaction\"/>."

#: func.xml:17674(function)
msgid "pg_export_snapshot()"
msgstr "pg_export_snapshot()"

#: func.xml:17677(entry)
msgid "Save the current snapshot and return its identifier"
msgstr "Сохраняет снимок текущего состояния и возвращает его идентификатор"

#: func.xml:17683(para)
msgid ""
"The function <function>pg_export_snapshot</function> saves the current "
"snapshot and returns a <type>text</type> string identifying the snapshot. "
"This string must be passed (outside the database) to clients that want to "
"import the snapshot. The snapshot is available for import only until the end "
"of the transaction that exported it. A transaction can export more than one "
"snapshot, if needed. Note that doing so is only useful in <literal>READ "
"COMMITTED</literal> transactions, since in <literal>REPEATABLE READ</"
"literal> and higher isolation levels, transactions use the same snapshot "
"throughout their lifetime. Once a transaction has exported any snapshots, it "
"cannot be prepared with <xref linkend=\"sql-prepare-transaction\"/>."
msgstr ""
"Функция <function>pg_export_snapshot</function> создаёт снимок текущего "
"состояния и возвращает его идентификатор в строке типа <type>text</type>. "
"Данная строка должна передаваться (за рамками базы данных) клиентам, которые "
"будут импортировать этот снимок. При этом импортировать его нужно раньше, "
"чем завершится транзакция, которая его экспортировала. Если необходимо, "
"транзакция может экспортировать несколько снимков. Заметьте, что это имеет "
"смысл только для транзакций уровня <literal>READ COMMITTED</literal>, так "
"как транзакции <literal>REPEATABLE READ</literal> и более высоких уровней "
"изоляции работают с одним снимком состояния. После того, как транзакция "
"экспортировала снимок, её нельзя подготовить с помощью <xref linkend=\"sql-"
"prepare-transaction\"/>."

#: func.xml:17696(para)
msgid ""
"See <xref linkend=\"sql-set-transaction\"/> for details of how to use an "
"exported snapshot."
msgstr ""
"Подробнее использование экспортированных снимков рассматривается в описании "
"<xref linkend=\"sql-set-transaction\"/>."

#: func.xml:17703(title)
msgid "Replication Functions"
msgstr "Функции репликации"

#: func.xml:17705(para)
msgid ""
"The functions shown in <xref linkend=\"functions-replication-table\"/> are "
"for controlling and interacting with replication features. See <xref linkend="
"\"streaming-replication\"/>, <xref linkend=\"streaming-replication-slots\"/"
">, and <xref linkend=\"replication-origins\"/> for information about the "
"underlying features. Use of these functions is restricted to superusers."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-replication-table\"/> перечислены "
"функции, предназначенные для управления и взаимодействия с механизмом "
"репликации. Чтобы изучить этот механизм детальнее, обратитесь к <xref remap="
"\"3\" linkend=\"streaming-replication\"/>, <xref remap=\"3\" linkend="
"\"streaming-replication-slots\"/> и <xref remap=\"3\" linkend=\"replication-"
"origins\"/>. Использовать эти функции разрешено только суперпользователям."

#: func.xml:17716(para)
msgid ""
"Many of these functions have equivalent commands in the replication "
"protocol; see <xref linkend=\"protocol-replication\"/>."
msgstr ""
"Многие из этих функций соответствуют командам в протоколе репликации; см. "
"<xref remap=\"4\" linkend=\"protocol-replication\"/>."

#: func.xml:17721(para)
msgid ""
"The functions described in <xref linkend=\"functions-admin-backup\"/>, <xref "
"linkend=\"functions-recovery-control\"/>, and <xref linkend=\"functions-"
"snapshot-synchronization\"/> are also relevant for replication."
msgstr ""
"Функции, описанные в <xref remap=\"6\" linkend=\"functions-admin-backup\"/>, "
"<xref linkend=\"functions-recovery-control\"/> и <xref remap=\"6\" linkend="
"\"functions-snapshot-synchronization\"/> также имеют отношение к репликации."

#: func.xml:17730(title)
msgid "Replication <acronym>SQL</acronym> Functions"
msgstr "Функции репликации <acronym>SQL</acronym>"

#: func.xml:17742(indexterm)
msgid "<primary>pg_create_physical_replication_slot</primary>"
msgstr "<primary>pg_create_physical_replication_slot</primary>"

#: func.xml:17745(parameter) func.xml:17768(parameter)
#: func.xml:17785(parameter) func.xml:17804(parameter)
#: func.xml:17829(parameter) func.xml:17847(parameter)
#: func.xml:17864(parameter)
msgid "slot_name"
msgstr "slot_name"

#: func.xml:17745(parameter)
#, fuzzy
msgid "immediately_reserve"
msgstr "i[mmediate]"

#: func.xml:17745(function)
#, fuzzy
msgid ""
"pg_create_physical_replication_slot(<placeholder-1/> <placeholder-2/> "
"<placeholder-3/>)"
msgstr "pg_create_physical_replication_slot(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17747(entry) func.xml:17787(entry)
msgid ""
"(<parameter>slot_name</parameter> <type>name</type>, "
"<parameter>xlog_position</parameter> <type>pg_lsn</type>)"
msgstr ""
"(<parameter>slot_name</parameter> <type>name</type>, "
"<parameter>xlog_position</parameter> <type>pg_lsn</type>)"

#: func.xml:17750(entry)
#, fuzzy
msgid ""
"Creates a new physical replication slot named <parameter>slot_name</"
"parameter>. The optional second parameter, when <literal>true</literal>, "
"specifies that the <acronym>LSN</acronym> for this replication slot be "
"reserved immediately; otherwise the <acronym>LSN</acronym> is reserved on "
"first connection from a streaming replication client. Streaming changes from "
"a physical slot is only possible with the streaming-replication protocol "
"&mdash; see <xref linkend=\"protocol-replication\"/>. This function "
"corresponds to the replication protocol command "
"<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>."
msgstr ""
"Создаёт новый физический слот репликации с именем <parameter>slot_name</"
"parameter>. Передача изменений из физического слота возможна только по "
"протоколу потоковой репликации &mdash; см. <xref remap=\"4\" linkend="
"\"protocol-replication\"/>. Соответствует команде протокола репликации "
"<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>."

#: func.xml:17765(indexterm)
msgid "<primary>pg_drop_replication_slot</primary>"
msgstr "<primary>pg_drop_replication_slot</primary>"

#: func.xml:17768(function)
msgid "pg_drop_replication_slot(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_drop_replication_slot(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17773(entry)
msgid ""
"Drops the physical or logical replication slot named <parameter>slot_name</"
"parameter>. Same as replication protocol command "
"<literal>DROP_REPLICATION_SLOT</literal>."
msgstr ""
"Удаляет физический или логический слот репликации с именем "
"<parameter>slot_name</parameter>. Соответствует команде протокола репликации "
"<literal>DROP_REPLICATION_SLOT</literal>."

#: func.xml:17782(indexterm)
msgid "<primary>pg_create_logical_replication_slot</primary>"
msgstr "<primary>pg_create_logical_replication_slot</primary>"

#: func.xml:17785(parameter)
msgid "plugin"
msgstr "plugin"

#: func.xml:17785(function)
msgid ""
"pg_create_logical_replication_slot(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_create_logical_replication_slot(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:17790(entry)
msgid ""
"Creates a new logical (decoding) replication slot named "
"<parameter>slot_name</parameter> using the output plugin <parameter>plugin</"
"parameter>. A call to this function has the same effect as the replication "
"protocol command <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>."
msgstr ""
"Создаёт новый логический (декодирующий) слот репликации с именем "
"<parameter>slot_name</parameter>, используя модуль вывода <parameter>plugin</"
"parameter>. Эта функция работает так же, как и команда протокола репликации "
"<literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>."

#: func.xml:17801(indexterm)
msgid "<primary>pg_logical_slot_get_changes</primary>"
msgstr "<primary>pg_logical_slot_get_changes</primary>"

#: func.xml:17804(parameter) func.xml:17829(parameter)
#: func.xml:17847(parameter) func.xml:17864(parameter)
msgid "upto_lsn"
msgstr "upto_lsn"

#: func.xml:17804(parameter) func.xml:17829(parameter)
#: func.xml:17847(parameter) func.xml:17864(parameter)
msgid "upto_nchanges"
msgstr "upto_nchanges"

#: func.xml:17804(parameter) func.xml:17829(parameter)
#: func.xml:17847(parameter) func.xml:17864(parameter)
msgctxt "parameter"
msgid "options"
msgstr "options"

#: func.xml:17804(function)
msgid ""
"pg_logical_slot_get_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_get_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#: func.xml:17806(entry)
msgid ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"
msgstr ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"

#: func.xml:17809(entry)
msgid ""
"Returns changes in the slot <parameter>slot_name</parameter>, starting from "
"the point at which since changes have been consumed last. If "
"<parameter>upto_lsn</parameter> and <parameter>upto_nchanges</parameter> are "
"NULL, logical decoding will continue until end of WAL. If "
"<parameter>upto_lsn</parameter> is non-NULL, decoding will include only "
"those transactions which commit prior to the specified LSN. If "
"<parameter>upto_nchanges</parameter> is non-NULL, decoding will stop when "
"the number of rows produced by decoding exceeds the specified value. Note, "
"however, that the actual number of rows returned may be larger, since this "
"limit is only checked after adding the rows produced when decoding each new "
"transaction commit."
msgstr ""
"Возвращает изменения в слоте <parameter>slot_name</parameter> с позиции, до "
"которой ранее были получены изменения. Если параметры <parameter>upto_lsn</"
"parameter> и <parameter>upto_nchanges</parameter> равны NULL, логическое "
"декодирование продолжится до конца журнала транзакций. Если "
"<parameter>upto_lsn</parameter> не NULL, декодироваться будут только "
"транзакции, зафиксированные до заданного LSN. Если <parameter>upto_nchanges</"
"parameter> не NULL, декодирование остановится, когда число строк, полученных "
"при декодировании, превысит заданное значение. Заметьте, однако, что "
"фактическое число возвращённых строк может быть больше, так как это "
"ограничение проверяется только после добавления строк, декодированных для "
"очередной транзакции."

#: func.xml:17826(indexterm)
msgid "<primary>pg_logical_slot_peek_changes</primary>"
msgstr "<primary>pg_logical_slot_peek_changes</primary>"

#: func.xml:17829(function)
msgid ""
"pg_logical_slot_peek_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_peek_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#: func.xml:17831(entry)
msgid ""
"(<parameter>location</parameter> <type>text</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"
msgstr ""
"(<parameter>location</parameter> <type>text</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"

#: func.xml:17834(entry)
msgid ""
"Behaves just like the <function>pg_logical_slot_get_changes()</function> "
"function, except that changes are not consumed; that is, they will be "
"returned again on future calls."
msgstr ""
"Работает так же, как функция <function>pg_logical_slot_get_changes()</"
"function>, но не забирает изменения; то есть, они будут получены снова при "
"следующих вызовах."

#: func.xml:17844(indexterm)
msgid "<primary>pg_logical_slot_get_binary_changes</primary>"
msgstr "<primary>pg_logical_slot_get_binary_changes</primary>"

#: func.xml:17847(function)
msgid ""
"pg_logical_slot_get_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_get_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#: func.xml:17849(entry) func.xml:17866(entry)
msgid ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)"
msgstr ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)"

#: func.xml:17852(entry)
msgid ""
"Behaves just like the <function>pg_logical_slot_get_changes()</function> "
"function, except that changes are returned as <type>bytea</type>."
msgstr ""
"Работает так же, как функция <function>pg_logical_slot_get_changes()</"
"function>, но выдаёт изменения в типе <type>bytea</type>."

#: func.xml:17861(indexterm)
msgid "<primary>pg_logical_slot_peek_binary_changes</primary>"
msgstr "<primary>pg_logical_slot_peek_binary_changes</primary>"

#: func.xml:17864(function)
msgid ""
"pg_logical_slot_peek_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_peek_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#: func.xml:17869(entry)
msgid ""
"Behaves just like the <function>pg_logical_slot_get_changes()</function> "
"function, except that changes are returned as <type>bytea</type> and that "
"changes are not consumed; that is, they will be returned again on future "
"calls."
msgstr ""
"Работает так же, как функция <function>pg_logical_slot_get_changes()</"
"function>, но выдаёт изменения в типе <type>bytea</type> и не забирает их; "
"то есть, они будут получены снова при следующих вызовах."

#: func.xml:17880(indexterm)
msgid "<primary>pg_replication_origin_create</primary>"
msgstr "<primary>pg_replication_origin_create</primary>"

#: func.xml:17883(parameter) func.xml:17899(parameter)
#: func.xml:17915(parameter) func.xml:17931(parameter)
#: func.xml:18033(parameter) func.xml:18052(parameter)
msgid "node_name"
msgstr "node_name"

#: func.xml:17883(function)
msgid "pg_replication_origin_create(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_create(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17888(entry)
msgid ""
"Create a replication origin with the given external name, and return the "
"internal id assigned to it."
msgstr ""
"Создаёт источник репликации с заданным внешним именем и возвращает "
"назначенный ему внутренний идентификатор."

#: func.xml:17896(indexterm)
msgid "<primary>pg_replication_origin_drop</primary>"
msgstr "<primary>pg_replication_origin_drop</primary>"

#: func.xml:17899(function)
msgid "pg_replication_origin_drop(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_drop(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17901(entry) func.xml:17933(entry) func.xml:17951(entry)
#: func.xml:18000(entry) func.xml:18019(entry) func.xml:18035(entry)
msgctxt "entry"
msgid "void"
msgstr "void"

#: func.xml:17904(entry)
msgid ""
"Delete a previously created replication origin, including any associated "
"replay progress."
msgstr ""
"Удаляет ранее созданный источник репликации, в том числе связанную "
"информацию о воспроизведении."

#: func.xml:17912(indexterm)
msgid "<primary>pg_replication_origin_oid</primary>"
msgstr "<primary>pg_replication_origin_oid</primary>"

#: func.xml:17915(function)
msgid "pg_replication_origin_oid(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_oid(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17920(entry)
msgid ""
"Lookup a replication origin by name and return the internal id. If no "
"corresponding replication origin is found an error is thrown."
msgstr ""
"Ищет источник репликации по имени и возвращает внутренний идентификатор. "
"Если такой источник не находится, выдаётся ошибка."

#: func.xml:17928(indexterm)
msgid "<primary>pg_replication_origin_session_setup</primary>"
msgstr "<primary>pg_replication_origin_session_setup</primary>"

#: func.xml:17931(function)
msgid "pg_replication_origin_session_setup(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_session_setup(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17936(entry)
msgid ""
"Mark the current session as replaying from the given origin, allowing replay "
"progress to be tracked. Use <function>pg_replication_origin_session_reset</"
"function> to revert. Can only be used if no previous origin is configured."
msgstr ""
"Помечает текущий сеанс, как воспроизводящий журнал из указанного источника, "
"что позволяет отслеживать положение воспроизведения. Чтобы отменить это "
"действие, вызовите <function>pg_replication_origin_session_reset</function>. "
"Может использоваться, только если не был настроен предыдущий источник."

#: func.xml:17946(indexterm)
msgid "<primary>pg_replication_origin_session_reset</primary>"
msgstr "<primary>pg_replication_origin_session_reset</primary>"

#: func.xml:17949(function)
msgid "pg_replication_origin_session_reset()"
msgstr "pg_replication_origin_session_reset()"

#: func.xml:17954(entry)
msgid ""
"Cancel the effects of <function>pg_replication_origin_session_setup()</"
"function>."
msgstr ""
"Отменяет действие <function>pg_replication_origin_session_setup()</function>."

#: func.xml:17962(indexterm)
msgid "<primary>pg_replication_origin_session_is_setup</primary>"
msgstr "<primary>pg_replication_origin_session_is_setup</primary>"

#: func.xml:17965(function)
msgid "pg_replication_origin_session_is_setup()"
msgstr "pg_replication_origin_session_is_setup()"

#: func.xml:17970(entry)
msgid "Has a replication origin been configured in the current session?"
msgstr "В текущем сеансе настроен источник репликации?"

#: func.xml:17977(indexterm)
msgid "<primary>pg_replication_origin_session_progress</primary>"
msgstr "<primary>pg_replication_origin_session_progress</primary>"

#: func.xml:17980(parameter) func.xml:18052(parameter)
msgid "flush"
msgstr "flush"

#: func.xml:17980(function)
msgid ""
"pg_replication_origin_session_progress(<placeholder-1/> <placeholder-2/>)"
msgstr ""
"pg_replication_origin_session_progress(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17985(entry)
msgid ""
"Return the replay position for the replication origin configured in the "
"current session. The parameter <parameter>flush</parameter> determines "
"whether the corresponding local transaction will be guaranteed to have been "
"flushed to disk or not."
msgstr ""
"Возвращает позицию воспроизведения для источника репликации, настроенного в "
"текущем сеансе. Параметр <parameter>flush</parameter> определяет, будет ли "
"гарантироваться сохранение локальной транзакции на диске."

#: func.xml:17995(indexterm)
msgid "<primary>pg_replication_origin_xact_setup</primary>"
msgstr "<primary>pg_replication_origin_xact_setup</primary>"

#: func.xml:17998(parameter)
msgid "origin_lsn"
msgstr "origin_lsn"

#: func.xml:17998(parameter)
msgid "origin_timestamp"
msgstr "origin_timestamp"

#: func.xml:17998(type)
msgid "timestamptz"
msgstr "timestamptz"

#: func.xml:17998(function)
msgid ""
"pg_replication_origin_xact_setup(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_replication_origin_xact_setup(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:18003(entry)
msgid ""
"Mark the current transaction as replaying a transaction that has committed "
"at the given <acronym>LSN</acronym> and timestamp. Can only be called when a "
"replication origin has previously been configured using "
"<function>pg_replication_origin_session_setup()</function>."
msgstr ""
"Помечает текущую транзакцию как воспроизводящую транзакцию, зафиксированную "
"с указанным <acronym>LSN</acronym> и временем. Может вызываться только после "
"того, как был настроен источник репликации в результате вызова "
"<function>pg_replication_origin_session_setup()</function>."

#: func.xml:18014(indexterm)
msgid "<primary>pg_replication_origin_xact_reset</primary>"
msgstr "<primary>pg_replication_origin_xact_reset</primary>"

#: func.xml:18017(function)
msgid "pg_replication_origin_xact_reset()"
msgstr "pg_replication_origin_xact_reset()"

#: func.xml:18022(entry)
msgid ""
"Cancel the effects of <function>pg_replication_origin_xact_setup()</"
"function>."
msgstr ""
"Отменяет действие <function>pg_replication_origin_xact_setup()</function>."

#: func.xml:18030(indexterm)
msgid "<primary>pg_replication_origin_advance</primary>"
msgstr "<primary>pg_replication_origin_advance</primary>"

#: func.xml:18033(parameter)
msgid "pos"
msgstr "pos"

#: func.xml:18033(function)
msgid "(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr "(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:18033(literal)
msgid "pg_replication_origin_advance<placeholder-1/>"
msgstr "pg_replication_origin_advance<placeholder-1/>"

#: func.xml:18038(entry)
msgid ""
"Set replication progress for the given node to the given position. This "
"primarily is useful for setting up the initial position or a new position "
"after configuration changes and similar. Be aware that careless use of this "
"function can lead to inconsistently replicated data."
msgstr ""
"Устанавливает положение репликации для заданного узла в указанную позицию. "
"Это в основном полезно для установки начальной позиции или новой позиции "
"после изменения конфигурации и подобных действий. Но учтите, что "
"неосторожное использование этой функции может привести к несогласованности "
"реплицированных данных."

#: func.xml:18049(indexterm)
msgid "<primary>pg_replication_origin_progress</primary>"
msgstr "<primary>pg_replication_origin_progress</primary>"

#: func.xml:18052(function)
msgid ""
"pg_replication_origin_progress(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_replication_origin_progress(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:18057(entry)
msgid ""
"Return the replay position for the given replication origin. The parameter "
"<parameter>flush</parameter> determines whether the corresponding local "
"transaction will be guaranteed to have been flushed to disk or not."
msgstr ""
"Возвращает позицию воспроизведения для заданного источника репликации. "
"Параметр <parameter>flush</parameter> определяет, будет ли гарантироваться "
"сохранение локальной транзакции на диске."

#: func.xml:18067(indexterm)
#, fuzzy
msgid "<primary>pg_logical_emit_message</primary>"
msgstr "<primary>pg_logical_slot_get_changes</primary>"

#: func.xml:18070(parameter) func.xml:18089(parameter)
#, fuzzy
msgid "transactional"
msgstr "transaction"

#: func.xml:18070(parameter) func.xml:18089(parameter)
msgid "prefix"
msgstr "prefix"

#: func.xml:18070(parameter) func.xml:18089(parameter)
msgctxt "parameter"
msgid "content"
msgstr "content"

#: func.xml:18070(function) func.xml:18089(function)
#, fuzzy
msgid ""
"pg_logical_emit_message(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"split_part(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:18075(entry)
msgid ""
"Emit text logical decoding message. This can be used to pass generic "
"messages to logical decoding plugins through WAL. The parameter "
"<parameter>transactional</parameter> specifies if the message should be part "
"of current transaction or if it should be written immediately and decoded as "
"soon as the logical decoding reads the record. The <parameter>prefix</"
"parameter> is textual prefix used by the logical decoding plugins to easily "
"recognize interesting messages for them. The <parameter>content</parameter> "
"is the text of the message."
msgstr ""

#: func.xml:18094(entry)
msgid ""
"Emit binary logical decoding message. This can be used to pass generic "
"messages to logical decoding plugins through WAL. The parameter "
"<parameter>transactional</parameter> specifies if the message should be part "
"of current transaction or if it should be written immediately and decoded as "
"soon as the logical decoding reads the record. The <parameter>prefix</"
"parameter> is textual prefix used by the logical decoding plugins to easily "
"recognize interesting messages for them. The <parameter>content</parameter> "
"is the binary content of the message."
msgstr ""

#: func.xml:18114(title)
msgid "Database Object Management Functions"
msgstr "Функции управления объектами баз данных"

#: func.xml:18116(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-dbsize\"/> calculate "
"the disk space usage of database objects."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-dbsize"
"\"/>, вычисляют объём, который занимают на диске различные объекты баз "
"данных."

#: func.xml:18121(indexterm)
msgid "<primary>pg_column_size</primary>"
msgstr "<primary>pg_column_size</primary>"

#: func.xml:18124(indexterm)
msgid "<primary>pg_database_size</primary>"
msgstr "<primary>pg_database_size</primary>"

#: func.xml:18127(indexterm)
msgid "<primary>pg_indexes_size</primary>"
msgstr "<primary>pg_indexes_size</primary>"

#: func.xml:18130(indexterm)
msgid "<primary>pg_relation_size</primary>"
msgstr "<primary>pg_relation_size</primary>"

#: func.xml:18133(indexterm)
#, fuzzy
msgid "<primary>pg_size_bytes</primary>"
msgstr "<primary>get_byte</primary>"

#: func.xml:18136(indexterm)
msgid "<primary>pg_size_pretty</primary>"
msgstr "<primary>pg_size_pretty</primary>"

#: func.xml:18139(indexterm)
msgid "<primary>pg_table_size</primary>"
msgstr "<primary>pg_table_size</primary>"

#: func.xml:18142(indexterm)
msgid "<primary>pg_tablespace_size</primary>"
msgstr "<primary>pg_tablespace_size</primary>"

#: func.xml:18145(indexterm)
msgid "<primary>pg_total_relation_size</primary>"
msgstr "<primary>pg_total_relation_size</primary>"

#: func.xml:18150(title)
msgid "Database Object Size Functions"
msgstr "Функции получения размера объектов БД"

#: func.xml:18159(function)
msgid "pg_column_size(<placeholder-1/>)"
msgstr "pg_column_size(<placeholder-1/>)"

#: func.xml:18161(entry)
msgid "Number of bytes used to store a particular value (possibly compressed)"
msgstr ""
"Число байт, необходимых для хранения заданного значения (возможно, в сжатом "
"виде)"

#: func.xml:18165(function) func.xml:18172(function)
msgid "pg_database_size(<placeholder-1/>)"
msgstr "pg_database_size(<placeholder-1/>)"

#: func.xml:18168(entry)
msgid "Disk space used by the database with the specified OID"
msgstr "Объём, который занимает на диске база данных с заданным OID"

#: func.xml:18175(entry)
msgid "Disk space used by the database with the specified name"
msgstr "Объём, который занимает на диске база данных с заданным именем"

#: func.xml:18179(function)
msgid "pg_indexes_size(<placeholder-1/>)"
msgstr "pg_indexes_size(<placeholder-1/>)"

#: func.xml:18182(entry)
msgid "Total disk space used by indexes attached to the specified table"
msgstr "Общий объём индексов, связанных с указанной таблицей"

#: func.xml:18188(parameter) func.xml:18199(parameter)
#: func.xml:18410(parameter) func.xml:18419(parameter)
msgid "relation"
msgstr "relation"

#: func.xml:18188(parameter)
msgid "fork"
msgstr "fork"

#: func.xml:18188(function)
msgid ""
"pg_relation_size(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_relation_size(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:18191(entry)
msgid ""
"Disk space used by the specified fork (<literal>'main'</literal>, "
"<literal>'fsm'</literal>, <literal>'vm'</literal>, or <literal>'init'</"
"literal>) of the specified table or index"
msgstr ""
"Объём, который занимает на диске указанный слой (<literal>'main'</literal>, "
"<literal>'fsm'</literal>, <literal>'vm'</literal> или <literal>'init'</"
"literal>) заданной таблицы или индекса"

#: func.xml:18199(function)
msgid "pg_relation_size(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_relation_size(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18202(entry)
msgid "Shorthand for <literal>pg_relation_size(..., 'main')</literal>"
msgstr "Краткая форма <literal>pg_relation_size(..., 'main')</literal>"

#: func.xml:18208(function)
#, fuzzy
msgid "pg_size_bytes(<placeholder-1/>)"
msgstr "pg_size_pretty(<placeholder-1/>)"

#: func.xml:18211(entry)
#, fuzzy
msgid "Converts a size in human-readable format with size units into bytes"
msgstr ""
"Преобразует размер в байтах, представленный в значении числового типа, в "
"понятный человеку формат с единицами измерения"

#: func.xml:18217(function) func.xml:18227(function)
msgid "pg_size_pretty(<placeholder-1/>)"
msgstr "pg_size_pretty(<placeholder-1/>)"

#: func.xml:18220(entry)
msgid ""
"Converts a size in bytes expressed as a 64-bit integer into a human-readable "
"format with size units"
msgstr ""
"Преобразует размер в байтах, представленный в 64-битном целом, в понятный "
"человеку формат с единицами измерения"

#: func.xml:18230(entry)
msgid ""
"Converts a size in bytes expressed as a numeric value into a human-readable "
"format with size units"
msgstr ""
"Преобразует размер в байтах, представленный в значении числового типа, в "
"понятный человеку формат с единицами измерения"

#: func.xml:18237(function)
msgid "pg_table_size(<placeholder-1/>)"
msgstr "pg_table_size(<placeholder-1/>)"

#: func.xml:18240(entry)
msgid ""
"Disk space used by the specified table, excluding indexes (but including "
"TOAST, free space map, and visibility map)"
msgstr ""
"Объём, который занимает на диске данная таблица, за исключением индексов (но "
"включая TOAST, карту свободного места и карту видимости)"

#: func.xml:18247(function) func.xml:18254(function)
msgid "pg_tablespace_size(<placeholder-1/>)"
msgstr "pg_tablespace_size(<placeholder-1/>)"

#: func.xml:18250(entry)
msgid "Disk space used by the tablespace with the specified OID"
msgstr ""
"Объём, который занимает на диске табличное пространство с указанным OID"

#: func.xml:18257(entry)
msgid "Disk space used by the tablespace with the specified name"
msgstr ""
"Объём, который занимает на диске табличное пространство с заданным именем"

#: func.xml:18261(function)
msgid "pg_total_relation_size(<placeholder-1/>)"
msgstr "pg_total_relation_size(<placeholder-1/>)"

#: func.xml:18264(entry)
msgid ""
"Total disk space used by the specified table, including all indexes and "
"<acronym>TOAST</acronym> data"
msgstr ""
"Общий объём, который занимает на диске заданная таблица, включая все индексы "
"и данные <acronym>TOAST</acronym>"

#: func.xml:18273(para)
msgid ""
"<function>pg_column_size</function> shows the space used to store any "
"individual data value."
msgstr ""
"<function>pg_column_size</function> показывает, какой объём требуется для "
"хранения данного значения."

#: func.xml:18278(para)
msgid ""
"<function>pg_total_relation_size</function> accepts the OID or name of a "
"table or toast table, and returns the total on-disk space used for that "
"table, including all associated indexes. This function is equivalent to "
"<function>pg_table_size</function>\n"
"    <literal>+</literal> <function>pg_indexes_size</function>."
msgstr ""
"<function>pg_total_relation_size</function> принимает OID или имя таблицы "
"или данных TOAST и возвращает общий объём, который занимает на диске эта "
"таблица, включая все связанные с ней индексы. Результат этой функции "
"равняется <function>pg_table_size</function> <literal>+</literal> "
"<function>pg_indexes_size</function>."

#: func.xml:18286(para)
msgid ""
"<function>pg_table_size</function> accepts the OID or name of a table and "
"returns the disk space needed for that table, exclusive of indexes. (TOAST "
"space, free space map, and visibility map are included.)"
msgstr ""
"<function>pg_table_size</function> принимает OID или имя таблицы и "
"возвращает объём, который занимает на диске эта таблица без индексов. (При "
"этом учитывается размер TOAST, карты свободного места и карты видимости.)"

#: func.xml:18292(para)
msgid ""
"<function>pg_indexes_size</function> accepts the OID or name of a table and "
"returns the total disk space used by all the indexes attached to that table."
msgstr ""
"<function>pg_indexes_size</function> принимает OID или имя таблицы и "
"возвращает общий объём, который занимают все индексы таблицы."

#: func.xml:18298(para)
msgid ""
"<function>pg_database_size</function> and <function>pg_tablespace_size</"
"function> accept the OID or name of a database or tablespace, and return the "
"total disk space used therein. To use <function>pg_database_size</function>, "
"you must have <literal>CONNECT</literal> permission on the specified "
"database (which is granted by default). To use <function>pg_tablespace_size</"
"function>, you must have <literal>CREATE</literal> permission on the "
"specified tablespace, unless it is the default tablespace for the current "
"database."
msgstr ""
"<function>pg_database_size</function> и <function>pg_tablespace_size</"
"function> принимают OID или имя базы данных либо табличного пространства и "
"возвращают общий объём, который они занимают на диске. Для использования "
"<function>pg_database_size</function> требуется право <literal>CONNECT</"
"literal> для указанной базы данных (оно имеется по умолчанию). Для "
"использования <function>pg_tablespace_size</function> необходимо иметь право "
"<literal>CREATE</literal> в указанном табличном пространстве, если только "
"это не табличное пространство по умолчанию для текущей базы данных."

#: func.xml:18319(para)
msgid ""
"<literal>'main'</literal> returns the size of the main data fork of the "
"relation."
msgstr ""
"<literal>'main'</literal> возвращает размер основного слоя данных заданного "
"отношения."

#: func.xml:18325(para)
msgid ""
"<literal>'fsm'</literal> returns the size of the Free Space Map (see <xref "
"linkend=\"storage-fsm\"/>) associated with the relation."
msgstr ""
"<literal>'fsm'</literal> возвращает размер карты свободного места (см. <xref "
"remap=\"4\" linkend=\"storage-fsm\"/>), связанной с заданным отношением."

#: func.xml:18331(para)
msgid ""
"<literal>'vm'</literal> returns the size of the Visibility Map (see <xref "
"linkend=\"storage-vm\"/>) associated with the relation."
msgstr ""
"<literal>'vm'</literal> возвращает размер карты видимости (см. <xref remap="
"\"4\" linkend=\"storage-vm\"/>), связанной с заданным отношением."

#: func.xml:18337(para)
msgid ""
"<literal>'init'</literal> returns the size of the initialization fork, if "
"any, associated with the relation."
msgstr ""
"<literal>'init'</literal> возвращает размер слоя инициализации для заданного "
"отношения, если он имеется."

#: func.xml:18308(para)
msgid ""
"<function>pg_relation_size</function> accepts the OID or name of a table, "
"index or toast table, and returns the on-disk size in bytes of one fork of "
"that relation. (Note that for most purposes it is more convenient to use the "
"higher-level functions <function>pg_total_relation_size</function> or "
"<function>pg_table_size</function>, which sum the sizes of all forks.) With "
"one argument, it returns the size of the main data fork of the relation. The "
"second argument can be provided to specify which fork to examine: "
"<placeholder-1/>"
msgstr ""
"<function>pg_relation_size</function> принимает OID или имя таблицы, индекса "
"или TOAST-таблицы и возвращает размер одного слоя этого отношения (в "
"байтах). (Заметьте, что в большинстве случае удобнее использовать более "
"высокоуровневые функции <function>pg_total_relation_size</function> и "
"<function>pg_table_size</function>, которые суммируют размер всех слоёв.) С "
"одним аргументом она возвращает размер основного слоя для данных заданного "
"отношения. Название другого интересующего слоя можно передать во втором "
"аргументе: <placeholder-1/>"

#: func.xml:18345(para)
#, fuzzy
msgid ""
"<function>pg_size_pretty</function> can be used to format the result of one "
"of the other functions in a human-readable way, using bytes, kB, MB, GB or "
"TB as appropriate."
msgstr ""
"<function>pg_size_pretty</function> можно использовать для форматирования "
"результатов других функций в виде, более понятном человеку, с единицами "
"измерения KB, MB, GB и TB."

#: func.xml:18351(para)
msgid ""
"<function>pg_size_bytes</function> can be used to get the size in bytes from "
"a string in human-readable format. The input may have units of bytes, kB, "
"MB, GB or TB, and is parsed case-insensitively. If no units are specified, "
"bytes are assumed."
msgstr ""

#: func.xml:18359(para)
msgid ""
"The units kB, MB, GB and TB used by the functions <function>pg_size_pretty</"
"function> and <function>pg_size_bytes</function> are defined using powers of "
"2 rather than powers of 10, so 1kB is 1024 bytes, 1MB is 1024<superscript>2</"
"superscript> = 1048576 bytes, and so on."
msgstr ""

#: func.xml:18367(para)
msgid ""
"The functions above that operate on tables or indexes accept a "
"<type>regclass</type> argument, which is simply the OID of the table or "
"index in the <structname>pg_class</structname> system catalog. You do not "
"have to look up the OID by hand, however, since the <type>regclass</type> "
"data type's input converter will do the work for you. Just write the table "
"name enclosed in single quotes so that it looks like a literal constant. For "
"compatibility with the handling of ordinary <acronym>SQL</acronym> names, "
"the string will be converted to lower case unless it contains double quotes "
"around the table name."
msgstr ""
"Вышеописанные функции, работающие с таблицами или индексами, принимают "
"аргумент типа <type>regclass</type>, который представляет собой просто OID "
"таблицы или индекса в системном каталоге <structname>pg_class</structname>. "
"Однако вам не нужно вручную вычислять OID, так как процедура ввода значения "
"<type>regclass</type> может сделать это за вас. Для этого достаточно "
"записать имя таблицы в апострофах, как обычную текстовую константу. В "
"соответствии с правилами обработки обычных имён <acronym>SQL</acronym>, если "
"имя таблицы не заключено в кавычки, эта строка будет переведена в нижний "
"регистр."

#: func.xml:18379(para)
msgid ""
"If an OID that does not represent an existing object is passed as argument "
"to one of the above functions, NULL is returned."
msgstr ""
"Если переданному значению OID не соответствуют существующий объект, эти "
"функции возвращают NULL."

#: func.xml:18384(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-dblocation\"/> assist "
"in identifying the specific disk files associated with database objects."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-"
"dblocation\"/>, помогают определить, в каких файлах на диске хранятся "
"объекты базы данных."

#: func.xml:18389(indexterm)
msgid "<primary>pg_relation_filenode</primary>"
msgstr "<primary>pg_relation_filenode</primary>"

#: func.xml:18392(indexterm)
msgid "<primary>pg_relation_filepath</primary>"
msgstr "<primary>pg_relation_filepath</primary>"

#: func.xml:18395(indexterm)
msgid "<primary>pg_filenode_relation</primary>"
msgstr "<primary>pg_filenode_relation</primary>"

#: func.xml:18400(title)
msgid "Database Object Location Functions"
msgstr "Функции определения расположения объектов"

#: func.xml:18410(function)
msgid "pg_relation_filenode(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_relation_filenode(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18413(entry)
msgid "Filenode number of the specified relation"
msgstr "Номер файлового узла для указанного отношения"

#: func.xml:18419(function)
msgid "pg_relation_filepath(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_relation_filepath(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18422(entry)
msgid "File path name of the specified relation"
msgstr "Путь к файлу, в котором хранится указанное отношение"

#: func.xml:18428(parameter)
msgid "filenode"
msgstr "filenode"

#: func.xml:18428(function)
msgid ""
"pg_filenode_relation(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_filenode_relation(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:18431(entry)
msgid "Find the relation associated with a given tablespace and filenode"
msgstr ""
"Находит отношение, связанное с данным табличным пространством и файловым "
"узлом"

#: func.xml:18439(para)
msgid ""
"<function>pg_relation_filenode</function> accepts the OID or name of a "
"table, index, sequence, or toast table, and returns the <quote>filenode</"
"quote> number currently assigned to it. The filenode is the base component "
"of the file name(s) used for the relation (see <xref linkend=\"storage-file-"
"layout\"/> for more information). For most tables the result is the same as "
"<structname>pg_class</structname>.<structfield>relfilenode</structfield>, "
"but for certain system catalogs <structfield>relfilenode</structfield> is "
"zero and this function must be used to get the correct value. The function "
"returns NULL if passed a relation that does not have storage, such as a view."
msgstr ""
"<function>pg_relation_filenode</function> принимает OID или имя таблицы, "
"индекса, последовательности или таблицы TOAST и возвращает номер "
"<quote>файлового узла</quote>, связанным с этим объектом. Файловым узлом "
"называется основной компонент имени файла, используемого для хранения данных "
"(подробнее это описано в <xref remap=\"6\" linkend=\"storage-file-layout\"/"
">). Для большинства таблиц этот номер совпадает со значением "
"<structname>pg_class</structname>.<structfield>relfilenode</structfield>, но "
"для некоторых системных каталогов <structfield>relfilenode</structfield> "
"равен 0, и нужно использовать эту функцию, чтобы узнать действительное "
"значение. Если указанное отношение не хранится на диске, как например "
"представление, данная функция возвращает NULL."

#: func.xml:18451(para)
msgid ""
"<function>pg_relation_filepath</function> is similar to "
"<function>pg_relation_filenode</function>, but it returns the entire file "
"path name (relative to the database cluster's data directory "
"<varname>PGDATA</varname>) of the relation."
msgstr ""
"<function>pg_relation_filepath</function> подобна "
"<function>pg_relation_filenode</function>, но возвращает полный путь к файлу "
"(относительно каталога данных <varname>PGDATA</varname>) отношения."

#: func.xml:18458(para)
msgid ""
"<function>pg_filenode_relation</function> is the reverse of "
"<function>pg_relation_filenode</function>. Given a <quote>tablespace</quote> "
"OID and a <quote>filenode</quote>, it returns the associated relation's OID. "
"For a table in the database's default tablespace, the tablespace can be "
"specified as 0."
msgstr ""
"Функция <function>pg_filenode_relation</function> является обратной к "
"<function>pg_relation_filenode</function>. Она возвращает OID отношения по "
"заданному OID <quote>табличного пространства</quote> и <quote>файловому "
"узлу</quote>. Для таблицы в табличном пространстве по умолчанию в первом "
"параметре можно передать 0."

#: func.xml:18468(title) func.xml:18487(title)
msgid "Index Maintenance Functions"
msgstr "Функции обслуживания индексов"

#: func.xml:18470(indexterm)
msgid "<primary>brin_summarize_new_values</primary>"
msgstr "<primary>brin_summarize_new_values</primary>"

#: func.xml:18474(indexterm)
#, fuzzy
msgid "<primary>gin_clean_pending_list</primary>"
msgstr "<primary>pg_client_encoding</primary>"

#: func.xml:18478(para)
#, fuzzy
msgid ""
"<xref linkend=\"functions-admin-index-table\"/> shows the functions "
"available for index maintenance tasks. These functions cannot be executed "
"during recovery. Use of these functions is restricted to superusers and the "
"owner of the given index."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-signal-"
"table\"/>, позволяют передавать управляющие сигналы другим серверным "
"процессам. Вызывать эти функции обычно могут только суперпользователи, кроме "
"явно отмеченных исключений."

#: func.xml:18496(function)
msgid "brin_summarize_new_values(<placeholder-1/> <placeholder-2/>)"
msgstr "brin_summarize_new_values(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18499(entry)
msgid "summarize page ranges not already summarized"
msgstr "обобщает ещё не обобщённые диапазоны страниц"

#: func.xml:18503(parameter)
msgid "index"
msgstr "index"

#: func.xml:18503(function)
#, fuzzy
msgid "gin_clean_pending_list(<placeholder-1/> <placeholder-2/>)"
msgstr "encode_typed_literal(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:18506(entry)
msgid "move GIN pending list entries into main index structure"
msgstr ""

#: func.xml:18512(para)
msgid ""
"<function>brin_summarize_new_values</function> receives a BRIN index OID as "
"argument and inspects the index to find page ranges in the base table that "
"are not currently summarized by the index; for any such range it creates a "
"new summary index tuple by scanning the table pages. It returns the number "
"of new page range summaries that were inserted into the index."
msgstr ""
"Функция <function>brin_summarize_new_values</function> получает в качестве "
"аргумента идентификатор индекса BRIN и просматривает индекс в поисках зон "
"страниц в базовой таблице, ещё не обобщённых в индексе; для каждой такой "
"зоны в результате сканирования таблиц страницы создаётся новый обобщённый "
"кортеж в индексе. Возвращает эта функция число вставленных в индекс "
"обобщённых записей о зонах страниц."

#: func.xml:18521(para)
msgid ""
"<function>gin_clean_pending_list</function> accepts the OID or name of a GIN "
"index and cleans up the pending list of the specified GIN index by moving "
"entries in it to the main GIN data structure in bulk. It returns the number "
"of pages cleaned up from the pending list. Note that if the argument is a "
"GIN index built with <literal>fastupdate</literal> option disabled, the "
"cleanup does not happen and the return value is 0 because the index doesn't "
"have a pending list. Please see <xref linkend=\"gin-fast-update\"/> and "
"<xref linkend=\"gin-tips\"/> for details of the pending list and "
"<literal>fastupdate</literal> option."
msgstr ""

#: func.xml:18536(title) func.xml:18549(title)
msgid "Generic File Access Functions"
msgstr "Функции для работы с обычными файлами"

#: func.xml:18538(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-genfile-table\"/> "
"provide native access to files on the machine hosting the server. Only files "
"within the database cluster directory and the <varname>log_directory</"
"varname> can be accessed. Use a relative path for files in the cluster "
"directory, and a path matching the <varname>log_directory</varname> "
"configuration setting for log files. Use of these functions is restricted to "
"superusers."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-genfile-"
"table\"/>, предоставляют прямой доступ к файлам, находящимся на сервере. Они "
"позволяют обращаться только к файлам в каталоге кластера баз данных (по "
"относительному пути) или в каталоге <varname>log_directory</varname> (по "
"пути, заданному в параметре конфигурации <varname>log_directory</varname>). "
"Использовать эти функции могут только суперпользователи."

#: func.xml:18559(parameter)
msgid "dirname"
msgstr "dirname"

#: func.xml:18559(parameter)
msgid "include_dot_dirs"
msgstr "include_dot_dirs"

#: func.xml:18559(function)
msgid ""
"pg_ls_dir(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>])"
msgstr ""
"pg_ls_dir(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>])"

#: func.xml:18562(entry)
msgid "List the contents of a directory."
msgstr "Возвращает список содержимого каталога."

#: func.xml:18568(parameter) func.xml:18577(parameter)
#: func.xml:18586(parameter)
msgid "filename"
msgstr "filename"

#: func.xml:18568(function)
msgid ""
"pg_read_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"
msgstr ""
"pg_read_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"

#: func.xml:18571(entry)
msgid "Return the contents of a text file."
msgstr "Возвращает содержимое текстового файла."

#: func.xml:18577(function)
msgid ""
"pg_read_binary_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"
msgstr ""
"pg_read_binary_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"

#: func.xml:18580(entry)
msgid "Return the contents of a file."
msgstr "Возвращает содержимое файла."

#: func.xml:18586(function)
msgid ""
"pg_stat_file(<placeholder-1/> <placeholder-2/>[, <placeholder-3/> "
"<placeholder-4/>])"
msgstr ""
"pg_stat_file(<placeholder-1/> <placeholder-2/>[, <placeholder-3/> "
"<placeholder-4/>])"

#: func.xml:18589(entry)
msgid "Return information about a file."
msgstr "Возвращает информацию о файле."

#: func.xml:18597(para)
msgid ""
"All of these functions take an optional <parameter>missing_ok</parameter> "
"parameter, which specifies the behavior when the file or directory does not "
"exist. If <literal>true</literal>, the function returns NULL (except "
"<function>pg_ls_dir</function>, which returns an empty result set). If "
"<literal>false</literal>, an error is raised. The default is <literal>false</"
"literal>."
msgstr ""
"Все эти функции принимают необязательный параметр <parameter>missing_ok</"
"parameter>, который определяет их поведение в случае отсутствия файла или "
"каталога. Если он равен <literal>true</literal>, функция возвращает NULL (за "
"исключением <function>pg_ls_dir</function>, которая возвращает пустое "
"множество). Если он равен <literal>false</literal>, возникает ошибка. "
"Значение по умолчанию — <literal>false</literal>."

#: func.xml:18605(indexterm)
msgid "<primary>pg_ls_dir</primary>"
msgstr "<primary>pg_ls_dir</primary>"

#: func.xml:18608(para)
msgid ""
"<function>pg_ls_dir</function> returns the names of all files (and "
"directories and other special files) in the specified directory. The "
"<parameter> include_dot_dirs</parameter> indicates whether <quote>.</quote> "
"and <quote>..</quote> are included in the result set. The default is to "
"exclude them (<literal>false</literal>), but including them can be useful "
"when <parameter>missing_ok</parameter> is <literal>true</literal>, to "
"distinguish an empty directory from an non-existent directory."
msgstr ""
"<function>pg_ls_dir</function> возвращает имена всех файлов (а также "
"каталогов и других специальных файлов) в заданном каталоге. Параметр "
"<parameter>include_dot_dirs</parameter> определяет, будут ли в "
"результирующий набор включаться каталоги <quote>.</quote> и <quote>..</"
"quote>. По умолчанию они не включаются (<literal>false</literal>), но их "
"можно включить, чтобы с параметром <parameter>missing_ok</parameter> равным "
"<literal>true</literal>, пустой каталог можно было отличить от "
"несуществующего."

#: func.xml:18618(indexterm)
msgid "<primary>pg_read_file</primary>"
msgstr "<primary>pg_read_file</primary>"

#: func.xml:18621(para)
msgid ""
"<function>pg_read_file</function> returns part of a text file, starting at "
"the given <parameter>offset</parameter>, returning at most "
"<parameter>length</parameter> bytes (less if the end of file is reached "
"first). If <parameter>offset</parameter> is negative, it is relative to the "
"end of the file. If <parameter>offset</parameter> and <parameter>length</"
"parameter> are omitted, the entire file is returned. The bytes read from the "
"file are interpreted as a string in the server encoding; an error is thrown "
"if they are not valid in that encoding."
msgstr ""
"<function>pg_read_file</function> возвращает фрагмент текстового файла с "
"заданного смещения (<parameter>offset</parameter>), размером не больше "
"<parameter>length</parameter> байт (размер может быть меньше, если файл "
"кончится раньше). Если смещение <parameter>offset</parameter> отрицательно, "
"оно отсчитывается от конца файла. Если параметры <parameter>offset</"
"parameter> и <parameter>length</parameter> опущены, возвращается всё "
"содержимое файла. Прочитанные из файла байты обрабатываются как символы в "
"серверной кодировке; если они оказываются недопустимыми для этой кодировки, "
"возникает ошибка."

#: func.xml:18632(indexterm)
msgid "<primary>pg_read_binary_file</primary>"
msgstr "<primary>pg_read_binary_file</primary>"

#: func.xml:18641(programlisting)
#, no-wrap
msgid "SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');"
msgstr "SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');"

#: func.xml:18635(para)
msgid ""
"<function>pg_read_binary_file</function> is similar to "
"<function>pg_read_file</function>, except that the result is a <type>bytea</"
"type> value; accordingly, no encoding checks are performed. In combination "
"with the <function>convert_from</function> function, this function can be "
"used to read a file in a specified encoding: <placeholder-1/>"
msgstr ""
"<function>pg_read_binary_file</function> подобна <function>pg_read_file</"
"function>, но её результат имеет тип <type>bytea</type>; как следствие, "
"никакие проверки кодировки не выполняются. В сочетании с "
"<function>convert_from</function> эту функцию можно применять для чтения "
"файлов в произвольной кодировке: <placeholder-1/>"

#: func.xml:18644(indexterm)
msgid "<primary>pg_stat_file</primary>"
msgstr "<primary>pg_stat_file</primary>"

#: func.xml:18653(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM pg_stat_file('filename');\n"
"SELECT (pg_stat_file('filename')).modification;"
msgstr ""
"SELECT * FROM pg_stat_file('filename');\n"
"SELECT (pg_stat_file('filename')).modification;"

#: func.xml:18647(para)
msgid ""
"<function>pg_stat_file</function> returns a record containing the file size, "
"last accessed time stamp, last modified time stamp, last file status change "
"time stamp (Unix platforms only), file creation time stamp (Windows only), "
"and a <type>boolean</type> indicating if it is a directory. Typical usages "
"include: <placeholder-1/>"
msgstr ""
"<function>pg_stat_file</function> возвращает запись, содержащую размер "
"файла, время последнего обращения и последнего изменения, а также время "
"последнего изменения состояния (только в Unix-системах), время создания "
"(только в Windows) и признак типа <type>boolean</type>, показывающий, что "
"это каталог. Примеры использования: <placeholder-1/>"

#: func.xml:18660(title) func.xml:18669(title)
msgid "Advisory Lock Functions"
msgstr "Функции управления рекомендательными блокировками"

#: func.xml:18662(para)
msgid ""
"The functions shown in <xref linkend=\"functions-advisory-locks-table\"/> "
"manage advisory locks. For details about proper use of these functions, see "
"<xref linkend=\"advisory-locks\"/>."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-advisory-"
"locks-table\"/>, предназначены для управления рекомендательными "
"блокировками. Подробнее об их использовании можно узнать в <xref remap=\"6\" "
"linkend=\"advisory-locks\"/>."

#: func.xml:18679(parameter) func.xml:18693(parameter)
#: func.xml:18707(parameter) func.xml:18728(parameter)
#: func.xml:18742(parameter) func.xml:18756(parameter)
#: func.xml:18770(parameter) func.xml:18784(parameter)
#: func.xml:18798(parameter) func.xml:18812(parameter)
msgid "key"
msgstr "key"

#: func.xml:18679(function)
msgid "pg_advisory_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_lock(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18682(entry) func.xml:18689(entry)
msgid "Obtain exclusive session level advisory lock"
msgstr "Получает исключительную блокировку на уровне сеанса"

#: func.xml:18686(parameter) func.xml:18700(parameter)
#: func.xml:18714(parameter) func.xml:18735(parameter)
#: func.xml:18749(parameter) func.xml:18763(parameter)
#: func.xml:18777(parameter) func.xml:18791(parameter)
#: func.xml:18805(parameter) func.xml:18819(parameter)
msgid "key1"
msgstr "key1"

#: func.xml:18686(parameter) func.xml:18700(parameter)
#: func.xml:18714(parameter) func.xml:18735(parameter)
#: func.xml:18749(parameter) func.xml:18763(parameter)
#: func.xml:18777(parameter) func.xml:18791(parameter)
#: func.xml:18805(parameter) func.xml:18819(parameter)
msgid "key2"
msgstr "key2"

#: func.xml:18686(function)
msgid ""
"pg_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:18693(function)
msgid "pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18696(entry) func.xml:18703(entry)
msgid "Obtain shared session level advisory lock"
msgstr "Получает разделяемую блокировку на уровне сеанса"

#: func.xml:18700(function)
msgid ""
"pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:18707(function)
msgid "pg_advisory_unlock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_unlock(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18710(entry) func.xml:18717(entry)
msgid "Release an exclusive session level advisory lock"
msgstr "Освобождает исключительную блокировку на уровне сеанса"

#: func.xml:18714(function)
msgid ""
"pg_advisory_unlock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_unlock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:18721(function)
msgid "pg_advisory_unlock_all()"
msgstr "pg_advisory_unlock_all()"

#: func.xml:18724(entry)
msgid "Release all session level advisory locks held by the current session"
msgstr ""
"Освобождает все блокировки на уровне сеанса, удерживаемые в данном сеансе"

#: func.xml:18728(function)
msgid "pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18731(entry) func.xml:18738(entry)
msgid "Release a shared session level advisory lock"
msgstr "Освобождает разделяемую блокировку на уровне сеанса"

#: func.xml:18735(function)
msgid ""
"pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"
msgstr ""
"pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"

#: func.xml:18742(function)
msgid "pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18745(entry) func.xml:18752(entry)
msgid "Obtain exclusive transaction level advisory lock"
msgstr "Получает исключительную блокировку на уровне транзакции"

#: func.xml:18749(function)
msgid ""
"pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:18756(function)
msgid "pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18759(entry) func.xml:18766(entry)
msgid "Obtain shared transaction level advisory lock"
msgstr "Получает разделяемую блокировку на уровне транзакции"

#: func.xml:18763(function)
msgid ""
"pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:18770(function)
msgid "pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18773(entry) func.xml:18780(entry)
msgid "Obtain exclusive session level advisory lock if available"
msgstr "Получает исключительную блокировку на уровне сеанса, если это возможно"

#: func.xml:18777(function)
msgid ""
"pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:18784(function)
msgid "pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18787(entry) func.xml:18794(entry)
msgid "Obtain shared session level advisory lock if available"
msgstr "Получает разделяемую блокировку на уровне сеанса, если это возможно"

#: func.xml:18791(function)
msgid ""
"pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:18798(function)
msgid "pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18801(entry) func.xml:18808(entry)
msgid "Obtain exclusive transaction level advisory lock if available"
msgstr ""
"Получает исключительную блокировку на уровне транзакции, если это возможно"

#: func.xml:18805(function)
msgid ""
"pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"
msgstr ""
"pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"

#: func.xml:18812(function)
msgid "pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18815(entry) func.xml:18822(entry)
msgid "Obtain shared transaction level advisory lock if available"
msgstr ""
"Получает разделяемую блокировку на уровне транзакции, если это возможно"

#: func.xml:18819(function)
msgid ""
"pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:18828(indexterm)
msgid "<primary>pg_advisory_lock</primary>"
msgstr "<primary>pg_advisory_lock</primary>"

#: func.xml:18831(para)
msgid ""
"<function>pg_advisory_lock</function> locks an application-defined resource, "
"which can be identified either by a single 64-bit key value or two 32-bit "
"key values (note that these two key spaces do not overlap). If another "
"session already holds a lock on the same resource identifier, this function "
"will wait until the resource becomes available. The lock is exclusive. "
"Multiple lock requests stack, so that if the same resource is locked three "
"times it must then be unlocked three times to be released for other "
"sessions' use."
msgstr ""
"<function>pg_advisory_lock</function> блокирует определённый приложением "
"ресурс, задаваемый одним 64-битным или двумя 32-битными ключами (заметьте, "
"что их значения не пересекаются). Если идентификатор этого ресурса "
"удерживает другой сеанс, эта функция не завершится, пока ресурс не станет "
"доступным. Данная функция устанавливает блокировку в исключительном режиме. "
"Если поступает сразу несколько запросов на блокировку, они накапливаются, "
"так что если один ресурс был заблокирован три раза, его необходимо три раза "
"разблокировать, чтобы он был доступен в других сеансах."

#: func.xml:18842(indexterm)
msgid "<primary>pg_advisory_lock_shared</primary>"
msgstr "<primary>pg_advisory_lock_shared</primary>"

#: func.xml:18845(para)
msgid ""
"<function>pg_advisory_lock_shared</function> works the same as "
"<function>pg_advisory_lock</function>, except the lock can be shared with "
"other sessions requesting shared locks. Only would-be exclusive lockers are "
"locked out."
msgstr ""
"<function>pg_advisory_lock_shared</function> работает подобно "
"<function>pg_advisory_lock</function>, но позволяет разделять блокировку с "
"другими сеансами, запрашивающими её как разделяемую. Выполнение может быть "
"приостановлено, только если другой сеанс запросил её в исключительном режиме."

#: func.xml:18852(indexterm)
msgid "<primary>pg_try_advisory_lock</primary>"
msgstr "<primary>pg_try_advisory_lock</primary>"

#: func.xml:18855(para)
msgid ""
"<function>pg_try_advisory_lock</function> is similar to "
"<function>pg_advisory_lock</function>, except the function will not wait for "
"the lock to become available. It will either obtain the lock immediately and "
"return <literal>true</literal>, or return <literal>false</literal> if the "
"lock cannot be acquired immediately."
msgstr ""
"<function>pg_try_advisory_lock</function> работает подобно "
"<function>pg_advisory_lock</function>, но не ждёт освобождения ресурса. Эта "
"функция либо немедленно получает блокировку и возвращает <literal>true</"
"literal>, либо сразу возвращает <literal>false</literal>, если получить её "
"не удаётся."

#: func.xml:18863(indexterm)
msgid "<primary>pg_try_advisory_lock_shared</primary>"
msgstr "<primary>pg_try_advisory_lock_shared</primary>"

#: func.xml:18866(para)
msgid ""
"<function>pg_try_advisory_lock_shared</function> works the same as "
"<function>pg_try_advisory_lock</function>, except it attempts to acquire a "
"shared rather than an exclusive lock."
msgstr ""
"<function>pg_try_advisory_lock_shared</function> работает как "
"<function>pg_try_advisory_lock</function>, но пытается получить разделяемую, "
"а не исключительную блокировку."

#: func.xml:18872(indexterm)
msgid "<primary>pg_advisory_unlock</primary>"
msgstr "<primary>pg_advisory_unlock</primary>"

#: func.xml:18875(para)
msgid ""
"<function>pg_advisory_unlock</function> will release a previously-acquired "
"exclusive session level advisory lock. It returns <literal>true</literal> if "
"the lock is successfully released. If the lock was not held, it will return "
"<literal>false</literal>, and in addition, an SQL warning will be reported "
"by the server."
msgstr ""
"<function>pg_advisory_unlock</function> освобождает ранее полученную "
"исключительную блокировку на уровне сеанса. Если блокировка освобождена "
"успешна, эта функция возвращает <literal>true</literal>, а если она не была "
"занята &mdash; <literal>false</literal>, при этом сервер выдаёт "
"предупреждение SQL."

#: func.xml:18883(indexterm)
msgid "<primary>pg_advisory_unlock_shared</primary>"
msgstr "<primary>pg_advisory_unlock_shared</primary>"

#: func.xml:18886(para)
msgid ""
"<function>pg_advisory_unlock_shared</function> works the same as "
"<function>pg_advisory_unlock</function>, except it releases a shared session "
"level advisory lock."
msgstr ""
"<function>pg_advisory_unlock_shared</function> работает подобно "
"<function>pg_advisory_unlock</function>, но освобождает разделяемую "
"блокировку на уровне сеанса."

#: func.xml:18892(indexterm)
msgid "<primary>pg_advisory_unlock_all</primary>"
msgstr "<primary>pg_advisory_unlock_all</primary>"

#: func.xml:18895(para)
msgid ""
"<function>pg_advisory_unlock_all</function> will release all session level "
"advisory locks held by the current session. (This function is implicitly "
"invoked at session end, even if the client disconnects ungracefully.)"
msgstr ""
"<function>pg_advisory_unlock_all</function> освобождает все блокировки на "
"уровне сеанса, закреплённые за текущим сеансом. (Эта функция неявно "
"вызывается в конце любого сеанса, даже при нештатном отключении клиента.)"

#: func.xml:18901(indexterm)
msgid "<primary>pg_advisory_xact_lock</primary>"
msgstr "<primary>pg_advisory_xact_lock</primary>"

#: func.xml:18904(para)
msgid ""
"<function>pg_advisory_xact_lock</function> works the same as "
"<function>pg_advisory_lock</function>, except the lock is automatically "
"released at the end of the current transaction and cannot be released "
"explicitly."
msgstr ""
"<function>pg_advisory_xact_lock</function> работает подобно "
"<function>pg_advisory_lock</function>, но её блокировка автоматически "
"освобождается в конце текущей транзакции и не может быть освобождена явным "
"образом."

#: func.xml:18910(indexterm)
msgid "<primary>pg_advisory_xact_lock_shared</primary>"
msgstr "<primary>pg_advisory_xact_lock_shared</primary>"

#: func.xml:18913(para)
msgid ""
"<function>pg_advisory_xact_lock_shared</function> works the same as "
"<function>pg_advisory_lock_shared</function>, except the lock is "
"automatically released at the end of the current transaction and cannot be "
"released explicitly."
msgstr ""
"<function>pg_advisory_xact_lock_shared</function> подобна функции "
"<function>pg_advisory_lock_shared</function>, но её блокировка автоматически "
"освобождается в конце текущей транзакции и не может быть освобождена явным "
"образом."

#: func.xml:18919(indexterm)
msgid "<primary>pg_try_advisory_xact_lock</primary>"
msgstr "<primary>pg_try_advisory_xact_lock</primary>"

#: func.xml:18922(para)
msgid ""
"<function>pg_try_advisory_xact_lock</function> works the same as "
"<function>pg_try_advisory_lock</function>, except the lock, if acquired, is "
"automatically released at the end of the current transaction and cannot be "
"released explicitly."
msgstr ""
"<function>pg_try_advisory_xact_lock</function> работает подобно "
"<function>pg_try_advisory_lock</function>, но её блокировка (если она была "
"получена) автоматически освобождается в конце текущей транзакции и не может "
"быть освобождена явным образом."

#: func.xml:18929(indexterm)
msgid "<primary>pg_try_advisory_xact_lock_shared</primary>"
msgstr "<primary>pg_try_advisory_xact_lock_shared</primary>"

#: func.xml:18932(para)
msgid ""
"<function>pg_try_advisory_xact_lock_shared</function> works the same as "
"<function>pg_try_advisory_lock_shared</function>, except the lock, if "
"acquired, is automatically released at the end of the current transaction "
"and cannot be released explicitly."
msgstr ""
"<function>pg_try_advisory_xact_lock_shared</function> работает подобно "
"<function>pg_try_advisory_lock_shared</function>, но её блокировка (если она "
"была получена) автоматически освобождается в конце текущей транзакции и не "
"может быть освобождена явным образом."

#: func.xml:18944(title)
msgid "Trigger Functions"
msgstr "Триггерные функции"

#: func.xml:18946(indexterm)
msgid "<primary>suppress_redundant_updates_trigger</primary>"
msgstr "<primary>suppress_redundant_updates_trigger</primary>"

#: func.xml:18950(para)
msgid ""
"Currently <productname>PostgreSQL</productname> provides one built in "
"trigger function, <function>suppress_redundant_updates_trigger</function>, "
"which will prevent any update that does not actually change the data in the "
"row from taking place, in contrast to the normal behavior which always "
"performs the update regardless of whether or not the data has changed. (This "
"normal behavior makes updates run faster, since no checking is required, and "
"is also useful in certain cases.)"
msgstr ""
"В настоящее время в <productname>PostgreSQL</productname> есть единственная "
"встроенная триггерная функция, <function>suppress_redundant_updates_trigger</"
"function>, которая предотвращает изменения, фактически не влияющие на данные "
"в строке, тогда как обычно изменения выполняются вне зависимости от того, "
"были ли изменены данные. (Обычное поведение не предполагает сравнения "
"данных, поэтому изменения выполняются быстрее, и в ряде случаев именно это "
"поведение желательно.)"

#: func.xml:18961(para)
msgid ""
"Ideally, you should normally avoid running updates that don't actually "
"change the data in the record. Redundant updates can cost considerable "
"unnecessary time, especially if there are lots of indexes to alter, and "
"space in dead rows that will eventually have to be vacuumed. However, "
"detecting such situations in client code is not always easy, or even "
"possible, and writing expressions to detect them can be error-prone. An "
"alternative is to use <function>suppress_redundant_updates_trigger</"
"function>, which will skip updates that don't change the data. You should "
"use this with care, however. The trigger takes a small but non-trivial time "
"for each record, so if most of the records affected by an update are "
"actually changed, use of this trigger will actually make the update run "
"slower."
msgstr ""
"В идеале, следует избегать операций изменения, которые фактически не меняют "
"данные в записях. Подобные ненужные изменения могут обходиться дорого, "
"особенно когда требуется обновлять множество индексов, к тому же "
"впоследствии базу данных придётся очищать от &laquo;мёртвых&raquo; строк. "
"Однако выявить такие изменения в клиентском коде бывает сложно, если вообще "
"возможно, а при составлении соответствующих проверочных выражений легко "
"допустить ошибку. В качестве альтернативного решения можно использовать "
"функцию <function>suppress_redundant_updates_trigger</function>, которая "
"опускает изменения, не меняющие данные. Однако использовать её следует с "
"осторожностью. Данный триггер выполняется не большое, но значительное время "
"для каждой записи, так что если большинство записей всё-таки фактически "
"изменяются, этот триггер скорее замедлит операцию изменения."

#: func.xml:18979(programlisting)
#, no-wrap
msgid ""
"CREATE TRIGGER z_min_update\n"
"BEFORE UPDATE ON tablename\n"
"FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();"
msgstr ""
"CREATE TRIGGER z_min_update\n"
"BEFORE UPDATE ON tablename\n"
"FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();"

#: func.xml:18976(para)
msgid ""
"The <function>suppress_redundant_updates_trigger</function> function can be "
"added to a table like this: <placeholder-1/> In most cases, you would want "
"to fire this trigger last for each row. Bearing in mind that triggers fire "
"in name order, you would then choose a trigger name that comes after the "
"name of any other trigger you might have on the table."
msgstr ""
"Функцию <function>suppress_redundant_updates_trigger</function> можно "
"привязать к таблице так: <placeholder-1/> В большинстве случаев этот триггер "
"должен вызываться для каждой строки последним. А так как триггеры вызываются "
"по порядку сортировки их имён, имя для него нужно выбирать таким, чтобы оно "
"было последним среди имён всех триггеров, которые могут быть в таблице."

#: func.xml:18987(para)
msgid ""
"For more information about creating triggers, see <xref linkend=\"sql-"
"createtrigger\"/>."
msgstr ""
"Подробнее о создании триггеров можно узнать в описании <xref linkend=\"sql-"
"createtrigger\"/>."

#: func.xml:18994(title)
msgid "Event Trigger Functions"
msgstr "Функции событийных триггеров"

#: func.xml:18996(para)
msgid ""
"<productname>PostgreSQL</productname> provides these helper functions to "
"retrieve information from event triggers."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет следующие "
"вспомогательные функции для получения информации в событийных триггерах."

#: func.xml:19001(para)
msgid ""
"For more information about event triggers, see <xref linkend=\"event-triggers"
"\"/>."
msgstr ""
"Подробнее о событийных триггерах можно узнать в <xref remap=\"6\" linkend="
"\"event-triggers\"/>."

#: func.xml:19007(title)
msgid "Capturing Changes at Command End"
msgstr "Получение изменений в конце команды"

#: func.xml:19009(indexterm)
msgid "<primary>pg_event_trigger_ddl_commands</primary>"
msgstr "<primary>pg_event_trigger_ddl_commands</primary>"

#: func.xml:19029(entry) func.xml:19116(entry)
msgid "Type"
msgstr "Тип"

#: func.xml:19036(literal) func.xml:19123(literal)
msgid "classid"
msgstr "classid"

#: func.xml:19037(type) func.xml:19042(type) func.xml:19124(type)
#: func.xml:19129(type) func.xml:19259(type)
msgid "Oid"
msgstr "Oid"

#: func.xml:19038(entry)
msgid "OID of catalog the object belongs in"
msgstr "OID каталога, к которому относится объект"

#: func.xml:19041(literal) func.xml:19128(literal)
msgid "objid"
msgstr "objid"

#: func.xml:19043(entry)
msgid "OID of the object in the catalog"
msgstr "OID объекта в каталоге"

#: func.xml:19046(literal) func.xml:19133(literal)
msgid "objsubid"
msgstr "objsubid"

#: func.xml:19048(entry) func.xml:19135(entry)
msgid "Object sub-id (e.g. attribute number for columns)"
msgstr "Идентификатор подобъекта (например, номер для столбцов)"

#: func.xml:19051(literal)
msgid "command_tag"
msgstr "command_tag"

#: func.xml:19053(entry)
msgid "command tag"
msgstr "Тег команды"

#: func.xml:19056(literal) func.xml:19158(literal)
msgid "object_type"
msgstr "object_type"

#: func.xml:19058(entry) func.xml:19160(entry)
msgid "Type of the object"
msgstr "Тип объекта"

#: func.xml:19061(literal) func.xml:19163(literal)
msgctxt "literal"
msgid "schema_name"
msgstr "schema_name"

#: func.xml:19063(entry)
msgid ""
"Name of the schema the object belongs in, if any; otherwise <literal>NULL</"
"literal>. No quoting is applied."
msgstr ""
"Имя схемы, к которой относится объект; если объект не относится ни к какой "
"схеме &mdash; <literal>NULL</literal>. В кавычки имя не заключается."

#: func.xml:19069(literal) func.xml:19180(literal)
msgid "object_identity"
msgstr "object_identity"

#: func.xml:19071(entry) func.xml:19182(entry)
msgid ""
"Text rendering of the object identity, schema-qualified. Each and every "
"identifier present in the identity is quoted if necessary."
msgstr ""
"Текстовое представление идентификатора объекта, дополненного схемой. "
"Компоненты этого идентификаторы могут заключаться в кавычки, если требуется."

#: func.xml:19077(literal)
msgid "in_extension"
msgstr "in_extension"

#: func.xml:19079(entry)
msgid "whether the command is part of an extension script"
msgstr "является ли команда частью скрипта расширения"

#: func.xml:19082(literal)
msgid "command"
msgstr "command"

#: func.xml:19083(type)
msgid "pg_ddl_command"
msgstr "pg_ddl_command"

#: func.xml:19084(entry)
msgid ""
"A complete representation of the command, in internal format. This cannot be "
"output directly, but it can be passed to other functions to obtain different "
"pieces of information about the command."
msgstr ""
"Полное представление команды, во внутреннем формате. Его нельзя вывести "
"непосредственно, но можно передать другим функциям, чтобы получить различные "
"сведения о команде."

#: func.xml:19013(para)
msgid ""
"<function>pg_event_trigger_ddl_commands</function> returns a list of "
"<acronym>DDL</acronym> commands executed by each user action, when invoked "
"in a function attached to a <literal>ddl_command_end</literal> event "
"trigger. If called in any other context, an error is raised. "
"<function>pg_event_trigger_ddl_commands</function> returns one row for each "
"base command executed; some commands that are a single SQL sentence may "
"return more than one row. This function returns the following columns: "
"<placeholder-1/>"
msgstr ""
"Функция <function>pg_event_trigger_ddl_commands</function> возвращает список "
"команд <acronym>DDL</acronym>, выполняемых в результате действия "
"пользователя. Вызывать её можно только в функции, реализующей событийный "
"триггер <literal>ddl_command_end</literal>. При попытке вызвать её в любом "
"другом контексте возникнет ошибка. Функция "
"<function>pg_event_trigger_ddl_commands</function> возвращает одну строку "
"для каждой базовой команды; для некоторых команд, записываемых в виде одного "
"предложения SQL, может возвращаться несколько строк. Эта функция возвращает "
"следующие столбцы: <placeholder-1/>"

#: func.xml:19098(title)
msgid "Processing Objects Dropped by a DDL Command"
msgstr "Обработка объектов, удалённых командой DDL"

#: func.xml:19100(indexterm)
msgid "<primary>pg_event_trigger_dropped_objects</primary>"
msgstr "<primary>pg_event_trigger_dropped_objects</primary>"

#: func.xml:19125(entry)
msgid "OID of catalog the object belonged in"
msgstr "OID каталога, к которому относился объект"

#: func.xml:19130(entry)
msgid "OID the object had within the catalog"
msgstr "OID, который имел объект в каталоге"

#: func.xml:19134(type)
msgid "int32"
msgstr "int32"

#: func.xml:19138(literal)
msgid "original"
msgstr "original"

#: func.xml:19140(entry)
msgid "Flag used to identify the root object(s) of the deletion"
msgstr "Флаг, обозначающий исходный удаляемый объект(ы)"

#: func.xml:19143(literal)
msgid "normal"
msgstr "normal"

#: func.xml:19145(entry)
msgid ""
"Flag indicating that there's a normal dependency relationship in the "
"dependency graph leading to this object"
msgstr ""
"Флаг, обозначающий, что к этому объекту в графе зависимостей привело "
"отношение обычной зависимости"

#: func.xml:19151(literal)
msgid "is_temporary"
msgstr "is_temporary"

#: func.xml:19153(entry)
msgid "Flag indicating that the object was a temporary object."
msgstr "Флаг, обозначающий, что объект был временным."

#: func.xml:19165(entry)
msgid ""
"Name of the schema the object belonged in, if any; otherwise <literal>NULL</"
"literal>. No quoting is applied."
msgstr ""
"Имя схемы, к которой относился объект; если объект не относился ни к какой "
"схеме &mdash; <literal>NULL</literal>. В кавычки имя не заключается."

#: func.xml:19171(literal)
msgid "object_name"
msgstr "object_name"

#: func.xml:19173(entry)
msgid ""
"Name of the object, if the combination of schema and name can be used as a "
"unique identifier for the object; otherwise <literal>NULL</literal>. No "
"quoting is applied, and name is never schema-qualified."
msgstr ""
"Имя объекта, если сочетание схемы и имени позволяет уникально "
"идентифицировать объект; в противном случае &mdash; <literal>NULL</literal>. "
"Имя не заключается в кавычки и не дополняется именем схемы."

#: func.xml:19188(literal)
msgid "address_names"
msgstr "address_names"

#: func.xml:19190(entry)
msgid ""
"An array that, together with <literal>object_type</literal> and "
"<literal>address_args</literal>, can be used by the "
"<function>pg_get_object_address()</function> to recreate the object address "
"in a remote server containing an identically named object of the same kind."
msgstr ""
"Массив, который в сочетании с <literal>object_type</literal> и массивом "
"<literal>address_args</literal> можно передать функции "
"<function>pg_get_object_address()</function> и воссоздать адрес объекта на "
"удалённом сервере, содержащем одноимённый объект того же рода."

#: func.xml:19199(literal)
msgid "address_args"
msgstr "address_args"

#: func.xml:19201(entry)
msgid "Complement for <literal>address_names</literal> above."
msgstr "Дополнение предшествующего массива <literal>address_names</literal>."

#: func.xml:19104(para)
msgid ""
"<function>pg_event_trigger_dropped_objects</function> returns a list of all "
"objects dropped by the command in whose <literal>sql_drop</literal> event it "
"is called. If called in any other context, "
"<function>pg_event_trigger_dropped_objects</function> raises an error. "
"<function>pg_event_trigger_dropped_objects</function> returns the following "
"columns: <placeholder-1/>"
msgstr ""
"Функция <function>pg_event_trigger_dropped_objects</function> возвращает "
"список всех объектов, удалённых командой, вызвавшей событие "
"<literal>sql_drop</literal>. При вызове в другом контексте "
"<function>pg_event_trigger_dropped_objects</function> выдаёт ошибку. "
"<function>pg_event_trigger_dropped_objects</function> возвращает следующие "
"столбцы: <placeholder-1/>"

#: func.xml:19213(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION test_event_trigger_for_drops()\n"
"        RETURNS event_trigger LANGUAGE plpgsql AS $$\n"
"DECLARE\n"
"    obj record;\n"
"BEGIN\n"
"    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n"
"    LOOP\n"
"        RAISE NOTICE '% dropped object: % %.% %',\n"
"                     tg_tag,\n"
"                     obj.object_type,\n"
"                     obj.schema_name,\n"
"                     obj.object_name,\n"
"                     obj.object_identity;\n"
"    END LOOP;\n"
"END\n"
"$$;\n"
"CREATE EVENT TRIGGER test_event_trigger_for_drops\n"
"   ON sql_drop\n"
"   EXECUTE PROCEDURE test_event_trigger_for_drops();"
msgstr ""
"CREATE FUNCTION test_event_trigger_for_drops()\n"
"        RETURNS event_trigger LANGUAGE plpgsql AS $$\n"
"DECLARE\n"
"    obj record;\n"
"BEGIN\n"
"    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n"
"    LOOP\n"
"        RAISE NOTICE '% dropped object: % %.% %',\n"
"                     tg_tag,\n"
"                     obj.object_type,\n"
"                     obj.schema_name,\n"
"                     obj.object_name,\n"
"                     obj.object_identity;\n"
"    END LOOP;\n"
"END\n"
"$$;\n"
"CREATE EVENT TRIGGER test_event_trigger_for_drops\n"
"   ON sql_drop\n"
"   EXECUTE PROCEDURE test_event_trigger_for_drops();"

#: func.xml:19210(para)
msgid ""
"The <function>pg_event_trigger_dropped_objects</function> function can be "
"used in an event trigger like this: <placeholder-1/>"
msgstr ""
"Функцию <function>pg_event_trigger_dropped_objects</function> можно "
"использовать в событийном триггере так: <placeholder-1/>"

#: func.xml:19236(title)
msgid "Handling a Table Rewrite Event"
msgstr "Обработка события перезаписи таблицы"

#: func.xml:19238(para)
msgid ""
"The functions shown in <xref linkend=\"functions-event-trigger-table-rewrite"
"\"/> provide information about a table for which a <literal>table_rewrite</"
"literal> event has just been called. If called in any other context, an "
"error is raised."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-event-trigger-table-rewrite\"/> "
"показаны функции, выдающие информацию о таблице, для которой произошло "
"событие перезаписи таблицы (<literal>table_rewrite</literal>). При попытке "
"вызвать их в другом контексте возникнет ошибка."

#: func.xml:19247(title)
msgid "Table Rewrite information"
msgstr "Информация о перезаписи таблицы"

#: func.xml:19256(indexterm)
msgid "<primary>pg_event_trigger_table_rewrite_oid</primary>"
msgstr "<primary>pg_event_trigger_table_rewrite_oid</primary>"

#: func.xml:19257(function)
msgid "pg_event_trigger_table_rewrite_oid()"
msgstr "pg_event_trigger_table_rewrite_oid()"

#: func.xml:19260(entry)
msgid "The OID of the table about to be rewritten."
msgstr "OID таблицы, которая будет перезаписана."

#: func.xml:19265(indexterm)
msgid "<primary>pg_event_trigger_table_rewrite_reason</primary>"
msgstr "<primary>pg_event_trigger_table_rewrite_reason</primary>"

#: func.xml:19266(function)
msgid "pg_event_trigger_table_rewrite_reason()"
msgstr "pg_event_trigger_table_rewrite_reason()"

#: func.xml:19269(entry)
msgid ""
"The reason code(s) explaining the reason for rewriting. The exact meaning of "
"the codes is release dependent."
msgstr ""
"Код причины, показывающий, чем вызвана перезапись. Точное значение кодов "
"зависит от выпуска (версии)."

#: func.xml:19281(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION test_event_trigger_table_rewrite_oid()\n"
" RETURNS event_trigger\n"
" LANGUAGE plpgsql AS\n"
"$$\n"
"BEGIN\n"
"  RAISE NOTICE 'rewriting table % for reason %',\n"
"                pg_event_trigger_table_rewrite_oid()::regclass,\n"
"                pg_event_trigger_table_rewrite_reason();\n"
"END;\n"
"$$;\n"
"\n"
"CREATE EVENT TRIGGER test_table_rewrite_oid\n"
"                  ON table_rewrite\n"
"   EXECUTE PROCEDURE test_event_trigger_table_rewrite_oid();"
msgstr ""
"CREATE FUNCTION test_event_trigger_table_rewrite_oid()\n"
" RETURNS event_trigger\n"
" LANGUAGE plpgsql AS\n"
"$$\n"
"BEGIN\n"
"  RAISE NOTICE 'rewriting table % for reason %',\n"
"                pg_event_trigger_table_rewrite_oid()::regclass,\n"
"                pg_event_trigger_table_rewrite_reason();\n"
"END;\n"
"$$;\n"
"\n"
"CREATE EVENT TRIGGER test_table_rewrite_oid\n"
"                  ON table_rewrite\n"
"   EXECUTE PROCEDURE test_event_trigger_table_rewrite_oid();"

#: func.xml:19278(para)
msgid ""
"The <function>pg_event_trigger_table_rewrite_oid</function> function can be "
"used in an event trigger like this: <placeholder-1/>"
msgstr ""
"Функцию <function>pg_event_trigger_table_rewrite_oid</function> можно "
"использовать в событийном триггере так: <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: func.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#~ msgid "replace target with substitute within query"
#~ msgstr "заменяет целевой подзапрос подстановкой"
