# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-09 11:01+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: advanced.xml:5(title)
msgid "Advanced Features"
msgstr "Расширенные возможности"

#: advanced.xml:8(title)
msgid "Introduction"
msgstr "Введение"

#: advanced.xml:10(para)
msgid ""
"In the previous chapter we have covered the basics of using <acronym>SQL</"
"acronym> to store and access your data in <productname>PostgreSQL</"
"productname>. We will now discuss some more advanced features of "
"<acronym>SQL</acronym> that simplify management and prevent loss or "
"corruption of your data. Finally, we will look at some "
"<productname>PostgreSQL</productname> extensions."
msgstr ""
"В предыдущей главе мы изучили азы использования <acronym>SQL</acronym> для "
"хранения и обработки данных в <productname>PostgreSQL</productname>. Теперь "
"мы обсудим более сложные возможности <acronym>SQL</acronym>, помогающие "
"управлять данными и предотвратить их потерю или порчу. В конце главы мы "
"рассмотрим некоторые расширения <productname>PostgreSQL</productname>."

#: advanced.xml:20(para)
msgid ""
"This chapter will on occasion refer to examples found in <xref linkend="
"\"tutorial-sql\"/> to change or improve them, so it will be useful to have "
"read that chapter. Some examples from this chapter can also be found in "
"<filename>advanced.sql</filename> in the tutorial directory. This file also "
"contains some sample data to load, which is not repeated here. (Refer to "
"<xref linkend=\"tutorial-sql-intro\"/> for how to use the file.)"
msgstr ""
"В этой главе мы будем время от времени ссылаться на примеры, приведённые в "
"<xref remap=\"6\" linkend=\"tutorial-sql\"/> и изменять или развивать их, "
"поэтому будет полезно сначала прочитать предыдущую главу. Некоторые примеры "
"этой главы также можно найти в файле <filename>advanced.sql</filename> в "
"каталоге tutorial. Кроме того, этот файл содержит пример данных для загрузки "
"(здесь она повторно не рассматривается). Если вы не знаете, как использовать "
"этот файл, обратитесь к <xref remap=\"3\" linkend=\"tutorial-sql-intro\"/>."

#: advanced.xml:34(title)
msgid "Views"
msgstr "Представления"

#: advanced.xml:36(indexterm)
msgid "<primary>view</primary>"
msgstr "<primary>представление</primary>"

#: advanced.xml:48(programlisting)
#, no-wrap
msgid ""
"CREATE VIEW myview AS\n"
"    SELECT city, temp_lo, temp_hi, prcp, date, location\n"
"        FROM weather, cities\n"
"        WHERE city = name;\n"
"\n"
"SELECT * FROM myview;"
msgstr ""
"CREATE VIEW myview AS\n"
"    SELECT city, temp_lo, temp_hi, prcp, date, location\n"
"        FROM weather, cities\n"
"        WHERE city = name;\n"
"\n"
"SELECT * FROM myview;"

#: advanced.xml:40(para)
msgid ""
"Refer back to the queries in <xref linkend=\"tutorial-join\"/>. Suppose the "
"combined listing of weather records and city location is of particular "
"interest to your application, but you do not want to type the query each "
"time you need it. You can create a <firstterm>view</firstterm> over the "
"query, which gives a name to the query that you can refer to like an "
"ordinary table: <placeholder-1/>"
msgstr ""
"Вспомните запросы, с которыми мы имели дело в <xref remap=\"6\" linkend="
"\"tutorial-join\"/>. Предположим, что вас интересует составной список из "
"погодных записей и координат городов, но вы не хотите каждый раз вводить "
"весь этот запрос. Вы можете создать <firstterm>представление</firstterm> по "
"данному запросу, фактически присвоить имя запросу, а затем обращаться к нему "
"как к обычной таблице: <placeholder-1/>"

#: advanced.xml:56(para)
msgid ""
"Making liberal use of views is a key aspect of good SQL database design. "
"Views allow you to encapsulate the details of the structure of your tables, "
"which might change as your application evolves, behind consistent interfaces."
msgstr ""
"Активное использование представлений &mdash; это ключевой аспект хорошего "
"проектирования баз данных SQL. Представления позволяют вам скрыть внутреннее "
"устройство ваших таблиц, которые могут меняться по мере развития приложения, "
"за надёжными интерфейсами."

#: advanced.xml:63(para)
msgid ""
"Views can be used in almost any place a real table can be used. Building "
"views upon other views is not uncommon."
msgstr ""
"Представления можно использовать практически везде, где можно использовать "
"обычные таблицы. И довольно часто представления создаются на базе других "
"представлений."

#: advanced.xml:71(title)
msgid "Foreign Keys"
msgstr "Внешние ключи"

#: advanced.xml:73(indexterm)
msgid "<primary>foreign key</primary>"
msgstr "<primary>внешний ключ</primary>"

#: advanced.xml:77(indexterm)
msgid "<primary>referential integrity</primary>"
msgstr "<primary>ссылочная целостность</primary>"

#: advanced.xml:81(para)
msgid ""
"Recall the <classname>weather</classname> and <classname>cities</classname> "
"tables from <xref linkend=\"tutorial-sql\"/>. Consider the following "
"problem: You want to make sure that no one can insert rows in the "
"<classname>weather</classname> table that do not have a matching entry in "
"the <classname>cities</classname> table. This is called maintaining the "
"<firstterm>referential integrity</firstterm> of your data. In simplistic "
"database systems this would be implemented (if at all) by first looking at "
"the <classname>cities</classname> table to check if a matching record "
"exists, and then inserting or rejecting the new <classname>weather</"
"classname> records. This approach has a number of problems and is very "
"inconvenient, so <productname>PostgreSQL</productname> can do this for you."
msgstr ""
"Вспомните таблицы <classname>weather</classname> и <classname>cities</"
"classname> из <xref remap=\"2\" linkend=\"tutorial-sql\"/>. Давайте "
"рассмотрим следующую задачу: вы хотите добиться, чтобы никто не мог вставить "
"в таблицу <classname>weather</classname> строки, для которых не находится "
"соответствующая строка в таблице <classname>cities</classname>. Это "
"называется обеспечением <firstterm>ссылочной целостности</firstterm> данных. "
"В простых СУБД это пришлось бы реализовать (если это вообще возможно) так: "
"сначала явно проверить, есть ли соответствующие записи в таблице "
"<classname>cities</classname>, а затем отклонить или вставить новые записи в "
"таблицу <classname>weather</classname>. Этот подход очень проблематичен и "
"неудобен, поэтому всё это <productname>PostgreSQL</productname> может "
"сделать за вас."

#: advanced.xml:101(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE cities (\n"
"        city     varchar(80) primary key,\n"
"        location point\n"
");\n"
"\n"
"CREATE TABLE weather (\n"
"        city      varchar(80) references cities(city),\n"
"        temp_lo   int,\n"
"        temp_hi   int,\n"
"        prcp      real,\n"
"        date      date\n"
");"
msgstr ""
"CREATE TABLE cities (\n"
"        city     varchar(80) primary key,\n"
"        location point\n"
");\n"
"\n"
"CREATE TABLE weather (\n"
"        city      varchar(80) references cities(city),\n"
"        temp_lo   int,\n"
"        temp_hi   int,\n"
"        prcp      real,\n"
"        date      date\n"
");"

#: advanced.xml:116(programlisting)
#, no-wrap
msgid "INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');"
msgstr "INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');"

#: advanced.xml:98(para)
msgid ""
"The new declaration of the tables would look like this: <placeholder-1/> Now "
"try inserting an invalid record: <placeholder-2/>\n"
"\n"
"<screen>ERROR:  insert or update on table \"weather\" violates foreign key "
"constraint \"weather_city_fkey\"\n"
"DETAIL:  Key (city)=(Berkeley) is not present in table \"cities\".</screen>"
msgstr ""
"Новое объявление таблицы будет выглядеть так: <placeholder-1/> Теперь "
"попробуйте вставить недопустимую запись: <placeholder-2/>\n"
"\n"
"<screen>ОШИБКА:  INSERT или UPDATE в таблице \"weather\" нарушает "
"ограничение внешнего\n"
"  ключа \"weather_city_fkey\"\n"
"ПОДРОБНОСТИ:  Ключ (city)=(Berkeley) отсутствует в таблице \"cities\".</"
"screen>"

#: advanced.xml:122(para)
msgid ""
"The behavior of foreign keys can be finely tuned to your application. We "
"will not go beyond this simple example in this tutorial, but just refer you "
"to <xref linkend=\"ddl\"/> for more information. Making correct use of "
"foreign keys will definitely improve the quality of your database "
"applications, so you are strongly encouraged to learn about them."
msgstr ""
"Поведение внешних ключей можно подстроить согласно требованиям вашего "
"приложения. Мы не будем усложнять этот простой пример в данном введении, но "
"вы можете обратиться за дополнительной информацией к <xref remap=\"3\" "
"linkend=\"ddl\"/>. Правильно применяя внешние ключи, вы определённо "
"создадите более качественные приложения, поэтому мы настоятельно рекомендуем "
"изучить их."

#: advanced.xml:134(title)
msgid "Transactions"
msgstr "Транзакции"

#: advanced.xml:136(indexterm)
msgid "<primary>transaction</primary>"
msgstr "<primary>транзакция</primary>"

#: advanced.xml:140(para)
msgid ""
"<firstterm>Transactions</firstterm> are a fundamental concept of all "
"database systems. The essential point of a transaction is that it bundles "
"multiple steps into a single, all-or-nothing operation. The intermediate "
"states between the steps are not visible to other concurrent transactions, "
"and if some failure occurs that prevents the transaction from completing, "
"then none of the steps affect the database at all."
msgstr ""
"<firstterm>Транзакции</firstterm> &mdash; это фундаментальное понятие во "
"всех СУБД. Суть транзакции в том, что она объединяет последовательность "
"действий в одну операцию \"всё или ничего\". Промежуточные состояния внутри "
"последовательности не видны другим транзакциям, и если что-то помешает "
"успешно завершить транзакцию, ни один из результатов этих действий не "
"сохранится в базе данных."

#: advanced.xml:156(programlisting)
#, no-wrap
msgid ""
"UPDATE accounts SET balance = balance - 100.00\n"
"    WHERE name = 'Alice';\n"
"UPDATE branches SET balance = balance - 100.00\n"
"    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');\n"
"UPDATE accounts SET balance = balance + 100.00\n"
"    WHERE name = 'Bob';\n"
"UPDATE branches SET balance = balance + 100.00\n"
"    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');"
msgstr ""
"UPDATE accounts SET balance = balance - 100.00\n"
"    WHERE name = 'Alice';\n"
"UPDATE branches SET balance = balance - 100.00\n"
"    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');\n"
"UPDATE accounts SET balance = balance + 100.00\n"
"    WHERE name = 'Bob';\n"
"UPDATE branches SET balance = balance + 100.00\n"
"    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');"

#: advanced.xml:149(para)
msgid ""
"For example, consider a bank database that contains balances for various "
"customer accounts, as well as total deposit balances for branches. Suppose "
"that we want to record a payment of $100.00 from Alice's account to Bob's "
"account. Simplifying outrageously, the SQL commands for this might look "
"like: <placeholder-1/>"
msgstr ""
"Например, рассмотрим базу данных банка, в которой содержится информация о "
"счетах клиентов, а также общие суммы по отделениям банка. Предположим, что "
"мы хотим перевести 100 долларов со счёта Алисы на счёт Боба. Простоты ради, "
"соответствующие SQL-команды можно записать так: <placeholder-1/>"

#: advanced.xml:166(para)
msgid ""
"The details of these commands are not important here; the important point is "
"that there are several separate updates involved to accomplish this rather "
"simple operation. Our bank's officers will want to be assured that either "
"all these updates happen, or none of them happen. It would certainly not do "
"for a system failure to result in Bob receiving $100.00 that was not debited "
"from Alice. Nor would Alice long remain a happy customer if she was debited "
"without Bob being credited. We need a guarantee that if something goes wrong "
"partway through the operation, none of the steps executed so far will take "
"effect. Grouping the updates into a <firstterm>transaction</firstterm> gives "
"us this guarantee. A transaction is said to be <firstterm>atomic</"
"firstterm>: from the point of view of other transactions, it either happens "
"completely or not at all."
msgstr ""
"Точное содержание команд здесь не важно, важно лишь то, что для выполнения "
"этой довольно простой операции потребовалось несколько отдельных действий. "
"При этом с точки зрения банка необходимо, чтобы все эти действия выполнились "
"вместе, либо не выполнились совсем. Если Боб получит 100 долларов, но они не "
"будут списаны со счёта Алисы, объяснить это сбоем системы определённо не "
"удастся. И наоборот, Алиса вряд ли будет довольна, если она переведёт "
"деньги, а до Боба они не дойдут. Нам нужна гарантия, что если что-то "
"помешает выполнить операцию до конца, ни одно из действий не оставит следа в "
"базе данных. И мы получаем эту гарантию, объединяя действия в одну "
"<firstterm>транзакцию</firstterm>. Говорят, что транзакция "
"<firstterm>атомарна</firstterm>: с точки зрения других транзакций она либо "
"выполняется и фиксируется полностью, либо не фиксируется совсем."

#: advanced.xml:181(para)
msgid ""
"We also want a guarantee that once a transaction is completed and "
"acknowledged by the database system, it has indeed been permanently recorded "
"and won't be lost even if a crash ensues shortly thereafter. For example, if "
"we are recording a cash withdrawal by Bob, we do not want any chance that "
"the debit to his account will disappear in a crash just after he walks out "
"the bank door. A transactional database guarantees that all the updates made "
"by a transaction are logged in permanent storage (i.e., on disk) before the "
"transaction is reported complete."
msgstr ""
"Нам также нужна гарантия, что после завершения и подтверждения транзакции "
"системой баз данных, её результаты в самом деле сохраняются и не будут "
"потеряны, даже если вскоре произойдёт авария. Например, если мы списали "
"сумму и выдали её Бобу, мы должны исключить возможность того, что сумма на "
"его счёте восстановится, как только он выйдет за двери банка. Транзакционная "
"база данных гарантирует, что все изменения записываются в постоянное "
"хранилище (например, на диск) до того, как транзакция будет считаться "
"завершённой."

#: advanced.xml:194(para)
msgid ""
"Another important property of transactional databases is closely related to "
"the notion of atomic updates: when multiple transactions are running "
"concurrently, each one should not be able to see the incomplete changes made "
"by others. For example, if one transaction is busy totalling all the branch "
"balances, it would not do for it to include the debit from Alice's branch "
"but not the credit to Bob's branch, nor vice versa. So transactions must be "
"all-or-nothing not only in terms of their permanent effect on the database, "
"but also in terms of their visibility as they happen. The updates made so "
"far by an open transaction are invisible to other transactions until the "
"transaction completes, whereupon all the updates become visible "
"simultaneously."
msgstr ""
"Другая важная характеристика транзакционных баз данных тесно связана с "
"атомарностью изменений: когда одновременно выполняется множество транзакций, "
"каждая из них не видит незавершённые изменения, произведённые другими. "
"Например, если одна транзакция подсчитывает баланс по отделениям, будет "
"неправильно, если она посчитает расход в отделении Алисы, но не учтёт приход "
"в отделении Боба, или наоборот. Поэтому свойство транзакций \"всё или ничего"
"\" должно определять не только, как изменения сохраняются в базе данных, но "
"и как они видны в процессе работы. Изменения, производимые открытой "
"транзакцией, невидимы для других транзакций, пока она не будет завершена, а "
"затем они становятся видны все сразу."

#: advanced.xml:215(programlisting)
#, no-wrap
msgid ""
"BEGIN;\n"
"UPDATE accounts SET balance = balance - 100.00\n"
"    WHERE name = 'Alice';\n"
"-- etc etc\n"
"COMMIT;"
msgstr ""
"BEGIN;\n"
"UPDATE accounts SET balance = balance - 100.00\n"
"    WHERE name = 'Alice';\n"
"-- ...\n"
"COMMIT;"

#: advanced.xml:209(para)
msgid ""
"In <productname>PostgreSQL</productname>, a transaction is set up by "
"surrounding the SQL commands of the transaction with <command>BEGIN</"
"command> and <command>COMMIT</command> commands. So our banking transaction "
"would actually look like: <placeholder-1/>"
msgstr ""
"В <productname>PostgreSQL</productname> транзакция определяется набором SQL-"
"команд, окружённым командами <command>BEGIN</command> и <command>COMMIT</"
"command>. Таким образом, наша банковская транзакция должна была бы выглядеть "
"так: <placeholder-1/>"

#: advanced.xml:222(para)
msgid ""
"If, partway through the transaction, we decide we do not want to commit "
"(perhaps we just noticed that Alice's balance went negative), we can issue "
"the command <command>ROLLBACK</command> instead of <command>COMMIT</"
"command>, and all our updates so far will be canceled."
msgstr ""
"Если в процессе выполнения транзакции мы решим, что не хотим фиксировать её "
"изменения (например, потому что оказалось, что баланс Алисы стал "
"отрицательным), мы можем выполнить команду <command>ROLLBACK</command> "
"вместо <command>COMMIT</command>, и все наши изменения будут отменены."

#: advanced.xml:229(para)
msgid ""
"<productname>PostgreSQL</productname> actually treats every SQL statement as "
"being executed within a transaction. If you do not issue a <command>BEGIN</"
"command> command, then each individual statement has an implicit "
"<command>BEGIN</command> and (if successful) <command>COMMIT</command> "
"wrapped around it. A group of statements surrounded by <command>BEGIN</"
"command> and <command>COMMIT</command> is sometimes called a "
"<firstterm>transaction block</firstterm>."
msgstr ""
"<productname>PostgreSQL</productname> на самом деле отрабатывает каждый SQL-"
"оператор как транзакцию. Если вы не вставите команду <command>BEGIN</"
"command>, то каждый отдельный оператор будет неявно окружён командами "
"<command>BEGIN</command> и <command>COMMIT</command> (в случае успешного "
"завершения). Группу операторов, окружённых командами <command>BEGIN</"
"command> и <command>COMMIT</command> иногда называют <firstterm>блоком "
"транзакции</firstterm>."

#: advanced.xml:240(para)
msgid ""
"Some client libraries issue <command>BEGIN</command> and <command>COMMIT</"
"command> commands automatically, so that you might get the effect of "
"transaction blocks without asking. Check the documentation for the interface "
"you are using."
msgstr ""
"Некоторые клиентские библиотеки добавляют команды <command>BEGIN</command> и "
"<command>COMMIT</command> автоматически и неявно создают за вас блоки "
"транзакций. Подробнее об этом вы можете узнать в документации интересующего "
"вас интерфейса."

#: advanced.xml:248(para)
msgid ""
"It's possible to control the statements in a transaction in a more granular "
"fashion through the use of <firstterm>savepoints</firstterm>. Savepoints "
"allow you to selectively discard parts of the transaction, while committing "
"the rest. After defining a savepoint with <command>SAVEPOINT</command>, you "
"can if needed roll back to the savepoint with <command>ROLLBACK TO</"
"command>. All the transaction's database changes between defining the "
"savepoint and rolling back to it are discarded, but changes earlier than the "
"savepoint are kept."
msgstr ""
"Операторами в транзакции можно также управлять на более детальном уровне, "
"используя <firstterm>точки сохранения</firstterm>. Точки сохранения "
"позволяют выборочно отменять некоторые части транзакции и фиксировать все "
"остальные. Определив точку сохранения с помощью <command>SAVEPOINT</"
"command>, при необходимости вы можете вернуться к ней с помощью команды "
"<command>ROLLBACK TO</command>. Все изменения в базе данных, произошедшие "
"после точки сохранения и до момента отката, отменяются, но изменения, "
"произведённые ранее, сохраняются."

#: advanced.xml:259(para)
msgid ""
"After rolling back to a savepoint, it continues to be defined, so you can "
"roll back to it several times. Conversely, if you are sure you won't need to "
"roll back to a particular savepoint again, it can be released, so the system "
"can free some resources. Keep in mind that either releasing or rolling back "
"to a savepoint will automatically release all savepoints that were defined "
"after it."
msgstr ""
"Когда вы возвращаетесь к точке сохранения, она продолжает существовать, так "
"что вы можете откатываться к ней несколько раз. С другой стороны, если вы "
"уверены, что вам не придётся откатываться к определённой точке сохранения, "
"её можно удалить, чтобы система высвободила ресурсы. Помните, что при "
"удалении или откате к точке сохранения все точки сохранения, определённые "
"после неё, автоматически уничтожаются."

#: advanced.xml:268(para)
msgid ""
"All this is happening within the transaction block, so none of it is visible "
"to other database sessions. When and if you commit the transaction block, "
"the committed actions become visible as a unit to other sessions, while the "
"rolled-back actions never become visible at all."
msgstr ""
"Всё это происходит в блоке транзакции, так что в других сеансах работы с "
"базой данных этого не видно. Совершённые действия становятся видны для "
"других сеансов все сразу, только когда вы фиксируете транзакцию, а "
"отменённые действия не видны вообще никогда."

#: advanced.xml:282(programlisting)
#, no-wrap
msgid ""
"BEGIN;\n"
"UPDATE accounts SET balance = balance - 100.00\n"
"    WHERE name = 'Alice';\n"
"SAVEPOINT my_savepoint;\n"
"UPDATE accounts SET balance = balance + 100.00\n"
"    WHERE name = 'Bob';\n"
"-- oops ... forget that and use Wally's account\n"
"ROLLBACK TO my_savepoint;\n"
"UPDATE accounts SET balance = balance + 100.00\n"
"    WHERE name = 'Wally';\n"
"COMMIT;"
msgstr ""
"BEGIN;\n"
"UPDATE accounts SET balance = balance - 100.00\n"
"    WHERE name = 'Alice';\n"
"SAVEPOINT my_savepoint;\n"
"UPDATE accounts SET balance = balance + 100.00\n"
"    WHERE name = 'Bob';\n"
"-- ошибочное действие... забыть его и использовать счёт Уолли\n"
"ROLLBACK TO my_savepoint;\n"
"UPDATE accounts SET balance = balance + 100.00\n"
"    WHERE name = 'Wally';\n"
"COMMIT;"

#: advanced.xml:276(para)
msgid ""
"Remembering the bank database, suppose we debit $100.00 from Alice's "
"account, and credit Bob's account, only to find later that we should have "
"credited Wally's account. We could do it using savepoints like this: "
"<placeholder-1/>"
msgstr ""
"Вернувшись к банковской базе данных, предположим, что мы списываем 100 "
"долларов со счёта Алисы, добавляем их на счёт Боба, и вдруг оказывается, что "
"деньги нужно было перевести Уолли. В данном случае мы можем применить точки "
"сохранения: <placeholder-1/>"

#: advanced.xml:295(para)
msgid ""
"This example is, of course, oversimplified, but there's a lot of control "
"possible in a transaction block through the use of savepoints. Moreover, "
"<command>ROLLBACK TO</command> is the only way to regain control of a "
"transaction block that was put in aborted state by the system due to an "
"error, short of rolling it back completely and starting again."
msgstr ""
"Этот пример, конечно, несколько надуман, но он показывает, как можно "
"управлять выполнением команд в блоке транзакций, используя точки сохранения. "
"Более того, <command>ROLLBACK TO</command> &mdash; это единственный способ "
"вернуть контроль над блоком транзакций, оказавшимся в прерванном состоянии "
"из-за ошибки системы, не считая возможности полностью отменить её и начать "
"снова."

#: advanced.xml:308(title)
msgid "Window Functions"
msgstr "Оконные функции"

#: advanced.xml:310(indexterm)
msgid "<primary>window function</primary>"
msgstr "<primary>оконная функция</primary>"

#: advanced.xml:314(para)
msgid ""
"A <firstterm>window function</firstterm> performs a calculation across a set "
"of table rows that are somehow related to the current row. This is "
"comparable to the type of calculation that can be done with an aggregate "
"function. But unlike regular aggregate functions, use of a window function "
"does not cause rows to become grouped into a single output row &mdash; the "
"rows retain their separate identities. Behind the scenes, the window "
"function is able to access more than just the current row of the query "
"result."
msgstr ""
"<firstterm>Оконная функция</firstterm> выполняет вычисления для набора "
"строк, некоторым образом связанных с текущей строкой. Можно сравнить её с "
"агрегатной функцией, но, в отличие от обычной агрегатной функции, при "
"использовании оконной функции несколько строк не группируются в одну, а "
"продолжают существовать отдельно. Внутри же, оконная функция, как и "
"агрегатная, может обращаться не только к текущей строке результата запроса."

#: advanced.xml:329(programlisting)
#, no-wrap
msgid "SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;"
msgstr ""
"SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname)\n"
"  FROM empsalary;"

#: advanced.xml:325(para)
msgid ""
"Here is an example that shows how to compare each employee's salary with the "
"average salary in his or her department: <placeholder-1/>\n"
"\n"
"<screen>  depname  | empno | salary |          avg          \n"
"-----------+-------+--------+-----------------------\n"
" develop   |    11 |   5200 | 5020.0000000000000000\n"
" develop   |     7 |   4200 | 5020.0000000000000000\n"
" develop   |     9 |   4500 | 5020.0000000000000000\n"
" develop   |     8 |   6000 | 5020.0000000000000000\n"
" develop   |    10 |   5200 | 5020.0000000000000000\n"
" personnel |     5 |   3500 | 3700.0000000000000000\n"
" personnel |     2 |   3900 | 3700.0000000000000000\n"
" sales     |     3 |   4800 | 4866.6666666666666667\n"
" sales     |     1 |   5000 | 4866.6666666666666667\n"
" sales     |     4 |   4800 | 4866.6666666666666667\n"
"(10 rows)</screen> The first three output columns come directly from the "
"table <structname>empsalary</structname>, and there is one output row for "
"each row in the table. The fourth column represents an average taken across "
"all the table rows that have the same <structfield>depname</structfield> "
"value as the current row. (This actually is the same function as the regular "
"<function>avg</function> aggregate function, but the <literal>OVER</literal> "
"clause causes it to be treated as a window function and computed across an "
"appropriate set of rows.)"
msgstr ""
"Вот пример, показывающий, как сравнить зарплату каждого сотрудника со "
"средней зарплатой его отдела: <placeholder-1/>\n"
"\n"
"<screen>  depname  | empno | salary |          avg          \n"
"-----------+-------+--------+-----------------------\n"
" develop   |    11 |   5200 | 5020.0000000000000000\n"
" develop   |     7 |   4200 | 5020.0000000000000000\n"
" develop   |     9 |   4500 | 5020.0000000000000000\n"
" develop   |     8 |   6000 | 5020.0000000000000000\n"
" develop   |    10 |   5200 | 5020.0000000000000000\n"
" personnel |     5 |   3500 | 3700.0000000000000000\n"
" personnel |     2 |   3900 | 3700.0000000000000000\n"
" sales     |     3 |   4800 | 4866.6666666666666667\n"
" sales     |     1 |   5000 | 4866.6666666666666667\n"
" sales     |     4 |   4800 | 4866.6666666666666667\n"
"(10 rows)</screen> Первые три столбца извлекаются непосредственно из таблицы "
"<structname>empsalary</structname>, при этом для каждой строки таблицы есть "
"строка результата. В четвёртом столбце оказалось среднее значение, "
"вычисленное по всем строкам, имеющим то же значение <structfield>depname</"
"structfield>, что и текущая строка. (Фактически среднее вычисляет та же "
"функция <function>avg</function>, которую мы знаем как агрегатную, но "
"предложение <literal>OVER</literal> превращает её в оконную, так что она "
"обрабатывает лишь заданный набор строк.)"

#: advanced.xml:355(para)
msgid ""
"A window function call always contains an <literal>OVER</literal> clause "
"directly following the window function's name and argument(s). This is what "
"syntactically distinguishes it from a regular function or aggregate "
"function. The <literal>OVER</literal> clause determines exactly how the rows "
"of the query are split up for processing by the window function. The "
"<literal>PARTITION BY</literal> list within <literal>OVER</literal> "
"specifies dividing the rows into groups, or partitions, that share the same "
"values of the <literal>PARTITION BY</literal> expression(s). For each row, "
"the window function is computed across the rows that fall into the same "
"partition as the current row."
msgstr ""
"Вызов оконной функции всегда содержит предложение <literal>OVER</literal>, "
"следующее за названием и аргументами оконной функции. Это синтаксически "
"отличает её от обычной или агрегатной функции. Предложение <literal>OVER</"
"literal> определяет, как именно нужно разделить строки запроса для обработки "
"оконной функцией. Предложение <literal>PARTITION BY</literal>, дополняющее "
"<literal>OVER</literal>, указывает, что строки нужно разделить по группам "
"или разделам, объединяя одинаковые значения выражений <literal>PARTITION BY</"
"literal>. Оконная функция вычисляется по строкам, попадающим в один раздел с "
"текущей строкой."

#: advanced.xml:374(programlisting)
#, no-wrap
msgid ""
"SELECT depname, empno, salary,\n"
"       rank() OVER (PARTITION BY depname ORDER BY salary DESC)\n"
"FROM empsalary;"
msgstr ""
"SELECT depname, empno, salary,\n"
"       rank() OVER (PARTITION BY depname ORDER BY salary DESC)\n"
"FROM empsalary;"

#: advanced.xml:368(para)
msgid ""
"You can also control the order in which rows are processed by window "
"functions using <literal>ORDER BY</literal> within <literal>OVER</literal>. "
"(The window <literal>ORDER BY</literal> does not even have to match the "
"order in which the rows are output.) Here is an example: <placeholder-1/>\n"
"\n"
"<screen>  depname  | empno | salary | rank \n"
"-----------+-------+--------+------\n"
" develop   |     8 |   6000 |    1\n"
" develop   |    10 |   5200 |    2\n"
" develop   |    11 |   5200 |    2\n"
" develop   |     9 |   4500 |    4\n"
" develop   |     7 |   4200 |    5\n"
" personnel |     2 |   3900 |    1\n"
" personnel |     5 |   3500 |    2\n"
" sales     |     1 |   5000 |    1\n"
" sales     |     4 |   4800 |    2\n"
" sales     |     3 |   4800 |    2\n"
"(10 rows)</screen> As shown here, the <function>rank</function> function "
"produces a numerical rank within the current row's partition for each "
"distinct <literal>ORDER BY</literal> value, in the order defined by the "
"<literal>ORDER BY</literal> clause. <function>rank</function> needs no "
"explicit parameter, because its behavior is entirely determined by the "
"<literal>OVER</literal> clause."
msgstr ""
"Вы можете также определять порядок, в котором строки будут обрабатываться "
"оконными функциями, используя <literal>ORDER BY</literal> в <literal>OVER</"
"literal>. (Порядок <literal>ORDER BY</literal> для окна может даже не "
"совпадать с порядком, в котором выводятся строки.) Например: <placeholder-1/"
">\n"
"\n"
"<screen>  depname  | empno | salary | rank \n"
"-----------+-------+--------+------\n"
" develop   |     8 |   6000 |    1\n"
" develop   |    10 |   5200 |    2\n"
" develop   |    11 |   5200 |    2\n"
" develop   |     9 |   4500 |    4\n"
" develop   |     7 |   4200 |    5\n"
" personnel |     2 |   3900 |    1\n"
" personnel |     5 |   3500 |    2\n"
" sales     |     1 |   5000 |    1\n"
" sales     |     4 |   4800 |    2\n"
" sales     |     3 |   4800 |    2\n"
"(10 rows)</screen> Как показано здесь, функция <function>rank</function> "
"выдаёт порядковый номер в разделе текущей строки для каждого уникального "
"значения, по которому выполняет сортировку предложение <literal>ORDER BY</"
"literal>. У функции <function>rank</function> нет параметров, так как её "
"поведение полностью определяется предложением <literal>OVER</literal>."

#: advanced.xml:399(para)
msgid ""
"The rows considered by a window function are those of the <quote>virtual "
"table</quote> produced by the query's <literal>FROM</literal> clause as "
"filtered by its <literal>WHERE</literal>, <literal>GROUP BY</literal>, and "
"<literal>HAVING</literal> clauses if any. For example, a row removed because "
"it does not meet the <literal>WHERE</literal> condition is not seen by any "
"window function. A query can contain multiple window functions that slice up "
"the data in different ways by means of different <literal>OVER</literal> "
"clauses, but they all act on the same collection of rows defined by this "
"virtual table."
msgstr ""
"Строки, обрабатываемые оконной функцией, представляют собой "
"<quote>виртуальные таблицы</quote>, созданные из предложения <literal>FROM</"
"literal> и затем прошедшие через фильтрацию и группировку <literal>WHERE</"
"literal> и <literal>GROUP BY</literal> и, возможно, условие <literal>HAVING</"
"literal>. Например, строка, отфильтрованная из-за нарушения условия "
"<literal>WHERE</literal>, не будет видна для оконных функций. Запрос может "
"содержать несколько оконных функций, разделяющих данные по-разному с помощью "
"разных предложений <literal>OVER</literal>, но все они будут обрабатывать "
"один и тот же набор строк этой виртуальной таблицы."

#: advanced.xml:410(para)
msgid ""
"We already saw that <literal>ORDER BY</literal> can be omitted if the "
"ordering of rows is not important. It is also possible to omit "
"<literal>PARTITION BY</literal>, in which case there is just one partition "
"containing all the rows."
msgstr ""
"Мы уже видели, что <literal>ORDER BY</literal> можно опустить, если порядок "
"строк не важен. Также возможно опустить <literal>PARTITION BY</literal>, в "
"этом случае будет только один раздел, содержащий все строки."

#: advanced.xml:427(para)
msgid ""
"There are options to define the window frame in other ways, but this "
"tutorial does not cover them. See <xref linkend=\"syntax-window-functions\"/"
"> for details."
msgstr ""
"Рамки окна можно определять и другими способами, но в этом введении они не "
"рассматриваются. Узнать о них подробнее вы можете в <xref remap=\"6\" "
"linkend=\"syntax-window-functions\"/>."

#: advanced.xml:416(para)
msgid ""
"There is another important concept associated with window functions: for "
"each row, there is a set of rows within its partition called its "
"<firstterm>window frame</firstterm>. Many (but not all) window functions act "
"only on the rows of the window frame, rather than of the whole partition. By "
"default, if <literal>ORDER BY</literal> is supplied then the frame consists "
"of all rows from the start of the partition up through the current row, plus "
"any following rows that are equal to the current row according to the "
"<literal>ORDER BY</literal> clause. When <literal>ORDER BY</literal> is "
"omitted the default frame consists of all rows in the partition. "
"<placeholder-1/> Here is an example using <function>sum</function>:"
msgstr ""
"Есть ещё одно важное понятие, связанное с оконными функциями: для каждой "
"строки существует набор строк в её разделе, называемый <firstterm>рамкой "
"окна</firstterm>. По умолчанию, с указанием <literal>ORDER BY</literal> "
"рамка состоит из всех строк от начала раздела до текущей строки и строк, "
"равных текущей по значению выражения <literal>ORDER BY</literal>. Без "
"<literal>ORDER BY</literal> рамка по умолчанию состоит из всех строк "
"раздела. <placeholder-1/> Посмотрите на пример использования <function>sum</"
"function>:"

#: advanced.xml:436(programlisting)
#, no-wrap
msgid "SELECT salary, sum(salary) OVER () FROM empsalary;"
msgstr "SELECT salary, sum(salary) OVER () FROM empsalary;"

#: advanced.xml:438(screen)
#, no-wrap
msgid ""
" salary |  sum  \n"
"--------+-------\n"
"   5200 | 47100\n"
"   5000 | 47100\n"
"   3500 | 47100\n"
"   4800 | 47100\n"
"   3900 | 47100\n"
"   4200 | 47100\n"
"   4500 | 47100\n"
"   4800 | 47100\n"
"   6000 | 47100\n"
"   5200 | 47100\n"
"(10 rows)"
msgstr ""
" salary |  sum  \n"
"--------+-------\n"
"   5200 | 47100\n"
"   5000 | 47100\n"
"   3500 | 47100\n"
"   4800 | 47100\n"
"   3900 | 47100\n"
"   4200 | 47100\n"
"   4500 | 47100\n"
"   4800 | 47100\n"
"   6000 | 47100\n"
"   5200 | 47100\n"
"(10 rows)"

#: advanced.xml:452(para)
msgid ""
"Above, since there is no <literal>ORDER BY</literal> in the <literal>OVER</"
"literal> clause, the window frame is the same as the partition, which for "
"lack of <literal>PARTITION BY</literal> is the whole table; in other words "
"each sum is taken over the whole table and so we get the same result for "
"each output row. But if we add an <literal>ORDER BY</literal> clause, we get "
"very different results:"
msgstr ""
"Так как в этом примере нет указания <literal>ORDER BY</literal> в "
"предложении <literal>OVER</literal>, рамка окна содержит все строки раздела, "
"а он, в свою очередь, без предложения <literal>PARTITION BY</literal> "
"включает все строки таблицы; другими словами, сумма вычисляется по всей "
"таблице и мы получаем один результат для каждой строки результата. Но если "
"мы добавим <literal>ORDER BY</literal>, мы получим совсем другие результаты:"

#: advanced.xml:461(programlisting)
#, no-wrap
msgid "SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;"
msgstr "SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;"

#: advanced.xml:463(screen)
#, no-wrap
msgid ""
" salary |  sum  \n"
"--------+-------\n"
"   3500 |  3500\n"
"   3900 |  7400\n"
"   4200 | 11600\n"
"   4500 | 16100\n"
"   4800 | 25700\n"
"   4800 | 25700\n"
"   5000 | 30700\n"
"   5200 | 41100\n"
"   5200 | 41100\n"
"   6000 | 47100\n"
"(10 rows)"
msgstr ""
" salary |  sum  \n"
"--------+-------\n"
"   3500 |  3500\n"
"   3900 |  7400\n"
"   4200 | 11600\n"
"   4500 | 16100\n"
"   4800 | 25700\n"
"   4800 | 25700\n"
"   5000 | 30700\n"
"   5200 | 41100\n"
"   5200 | 41100\n"
"   6000 | 47100\n"
"(10 rows)"

#: advanced.xml:477(para)
msgid ""
"Here the sum is taken from the first (lowest) salary up through the current "
"one, including any duplicates of the current one (notice the results for the "
"duplicated salaries)."
msgstr ""
"Здесь в сумме накапливаются зарплаты от первой (самой низкой) до текущей, "
"включая повторяющиеся текущие значения (обратите внимание на результат в "
"строках с одинаковой зарплатой)."

#: advanced.xml:483(para)
msgid ""
"Window functions are permitted only in the <literal>SELECT</literal> list "
"and the <literal>ORDER BY</literal> clause of the query. They are forbidden "
"elsewhere, such as in <literal>GROUP BY</literal>, <literal>HAVING</literal> "
"and <literal>WHERE</literal> clauses. This is because they logically execute "
"after the processing of those clauses. Also, window functions execute after "
"regular aggregate functions. This means it is valid to include an aggregate "
"function call in the arguments of a window function, but not vice versa."
msgstr ""
"Оконные функции разрешается использовать в запросе только в списке "
"<literal>SELECT</literal> и предложении <literal>ORDER BY</literal>. Во всех "
"остальных предложениях, включая <literal>GROUP BY</literal>, "
"<literal>HAVING</literal> и <literal>WHERE</literal>, они запрещены. Это "
"объясняется тем, что логически они выполняются после обычных агрегатных "
"функций, а значит агрегатную функцию можно вызвать из оконной, но не "
"наоборот."

#: advanced.xml:498(programlisting)
#, no-wrap
msgid ""
"SELECT depname, empno, salary, enroll_date\n"
"FROM\n"
"  (SELECT depname, empno, salary, enroll_date,\n"
"          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos\n"
"     FROM empsalary\n"
"  ) AS ss\n"
"WHERE pos &lt; 3;"
msgstr ""
"SELECT depname, empno, salary, enroll_date\n"
"FROM\n"
"  (SELECT depname, empno, salary, enroll_date,\n"
"    rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos\n"
"   FROM empsalary\n"
"  ) AS ss\n"
"WHERE pos &lt; 3;"

#: advanced.xml:494(para)
msgid ""
"If there is a need to filter or group rows after the window calculations are "
"performed, you can use a sub-select. For example: <placeholder-1/> The above "
"query only shows the rows from the inner query having <literal>rank</"
"literal> less than 3."
msgstr ""
"Если вам нужно отфильтровать или сгруппировать строки после вычисления "
"оконных функций, вы можете использовать вложенный запрос. Например: "
"<placeholder-1/> Данный запрос покажет только те строки внутреннего запроса, "
"у которых <literal>rank</literal> (порядковый номер) меньше 3."

#: advanced.xml:518(programlisting)
#, no-wrap
msgid ""
"SELECT sum(salary) OVER w, avg(salary) OVER w\n"
"  FROM empsalary\n"
"  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);"
msgstr ""
"SELECT sum(salary) OVER w, avg(salary) OVER w\n"
"  FROM empsalary\n"
"  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);"

#: advanced.xml:510(para)
msgid ""
"When a query involves multiple window functions, it is possible to write out "
"each one with a separate <literal>OVER</literal> clause, but this is "
"duplicative and error-prone if the same windowing behavior is wanted for "
"several functions. Instead, each windowing behavior can be named in a "
"<literal>WINDOW</literal> clause and then referenced in <literal>OVER</"
"literal>. For example: <placeholder-1/>"
msgstr ""
"Когда в запросе вычисляются несколько оконных функций для одинаково "
"определённых окон, конечно можно написать для каждой из них отдельное "
"предложение <literal>OVER</literal>, но при этом оно будет дублироваться, "
"что неизбежно будет провоцировать ошибки. Поэтому лучше определение окна "
"выделить в предложение <literal>WINDOW</literal>, а затем ссылаться на него "
"в <literal>OVER</literal>. Например: <placeholder-1/>"

#: advanced.xml:523(para)
msgid ""
"More details about window functions can be found in <xref linkend=\"syntax-"
"window-functions\"/>, <xref linkend=\"functions-window\"/>, <xref linkend="
"\"queries-window\"/>, and the <xref linkend=\"sql-select\"/> reference page."
msgstr ""
"Подробнее об оконных функциях можно узнать в <xref remap=\"6\" linkend="
"\"syntax-window-functions\"/>, <xref remap=\"6\" linkend=\"functions-window"
"\"/>, <xref remap=\"6\" linkend=\"queries-window\"/> и в справке <xref "
"linkend=\"sql-select\"/>."

#: advanced.xml:534(title)
msgid "Inheritance"
msgstr "Наследование"

#: advanced.xml:536(indexterm)
msgid "<primary>inheritance</primary>"
msgstr "<primary>наследование</primary>"

#: advanced.xml:540(para)
msgid ""
"Inheritance is a concept from object-oriented databases. It opens up "
"interesting new possibilities of database design."
msgstr ""
"Наследование &mdash; это концепция, взятая из объектно-ориентированных баз "
"данных. Она открывает множество интересных возможностей при проектировании "
"баз данных."

#: advanced.xml:552(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE capitals (\n"
"  name       text,\n"
"  population real,\n"
"  altitude   int,    -- (in ft)\n"
"  state      char(2)\n"
");\n"
"\n"
"CREATE TABLE non_capitals (\n"
"  name       text,\n"
"  population real,\n"
"  altitude   int     -- (in ft)\n"
");\n"
"\n"
"CREATE VIEW cities AS\n"
"  SELECT name, population, altitude FROM capitals\n"
"    UNION\n"
"  SELECT name, population, altitude FROM non_capitals;"
msgstr ""
"CREATE TABLE capitals (\n"
"  name       text,\n"
"  population real,\n"
"  altitude   int,    -- (высота в футах)\n"
"  state      char(2)\n"
");\n"
"\n"
"CREATE TABLE non_capitals (\n"
"  name       text,\n"
"  population real,\n"
"  altitude   int     -- (высота в футах)\n"
");\n"
"\n"
"CREATE VIEW cities AS\n"
"  SELECT name, population, altitude FROM capitals\n"
"    UNION\n"
"  SELECT name, population, altitude FROM non_capitals;"

#: advanced.xml:545(para)
msgid ""
"Let's create two tables: A table <classname>cities</classname> and a table "
"<classname>capitals</classname>. Naturally, capitals are also cities, so you "
"want some way to show the capitals implicitly when you list all cities. If "
"you're really clever you might invent some scheme like this: <placeholder-1/"
"> This works OK as far as querying goes, but it gets ugly when you need to "
"update several rows, for one thing."
msgstr ""
"Давайте создадим две таблицы: <classname>cities</classname> (города) и "
"<classname>capitals</classname> (столицы штатов). Естественно, столицы "
"штатов также являются городами, поэтому нам нужно явным образом добавлять их "
"в результат, когда мы хотим просмотреть все города. Если вы проявите "
"смекалку, вы можете предложить, например, такое решение: <placeholder-1/> "
"Оно может устраивать, пока мы извлекаем данные, но если нам потребуется "
"изменить несколько строк, это будет выглядеть некрасиво."

#: advanced.xml:577(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE cities (\n"
"  name       text,\n"
"  population real,\n"
"  altitude   int     -- (in ft)\n"
");\n"
"\n"
"CREATE TABLE capitals (\n"
"  state      char(2)\n"
") INHERITS (cities);"
msgstr ""
"CREATE TABLE cities (\n"
"  name       text,\n"
"  population real,\n"
"  altitude   int     -- (высота в футах)\n"
");\n"
"\n"
"CREATE TABLE capitals (\n"
"  state      char(2)\n"
") INHERITS (cities);"

#: advanced.xml:574(para)
msgid "A better solution is this: <placeholder-1/>"
msgstr "Поэтому есть лучшее решение: <placeholder-1/>"

#: advanced.xml:588(para)
msgid ""
"In this case, a row of <classname>capitals</classname>\n"
"    <firstterm>inherits</firstterm> all columns (<structfield>name</"
"structfield>, <structfield>population</structfield>, and "
"<structfield>altitude</structfield>) from its <firstterm>parent</firstterm>, "
"<classname>cities</classname>. The type of the column <structfield>name</"
"structfield> is <type>text</type>, a native <productname>PostgreSQL</"
"productname> type for variable length character strings. State capitals have "
"an extra column, <structfield>state</structfield>, that shows their state. "
"In <productname>PostgreSQL</productname>, a table can inherit from zero or "
"more other tables."
msgstr ""
"В данном случае строка таблицы <classname>capitals</classname> "
"<firstterm>наследует</firstterm> все столбцы (<structfield>name</"
"structfield>, <structfield>population</structfield> и <structfield>altitude</"
"structfield>) от <firstterm>родительской таблицы</firstterm> "
"<classname>cities</classname>. Столбец <structfield>name</structfield> имеет "
"тип <type>text</type>, собственный тип <productname>PostgreSQL</productname> "
"для текстовых строк переменной длины. А в таблицу столиц добавлен "
"дополнительный столбец <structfield>state</structfield>, в котором будет "
"указан штат. В <productname>PostgreSQL</productname> таблица может "
"наследоваться от нуля или нескольких других таблиц."

#: advanced.xml:606(programlisting)
#, no-wrap
msgid ""
"SELECT name, altitude\n"
"  FROM cities\n"
"  WHERE altitude &gt; 500;"
msgstr ""
"SELECT name, altitude\n"
"  FROM cities\n"
"  WHERE altitude &gt; 500;"

#: advanced.xml:601(para)
msgid ""
"For example, the following query finds the names of all cities, including "
"state capitals, that are located at an altitude over 500 feet: "
"<placeholder-1/> which returns: <screen>   name    | altitude\n"
"-----------+----------\n"
" Las Vegas |     2174\n"
" Mariposa  |     1953\n"
" Madison   |      845\n"
"(3 rows)</screen>"
msgstr ""
"Например, следующий запрос выведет названия всех городов, включая столицы, "
"находящихся выше 500 футов над уровнем моря: <placeholder-1/> Результат его "
"выполнения: <screen>   name    | altitude\n"
"-----------+----------\n"
" Las Vegas |     2174\n"
" Mariposa  |     1953\n"
" Madison   |      845\n"
"(3 rows)</screen>"

#: advanced.xml:625(programlisting)
#, no-wrap
msgid ""
"SELECT name, altitude\n"
"    FROM ONLY cities\n"
"    WHERE altitude &gt; 500;"
msgstr ""
"SELECT name, altitude\n"
"    FROM ONLY cities\n"
"    WHERE altitude &gt; 500;"

#: advanced.xml:620(para)
msgid ""
"On the other hand, the following query finds all the cities that are not "
"state capitals and are situated at an altitude over 500 feet: <placeholder-1/"
">\n"
"\n"
"<screen>   name    | altitude\n"
"-----------+----------\n"
" Las Vegas |     2174\n"
" Mariposa  |     1953\n"
"(2 rows)</screen>"
msgstr ""
"А следующий запрос находит все города, которые не являются столицами штатов, "
"но также находятся выше 500 футов: <placeholder-1/>\n"
"\n"
"<screen>   name    | altitude\n"
"-----------+----------\n"
" Las Vegas |     2174\n"
" Mariposa  |     1953\n"
"(2 rows)</screen>"

#: advanced.xml:636(para)
msgid ""
"Here the <literal>ONLY</literal> before <literal>cities</literal> indicates "
"that the query should be run over only the <classname>cities</classname> "
"table, and not tables below <classname>cities</classname> in the inheritance "
"hierarchy. Many of the commands that we have already discussed &mdash;\n"
"    <command>SELECT</command>, <command>UPDATE</command>, and "
"<command>DELETE</command> &mdash; support this <literal>ONLY</literal> "
"notation."
msgstr ""
"Здесь слово <literal>ONLY</literal> перед названием таблицы <literal>cities</"
"literal> указывает, что запрос следует выполнять только для строк таблицы "
"<classname>cities</classname>, не включая таблицы, унаследованные от "
"<classname>cities</classname>. Многие операторы, которые мы уже обсудили "
"&mdash; <command>SELECT</command>, <command>UPDATE</command> и "
"<command>DELETE</command> &mdash; поддерживают указание <literal>ONLY</"
"literal>."

#: advanced.xml:648(para)
msgid ""
"Although inheritance is frequently useful, it has not been integrated with "
"unique constraints or foreign keys, which limits its usefulness. See <xref "
"linkend=\"ddl-inherit\"/> for more detail."
msgstr ""
"Хотя наследование часто бывает полезно, оно не интегрировано с ограничениями "
"уникальности и внешними ключами, что ограничивает его применимость. "
"Подробнее это описывается в <xref remap=\"6\" linkend=\"ddl-inherit\"/>."

#: advanced.xml:658(title)
msgid "Conclusion"
msgstr "Заключение"

#: advanced.xml:660(para)
msgid ""
"<productname>PostgreSQL</productname> has many features not touched upon in "
"this tutorial introduction, which has been oriented toward newer users of "
"<acronym>SQL</acronym>. These features are discussed in more detail in the "
"remainder of this book."
msgstr ""
"<productname>PostgreSQL</productname> имеет множество возможностей, не "
"затронутых в этом кратком введении, рассчитанном на начинающих пользователей "
"<acronym>SQL</acronym>. Эти возможности будут рассмотрены в деталях в "
"продолжении книги."

#: advanced.xml:668(para)
msgid ""
"If you feel you need more introductory material, please visit the PostgreSQL "
"<ulink url=\"http://www.postgresql.org\">web site</ulink> for links to more "
"resources."
msgstr ""
"Если вам необходима дополнительная вводная информация, посетите <ulink url="
"\"http://www.postgresql.org\">сайт PostgreSQL</ulink>, там вы найдёте ссылки "
"на другие ресурсы."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: advanced.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
