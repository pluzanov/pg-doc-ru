# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-11 12:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: ref/create_policy.xml:8(indexterm)
msgid "<primary>CREATE POLICY</primary>"
msgstr "<primary>CREATE POLICY</primary>"

#: ref/create_policy.xml:13(refentrytitle)
msgctxt "refentrytitle"
msgid "CREATE POLICY"
msgstr "CREATE POLICY"

#: ref/create_policy.xml:14(manvolnum)
msgid "7"
msgstr "7"

#: ref/create_policy.xml:15(refmiscinfo)
msgid "SQL - Language Statements"
msgstr "Операторы языка SQL"

#: ref/create_policy.xml:19(refname)
msgctxt "refname"
msgid "CREATE POLICY"
msgstr "CREATE POLICY"

#: ref/create_policy.xml:20(refpurpose)
msgid "define a new row level security policy for a table"
msgstr "создать новую политику защиты на уровне строк для таблицы"

#: ref/create_policy.xml:24(replaceable) ref/create_policy.xml:102(replaceable)
msgid "name"
msgstr "имя"

#: ref/create_policy.xml:24(replaceable) ref/create_policy.xml:112(replaceable)
msgid "table_name"
msgstr "имя_таблицы"

#: ref/create_policy.xml:26(replaceable) ref/create_policy.xml:136(replaceable)
msgid "role_name"
msgstr "имя_роли"

#: ref/create_policy.xml:27(replaceable) ref/create_policy.xml:146(replaceable)
msgid "using_expression"
msgstr "выражение_USING"

#: ref/create_policy.xml:28(replaceable) ref/create_policy.xml:164(replaceable)
msgid "check_expression"
msgstr "выражение_CHECK"

#: ref/create_policy.xml:24(synopsis)
#, no-wrap
msgid ""
"CREATE POLICY <placeholder-1/> ON <placeholder-2/>\n"
"    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]\n"
"    [ TO { <placeholder-3/> | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]\n"
"    [ USING ( <placeholder-4/> ) ]\n"
"    [ WITH CHECK ( <placeholder-5/> ) ]"
msgstr ""
"CREATE POLICY <placeholder-1/> ON <placeholder-2/>\n"
"    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]\n"
"    [ TO { <placeholder-3/> | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]\n"
"    [ USING ( <placeholder-4/> ) ]\n"
"    [ WITH CHECK ( <placeholder-5/> ) ]"

#: ref/create_policy.xml:32(title)
msgid "Description"
msgstr "Описание"

#: ref/create_policy.xml:34(para)
msgid ""
"The <command>CREATE POLICY</command> command defines a new row-level "
"security policy for a table. Note that row-level security must be enabled on "
"the table (using <command>ALTER TABLE ... ENABLE ROW LEVEL SECURITY</"
"command>) in order for created policies to be applied."
msgstr ""
"Команда <command>CREATE POLICY</command> определяет для таблицы новую "
"политику защиты на уровне строк. Заметьте, что для таблицы должна быть "
"включена защита на уровне строк (using <command>ALTER TABLE ... ENABLE ROW "
"LEVEL SECURITY</command>), чтобы созданные политики действовали."

#: ref/create_policy.xml:41(para)
msgid ""
"A policy grants the permission to select, insert, update, or delete rows "
"that match the relevant policy expression. Existing table rows are checked "
"against the expression specified in <literal>USING</literal>, while new rows "
"that would be created via <literal>INSERT</literal> or <literal>UPDATE</"
"literal> are checked against the expression specified in <literal>WITH "
"CHECK</literal>. When a <literal>USING</literal> expression returns true for "
"a given row then that row is visible to the user, while if false or null is "
"returned then the row is not visible. When a <literal>WITH CHECK</literal> "
"expression returns true for a row then that row is inserted or updated, "
"while if false or null is returned then an error occurs."
msgstr ""
"Политика даёт разрешение на выборку, добавление, изменение или удаление "
"строк, удовлетворяющих соответствующему выражению политики. Существующие "
"строки таблицы проверяются по выражению, указанному в <literal>USING</"
"literal>, тогда как строки, которые могут быть созданы командами "
"<literal>INSERT</literal> или <literal>UPDATE</literal> проверяются по "
"выражению, указанному в <literal>WITH CHECK</literal>. Когда выражение "
"<literal>USING</literal> истинно для заданной строки, эта строка видна "
"пользователю, а если ложно или выдаёт NULL, строка не видна. Когда выражение "
"<literal>WITH CHECK</literal> истинно для заданной строки, эта строка "
"добавляется или изменяется, а если ложно или выдаёт NULL, происходит ошибка."

#: ref/create_policy.xml:55(para)
msgid ""
"For <command>INSERT</command> and <command>UPDATE</command> statements, "
"<literal>WITH CHECK</literal> expressions are enforced after "
"<literal>BEFORE</literal> triggers are fired, and before any actual data "
"modifications are made. Thus a <literal>BEFORE ROW</literal> trigger may "
"modify the data to be inserted, affecting the result of the security policy "
"check. <literal>WITH CHECK</literal> expressions are enforced before any "
"other constraints."
msgstr ""
"Для операторов <command>INSERT</command> и <command>UPDATE</command> "
"выражения <literal>WITH CHECK</literal> применяются после срабатывания "
"триггеров <literal>BEFORE</literal>, но до того, как будут собственно "
"модифицированы данные. Таким образом, триггер <literal>BEFORE ROW</literal> "
"может изменить данные, подлежащие добавлению, и повлиять на результат "
"условия политики защиты. Выражения <literal>WITH CHECK</literal> "
"обрабатываются до каких-либо других ограничений."

#: ref/create_policy.xml:65(para)
msgid ""
"Policy names are per-table. Therefore, one policy name can be used for many "
"different tables and have a definition for each table which is appropriate "
"to that table."
msgstr ""
"Имена политик задаются на уровне таблицы. Таким образом, одно имя политики "
"можно использовать в нескольких разных таблицах и в каждой дать отдельное, "
"подходящее этой таблице определение политики."

#: ref/create_policy.xml:71(para)
msgid ""
"Policies can be applied for specific commands or for specific roles. The "
"default for newly created policies is that they apply for all commands and "
"roles, unless otherwise specified. If multiple policies apply to a given "
"statement, they will be combined using OR (although <literal>ON CONFLICT DO "
"UPDATE</literal> and <literal>INSERT</literal> policies are not combined in "
"this way, but rather enforced as noted at each stage of <literal>ON "
"CONFLICT</literal> execution)."
msgstr ""
"Политики можно применять к определённым командам или избранным ролям. По "
"умолчанию создаваемые политики применяются ко всем командам и ролям, если "
"нет других указаний. Если к заданному оператору применяются несколько "
"политик, они будут объединены логическим сложением (хотя политики "
"<literal>ON CONFLICT DO UPDATE</literal> и <literal>INSERT</literal> таким "
"образом не складываются, а применяются как отмечено на каждой стадии "
"выполнения <literal>ON CONFLICT</literal>)."

#: ref/create_policy.xml:80(para)
msgid ""
"For commands that can have both <literal>USING</literal> and <literal>WITH "
"CHECK</literal> policies (<literal>ALL</literal> and <literal>UPDATE</"
"literal>), if no <literal>WITH CHECK</literal> policy is defined, then the "
"<literal>USING</literal> policy will be used both for which rows are visible "
"(normal <literal>USING</literal> case) and for which rows will be allowed to "
"be added (<literal>WITH CHECK</literal> case)."
msgstr ""
"Для команд, допускающих наличие политик <literal>USING</literal> и "
"<literal>WITH CHECK</literal> (<literal>ALL</literal> и <literal>UPDATE</"
"literal>), в отсутствие политики <literal>WITH CHECK</literal> политика "
"<literal>USING</literal> будет определять и видимость строк (обычное "
"предназначение <literal>USING</literal>), и разрешение на добавление строк "
"(предназначение <literal>WITH CHECK</literal>)."

#: ref/create_policy.xml:90(para)
msgid ""
"If row-level security is enabled for a table, but no applicable policies "
"exist, a <quote>default deny</quote> policy is assumed, so that no rows will "
"be visible or updatable."
msgstr ""
"Если для таблицы включена защита на уровне строк, но применимые политики "
"отсутствуют, предполагается политика <quote>запрета по умолчанию</quote>, "
"так что никакие строки нельзя будет увидеть или изменить."

#: ref/create_policy.xml:98(title)
msgid "Parameters"
msgstr "Параметры"

#: ref/create_policy.xml:104(para)
msgid ""
"The name of the policy to be created. This must be distinct from the name of "
"any other policy for the table."
msgstr ""
"Имя создаваемой политики. Оно должно отличаться от имён других политик для "
"этой таблицы."

#: ref/create_policy.xml:114(para)
msgid ""
"The name (optionally schema-qualified) of the table the policy applies to."
msgstr ""
"Имя (возможно, дополненное схемой) существующей таблицы (или представления), "
"к которой применяется эта политика."

#: ref/create_policy.xml:122(replaceable)
msgid "command"
msgstr "команда"

#: ref/create_policy.xml:124(para)
msgid ""
"The command to which the policy applies. Valid options are <command>ALL</"
"command>, <command>SELECT</command>, <command>INSERT</command>, "
"<command>UPDATE</command>, and <command>DELETE</command>. <command>ALL</"
"command> is the default. See below for specifics regarding how these are "
"applied."
msgstr ""
"Команда, к которой применяется политика. Допустимые варианты: <command>ALL</"
"command>, <command>SELECT</command>, <command>INSERT</command>, "
"<command>UPDATE</command> и <command>DELETE</command>. <command>ALL</"
"command> (все) подразумевается по умолчанию. Особенности их применения "
"описаны ниже."

#: ref/create_policy.xml:138(para)
msgid ""
"The role(s) to which the policy is to be applied. The default is "
"<literal>PUBLIC</literal>, which will apply the policy to all roles."
msgstr ""
"Роль (роли), к которой применяется политика. По умолчанию подразумевается "
"<literal>PUBLIC</literal>, то есть политика применяется ко всем ролям."

#: ref/create_policy.xml:148(para)
msgid ""
"Any <acronym>SQL</acronym> conditional expression (returning <type>boolean</"
"type>). The conditional expression cannot contain any aggregate or window "
"functions. This expression will be added to queries that refer to the table "
"if row level security is enabled. Rows for which the expression returns true "
"will be visible. Any rows for which the expression returns false or null "
"will not be visible to the user (in a <command>SELECT</command>), and will "
"not be available for modification (in an <command>UPDATE</command> or "
"<command>DELETE</command>). Such rows are silently suppressed; no error is "
"reported."
msgstr ""
"Произвольное условное выражение <acronym>SQL</acronym> (возвращающее "
"<type>boolean</type>). Это условное выражение не может содержать агрегатные "
"или оконные функции. Когда включена защита на уровне строк, оно добавляется "
"в запросы, обращающиеся к данной таблице, и в их результатах оказываются "
"видимыми только те строки, для которых оно выдаёт true. Все строки, для "
"которых это выражение возвращает false или NULL, не будут видны пользователю "
"(в запросе <command>SELECT</command>), и не будут доступны для модификации "
"(запросами <command>UPDATE</command> или <command>DELETE</command>). Такая "
"строка просто пропускается, ошибка при этом не выдаётся."

#: ref/create_policy.xml:166(para)
msgid ""
"Any <acronym>SQL</acronym> conditional expression (returning <type>boolean</"
"type>). The conditional expression cannot contain any aggregate or window "
"functions. This expression will be used in <command>INSERT</command> and "
"<command>UPDATE</command> queries against the table if row level security is "
"enabled. Only rows for which the expression evaluates to true will be "
"allowed. An error will be thrown if the expression evaluates to false or "
"null for any of the records inserted or any of the records that result from "
"the update. Note that the <replaceable class=\"parameter\">check_expression</"
"replaceable> is evaluated against the proposed new contents of the row, not "
"the original contents."
msgstr ""
"Произвольное условное выражение <acronym>SQL</acronym> (возвращающее "
"<type>boolean</type>). Это условное выражение не может содержать агрегатные "
"или оконные функции. Когда включена защита на уровне строк, оно применяется "
"в запросах <command>INSERT</command> и <command>UPDATE</command> к этой "
"таблице, так что в них принимаются только те строки, для которых оно выдаёт "
"true. Если это выражение выдаёт false или NULL для любой из добавляемых "
"записей или записей, получаемых при изменении, выдаётся ошибка. Заметьте, "
"что <replaceable class=\"parameter\">ограничение_проверки</replaceable> "
"вычисляется для предлагаемого нового содержимого строки, а не для "
"существующих данных."

#: ref/create_policy.xml:185(title)
msgid "Per-Command Policies"
msgstr "Политики по командам"

#: ref/create_policy.xml:190(literal)
msgid "ALL"
msgstr "ALL"

#: ref/create_policy.xml:192(para)
msgid ""
"Using <literal>ALL</literal> for a policy means that it will apply to all "
"commands, regardless of the type of command. If an <literal>ALL</literal> "
"policy exists and more specific policies exist, then both the <literal>ALL</"
"literal> policy and the more specific policy (or policies) will be combined "
"using OR, as usual for overlapping policies. Additionally, <literal>ALL</"
"literal> policies will be applied to both the selection side of a query and "
"the modification side, using the <literal>USING</literal> expression for "
"both cases if only a <literal>USING</literal> expression has been defined."
msgstr ""
"Указание <literal>ALL</literal> для политики означает, что она применяется "
"ко всем командам, вне зависимости от типа. Если существует политика "
"<literal>ALL</literal> и другие более детализированные политики, тогда и "
"политика <literal>ALL</literal>, и более детализированная политика (или "
"политики) объединяются логическим сложением, как обычно при наложении "
"политик. Кроме того, политики <literal>ALL</literal> с выражением "
"<literal>USING</literal> будут применяться и к стороне выборки, и к стороне "
"изменения данных в запросе, если определено только выражение <literal>USING</"
"literal>."

#: ref/create_policy.xml:204(para)
msgid ""
"As an example, if an <literal>UPDATE</literal> is issued, then the "
"<literal>ALL</literal> policy will be applicable both to what the "
"<literal>UPDATE</literal> will be able to select as rows to be updated "
"(applying the <literal>USING</literal> expression), and to the resulting "
"updated rows, to check if they are permitted to be added to the table "
"(applying the <literal>WITH CHECK</literal> expression, if defined, and the "
"<literal>USING</literal> expression otherwise). If an <command>INSERT</"
"command> or <command>UPDATE</command> command attempts to add rows to the "
"table that do not pass the <literal>ALL</literal> policy's <literal>WITH "
"CHECK</literal> expression, the entire command will be aborted."
msgstr ""
"Например, когда выполняется <literal>UPDATE</literal>, политика "
"<literal>ALL</literal> будет фильтровать и строки, которые сможет прочитать "
"<literal>UPDATE</literal> для изменения (применяя выражение <literal>USING</"
"literal>), и окончательные изменённые строки, проверяя, можно ли записать их "
"в таблицу (применяя выражение <literal>WITH CHECK</literal>, если оно "
"определено, или <literal>USING</literal> в противном случае). Если команда "
"<command>INSERT</command> или <command>UPDATE</command> пытается добавить в "
"таблицу строки, не удовлетворяющие выражению <literal>WITH CHECK</literal> "
"политики <literal>ALL</literal>, вся команда будет прервана."

#: ref/create_policy.xml:222(literal)
msgid "SELECT"
msgstr "SELECT"

#: ref/create_policy.xml:224(para)
msgid ""
"Using <literal>SELECT</literal> for a policy means that it will apply to "
"<literal>SELECT</literal> queries and whenever <literal>SELECT</literal> "
"permissions are required on the relation the policy is defined for. The "
"result is that only those records from the relation that pass the "
"<literal>SELECT</literal> policy will be returned during a <literal>SELECT</"
"literal> query, and that queries that require <literal>SELECT</literal> "
"permissions, such as <literal>UPDATE</literal>, will also only see those "
"records that are allowed by the <literal>SELECT</literal> policy. A "
"<literal>SELECT</literal> policy cannot have a <literal>WITH CHECK</literal> "
"expression, as it only applies in cases where records are being retrieved "
"from the relation."
msgstr ""
"Указание <literal>SELECT</literal> для политики означает, что она "
"применяется к запросам <literal>SELECT</literal> и тогда, когда при "
"обращении к отношению, для которого определена политика, задействуется право "
"<literal>SELECT</literal>. В результате запрос <literal>SELECT</literal> "
"выдаст только те записи из отношения, которые удовлетворят политике "
"<literal>SELECT</literal>, и запрос, использующий право <literal>SELECT</"
"literal>, например, запрос <literal>UPDATE</literal>, увидит только записи, "
"разрешённые политикой <literal>SELECT</literal>. Для политики "
"<literal>SELECT</literal> не может задаваться выражение <literal>WITH CHECK</"
"literal>, так как оно действует только когда записи читаются из отношения."

#: ref/create_policy.xml:242(literal)
msgid "INSERT"
msgstr "INSERT"

#: ref/create_policy.xml:244(para)
msgid ""
"Using <literal>INSERT</literal> for a policy means that it will apply to "
"<literal>INSERT</literal> commands. Rows being inserted that do not pass "
"this policy will result in a policy violation error, and the entire "
"<literal>INSERT</literal> command will be aborted. An <literal>INSERT</"
"literal> policy cannot have a <literal>USING</literal> expression, as it "
"only applies in cases where records are being added to the relation."
msgstr ""
"Указание <literal>INSERT</literal> для политики означает, что она "
"применяется к командам <literal>INSERT</literal>. Если вставляемые строки не "
"проходят проверку политики, выдаётся ошибка нарушения политики и вся команда "
"<literal>INSERT</literal> прерывается. Для политики <literal>INSERT</"
"literal> не может задаваться выражение <literal>USING</literal>, так как она "
"действует только когда в отношение добавляются записи."

#: ref/create_policy.xml:253(para)
msgid ""
"Note that <literal>INSERT</literal> with <literal>ON CONFLICT DO UPDATE</"
"literal> checks <literal>INSERT</literal> policies' <literal>WITH CHECK</"
"literal> expressions only for rows appended to the relation by the "
"<literal>INSERT</literal> path."
msgstr ""
"Заметьте, что <literal>INSERT</literal> с указанием <literal>ON CONFLICT DO "
"UPDATE</literal> проверяет выражения <literal>WITH CHECK</literal> политик "
"<literal>INSERT</literal> только для строк, добавляемых в отношение по пути "
"<literal>INSERT</literal>."

#: ref/create_policy.xml:263(literal)
msgid "UPDATE"
msgstr "UPDATE"

#: ref/create_policy.xml:265(para)
msgid ""
"Using <literal>UPDATE</literal> for a policy means that it will apply to "
"<literal>UPDATE</literal> commands (or auxiliary <literal>ON CONFLICT DO "
"UPDATE</literal> clauses of <literal>INSERT</literal> commands). Since "
"<literal>UPDATE</literal> involves pulling an existing record and then "
"making changes to some portion (but possibly not all) of the record, "
"<literal>UPDATE</literal> policies accept both a <literal>USING</literal> "
"expression and a <literal>WITH CHECK</literal> expression. The "
"<literal>USING</literal> expression determines which records the "
"<literal>UPDATE</literal> command will see to operate against, while the "
"<literal>WITH CHECK</literal> expression defines which modified rows are "
"allowed to be stored back into the relation."
msgstr ""
"Указание <literal>UPDATE</literal> для политики означает, что она "
"применяется к командам <literal>UPDATE</literal> (или дополнительным "
"предложениям <literal>ON CONFLICT DO UPDATE</literal> команд "
"<literal>INSERT</literal>). Так как действие <literal>UPDATE</literal> "
"подразумевает извлечение существующей записи и последующее изменение в ней "
"полей (возможно, не всех), политики <literal>UPDATE</literal> принимают и "
"выражение <literal>USING</literal>, и выражение <literal>WITH CHECK</"
"literal>. Выражение <literal>USING</literal> определяет, какие строки будет "
"обрабатывать команда <literal>UPDATE</literal>, тогда как выражение "
"<literal>WITH CHECK</literal> определяет, какие изменённые строки можно "
"снова записать в отношение."

#: ref/create_policy.xml:280(para)
msgid ""
"When an <literal>UPDATE</literal> command is used with a <literal>WHERE</"
"literal> clause or a <literal>RETURNING</literal> clause, <literal>SELECT</"
"literal> rights are also required on the relation being updated and the "
"appropriate <literal>SELECT</literal> and <literal>ALL</literal> policies "
"will be combined (using OR for any overlapping <literal>SELECT</literal> "
"related policies found) with the <literal>USING</literal> clause of the "
"<literal>UPDATE</literal> policy using AND. Therefore, in order for a user "
"to be able to <literal>UPDATE</literal> specific rows, the user must have "
"access to the row(s) through a <literal>SELECT</literal> or <literal>ALL</"
"literal> policy and the row(s) must pass the <literal>UPDATE</literal> "
"policy's <literal>USING</literal> expression."
msgstr ""
"Когда выполняется команда <literal>UPDATE</literal> с предложением "
"<literal>WHERE</literal> или <literal>RETURNING</literal>, для обращения к "
"целевому отношению также требуются права <literal>SELECT</literal>, так что "
"соответствующие политики <literal>SELECT</literal> и <literal>ALL</literal> "
"будут объединены (логическим сложением всех найденных связанных политик "
"<literal>SELECT</literal>), а затем совмещены (логическим умножением) с "
"предложением <literal>USING</literal> политики <literal>UPDATE</literal>. "
"Таким образом, чтобы пользователь мог изменять определённые строки (выполняя "
"<literal>UPDATE</literal>), ему должен быть разрешён доступ к ним политикой "
"<literal>SELECT</literal> или <literal>ALL</literal> и эти строки должны "
"удовлетворять выражению <literal>USING</literal> политики <literal>UPDATE</"
"literal>."

#: ref/create_policy.xml:296(para)
msgid ""
"Any rows whose updated values do not pass the <literal>WITH CHECK</literal> "
"expression will cause an error, and the entire command will be aborted. If "
"only a <literal>USING</literal> clause is specified, then that clause will "
"be used for both <literal>USING</literal> and <literal>WITH CHECK</literal> "
"cases."
msgstr ""
"Если в какой-либо строке изменённые значения не будут удовлетворять "
"выражению <literal>WITH CHECK</literal>, произойдёт ошибка и вся команда "
"будет прервана. Если указывается только предложение <literal>USING</"
"literal>, его выражение будет применяться и в качестве <literal>USING</"
"literal>, и в качестве выражения <literal>WITH CHECK</literal>."

#: ref/create_policy.xml:304(para)
msgid ""
"Note, however, that <literal>INSERT</literal> with <literal>ON CONFLICT DO "
"UPDATE</literal> requires that an <literal>UPDATE</literal> policy "
"<literal>USING</literal> expression always be enforced as a <literal>WITH "
"CHECK</literal> expression. This <literal>UPDATE</literal> policy must "
"always pass when the <literal>UPDATE</literal> path is taken. Any existing "
"row that necessitates that the <literal>UPDATE</literal> path be taken must "
"pass the (<literal>UPDATE</literal> or <literal>ALL</literal>) "
"<literal>USING</literal> qualifications (combined using OR), which are "
"always enforced as <literal>WITH CHECK</literal> options in this context. "
"(The <literal>UPDATE</literal> path will <emphasis>never</emphasis> be "
"silently avoided; an error will be thrown instead.) Finally, the final row "
"appended to the relation must pass any <literal>WITH CHECK</literal> options "
"that a conventional <literal>UPDATE</literal> is required to pass."
msgstr ""
"Заметьте однако, что <literal>INSERT</literal> с <literal>ON CONFLICT DO "
"UPDATE</literal> требует, чтобы выражение <literal>USING</literal> политики "
"<literal>UPDATE</literal> всегда действовало как выражение <literal>WITH "
"CHECK</literal>. Эта политика <literal>UPDATE</literal> должна всегда "
"выполняться, когда выбирается путь <literal>UPDATE</literal>. Любая "
"существующая строка, из-за которой выбирается путь <literal>UPDATE</"
"literal>, должна удовлетворять проверкам (политик <literal>UPDATE</literal> "
"или <literal>ALL</literal>) <literal>USING</literal> (объединённым "
"логическим сложением), которые всегда действуют как <literal>WITH CHECK</"
"literal> в данном контексте. (Путь <literal>UPDATE</literal> "
"<emphasis>никогда</emphasis> не игнорируется, так что в случае невыполнения "
"условия выдаётся ошибка.) Наконец, окончательная строка, добавляемая в "
"отношение, должна проходить все проверки <literal>WITH CHECK</literal>, "
"которые должны быть пройдены и при обычном <literal>UPDATE</literal>."

#: ref/create_policy.xml:325(literal)
msgid "DELETE"
msgstr "DELETE"

#: ref/create_policy.xml:327(para)
msgid ""
"Using <literal>DELETE</literal> for a policy means that it will apply to "
"<literal>DELETE</literal> commands. Only rows that pass this policy will be "
"seen by a <literal>DELETE</literal> command. There can be rows that are "
"visible through a <literal>SELECT</literal> that are not available for "
"deletion, if they do not pass the <literal>USING</literal> expression for "
"the <literal>DELETE</literal> policy."
msgstr ""
"Указание <literal>DELETE</literal> для политики означает, что она "
"применяется к командам <literal>DELETE</literal>. Команда <literal>DELETE</"
"literal> будет видеть только те строки, которые позволит эта политика. При "
"этом строки могут быть видны через <literal>SELECT</literal>, но удалить их "
"будет нельзя, если они не удовлетворяют выражению <literal>USING</literal> "
"политики <literal>DELETE</literal>."

#: ref/create_policy.xml:337(para)
msgid ""
"When a <literal>DELETE</literal> command is used with a <literal>WHERE</"
"literal> clause or a <literal>RETURNING</literal> clause, <literal>SELECT</"
"literal> rights are also required on the relation being updated and the "
"appropriate <literal>SELECT</literal> and <literal>ALL</literal> policies "
"will be combined (using OR for any overlapping <literal>SELECT</literal> "
"related policies found) with the <literal>USING</literal> clause of the "
"<literal>DELETE</literal> policy using AND. Therefore, in order for a user "
"to be able to <literal>DELETE</literal> specific rows, the user must have "
"access to the row(s) through a <literal>SELECT</literal> or <literal>ALL</"
"literal> policy and the row(s) must pass the <literal>DELETE</literal> "
"policy's <literal>USING</literal> expression."
msgstr ""
"Когда выполняется команда <literal>DELETE</literal> с предложением "
"<literal>WHERE</literal> или <literal>RETURNING</literal>, для обращения к "
"целевому отношению также требуются права <literal>SELECT</literal>, так что "
"соответствующие политики <literal>SELECT</literal> и <literal>ALL</literal> "
"будут объединены (логическим сложением всех найденных связанных политик "
"<literal>SELECT</literal>), а затем совмещены (логическим умножением) с "
"предложением <literal>USING</literal> политики <literal>DELETE</literal>. "
"Таким образом, чтобы пользователь мог удалить определённые строки (выполняя "
"<literal>DELETE</literal>), ему должен быть разрешён доступ к ним политикой "
"<literal>SELECT</literal> или <literal>ALL</literal> и эти строки должны "
"удовлетворять выражению <literal>USING</literal> политики <literal>DELETE</"
"literal>."

#: ref/create_policy.xml:353(para)
msgid ""
"A <literal>DELETE</literal> policy cannot have a <literal>WITH CHECK</"
"literal> expression, as it only applies in cases where records are being "
"deleted from the relation, so that there is no new row to check."
msgstr ""
"Для политики <literal>DELETE</literal> не может задаваться выражение "
"<literal>WITH CHECK</literal>, так как она применяется только тогда, когда "
"записи удаляются из отношения, а в этом случае новые строки, подлежащие "
"проверке, отсутствуют."

#: ref/create_policy.xml:367(title)
msgid "Notes"
msgstr "Замечания"

#: ref/create_policy.xml:369(para)
msgid "You must be the owner of a table to create or change policies for it."
msgstr ""
"Чтобы создать или изменить политики для таблицы, нужно быть её владельцем."

#: ref/create_policy.xml:373(para)
msgid ""
"While policies will be applied for explicit queries against tables in the "
"database, they are not applied when the system is performing internal "
"referential integrity checks or validating constraints. This means there are "
"indirect ways to determine that a given value exists. An example of this is "
"attempting to insert a duplicate value into a column that is a primary key "
"or has a unique constraint. If the insert fails then the user can infer that "
"the value already exists. (This example assumes that the user is permitted "
"by policy to insert records which they are not allowed to see.) Another "
"example is where a user is allowed to insert into a table which references "
"another, otherwise hidden table. Existence can be determined by the user "
"inserting values into the referencing table, where success would indicate "
"that the value exists in the referenced table. These issues can be addressed "
"by carefully crafting policies to prevent users from being able to insert, "
"delete, or update records at all which might possibly indicate a value they "
"are not otherwise able to see, or by using generated values (e.g., surrogate "
"keys) instead of keys with external meanings."
msgstr ""
"Хотя политики применяются к явно выполняемым запросам к таблицам БД, они не "
"применяются, когда система выполняет внутренние проверки ссылочной "
"целостности или проверяет ограничения. Это означает, что существуют "
"косвенные пути проверить существование заданного значения. Например, можно "
"попытаться вставить повторяющееся значение в столбец, образующий первичный "
"ключ или имеющую ограничение уникальности. Если при этом произойдёт ошибка, "
"пользователь может заключить, что это значение уже существует. (В данном "
"случае предполагается, что политика разрешает пользователю вставлять записи, "
"которые он может не видеть.) Подобный приём также возможен, если "
"пользователь может вставлять записи в таблицу, которая ссылается на другую, "
"иным образом не видимую. Существование значения можно определить, вставив "
"его в подчинённую таблицу, при этом успешный результат операции будет "
"признаком того, что это значение есть в главной таблице. Эти изъяны можно "
"устранить, либо тщательно разработав политики, которые вовсе не позволят "
"пользователям выполнять операции добавления, изменения и удаления, по "
"результатам которых можно узнать о значениях в таблицах, не видимых иным "
"образом, либо используя генерируемые значения (например, суррогатные ключи)."

#: ref/create_policy.xml:392(para)
msgid ""
"Generally, the system will enforce filter conditions imposed using security "
"policies prior to qualifications that appear in user queries, in order to "
"prevent inadvertent exposure of the protected data to user-defined functions "
"which might not be trustworthy. However, functions and operators marked by "
"the system (or the system administrator) as <literal>LEAKPROOF</literal> may "
"be evaluated before policy expressions, as they are assumed to be "
"trustworthy."
msgstr ""
"Вообще система будет применять фильтры, устанавливаемые политиками "
"безопасности, до условий в запросах пользователя, чтобы предотвратить "
"нежелательную утечку защищаемых данных через пользовательские функции, "
"которые могут быть недоверенными. Однако функции и операторы, помеченные "
"системой (или системным администратором) как <literal>LEAKPROOF</literal> "
"(герметичные) могут вычисляться до условий политики, так как они считаются "
"доверенными."

#: ref/create_policy.xml:402(para)
msgid ""
"Since policy expressions are added to the user's query directly, they will "
"be run with the rights of the user running the overall query. Therefore, "
"users who are using a given policy must be able to access any tables or "
"functions referenced in the expression or they will simply receive a "
"permission denied error when attempting to query the table that has row-"
"level security enabled. This does not change how views work, however. As "
"with normal queries and views, permission checks and policies for the tables "
"which are referenced by a view will use the view owner's rights and any "
"policies which apply to the view owner."
msgstr ""
"Так как выражения политики добавляются непосредственно в запрос "
"пользователя, они выполняются с правами пользователя, запускающего исходный "
"запрос. Таким образом, пользователи, на которых распространяется заданная "
"политика, должны иметь права для обращения ко всем таблицам и функциям, "
"задействованным в выражении, иначе им просто будет отказано в доступе при "
"попытке обращения к целевой таблице (если для неё включена защита на уровне "
"строк). Однако это не влияет на работу представлений — как и с обычными "
"запросами и представлениями, проверки разрешений и политики для нижележащих "
"таблиц представления будут выполняться с правами владельца представления, и "
"при этом будут действовать политики, распространяющиеся на этого владельца."

#: ref/create_policy.xml:415(para)
msgid ""
"Additional discussion and practical examples can be found in <xref linkend="
"\"ddl-rowsecurity\"/>."
msgstr ""
"Дополнительное описание и практические примеры можно найти в <xref remap="
"\"6\" linkend=\"ddl-rowsecurity\"/>."

#: ref/create_policy.xml:423(title)
msgid "Compatibility"
msgstr "Совместимость"

#: ref/create_policy.xml:425(para)
msgid ""
"<command>CREATE POLICY</command> is a <productname>PostgreSQL</productname> "
"extension."
msgstr ""
"<command>CREATE POLICY</command> является расширением "
"<productname>PostgreSQL</productname>."

#: ref/create_policy.xml:432(title)
msgid "See Also"
msgstr "См. также"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: ref/create_policy.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
