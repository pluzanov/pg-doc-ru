# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-11 12:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: ref/create_type.xml:8(indexterm)
msgid "<primary>CREATE TYPE</primary>"
msgstr "<primary>CREATE TYPE</primary>"

#: ref/create_type.xml:13(refentrytitle)
msgctxt "refentrytitle"
msgid "CREATE TYPE"
msgstr "CREATE TYPE"

#: ref/create_type.xml:14(manvolnum)
msgid "7"
msgstr "7"

#: ref/create_type.xml:15(refmiscinfo)
msgid "SQL - Language Statements"
msgstr "Операторы языка SQL"

#: ref/create_type.xml:19(refname)
msgctxt "refname"
msgid "CREATE TYPE"
msgstr "CREATE TYPE"

#: ref/create_type.xml:20(refpurpose)
msgid "define a new data type"
msgstr "создать новый тип данных"

#: ref/create_type.xml:25(replaceable) ref/create_type.xml:28(replaceable)
#: ref/create_type.xml:31(replaceable) ref/create_type.xml:39(replaceable)
#: ref/create_type.xml:60(replaceable) ref/create_type.xml:501(replaceable)
msgid "name"
msgstr "имя"

#: ref/create_type.xml:26(replaceable) ref/create_type.xml:510(replaceable)
msgid "attribute_name"
msgstr "имя_атрибута"

#: ref/create_type.xml:26(replaceable) ref/create_type.xml:519(replaceable)
msgid "data_type"
msgstr "тип_данных"

#: ref/create_type.xml:26(replaceable) ref/create_type.xml:34(replaceable)
#: ref/create_type.xml:529(replaceable)
msgid "collation"
msgstr "правило_сортировки"

#: ref/create_type.xml:29(replaceable) ref/create_type.xml:539(replaceable)
msgid "label"
msgstr "метка"

#: ref/create_type.xml:32(replaceable) ref/create_type.xml:549(replaceable)
msgid "subtype"
msgstr "подтип"

#: ref/create_type.xml:33(replaceable) ref/create_type.xml:559(replaceable)
msgid "subtype_operator_class"
msgstr "класс_оператора_подтипа"

#: ref/create_type.xml:35(replaceable) ref/create_type.xml:568(replaceable)
msgid "canonical_function"
msgstr "каноническая_функция"

#: ref/create_type.xml:36(replaceable) ref/create_type.xml:577(replaceable)
msgid "subtype_diff_function"
msgstr "функция_разницы_подтипа"

#: ref/create_type.xml:40(replaceable) ref/create_type.xml:586(replaceable)
msgid "input_function"
msgstr "функция_ввода"

#: ref/create_type.xml:41(replaceable) ref/create_type.xml:596(replaceable)
msgid "output_function"
msgstr "функция_вывода"

#: ref/create_type.xml:42(replaceable) ref/create_type.xml:606(replaceable)
msgid "receive_function"
msgstr "функция_получения"

#: ref/create_type.xml:43(replaceable) ref/create_type.xml:616(replaceable)
msgid "send_function"
msgstr "функция_отправки"

#: ref/create_type.xml:44(replaceable) ref/create_type.xml:626(replaceable)
msgid "type_modifier_input_function"
msgstr "функция_ввода_модификатора_типа"

#: ref/create_type.xml:45(replaceable) ref/create_type.xml:636(replaceable)
msgid "type_modifier_output_function"
msgstr "функция_вывода_модификатора_типа"

#: ref/create_type.xml:46(replaceable) ref/create_type.xml:646(replaceable)
msgid "analyze_function"
msgstr "функция_анализа"

#: ref/create_type.xml:47(replaceable) ref/create_type.xml:656(replaceable)
msgid "internallength"
msgstr "внутр_длина"

#: ref/create_type.xml:49(replaceable) ref/create_type.xml:667(replaceable)
msgid "alignment"
msgstr "выравнивание"

#: ref/create_type.xml:50(replaceable) ref/create_type.xml:679(replaceable)
msgid "storage"
msgstr "хранение"

#: ref/create_type.xml:51(replaceable) ref/create_type.xml:691(replaceable)
msgid "like_type"
msgstr "тип_образец"

#: ref/create_type.xml:52(replaceable) ref/create_type.xml:707(replaceable)
msgid "category"
msgstr "категория"

#: ref/create_type.xml:53(replaceable) ref/create_type.xml:720(replaceable)
msgid "preferred"
msgstr "предпочитаемый"

#: ref/create_type.xml:54(replaceable) ref/create_type.xml:732(replaceable)
msgid "default"
msgstr "по_умолчанию"

#: ref/create_type.xml:55(replaceable) ref/create_type.xml:742(replaceable)
msgid "element"
msgstr "элемент"

#: ref/create_type.xml:56(replaceable) ref/create_type.xml:752(replaceable)
msgid "delimiter"
msgstr "разделитель"

#: ref/create_type.xml:57(replaceable) ref/create_type.xml:762(replaceable)
msgid "collatable"
msgstr "сортируемый"

#: ref/create_type.xml:24(synopsis)
#, no-wrap
msgid ""
"CREATE TYPE <placeholder-1/> AS\n"
"    ( [ <placeholder-2/> <placeholder-3/> [ COLLATE <placeholder-4/> ] [, ... ] ] )\n"
"\n"
"CREATE TYPE <placeholder-5/> AS ENUM\n"
"    ( [ '<placeholder-6/>' [, ... ] ] )\n"
"\n"
"CREATE TYPE <placeholder-7/> AS RANGE (\n"
"    SUBTYPE = <placeholder-8/>\n"
"    [ , SUBTYPE_OPCLASS = <placeholder-9/> ]\n"
"    [ , COLLATION = <placeholder-10/> ]\n"
"    [ , CANONICAL = <placeholder-11/> ]\n"
"    [ , SUBTYPE_DIFF = <placeholder-12/> ]\n"
")\n"
"\n"
"CREATE TYPE <placeholder-13/> (\n"
"    INPUT = <placeholder-14/>,\n"
"    OUTPUT = <placeholder-15/>\n"
"    [ , RECEIVE = <placeholder-16/> ]\n"
"    [ , SEND = <placeholder-17/> ]\n"
"    [ , TYPMOD_IN = <placeholder-18/> ]\n"
"    [ , TYPMOD_OUT = <placeholder-19/> ]\n"
"    [ , ANALYZE = <placeholder-20/> ]\n"
"    [ , INTERNALLENGTH = { <placeholder-21/> | VARIABLE } ]\n"
"    [ , PASSEDBYVALUE ]\n"
"    [ , ALIGNMENT = <placeholder-22/> ]\n"
"    [ , STORAGE = <placeholder-23/> ]\n"
"    [ , LIKE = <placeholder-24/> ]\n"
"    [ , CATEGORY = <placeholder-25/> ]\n"
"    [ , PREFERRED = <placeholder-26/> ]\n"
"    [ , DEFAULT = <placeholder-27/> ]\n"
"    [ , ELEMENT = <placeholder-28/> ]\n"
"    [ , DELIMITER = <placeholder-29/> ]\n"
"    [ , COLLATABLE = <placeholder-30/> ]\n"
")\n"
"\n"
"CREATE TYPE <placeholder-31/>"
msgstr ""
"CREATE TYPE <placeholder-1/> AS\n"
"    ( [ <placeholder-2/> <placeholder-3/> [ COLLATE <placeholder-4/> ] [, ... ] ] )\n"
"\n"
"CREATE TYPE <placeholder-5/> AS ENUM\n"
"    ( [ '<placeholder-6/>' [, ... ] ] )\n"
"\n"
"CREATE TYPE <placeholder-7/> AS RANGE (\n"
"    SUBTYPE = <placeholder-8/>\n"
"    [ , SUBTYPE_OPCLASS = <placeholder-9/> ]\n"
"    [ , COLLATION = <placeholder-10/> ]\n"
"    [ , CANONICAL = <placeholder-11/> ]\n"
"    [ , SUBTYPE_DIFF = <placeholder-12/> ]\n"
")\n"
"\n"
"CREATE TYPE <placeholder-13/> (\n"
"    INPUT = <placeholder-14/>,\n"
"    OUTPUT = <placeholder-15/>\n"
"    [ , RECEIVE = <placeholder-16/> ]\n"
"    [ , SEND = <placeholder-17/> ]\n"
"    [ , TYPMOD_IN = <placeholder-18/> ]\n"
"    [ , TYPMOD_OUT = <placeholder-19/> ]\n"
"    [ , ANALYZE = <placeholder-20/> ]\n"
"    [ , INTERNALLENGTH = { <placeholder-21/> | VARIABLE } ]\n"
"    [ , PASSEDBYVALUE ]\n"
"    [ , ALIGNMENT = <placeholder-22/> ]\n"
"    [ , STORAGE = <placeholder-23/> ]\n"
"    [ , LIKE = <placeholder-24/> ]\n"
"    [ , CATEGORY = <placeholder-25/> ]\n"
"    [ , PREFERRED = <placeholder-26/> ]\n"
"    [ , DEFAULT = <placeholder-27/> ]\n"
"    [ , ELEMENT = <placeholder-28/> ]\n"
"    [ , DELIMITER = <placeholder-29/> ]\n"
"    [ , COLLATABLE = <placeholder-30/> ]\n"
")\n"
"\n"
"CREATE TYPE <placeholder-31/>"

#: ref/create_type.xml:65(title)
msgid "Description"
msgstr "Описание"

#: ref/create_type.xml:67(para)
msgid ""
"<command>CREATE TYPE</command> registers a new data type for use in the "
"current database. The user who defines a type becomes its owner."
msgstr ""
"<command>CREATE TYPE</command> регистрирует новый тип данных для "
"использования в текущей базе данных. Владельцем типа становится создавший "
"его пользователь."

#: ref/create_type.xml:73(para)
msgid ""
"If a schema name is given then the type is created in the specified schema. "
"Otherwise it is created in the current schema. The type name must be "
"distinct from the name of any existing type or domain in the same schema. "
"(Because tables have associated data types, the type name must also be "
"distinct from the name of any existing table in the same schema.)"
msgstr ""
"Если указано имя схемы, тип создаётся в указанной схеме. В противном случае, "
"он создаётся в текущей схеме. Имя типа должно отличаться от имён любых "
"других существующих типов или доменов в той же схеме. (А так как с таблицами "
"связываются типы данных, имя типа должно также отличаться и от имён "
"существующих таблиц в этой схеме.)"

#: ref/create_type.xml:82(para)
msgid ""
"There are five forms of <command>CREATE TYPE</command>, as shown in the "
"syntax synopsis above. They respectively create a <firstterm>composite type</"
"firstterm>, an <firstterm>enum type</firstterm>, a <firstterm>range type</"
"firstterm>, a <firstterm>base type</firstterm>, or a <firstterm>shell type</"
"firstterm>. The first four of these are discussed in turn below. A shell "
"type is simply a placeholder for a type to be defined later; it is created "
"by issuing <command>CREATE TYPE</command> with no parameters except for the "
"type name. Shell types are needed as forward references when creating range "
"types and base types, as discussed in those sections."
msgstr ""
"Команда <command>CREATE TYPE</command> имеет пять форм, показанных выше в "
"сводке синтаксиса. Они создают соответственно <firstterm>составной тип</"
"firstterm>, <firstterm>перечисление</firstterm>, <firstterm>диапазон</"
"firstterm>, <firstterm>базовый тип</firstterm> или <firstterm>тип-пустышку</"
"firstterm>. Первые четыре эти типа рассматриваются по порядку ниже. Тип-"
"пустышка представляет собой просто заготовку для типа, который будет "
"определён позже; он создаётся командой <command>CREATE TYPE</command> с "
"одним именем, без параметров. Типы-пустышки необходимы для определения "
"прямых ссылок при создании базовых типов и типов-диапазонов, как описывается "
"в соответствующих разделах."

#: ref/create_type.xml:95(title)
msgid "Composite Types"
msgstr "Составные типы"

#: ref/create_type.xml:97(para)
msgid ""
"The first form of <command>CREATE TYPE</command> creates a composite type. "
"The composite type is specified by a list of attribute names and data types. "
"An attribute's collation can be specified too, if its data type is "
"collatable. A composite type is essentially the same as the row type of a "
"table, but using <command>CREATE TYPE</command> avoids the need to create an "
"actual table when all that is wanted is to define a type. A stand-alone "
"composite type is useful, for example, as the argument or return type of a "
"function."
msgstr ""
"Первая форма <command>CREATE TYPE</command> создаёт составной тип. Составной "
"тип задаётся списком имён и типами данных атрибутов. Если тип данных "
"является сортируемым, то для атрибута можно также задать правило сортировки. "
"Составной тип по сути не отличается от типа строки таблицы, но "
"<command>CREATE TYPE</command> избавляет от необходимости создавать таблицу, "
"когда всё, что нужно, это создать тип. Отдельный составной тип может быть "
"полезен, например, для передачи аргументов или результатов функции."

#: ref/create_type.xml:109(para)
msgid ""
"To be able to create a composite type, you must have <literal>USAGE</"
"literal> privilege on all attribute types."
msgstr ""
"Чтобы создать составной тип, необходимо иметь право <literal>USAGE</literal> "
"для типов всех его атрибутов."

#: ref/create_type.xml:116(title)
msgid "Enumerated Types"
msgstr "Типы перечислений"

#: ref/create_type.xml:118(para)
msgid ""
"The second form of <command>CREATE TYPE</command> creates an enumerated "
"(enum) type, as described in <xref linkend=\"datatype-enum\"/>. Enum types "
"take a list of one or more quoted labels, each of which must be less than "
"<symbol>NAMEDATALEN</symbol> bytes long (64 bytes in a standard "
"<productname>PostgreSQL</productname> build)."
msgstr ""
"Вторая форма <command>CREATE TYPE</command> создаёт тип-перечисление (такие "
"типы описываются в <xref remap=\"6\" linkend=\"datatype-enum\"/>). "
"Перечисления принимают список из одной или нескольких меток в кавычках, "
"каждая не длиннее <symbol>NAMEDATALEN</symbol> байт (64 байта в стандартной "
"сборке <productname>PostgreSQL</productname>)."

#: ref/create_type.xml:128(title)
msgid "Range Types"
msgstr "Диапазонные типы"

#: ref/create_type.xml:130(para)
msgid ""
"The third form of <command>CREATE TYPE</command> creates a new range type, "
"as described in <xref linkend=\"rangetypes\"/>."
msgstr ""
"Третья форма <command>CREATE TYPE</command> создаёт тип-диапазон (такие типы "
"описываются в <xref remap=\"6\" linkend=\"rangetypes\"/>)."

#: ref/create_type.xml:135(para)
msgid ""
"The range type's <replaceable class=\"parameter\">subtype</replaceable> can "
"be any type with an associated b-tree operator class (to determine the "
"ordering of values for the range type). Normally the subtype's default b-"
"tree operator class is used to determine ordering; to use a non-default "
"operator class, specify its name with <replaceable class=\"parameter"
"\">subtype_opclass</replaceable>. If the subtype is collatable, and you want "
"to use a non-default collation in the range's ordering, specify the desired "
"collation with the <replaceable class=\"parameter\">collation</replaceable> "
"option."
msgstr ""
"Задаваемый для диапазона <replaceable class=\"parameter\">подтип</"
"replaceable> может быть любым типом со связанным классом операторов B-дерева "
"(что позволяет определить порядок значений в диапазоне). Обычно порядок "
"элементов определяет класс операторов B-дерева по умолчанию, но его можно "
"изменить, задав имя другого класса в параметре <replaceable class=\"parameter"
"\">класс_операторов_подтипа</replaceable>. Если подтип поддерживает "
"сортировку и требуется, чтобы значения упорядочивались с нестандартным "
"правилом сортировки, его имя можно задать в параметре <replaceable class="
"\"parameter\">правило_сортировки</replaceable>."

#: ref/create_type.xml:147(para)
msgid ""
"The optional <replaceable class=\"parameter\">canonical</replaceable> "
"function must take one argument of the range type being defined, and return "
"a value of the same type. This is used to convert range values to a "
"canonical form, when applicable. See <xref linkend=\"rangetypes-defining\"/> "
"for more information. Creating a <replaceable class=\"parameter\">canonical</"
"replaceable> function is a bit tricky, since it must be defined before the "
"range type can be declared. To do this, you must first create a shell type, "
"which is a placeholder type that has no properties except a name and an "
"owner. This is done by issuing the command <literal>CREATE TYPE "
"<replaceable>name</replaceable></literal>, with no additional parameters. "
"Then the function can be declared using the shell type as argument and "
"result, and finally the range type can be declared using the same name. This "
"automatically replaces the shell type entry with a valid range type."
msgstr ""
"Необязательная <replaceable class=\"parameter\">каноническая_функция</"
"replaceable> должна принимать один аргумент определяемого типа диапазона и "
"возвращать значение того же типа. Это используется для преобразования "
"значений диапазона в каноническую форму, когда это уместно. За "
"дополнительными сведениями обратитесь к <xref remap=\"3\" linkend="
"\"rangetypes-defining\"/>. Создаётся <replaceable class=\"parameter"
"\">каноническая_функция</replaceable> несколько нетривиально, так как она "
"должна быть уже определена, прежде чем можно будет объявить тип-диапазон. "
"Для этого нужно сначала создать тип-пустышку, который будет заготовкой типа, "
"не имеющей никаких свойств, кроме имени и владельца. Это можно сделать, "
"выполнив команду <literal>CREATE TYPE <replaceable>имя</replaceable></"
"literal> без дополнительных параметров. Затем можно объявить функцию, для "
"которой тип-пустышка будет типом аргумента и результата, и, наконец, "
"объявить тип-диапазон с тем же именем. При этом тип-пустышка автоматически "
"заменится полноценным типом-диапазоном."

#: ref/create_type.xml:164(para)
msgid ""
"The optional <replaceable class=\"parameter\">subtype_diff</replaceable> "
"function must take two values of the <replaceable class=\"parameter"
"\">subtype</replaceable> type as argument, and return a <type>double "
"precision</type> value representing the difference between the two given "
"values. While this is optional, providing it allows much greater efficiency "
"of GiST indexes on columns of the range type. See <xref linkend=\"rangetypes-"
"defining\"/> for more information."
msgstr ""
"Необязательная <replaceable class=\"parameter\">функция_разницы_подтипа</"
"replaceable> должна принимать в аргументах два значения типа <replaceable "
"class=\"parameter\">подтип</replaceable> и возвращать значение <type>double "
"precision</type>, представляющее разницу между двумя данными значениями. "
"Хотя эту функцию можно не использовать, она позволяет кардинально увеличить "
"эффективность индексов GiST для столбцов с типом-диапазоном. За "
"дополнительными сведениями обратитесь к <xref remap=\"3\" linkend="
"\"rangetypes-defining\"/>."

#: ref/create_type.xml:177(title)
msgid "Base Types"
msgstr "Базовые типы"

#: ref/create_type.xml:179(para)
msgid ""
"The fourth form of <command>CREATE TYPE</command> creates a new base type "
"(scalar type). To create a new base type, you must be a superuser. (This "
"restriction is made because an erroneous type definition could confuse or "
"even crash the server.)"
msgstr ""
"Четвёртая форма <command>CREATE TYPE</command> создаёт новый базовый тип "
"(скалярный тип). Чтобы создать новый базовый тип, нужно быть "
"суперпользователем. (Это ограничение введено потому, что ошибочное "
"определение типа может вызвать нарушения или даже сбой в работе сервера.)"

#: ref/create_type.xml:186(para)
msgid ""
"The parameters can appear in any order, not only that illustrated above, and "
"most are optional. You must register two or more functions (using "
"<command>CREATE FUNCTION</command>) before defining the type. The support "
"functions <replaceable class=\"parameter\">input_function</replaceable> and "
"<replaceable class=\"parameter\">output_function</replaceable> are required, "
"while the functions <replaceable class=\"parameter\">receive_function</"
"replaceable>, <replaceable class=\"parameter\">send_function</replaceable>, "
"<replaceable class=\"parameter\">type_modifier_input_function</replaceable>, "
"<replaceable class=\"parameter\">type_modifier_output_function</replaceable> "
"and <replaceable class=\"parameter\">analyze_function</replaceable> are "
"optional. Generally these functions have to be coded in C or another low-"
"level language."
msgstr ""
"Эти параметры могут перечисляться в любом порядке, не только в показанном "
"выше, и большинство из них необязательные. Прежде чем создавать тип, "
"необходимо зарегистрировать две или более функций (с помощью <command>CREATE "
"FUNCTION</command>). Обязательными являются функции <replaceable class="
"\"parameter\">функция_ввода</replaceable> и <replaceable class=\"parameter"
"\">функция_вывода</replaceable>, тогда как <replaceable class=\"parameter"
"\">функция_получения</replaceable>, <replaceable class=\"parameter"
"\">функция_отправки</replaceable>, <replaceable class=\"parameter"
"\">функция_модификатора_типа</replaceable>, <replaceable class=\"parameter"
"\">функция_вывода_модификатора_типа</replaceable> и <replaceable class="
"\"parameter\">функция_анализа</replaceable> могут отсутствовать. Обычно эти "
"функции разрабатываются на C или другом низкоуровневом языке."

#: ref/create_type.xml:203(para)
msgid ""
"The <replaceable class=\"parameter\">input_function</replaceable> converts "
"the type's external textual representation to the internal representation "
"used by the operators and functions defined for the type. <replaceable class="
"\"parameter\">output_function</replaceable> performs the reverse "
"transformation. The input function can be declared as taking one argument of "
"type <type>cstring</type>, or as taking three arguments of types "
"<type>cstring</type>, <type>oid</type>, <type>integer</type>. The first "
"argument is the input text as a C string, the second argument is the type's "
"own OID (except for array types, which instead receive their element type's "
"OID), and the third is the <literal>typmod</literal> of the destination "
"column, if known (-1 will be passed if not). The input function must return "
"a value of the data type itself. Usually, an input function should be "
"declared STRICT; if it is not, it will be called with a NULL first parameter "
"when reading a NULL input value. The function must still return NULL in this "
"case, unless it raises an error. (This case is mainly meant to support "
"domain input functions, which might need to reject NULL inputs.) The output "
"function must be declared as taking one argument of the new data type. The "
"output function must return type <type>cstring</type>. Output functions are "
"not invoked for NULL values."
msgstr ""
"<replaceable class=\"parameter\">Функция_ввода</replaceable> преобразует "
"внешнее текстовое представление типа во внутреннее, с которым работают "
"операторы и функции, определённые для этого типа. <replaceable class="
"\"parameter\">Функция_вывода</replaceable> выполняет обратное "
"преобразование. Функцию ввода можно объявить как принимающую один аргумент "
"типа <type>cstring</type>, либо как принимающую три аргумента типов "
"<type>cstring</type>, <type>oid</type> и <type>integer</type>. В первом "
"аргументе передаётся вводимый текст в виде строки в стиле C, во втором "
"аргументе — собственный OID типа (кроме типов массивов, для которых "
"передаётся OID типа элемента), а в третьем — <literal>модификатор_типа</"
"literal> для целевого столбца, если он определён (или -1 в противном "
"случае). Функция ввода должна возвращать значение нового типа данных. Обычно "
"функция ввода должна быть строгой (STRICT); если это не так, при получении "
"на вход значения NULL она будет вызываться с первым параметром NULL. Функция "
"может в этом случае сама вернуть NULL или вызвать ошибку. (Это полезно в "
"основном для поддержки функций ввода доменных типов, которые не должны "
"принимать данные NULL.) Функция вывода должна принимать один аргумент нового "
"типа данных, а возвращать она должна <type>cstring</type>. Для значений NULL "
"функции вывода не вызываются."

#: ref/create_type.xml:230(para)
msgid ""
"The optional <replaceable class=\"parameter\">receive_function</replaceable> "
"converts the type's external binary representation to the internal "
"representation. If this function is not supplied, the type cannot "
"participate in binary input. The binary representation should be chosen to "
"be cheap to convert to internal form, while being reasonably portable. (For "
"example, the standard integer data types use network byte order as the "
"external binary representation, while the internal representation is in the "
"machine's native byte order.) The receive function should perform adequate "
"checking to ensure that the value is valid. The receive function can be "
"declared as taking one argument of type <type>internal</type>, or as taking "
"three arguments of types <type>internal</type>, <type>oid</type>, "
"<type>integer</type>. The first argument is a pointer to a <type>StringInfo</"
"type> buffer holding the received byte string; the optional arguments are "
"the same as for the text input function. The receive function must return a "
"value of the data type itself. Usually, a receive function should be "
"declared STRICT; if it is not, it will be called with a NULL first parameter "
"when reading a NULL input value. The function must still return NULL in this "
"case, unless it raises an error. (This case is mainly meant to support "
"domain receive functions, which might need to reject NULL inputs.) "
"Similarly, the optional <replaceable class=\"parameter\">send_function</"
"replaceable> converts from the internal representation to the external "
"binary representation. If this function is not supplied, the type cannot "
"participate in binary output. The send function must be declared as taking "
"one argument of the new data type. The send function must return type "
"<type>bytea</type>. Send functions are not invoked for NULL values."
msgstr ""
"Необязательная <replaceable class=\"parameter\">функция_получения</"
"replaceable> преобразует двоичное внешнее представление типа во внутреннее "
"представление. Если эта функция отсутствует, новый тип не сможет участвовать "
"в двоичном вводе. Двоичное представление следует выбирать таким, чтобы оно "
"легко переводилось во внутреннюю форму и при этом было переносимым до "
"разумной степени. (Например, для стандартных целочисленных типов данных во "
"внешнем двоичном представлении выбран сетевой порядок байтов, тогда как "
"внутреннее представление определяется порядком байтов в процессоре.) Функция "
"получения должна выполнить проверку вводимого значения на допустимость. "
"Функция получения может быть объявлена как принимающая один аргумент типа "
"<type>internal</type>, либо как принимающая три аргумента типов "
"<type>internal</type>, <type>oid</type> и <type>integer</type>. В первом "
"аргументе передаётся указатель на буфер <type>StringInfo</type>, содержащий "
"полученную байтовую строку, а дополнительные аргументы такие же, как и для "
"функции ввода текста. Функция получения должна возвращать значение нового "
"типа данных. Обычно функция получения должна быть строгой (STRICT); если это "
"не так, при получении на вход значения NULL, она будет вызываться с первым "
"параметром NULL. Функция может в этом случае сама вернуть NULL или вызывать "
"ошибку. (Это полезно в основном для поддержки функций получения доменных "
"типов, которые не должны принимать значения NULL.) Подобным образом, "
"необязательная <replaceable class=\"parameter\">функция_отправки</"
"replaceable> преобразует данные из внутреннего во внешнее двоичное "
"представление. Если эта функция не определена, новый тип не может "
"участвовать в двоичном выводе. Функция отправки должна принимать один "
"аргумент нового типа данных, а возвращать она должна <type>bytea</type>. Для "
"значений NULL функции отправки не вызываются."

#: ref/create_type.xml:264(para)
msgid ""
"You should at this point be wondering how the input and output functions can "
"be declared to have results or arguments of the new type, when they have to "
"be created before the new type can be created. The answer is that the type "
"should first be defined as a <firstterm>shell type</firstterm>, which is a "
"placeholder type that has no properties except a name and an owner. This is "
"done by issuing the command <literal>CREATE TYPE <replaceable>name</"
"replaceable></literal>, with no additional parameters. Then the C I/O "
"functions can be defined referencing the shell type. Finally, "
"<command>CREATE TYPE</command> with a full definition replaces the shell "
"entry with a complete, valid type definition, after which the new type can "
"be used normally."
msgstr ""
"Здесь у вас может возникнуть вопрос, как функции ввода и вывода могут быть "
"объявлены принимающими или возвращающими значения нового типа, если они "
"должны быть созданы до объявления нового типа. Ответ довольно прост: сначала "
"нужно создать <firstterm>тип-пустышку</firstterm>, который будет заготовкой "
"типа, не имеющей никаких свойств, кроме имени и владельца. Это можно "
"сделать, выполнив команду <literal>CREATE TYPE <replaceable>имя</"
"replaceable></literal> без дополнительных параметров. Затем можно будет "
"определить функции ввода/вывода на C, ссылающиеся на этот тип. И наконец, "
"команда <command>CREATE TYPE</command> с полным определением заменит тип-"
"пустышку окончательным и полноценным определением, после чего новый тип "
"можно будет использовать как обычно."

#: ref/create_type.xml:278(para)
msgid ""
"The optional <replaceable class=\"parameter\">type_modifier_input_function</"
"replaceable> and <replaceable class=\"parameter"
"\">type_modifier_output_function</replaceable> are needed if the type "
"supports modifiers, that is optional constraints attached to a type "
"declaration, such as <literal>char(5)</literal> or <literal>numeric(30,2)</"
"literal>. <productname>PostgreSQL</productname> allows user-defined types to "
"take one or more simple constants or identifiers as modifiers. However, this "
"information must be capable of being packed into a single non-negative "
"integer value for storage in the system catalogs. The <replaceable class="
"\"parameter\">type_modifier_input_function</replaceable> is passed the "
"declared modifier(s) in the form of a <type>cstring</type> array. It must "
"check the values for validity (throwing an error if they are wrong), and if "
"they are correct, return a single non-negative <type>integer</type> value "
"that will be stored as the column <quote>typmod</quote>. Type modifiers will "
"be rejected if the type does not have a <replaceable class=\"parameter"
"\">type_modifier_input_function</replaceable>. The <replaceable class="
"\"parameter\">type_modifier_output_function</replaceable> converts the "
"internal integer typmod value back to the correct form for user display. It "
"must return a <type>cstring</type> value that is the exact string to append "
"to the type name; for example <type>numeric</type>'s function might return "
"<literal>(30,2)</literal>. It is allowed to omit the <replaceable class="
"\"parameter\">type_modifier_output_function</replaceable>, in which case the "
"default display format is just the stored typmod integer value enclosed in "
"parentheses."
msgstr ""
"Необязательные <replaceable class=\"parameter"
"\">функция_ввода_модификатора_типа</replaceable> и <replaceable class="
"\"parameter\">функция_вывода_модификатора_типа</replaceable> требуются, "
"только если типы поддерживают модификаторы, или, другими словами, "
"дополнительные ограничения, связываемые с объявлением типа, например "
"<literal>char(5)</literal> или <literal>numeric(30,2)</literal>. В "
"<productname>PostgreSQL</productname> типы могут принимать в качестве "
"модификаторов одну или несколько простых констант или идентификаторов. "
"Однако эти данные должны упаковываться в единственное неотрицательное "
"целочисленное значение, которое и будет храниться в системных каталогах. "
"<replaceable class=\"parameter\">Функция_ввода_модификатора_типа</"
"replaceable> получает объявленные модификаторы в виде строки <type>cstring</"
"type>. Она должна проверить значения на допустимость (и вызвать ошибку, если "
"они неверны), а затем выдать неотрицательное значение <type>integer</type>, "
"которое будет сохранено в столбце <quote>typmod</quote>. Если для типа не "
"определена <replaceable class=\"parameter\">функция_ввода_модификатора_типа</"
"replaceable>, модификаторы типа приниматься не будут. <replaceable class="
"\"parameter\">Функция_вывода_модификатора_типа</replaceable> преобразует "
"внутреннее целочисленное значение typmod обратно, в форму, понятную "
"пользователю. Она должна вернуть значение <type>cstring</type>, которое "
"именно в этом виде будет добавлено к имени типа; например, функция для "
"<type>numeric</type> должна вернуть <literal>(30,2)</literal>. <replaceable "
"class=\"parameter\">Функция_вывода_модификатора_типа</replaceable> может "
"быть опущена, в этом случае сохранённое целочисленное значение typmod по "
"умолчанию будет выводиться просто в виде числа, заключённого в скобки."

#: ref/create_type.xml:306(para)
msgid ""
"The optional <replaceable class=\"parameter\">analyze_function</replaceable> "
"performs type-specific statistics collection for columns of the data type. "
"By default, <command>ANALYZE</command> will attempt to gather statistics "
"using the type's <quote>equals</quote> and <quote>less-than</quote> "
"operators, if there is a default b-tree operator class for the type. For non-"
"scalar types this behavior is likely to be unsuitable, so it can be "
"overridden by specifying a custom analysis function. The analysis function "
"must be declared to take a single argument of type <type>internal</type>, "
"and return a <type>boolean</type> result. The detailed API for analysis "
"functions appears in <filename>src/include/commands/vacuum.h</filename>."
msgstr ""
"Необязательная <replaceable class=\"parameter\">функция_анализа</"
"replaceable> выполняет сбор специфической для этого типа статистики в "
"столбцах с таким типом данных. По умолчанию <command>ANALYZE</command> "
"пытается собрать статистику, используя операторы <quote>равно</quote> и "
"<quote>меньше</quote>, если для этого типа определён класс операторов B-"
"дерева по умолчанию. Для нескалярных типов это поведение скорее всего не "
"подойдёт, поэтому его можно переопределить, задав собственную функцию "
"анализа. Эта функция должна принимать единственный аргумент типа "
"<type>internal</type> и возвращать результат <type>boolean</type>. Более "
"глубоко API функций анализа описан в <filename>src/include/commands/vacuum."
"h</filename>."

#: ref/create_type.xml:319(para)
msgid ""
"While the details of the new type's internal representation are only known "
"to the I/O functions and other functions you create to work with the type, "
"there are several properties of the internal representation that must be "
"declared to <productname>PostgreSQL</productname>. Foremost of these is "
"<replaceable class=\"parameter\">internallength</replaceable>. Base data "
"types can be fixed-length, in which case <replaceable class=\"parameter"
"\">internallength</replaceable> is a positive integer, or variable-length, "
"indicated by setting <replaceable class=\"parameter\">internallength</"
"replaceable> to <literal>VARIABLE</literal>. (Internally, this is "
"represented by setting <literal>typlen</literal> to -1.) The internal "
"representation of all variable-length types must start with a 4-byte integer "
"giving the total length of this value of the type. (Note that the length "
"field is often encoded, as described in <xref linkend=\"storage-toast\"/>; "
"it's unwise to access it directly.)"
msgstr ""
"Если особенности внутреннего представления нового типа известны функциям "
"ввода/вывода и другим функциям, созданным специально для работы с этим "
"типом, необходимо определить ряд характеристик внутреннего представления, о "
"которых должен знать <productname>PostgreSQL</productname>. В первую очередь "
"это <replaceable class=\"parameter\">internallength</replaceable> "
"(внутренняя длина). Если базовый тип данных имеет фиксированную длину, в "
"<replaceable class=\"parameter\">internallength</replaceable> указывается "
"эта длина в виде положительного числа, а если длина переменная, в "
"<replaceable class=\"parameter\">internallength</replaceable> задаётся "
"значение <literal>VARIABLE</literal>. (Внутри при этом <literal>typlen</"
"literal> принимает значение -1.) Внутреннее представление всех типов "
"переменной длины должно начинаться с 4-байтового целого, задающего общую "
"длину значения этого типа. (Заметьте, что поле длины часто кодируется, как "
"описано в <xref remap=\"6\" linkend=\"storage-toast\"/>; обращаться к нему "
"напрямую неразумно.)"

#: ref/create_type.xml:338(para)
msgid ""
"The optional flag <literal>PASSEDBYVALUE</literal> indicates that values of "
"this data type are passed by value, rather than by reference. Types passed "
"by value must be fixed-length, and their internal representation cannot be "
"larger than the size of the <type>Datum</type> type (4 bytes on some "
"machines, 8 bytes on others)."
msgstr ""
"Необязательный флаг <literal>PASSEDBYVALUE</literal> указывает, что значения "
"этого типа данных передаются по значению, а не по ссылке. Типы, передаваемые "
"по значению, должны быть фиксированной длины и их внутреннее представление "
"не может быть больше размера типа <type>Datum</type> (4 байта на одних "
"машинах, 8 — на других)."

#: ref/create_type.xml:346(para)
msgid ""
"The <replaceable class=\"parameter\">alignment</replaceable> parameter "
"specifies the storage alignment required for the data type. The allowed "
"values equate to alignment on 1, 2, 4, or 8 byte boundaries. Note that "
"variable-length types must have an alignment of at least 4, since they "
"necessarily contain an <type>int4</type> as their first component."
msgstr ""
"Параметр <replaceable class=\"parameter\">выравнивание</replaceable> "
"определяет, как требуется выравнивать данные этого типа. Допускается "
"выравнивание по границам 1, 2, 4 или 8 байт. Заметьте, что типы переменной "
"длины должны быть выровнены как минимум по границе 4 байт, так как их первым "
"компонентом обязательно должен быть <type>int4</type>."

#: ref/create_type.xml:354(para)
msgid ""
"The <replaceable class=\"parameter\">storage</replaceable> parameter allows "
"selection of storage strategies for variable-length data types. (Only "
"<literal>plain</literal> is allowed for fixed-length types.) <literal>plain</"
"literal> specifies that data of the type will always be stored in-line and "
"not compressed. <literal>extended</literal> specifies that the system will "
"first try to compress a long data value, and will move the value out of the "
"main table row if it's still too long. <literal>external</literal> allows "
"the value to be moved out of the main table, but the system will not try to "
"compress it. <literal>main</literal> allows compression, but discourages "
"moving the value out of the main table. (Data items with this storage "
"strategy might still be moved out of the main table if there is no other way "
"to make a row fit, but they will be kept in the main table preferentially "
"over <literal>extended</literal> and <literal>external</literal> items.)"
msgstr ""
"Параметр <replaceable class=\"parameter\">хранение</replaceable> позволяет "
"выбрать стратегию хранения для типов данных переменной длины. (Для типов с "
"фиксированной длиной поддерживается только вариант <literal>plain</"
"literal>.) Если выбрана стратегия <literal>plain</literal>, данные этого "
"типа всегда хранятся внутри, без сжатия. Со стратегией <literal>extended</"
"literal> система сначала попытается сжать большое значение, а затем выносит "
"его из строки основной таблицы, если оно всё же окажется слишком большим. С "
"<literal>external</literal> значение может быть вынесено из основной "
"таблицы, но система не будет пытаться сжать его. Стратегия <literal>main</"
"literal> позволяет сжать данные, но не стремится вынести их из основной "
"таблицы. (Элементы данных с этой стратегией хранения, тем не менее, могут "
"быть вынесены из основной таблицы, если другого способа уместить их в строке "
"нет, но всё же она отдаёт большее предпочтение основной таблице, по "
"сравнению со стратегиями <literal>extended</literal> и <literal>external</"
"literal>.)"

#: ref/create_type.xml:373(para)
msgid ""
"All <replaceable class=\"parameter\">storage</replaceable> values other than "
"<literal>plain</literal> imply that the functions of the data type can "
"handle values that have been <firstterm>toasted</firstterm>, as described in "
"<xref linkend=\"storage-toast\"/> and <xref linkend=\"xtypes-toast\"/>. The "
"specific other value given merely determines the default TOAST storage "
"strategy for columns of a toastable data type; users can pick other "
"strategies for individual columns using <literal>ALTER TABLE SET STORAGE</"
"literal>."
msgstr ""
"Значения <replaceable class=\"parameter\">storage</replaceable>, отличные от "
"<literal>plain</literal>, подразумевают, что функции типа данных могут "
"принимать значения в формате <firstterm>toast</firstterm>, описанном в <xref "
"remap=\"6\" linkend=\"storage-toast\"/> и <xref remap=\"6\" linkend=\"xtypes-"
"toast\"/>. Эти значения просто определяют стратегию хранения TOAST по "
"умолчанию для столбцов отделяемого в TOAST типа данных; пользователи могут "
"выбирать другие стратегии для отдельных столбцов, применяя команду "
"<literal>ALTER TABLE SET STORAGE</literal>."

#: ref/create_type.xml:384(para)
msgid ""
"The <replaceable class=\"parameter\">like_type</replaceable> parameter "
"provides an alternative method for specifying the basic representation "
"properties of a data type: copy them from some existing type. The values of "
"<replaceable class=\"parameter\">internallength</replaceable>, <replaceable "
"class=\"parameter\">passedbyvalue</replaceable>, <replaceable class="
"\"parameter\">alignment</replaceable>, and <replaceable class=\"parameter"
"\">storage</replaceable> are copied from the named type. (It is possible, "
"though usually undesirable, to override some of these values by specifying "
"them along with the <literal>LIKE</literal> clause.) Specifying "
"representation this way is especially useful when the low-level "
"implementation of the new type <quote>piggybacks</quote> on an existing type "
"in some fashion."
msgstr ""
"Параметр <replaceable class=\"parameter\">тип_образец</replaceable> "
"позволяет задать основные свойства представления типа другим способом: "
"скопировать их из существующего типа. В частности, из указанного типа будут "
"скопированы свойства <replaceable class=\"parameter\">internallength</"
"replaceable>, <replaceable class=\"parameter\">passedbyvalue</replaceable>, "
"<replaceable class=\"parameter\">alignment</replaceable> и <replaceable "
"class=\"parameter\">storage</replaceable>. (Также возможно, хотя обычно это "
"не требуется, переопределить некоторые из этих значений, указав их вместе с "
"предложением <literal>LIKE</literal>.) Определять представление типа таким "
"образом особенно удобно, когда низкоуровневая реализация нового типа "
"некоторым образом опирается на существующий тип."

#: ref/create_type.xml:399(para)
msgid ""
"The <replaceable class=\"parameter\">category</replaceable> and <replaceable "
"class=\"parameter\">preferred</replaceable> parameters can be used to help "
"control which implicit cast will be applied in ambiguous situations. Each "
"data type belongs to a category named by a single ASCII character, and each "
"type is either <quote>preferred</quote> or not within its category. The "
"parser will prefer casting to preferred types (but only from other types "
"within the same category) when this rule is helpful in resolving overloaded "
"functions or operators. For more details see <xref linkend=\"typeconv\"/>. "
"For types that have no implicit casts to or from any other types, it is "
"sufficient to leave these settings at the defaults. However, for a group of "
"related types that have implicit casts, it is often helpful to mark them all "
"as belonging to a category and select one or two of the <quote>most general</"
"quote> types as being preferred within the category. The <replaceable class="
"\"parameter\">category</replaceable> parameter is especially useful when "
"adding a user-defined type to an existing built-in category, such as the "
"numeric or string types. However, it is also possible to create new entirely-"
"user-defined type categories. Select any ASCII character other than an upper-"
"case letter to name such a category."
msgstr ""
"Параметры <replaceable class=\"parameter\">категория</replaceable> и "
"<replaceable class=\"parameter\">предпочитаемый</replaceable> позволяют "
"определять, какое неявное приведение будет применяться в неоднозначных "
"ситуациях. Каждый тип данных принадлежит к некоторой категории, обозначаемой "
"одним символом ASCII, при этом он может быть, либо не быть "
"<quote>предпочитаемым</quote> в этой категории. Анализатор запроса по "
"возможности выберет приведение к предпочитаемому типу (но только среди "
"других типов той же категории), когда это может помочь разрешить имя "
"перегруженной функции или оператора. За дополнительными подробностями "
"обратитесь к <xref remap=\"3\" linkend=\"typeconv\"/>. Если для типа не "
"определено неявное приведение к какому-либо другому типу или обратное, для "
"этих параметров достаточно оставить значения по умолчанию. Однако если есть "
"группа связанных типов, для которых определены неявные приведения, часто "
"бывает полезно пометить их все как принадлежащие некоторой категории и "
"назначить один или два <quote>наиболее общих</quote> предпочитаемыми в этой "
"категории. Параметр <replaceable class=\"parameter\">категория</replaceable> "
"особенно полезен при добавлении типа, определённого пользователем, в "
"существующую встроенную категорию, например, в категорию числовых или "
"строковых типов. Однако так же возможно создать категории типов, полностью "
"определённые пользователем. В качестве имени такой категории можно выбрать "
"любой ASCII-символ, кроме латинской заглавной буквы."

#: ref/create_type.xml:420(para)
msgid ""
"A default value can be specified, in case a user wants columns of the data "
"type to default to something other than the null value. Specify the default "
"with the <literal>DEFAULT</literal> key word. (Such a default can be "
"overridden by an explicit <literal>DEFAULT</literal> clause attached to a "
"particular column.)"
msgstr ""
"Если пользователь хочет назначить столбцам с этим типом данных значение по "
"умолчанию, отличное от NULL, он может задать его в этой команде, указав его "
"после ключевого слова <literal>DEFAULT</literal>. (Такое значение по "
"умолчанию можно переопределить явным предложением <literal>DEFAULT</"
"literal>, добавленным при создании столбца.)"

#: ref/create_type.xml:428(para)
msgid ""
"To indicate that a type is an array, specify the type of the array elements "
"using the <literal>ELEMENT</literal> key word. For example, to define an "
"array of 4-byte integers (<type>int4</type>), specify <literal>ELEMENT = "
"int4</literal>. More details about array types appear below."
msgstr ""
"Чтобы обозначить, что тип является массивом, укажите тип элементов массива, "
"добавив ключевое слово <literal>ELEMENT</literal>. Например, чтобы "
"определить массив из четырёхбайтовых целых (<type>int4</type>), укажите "
"<literal>ELEMENT = int4</literal>. Дополнительные сведения о типах массивов "
"приведены ниже."

#: ref/create_type.xml:436(para)
msgid ""
"To indicate the delimiter to be used between values in the external "
"representation of arrays of this type, <replaceable class=\"parameter"
"\">delimiter</replaceable> can be set to a specific character. The default "
"delimiter is the comma (<literal>,</literal>). Note that the delimiter is "
"associated with the array element type, not the array type itself."
msgstr ""
"Параметр <replaceable class=\"parameter\">delimiter</replaceable> позволяет "
"задать разделитель, который будет вставляться между значениями во внешнем "
"представлении массива с элементами этого типа. По умолчанию разделителем "
"является запятая (<literal>,</literal>). Заметьте, что разделитель "
"связывается с типом элементов массива, а не с типом самого массива."

#: ref/create_type.xml:445(para)
msgid ""
"If the optional Boolean parameter <replaceable class=\"parameter"
"\">collatable</replaceable> is true, column definitions and expressions of "
"the type may carry collation information through use of the "
"<literal>COLLATE</literal> clause. It is up to the implementations of the "
"functions operating on the type to actually make use of the collation "
"information; this does not happen automatically merely by marking the type "
"collatable."
msgstr ""
"Если необязательный логический параметр <replaceable class=\"parameter"
"\">сортируемый</replaceable> равен true, определения столбцов и выражения с "
"этим типом могут включать указания о порядке сортировки, в предложении "
"<literal>COLLATE</literal>. Как именно будут использоваться эти указания, "
"зависит от реализации функций, работающих с этим типом; эти указания не "
"действуют автоматически просто от того, что тип помечен как сортируемый."

#: ref/create_type.xml:458(title)
msgid "Array Types"
msgstr "Типы массивов"

#: ref/create_type.xml:460(para)
msgid ""
"Whenever a user-defined type is created, <productname>PostgreSQL</"
"productname> automatically creates an associated array type, whose name "
"consists of the element type's name prepended with an underscore, and "
"truncated if necessary to keep it less than <symbol>NAMEDATALEN</symbol> "
"bytes long. (If the name so generated collides with an existing type name, "
"the process is repeated until a non-colliding name is found.) This "
"implicitly-created array type is variable length and uses the built-in input "
"and output functions <literal>array_in</literal> and <literal>array_out</"
"literal>. The array type tracks any changes in its element type's owner or "
"schema, and is dropped if the element type is."
msgstr ""
"При создании любого нового типа <productname>PostgreSQL</productname> "
"автоматически создаёт соответствующий тип массива, имя которого он получает, "
"добавляя подчёркивание перед именем типа элементов. Если полученное имя "
"оказывается не короче <symbol>NAMEDATALEN</symbol> байт, оно усекается. "
"(Если полученное таким образом имя конфликтует с именем уже существующего "
"типа, процесс повторяется, пока не будет получено уникальное имя.) Этот "
"неявно создаваемый тип массива имеет переменную длину и использует "
"встроенные функции ввода и вывода <literal>array_in</literal> и "
"<literal>array_out</literal>. Тип массива отражает любые изменения владельца "
"или схемы связанного типа элемента и удаляется сам при удалении типа "
"элемента."

#: ref/create_type.xml:474(para)
msgid ""
"You might reasonably ask why there is an <option>ELEMENT</option> option, if "
"the system makes the correct array type automatically. The only case where "
"it's useful to use <option>ELEMENT</option> is when you are making a fixed-"
"length type that happens to be internally an array of a number of identical "
"things, and you want to allow these things to be accessed directly by "
"subscripting, in addition to whatever operations you plan to provide for the "
"type as a whole. For example, type <type>point</type> is represented as just "
"two floating-point numbers, which can be accessed using <literal>point[0]</"
"literal> and <literal>point[1]</literal>. Note that this facility only works "
"for fixed-length types whose internal form is exactly a sequence of "
"identical fixed-length fields. A subscriptable variable-length type must "
"have the generalized internal representation used by <literal>array_in</"
"literal> and <literal>array_out</literal>. For historical reasons (i.e., "
"this is clearly wrong but it's far too late to change it), subscripting of "
"fixed-length array types starts from zero, rather than from one as for "
"variable-length arrays."
msgstr ""
"Вы можете вполне резонно спросить, зачем нужен параметр <option>ELEMENT</"
"option>, если система создаёт правильный тип массива автоматически. "
"Единственный случай, когда параметр <option>ELEMENT</option> может быть "
"полезен, это когда вы создаёте тип фиксированной длины, который внутри "
"оказывается массивом одинаковых элементов, и вы хотите, чтобы к этим "
"элементам можно было обращаться по индексу, помимо того, что вы можете "
"реализовать какие угодно операции с типом в целом. Например, тип "
"<type>point</type> представлен просто как два числа с плавающей точкой, к "
"которым можно обратиться так: <literal>point[0]</literal> и "
"<literal>point[1]</literal>. Заметьте, что это работает только с типами "
"фиксированной длины, которые представляют собой в точности "
"последовательность одинаковых полей фиксированной длины. Тип массива "
"переменной длины должен иметь обобщённое внутреннее представление, с которым "
"умеют работать <literal>array_in</literal> и <literal>array_out</literal>. "
"По историческим причинам (т. е. это определённо некорректно, но менять уже "
"слишком поздно), индексы в массивах фиксированной длины начинаются с нуля, а "
"не с 1, как в массивах переменной длины."

#: ref/create_type.xml:497(title)
msgid "Parameters"
msgstr "Параметры"

#: ref/create_type.xml:503(para)
msgid "The name (optionally schema-qualified) of a type to be created."
msgstr "Имя (возможно, дополненное схемой) создаваемого типа."

#: ref/create_type.xml:512(para)
msgid "The name of an attribute (column) for the composite type."
msgstr "Имя атрибута (столбца) составного типа."

#: ref/create_type.xml:521(para)
msgid ""
"The name of an existing data type to become a column of the composite type."
msgstr ""
"Имя существующего типа данных, который станет типом столбца составного типа."

#: ref/create_type.xml:531(para)
msgid ""
"The name of an existing collation to be associated with a column of a "
"composite type, or with a range type."
msgstr ""
"Имя существующего правила сортировки, связываемого со столбцом составного "
"типа или с типом-диапазоном."

#: ref/create_type.xml:541(para)
msgid ""
"A string literal representing the textual label associated with one value of "
"an enum type."
msgstr ""
"Строковая константа, представляющая текстовую метку, связанную с отдельным "
"значением типа-перечисления."

#: ref/create_type.xml:551(para)
msgid ""
"The name of the element type that the range type will represent ranges of."
msgstr ""
"Имя типа элемента, множество значений которого будет представлять тип-"
"диапазон."

#: ref/create_type.xml:561(para)
msgid "The name of a b-tree operator class for the subtype."
msgstr "Имя класса операторов B-дерева для подтипа."

#: ref/create_type.xml:570(para)
msgid "The name of the canonicalization function for the range type."
msgstr "Имя функции канонизации для типа-диапазона."

#: ref/create_type.xml:579(para)
msgid "The name of a difference function for the subtype."
msgstr "Имя функции разницы для значений подтипа."

#: ref/create_type.xml:588(para)
msgid ""
"The name of a function that converts data from the type's external textual "
"form to its internal form."
msgstr ""
"Имя функции, преобразующей данные из внешнего текстового представления типа "
"во внутреннюю форму."

#: ref/create_type.xml:598(para)
msgid ""
"The name of a function that converts data from the type's internal form to "
"its external textual form."
msgstr ""
"Имя функции, преобразующей данные из внутренней формы во внешнее текстовое "
"представление типа."

#: ref/create_type.xml:608(para)
msgid ""
"The name of a function that converts data from the type's external binary "
"form to its internal form."
msgstr ""
"Имя функции, преобразующей данные из внешнего двоичного представления типа "
"во внутреннюю форму."

#: ref/create_type.xml:618(para)
msgid ""
"The name of a function that converts data from the type's internal form to "
"its external binary form."
msgstr ""
"Имя функции, преобразующей данные из внутренней формы во внешнее двоичное "
"представление типа."

#: ref/create_type.xml:628(para)
msgid ""
"The name of a function that converts an array of modifier(s) for the type "
"into internal form."
msgstr ""
"Имя функции, преобразующей массив модификаторов типа во внутреннюю форму."

#: ref/create_type.xml:638(para)
msgid ""
"The name of a function that converts the internal form of the type's "
"modifier(s) to external textual form."
msgstr ""
"Имя функции, преобразующей внутреннюю форму модификаторов типа во внешнее "
"текстовое представление."

#: ref/create_type.xml:648(para)
msgid ""
"The name of a function that performs statistical analysis for the data type."
msgstr "Имя функции, производящей статистический анализ типа данных."

#: ref/create_type.xml:658(para)
msgid ""
"A numeric constant that specifies the length in bytes of the new type's "
"internal representation. The default assumption is that it is variable-"
"length."
msgstr ""
"Числовая константа, задающая размер внутреннего представления нового типа в "
"байтах. По умолчанию предполагается, что тип имеет переменную длину."

#: ref/create_type.xml:669(para)
msgid ""
"The storage alignment requirement of the data type. If specified, it must be "
"<literal>char</literal>, <literal>int2</literal>, <literal>int4</literal>, "
"or <literal>double</literal>; the default is <literal>int4</literal>."
msgstr ""
"Требуемое выравнивание для типа данных. Допустимые значения этого параметра, "
"если он указывается: <literal>char</literal>, <literal>int2</literal>, "
"<literal>int4</literal> или <literal>double</literal>; по умолчанию "
"подразумевается <literal>int4</literal>."

#: ref/create_type.xml:681(para)
msgid ""
"The storage strategy for the data type. If specified, must be "
"<literal>plain</literal>, <literal>external</literal>, <literal>extended</"
"literal>, or <literal>main</literal>; the default is <literal>plain</"
"literal>."
msgstr ""
"Стратегия хранения для типа данных. Допустимые значения этого параметра, "
"если он указывается: <literal>plain</literal>, <literal>external</literal>, "
"<literal>extended</literal> или <literal>main</literal>; по умолчанию "
"подразумевается <literal>plain</literal>."

#: ref/create_type.xml:693(para)
msgid ""
"The name of an existing data type that the new type will have the same "
"representation as. The values of <replaceable class=\"parameter"
"\">internallength</replaceable>, <replaceable class=\"parameter"
"\">passedbyvalue</replaceable>, <replaceable class=\"parameter\">alignment</"
"replaceable>, and <replaceable class=\"parameter\">storage</replaceable> are "
"copied from that type, unless overridden by explicit specification elsewhere "
"in this <command>CREATE TYPE</command> command."
msgstr ""
"Имя существующего типа данных, от которого новый тип получит свойства "
"представления. Из этого типа будут скопированы значения параметров "
"<replaceable class=\"parameter\">internallength</replaceable>, <replaceable "
"class=\"parameter\">passedbyvalue</replaceable>, <replaceable class="
"\"parameter\">alignment</replaceable> и <replaceable class=\"parameter"
"\">storage</replaceable>, если их не переопределят явные указания, заданные "
"дополнительно в этой команде <command>CREATE TYPE</command>."

#: ref/create_type.xml:709(para)
msgid ""
"The category code (a single ASCII character) for this type. The default is "
"<literal>'U'</literal> for <quote>user-defined type</quote>. Other standard "
"category codes can be found in <xref linkend=\"catalog-typcategory-table\"/"
">. You may also choose other ASCII characters in order to create custom "
"categories."
msgstr ""
"Код категории (один символ ASCII) для этого типа. По умолчанию "
"подразумевается <literal>'U'</literal> (что означает пользовательский тип, "
"<quote>User-defined</quote>). Коды других стандартных категорий можно найти "
"в <xref remap=\"6\" linkend=\"catalog-typcategory-table\"/>. Для "
"нестандартных категорий можно выбрать другие ASCII-символы."

#: ref/create_type.xml:722(para)
msgid ""
"True if this type is a preferred type within its type category, else false. "
"The default is false. Be very careful about creating a new preferred type "
"within an existing type category, as this could cause surprising changes in "
"behavior."
msgstr ""
"Если значение этого параметра равно true, создаваемый тип будет "
"предпочитаемым в своей категории. По умолчанию подразумевается false. Будьте "
"очень осторожны, создавая новый предпочитаемый тип в существующей категории, "
"так как это может поменять поведение выражений неожиданным образом."

#: ref/create_type.xml:734(para)
msgid ""
"The default value for the data type. If this is omitted, the default is null."
msgstr ""
"Значение по умолчанию для создаваемого типа данных. Если не указано, "
"значением по умолчанию будет NULL."

#: ref/create_type.xml:744(para)
msgid ""
"The type being created is an array; this specifies the type of the array "
"elements."
msgstr ""
"Создаваемый тип будет массивом; этот параметр определяет тип элементов "
"массива."

#: ref/create_type.xml:754(para)
msgid ""
"The delimiter character to be used between values in arrays made of this "
"type."
msgstr ""
"Символ, разделяющий значения в массивах, образованных из значений "
"создаваемого типа."

#: ref/create_type.xml:764(para)
msgid ""
"True if this type's operations can use collation information. The default is "
"false."
msgstr ""
"Если значение этого параметра равно true, в операциях с создаваемым типом "
"может учитываться информация о правилах сортировки. По умолчанию "
"подразумевается false."

#: ref/create_type.xml:774(title)
msgid "Notes"
msgstr "Замечания"

#: ref/create_type.xml:776(para)
msgid ""
"Because there are no restrictions on use of a data type once it's been "
"created, creating a base type or range type is tantamount to granting public "
"execute permission on the functions mentioned in the type definition. This "
"is usually not an issue for the sorts of functions that are useful in a type "
"definition. But you might want to think twice before designing a type in a "
"way that would require <quote>secret</quote> information to be used while "
"converting it to or from external form."
msgstr ""
"Так как на использование типа данных после создания не накладываются "
"ограничения, объявление базового типа или типа-диапазона по сути даёт всем "
"право на выполнение функций, упомянутых в определении типа. Обычно это не "
"проблема для таких функций, какие бывают полезны в определении типов. Но "
"прежде чем создать тип, преобразование которого во внешнюю форму и обратно "
"будет использовать <quote>секретную</quote> информацию, стоит подумать "
"дважды."

#: ref/create_type.xml:787(para)
msgid ""
"Before <productname>PostgreSQL</productname> version 8.3, the name of a "
"generated array type was always exactly the element type's name with one "
"underscore character (<literal>_</literal>) prepended. (Type names were "
"therefore restricted in length to one less character than other names.) "
"While this is still usually the case, the array type name may vary from this "
"in case of maximum-length names or collisions with user type names that "
"begin with underscore. Writing code that depends on this convention is "
"therefore deprecated. Instead, use <structname>pg_type</structname>."
"<structfield>typarray</structfield> to locate the array type associated with "
"a given type."
msgstr ""
"В <productname>PostgreSQL</productname> до версии 8.3 имя генерируемого типа-"
"массива всегда образовалось из имени типа элемента и добавленного спереди "
"символа подчёркивания (<literal>_</literal>). (Таким образом, допустимая "
"максимальная длина имени типа была на символ меньше, чем длины других имён.) "
"Хотя и сейчас имя типа массива чаще всего образуется таким образом, оно "
"может быть и другим в случае достижения максимальной длины или конфликтов с "
"именами пользовательских типов, начинающихся с подчёркивания. Поэтому "
"полагаться на это соглашение в коде не рекомендуется. Вместо этого, имя типа "
"массива, связанного с данным типом, следует определять по значению "
"<structname>pg_type</structname>.<structfield>typarray</structfield>."

#: ref/create_type.xml:800(para)
msgid ""
"It may be advisable to avoid using type and table names that begin with "
"underscore. While the server will change generated array type names to avoid "
"collisions with user-given names, there is still risk of confusion, "
"particularly with old client software that may assume that type names "
"beginning with underscores always represent arrays."
msgstr ""
"Вообще же можно посоветовать не использовать имена типов и таблиц, "
"начинающиеся с подчёркивания. Хотя сервер сможет сгенерировать другое имя, "
"не конфликтующее с пользовательским, некоторая путаница всё же возможна, "
"особенно со старыми клиентскими приложениями, которые могут полагать, что "
"имя типа, начинающееся с подчёркивания, всегда относится к типу массива."

#: ref/create_type.xml:808(para)
msgid ""
"Before <productname>PostgreSQL</productname> version 8.2, the shell-type "
"creation syntax <literal>CREATE TYPE <replaceable>name</replaceable></"
"literal> did not exist. The way to create a new base type was to create its "
"input function first. In this approach, <productname>PostgreSQL</"
"productname> will first see the name of the new data type as the return type "
"of the input function. The shell type is implicitly created in this "
"situation, and then it can be referenced in the definitions of the remaining "
"I/O functions. This approach still works, but is deprecated and might be "
"disallowed in some future release. Also, to avoid accidentally cluttering "
"the catalogs with shell types as a result of simple typos in function "
"definitions, a shell type will only be made this way when the input function "
"is written in C."
msgstr ""
"В <productname>PostgreSQL</productname> до версии 8.2 у <literal>CREATE TYPE "
"<replaceable>name</replaceable></literal> отсутствовала форма для создания "
"типа-пустышки. Поэтому для создания нового базового типа требовалось сначала "
"создать функцию ввода. При таком подходе <productname>PostgreSQL</"
"productname> воспринимал тип возврата функции ввода как имя нового типа "
"данных и неявно создавал тип-пустышку, на который затем можно было ссылаться "
"в определениях остальных функций ввода/вывода. Этот подход по-прежнему "
"работает, но считается устаревшим и может быть запрещён в будущих версиях. "
"Кроме того, во избежание непреднамеренного заполнения каталогов типами-"
"пустышками, появляющимися в результате простых опечаток в определении "
"функций, тип-пустышка будет создаваться таким образом, только если функция "
"ввода написана на C."

#: ref/create_type.xml:824(para)
msgid ""
"In <productname>PostgreSQL</productname> versions before 7.3, it was "
"customary to avoid creating a shell type at all, by replacing the functions' "
"forward references to the type name with the placeholder pseudotype "
"<type>opaque</type>. The <type>cstring</type> arguments and results also had "
"to be declared as <type>opaque</type> before 7.3. To support loading of old "
"dump files, <command>CREATE TYPE</command> will accept I/O functions "
"declared using <type>opaque</type>, but it will issue a notice and change "
"the function declarations to use the correct types."
msgstr ""
"В <productname>PostgreSQL</productname> до версии 7.3 было принято вовсе не "
"создавать тип-пустышку, заменяя в определении функций ссылки на ещё не "
"созданный тип именем псевдотипа <type>opaque</type>. Аргументы "
"<type>cstring</type> и результаты так же должны были объявляться как "
"<type>opaque</type> до версии 7.3. Для поддержки загрузки старых файлов "
"экспорта БД, <command>CREATE TYPE</command> примет ссылки на функции ввода/"
"вывода, объявленные с типом <type>opaque</type>, но при этом выдаст "
"замечание и изменит в объявлении функции псевдотип на правильный."

#: ref/create_type.xml:839(title)
msgid "Examples"
msgstr "Примеры"

#: ref/create_type.xml:844(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE compfoo AS (f1 int, f2 text);\n"
"\n"
"CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$\n"
"    SELECT fooid, fooname FROM foo\n"
"$$ LANGUAGE SQL;"
msgstr ""
"CREATE TYPE compfoo AS (f1 int, f2 text);\n"
"\n"
"CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$\n"
"    SELECT fooid, fooname FROM foo\n"
"$$ LANGUAGE SQL;"

#: ref/create_type.xml:841(para)
msgid ""
"This example creates a composite type and uses it in a function definition: "
"<placeholder-1/>"
msgstr ""
"В этом примере создаётся составной тип, а затем он используется в "
"определении функции: <placeholder-1/>"

#: ref/create_type.xml:856(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');\n"
"\n"
"CREATE TABLE bug (\n"
"    id serial,\n"
"    description text,\n"
"    status bug_status\n"
");"
msgstr ""
"CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');\n"
"\n"
"CREATE TABLE bug (\n"
"    id serial,\n"
"    description text,\n"
"    status bug_status\n"
");"

#: ref/create_type.xml:853(para)
msgid ""
"This example creates an enumerated type and uses it in a table definition: "
"<placeholder-1/>"
msgstr ""
"В этом примере создаётся тип-перечисление, а затем он используется в "
"определении таблицы: <placeholder-1/>"

#: ref/create_type.xml:869(programlisting)
#, no-wrap
msgid "CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);"
msgstr "CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);"

#: ref/create_type.xml:867(para)
msgid "This example creates a range type: <placeholder-1/>"
msgstr "В этом примере создаётся тип-диапазон: <placeholder-1/>"

#: ref/create_type.xml:877(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE box;\n"
"\n"
"CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;\n"
"CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;\n"
"\n"
"CREATE TYPE box (\n"
"    INTERNALLENGTH = 16,\n"
"    INPUT = my_box_in_function,\n"
"    OUTPUT = my_box_out_function\n"
");\n"
"\n"
"CREATE TABLE myboxes (\n"
"    id integer,\n"
"    description box\n"
");"
msgstr ""
"CREATE TYPE box;\n"
"\n"
"CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;\n"
"CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;\n"
"\n"
"CREATE TYPE box (\n"
"    INTERNALLENGTH = 16,\n"
"    INPUT = my_box_in_function,\n"
"    OUTPUT = my_box_out_function\n"
");\n"
"\n"
"CREATE TABLE myboxes (\n"
"    id integer,\n"
"    description box\n"
");"

#: ref/create_type.xml:874(para)
msgid ""
"This example creates the base data type <type>box</type> and then uses the "
"type in a table definition: <placeholder-1/>"
msgstr ""
"В следующем примере создаётся базовый тип данных <type>box</type>, а затем "
"он используется в определении таблицы: <placeholder-1/>"

#: ref/create_type.xml:899(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE box (\n"
"    INTERNALLENGTH = 16,\n"
"    INPUT = my_box_in_function,\n"
"    OUTPUT = my_box_out_function,\n"
"    ELEMENT = float4\n"
");"
msgstr ""
"CREATE TYPE box (\n"
"    INTERNALLENGTH = 16,\n"
"    INPUT = my_box_in_function,\n"
"    OUTPUT = my_box_out_function,\n"
"    ELEMENT = float4\n"
");"

#: ref/create_type.xml:896(para)
msgid ""
"If the internal structure of <type>box</type> were an array of four "
"<type>float4</type> elements, we might instead use: <placeholder-1/> which "
"would allow a box value's component numbers to be accessed by subscripting. "
"Otherwise the type behaves the same as before."
msgstr ""
"Если бы внутренней структурой <type>box</type> был массив из четырёх "
"элементов <type>float4</type>, вместо этого можно было бы использовать "
"определение: <placeholder-1/> В таком случае к числам, составляющим значение "
"этого типа, можно было бы обращаться по индексу. В остальном поведение этого "
"типа будет таким же."

#: ref/create_type.xml:914(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE bigobj (\n"
"    INPUT = lo_filein, OUTPUT = lo_fileout,\n"
"    INTERNALLENGTH = VARIABLE\n"
");\n"
"CREATE TABLE big_objs (\n"
"    id integer,\n"
"    obj bigobj\n"
");"
msgstr ""
"CREATE TYPE bigobj (\n"
"    INPUT = lo_filein, OUTPUT = lo_fileout,\n"
"    INTERNALLENGTH = VARIABLE\n"
");\n"
"CREATE TABLE big_objs (\n"
"    id integer,\n"
"    obj bigobj\n"
");"

#: ref/create_type.xml:911(para)
msgid ""
"This example creates a large object type and uses it in a table definition: "
"<placeholder-1/>"
msgstr ""
"В этом примере создаётся тип большого объекта, а затем он используется в "
"определении таблицы: <placeholder-1/>"

#: ref/create_type.xml:926(para)
msgid ""
"More examples, including suitable input and output functions, are in <xref "
"linkend=\"xtypes\"/>."
msgstr ""
"Другие примеры, в том числе демонстрирующие подходящие функции ввода/вывода, "
"можно найти в <xref remap=\"6\" linkend=\"xtypes\"/>."

#: ref/create_type.xml:933(title)
msgid "Compatibility"
msgstr "Совместимость"

#: ref/create_type.xml:935(para)
msgid ""
"The first form of the <command>CREATE TYPE</command> command, which creates "
"a composite type, conforms to the <acronym>SQL</acronym> standard. The other "
"forms are <productname>PostgreSQL</productname> extensions. The "
"<command>CREATE TYPE</command> statement in the <acronym>SQL</acronym> "
"standard also defines other forms that are not implemented in "
"<productname>PostgreSQL</productname>."
msgstr ""
"Первая форма команды <command>CREATE TYPE</command>, создающая составной "
"тип, соответствует стандарту <acronym>SQL</acronym>. Другие формы являются "
"расширениями <productname>PostgreSQL</productname>. Для оператора "
"<command>CREATE TYPE</command> в стандарте <acronym>SQL</acronym> также "
"определены другие формы, не реализованные в <productname>PostgreSQL</"
"productname>."

#: ref/create_type.xml:944(para)
msgid ""
"The ability to create a composite type with zero attributes is a "
"<productname>PostgreSQL</productname>-specific deviation from the standard "
"(analogous to the same case in <command>CREATE TABLE</command>)."
msgstr ""
"Возможность создавать составной тип без атрибутов — специфическое отклонение "
"<productname>PostgreSQL</productname> от стандарта (как и аналогичная "
"особенность команды <command>CREATE TABLE</command>)."

#: ref/create_type.xml:952(title)
msgid "See Also"
msgstr "См. также"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: ref/create_type.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
