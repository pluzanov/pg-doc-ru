# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-09 11:03+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: ref/create_aggregate.xml:8(indexterm)
msgid "<primary>CREATE AGGREGATE</primary>"
msgstr "<primary>CREATE AGGREGATE</primary>"

#: ref/create_aggregate.xml:13(refentrytitle)
msgctxt "refentrytitle"
msgid "CREATE AGGREGATE"
msgstr "CREATE AGGREGATE"

#: ref/create_aggregate.xml:14(manvolnum)
msgid "7"
msgstr "7"

#: ref/create_aggregate.xml:15(refmiscinfo)
msgid "SQL - Language Statements"
msgstr "Операторы языка SQL"

#: ref/create_aggregate.xml:19(refname)
msgctxt "refname"
msgid "CREATE AGGREGATE"
msgstr "CREATE AGGREGATE"

#: ref/create_aggregate.xml:20(refpurpose)
msgid "define a new aggregate function"
msgstr "создать агрегатную функцию"

#: ref/create_aggregate.xml:24(replaceable)
#: ref/create_aggregate.xml:45(replaceable)
#: ref/create_aggregate.xml:59(replaceable)
#: ref/create_aggregate.xml:264(replaceable)
msgid "name"
msgstr "имя"

#: ref/create_aggregate.xml:24(replaceable)
#: ref/create_aggregate.xml:45(replaceable)
#: ref/create_aggregate.xml:46(replaceable)
#: ref/create_aggregate.xml:274(replaceable)
msgid "argmode"
msgstr "режим_аргумента"

#: ref/create_aggregate.xml:24(replaceable)
#: ref/create_aggregate.xml:45(replaceable)
#: ref/create_aggregate.xml:46(replaceable)
#: ref/create_aggregate.xml:287(replaceable)
msgid "argname"
msgstr "имя_аргумента"

#: ref/create_aggregate.xml:24(replaceable)
#: ref/create_aggregate.xml:45(replaceable)
#: ref/create_aggregate.xml:46(replaceable)
#: ref/create_aggregate.xml:298(replaceable)
msgid "arg_data_type"
msgstr "тип_данных_аргумента"

#: ref/create_aggregate.xml:25(replaceable)
#: ref/create_aggregate.xml:47(replaceable)
#: ref/create_aggregate.xml:61(replaceable)
#: ref/create_aggregate.xml:325(replaceable)
msgid "sfunc"
msgstr "функция_состояния"

#: ref/create_aggregate.xml:26(replaceable)
#: ref/create_aggregate.xml:48(replaceable)
#: ref/create_aggregate.xml:62(replaceable)
#: ref/create_aggregate.xml:351(replaceable)
msgid "state_data_type"
msgstr "тип_данных_состояния"

#: ref/create_aggregate.xml:27(replaceable)
#: ref/create_aggregate.xml:49(replaceable)
#: ref/create_aggregate.xml:63(replaceable)
#: ref/create_aggregate.xml:360(replaceable)
msgid "state_data_size"
msgstr "размер_данных_состояния"

#: ref/create_aggregate.xml:28(replaceable)
#: ref/create_aggregate.xml:50(replaceable)
#: ref/create_aggregate.xml:64(replaceable)
#: ref/create_aggregate.xml:376(replaceable)
msgid "ffunc"
msgstr "функция_завершения"

#: ref/create_aggregate.xml:30(replaceable)
#: ref/create_aggregate.xml:66(replaceable)
#: ref/create_aggregate.xml:409(replaceable)
msgid "combinefunc"
msgstr "комбинирующая_функция"

#: ref/create_aggregate.xml:31(replaceable)
#: ref/create_aggregate.xml:67(replaceable)
#: ref/create_aggregate.xml:452(replaceable)
msgid "serialfunc"
msgstr "функция_сериализации"

#: ref/create_aggregate.xml:32(replaceable)
#: ref/create_aggregate.xml:68(replaceable)
#: ref/create_aggregate.xml:469(replaceable)
msgid "deserialfunc"
msgstr "функция_десериализации"

#: ref/create_aggregate.xml:33(replaceable)
#: ref/create_aggregate.xml:52(replaceable)
#: ref/create_aggregate.xml:69(replaceable)
#: ref/create_aggregate.xml:483(replaceable)
msgid "initial_condition"
msgstr "начальное_условие"

#: ref/create_aggregate.xml:34(replaceable)
#: ref/create_aggregate.xml:70(replaceable)
#: ref/create_aggregate.xml:495(replaceable)
msgid "msfunc"
msgstr "функция_состояния_движ"

#: ref/create_aggregate.xml:35(replaceable)
#: ref/create_aggregate.xml:71(replaceable)
#: ref/create_aggregate.xml:508(replaceable)
msgid "minvfunc"
msgstr "обратная_функция_движ"

#: ref/create_aggregate.xml:36(replaceable)
#: ref/create_aggregate.xml:72(replaceable)
#: ref/create_aggregate.xml:522(replaceable)
msgid "mstate_data_type"
msgstr "тип_данных_состояния_движ"

#: ref/create_aggregate.xml:37(replaceable)
#: ref/create_aggregate.xml:73(replaceable)
#: ref/create_aggregate.xml:532(replaceable)
msgid "mstate_data_size"
msgstr "размер_данных_состояния_движ"

#: ref/create_aggregate.xml:38(replaceable)
#: ref/create_aggregate.xml:74(replaceable)
#: ref/create_aggregate.xml:543(replaceable)
msgid "mffunc"
msgstr "функция_завершения_движ"

#: ref/create_aggregate.xml:40(replaceable)
#: ref/create_aggregate.xml:76(replaceable)
#: ref/create_aggregate.xml:560(replaceable)
msgid "minitial_condition"
msgstr "начальное_условие_движ"

#: ref/create_aggregate.xml:41(replaceable)
#: ref/create_aggregate.xml:77(replaceable)
#: ref/create_aggregate.xml:570(replaceable)
msgid "sort_operator"
msgstr "оператор_сортировки"

#: ref/create_aggregate.xml:57(phrase)
msgid "or the old syntax"
msgstr "или старый синтаксис"

#: ref/create_aggregate.xml:60(replaceable)
#: ref/create_aggregate.xml:310(replaceable)
msgid "base_type"
msgstr "базовый_тип"

#: ref/create_aggregate.xml:24(synopsis)
#, no-wrap
msgid ""
"CREATE AGGREGATE <placeholder-1/> ( [ <placeholder-2/> ] [ <placeholder-3/> ] <placeholder-4/> [ , ... ] ) (\n"
"    SFUNC = <placeholder-5/>,\n"
"    STYPE = <placeholder-6/>\n"
"    [ , SSPACE = <placeholder-7/> ]\n"
"    [ , FINALFUNC = <placeholder-8/> ]\n"
"    [ , FINALFUNC_EXTRA ]\n"
"    [ , COMBINEFUNC = <placeholder-9/> ]\n"
"    [ , SERIALFUNC = <placeholder-10/> ]\n"
"    [ , DESERIALFUNC = <placeholder-11/> ]\n"
"    [ , INITCOND = <placeholder-12/> ]\n"
"    [ , MSFUNC = <placeholder-13/> ]\n"
"    [ , MINVFUNC = <placeholder-14/> ]\n"
"    [ , MSTYPE = <placeholder-15/> ]\n"
"    [ , MSSPACE = <placeholder-16/> ]\n"
"    [ , MFINALFUNC = <placeholder-17/> ]\n"
"    [ , MFINALFUNC_EXTRA ]\n"
"    [ , MINITCOND = <placeholder-18/> ]\n"
"    [ , SORTOP = <placeholder-19/> ]\n"
"    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]\n"
")\n"
"\n"
"CREATE AGGREGATE <placeholder-20/> ( [ [ <placeholder-21/> ] [ <placeholder-22/> ] <placeholder-23/> [ , ... ] ]\n"
"                        ORDER BY [ <placeholder-24/> ] [ <placeholder-25/> ] <placeholder-26/> [ , ... ] ) (\n"
"    SFUNC = <placeholder-27/>,\n"
"    STYPE = <placeholder-28/>\n"
"    [ , SSPACE = <placeholder-29/> ]\n"
"    [ , FINALFUNC = <placeholder-30/> ]\n"
"    [ , FINALFUNC_EXTRA ]\n"
"    [ , INITCOND = <placeholder-31/> ]\n"
"    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]\n"
"    [ , HYPOTHETICAL ]\n"
")\n"
"\n"
"<placeholder-32/>\n"
"\n"
"CREATE AGGREGATE <placeholder-33/> (\n"
"    BASETYPE = <placeholder-34/>,\n"
"    SFUNC = <placeholder-35/>,\n"
"    STYPE = <placeholder-36/>\n"
"    [ , SSPACE = <placeholder-37/> ]\n"
"    [ , FINALFUNC = <placeholder-38/> ]\n"
"    [ , FINALFUNC_EXTRA ]\n"
"    [ , COMBINEFUNC = <placeholder-39/> ]\n"
"    [ , SERIALFUNC = <placeholder-40/> ]\n"
"    [ , DESERIALFUNC = <placeholder-41/> ]\n"
"    [ , INITCOND = <placeholder-42/> ]\n"
"    [ , MSFUNC = <placeholder-43/> ]\n"
"    [ , MINVFUNC = <placeholder-44/> ]\n"
"    [ , MSTYPE = <placeholder-45/> ]\n"
"    [ , MSSPACE = <placeholder-46/> ]\n"
"    [ , MFINALFUNC = <placeholder-47/> ]\n"
"    [ , MFINALFUNC_EXTRA ]\n"
"    [ , MINITCOND = <placeholder-48/> ]\n"
"    [ , SORTOP = <placeholder-49/> ]\n"
")"
msgstr ""
"CREATE AGGREGATE <placeholder-1/> ( [ <placeholder-2/> ] [ <placeholder-3/> ] <placeholder-4/> [ , ... ] ) (\n"
"    SFUNC = <placeholder-5/>,\n"
"    STYPE = <placeholder-6/>\n"
"    [ , SSPACE = <placeholder-7/> ]\n"
"    [ , FINALFUNC = <placeholder-8/> ]\n"
"    [ , FINALFUNC_EXTRA ]\n"
"    [ , COMBINEFUNC = <placeholder-9/> ]\n"
"    [ , SERIALFUNC = <placeholder-10/> ]\n"
"    [ , DESERIALFUNC = <placeholder-11/> ]\n"
"    [ , INITCOND = <placeholder-12/> ]\n"
"    [ , MSFUNC = <placeholder-13/> ]\n"
"    [ , MINVFUNC = <placeholder-14/> ]\n"
"    [ , MSTYPE = <placeholder-15/> ]\n"
"    [ , MSSPACE = <placeholder-16/> ]\n"
"    [ , MFINALFUNC = <placeholder-17/> ]\n"
"    [ , MFINALFUNC_EXTRA ]\n"
"    [ , MINITCOND = <placeholder-18/> ]\n"
"    [ , SORTOP = <placeholder-19/> ]\n"
"    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]\n"
")\n"
"\n"
"CREATE AGGREGATE <placeholder-20/> ( [ [ <placeholder-21/> ] [ <placeholder-22/> ] <placeholder-23/> [ , ... ] ]\n"
"                        ORDER BY [ <placeholder-24/> ] [ <placeholder-25/> ] <placeholder-26/> [ , ... ] ) (\n"
"    SFUNC = <placeholder-27/>,\n"
"    STYPE = <placeholder-28/>\n"
"    [ , SSPACE = <placeholder-29/> ]\n"
"    [ , FINALFUNC = <placeholder-30/> ]\n"
"    [ , FINALFUNC_EXTRA ]\n"
"    [ , INITCOND = <placeholder-31/> ]\n"
"    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]\n"
"    [ , HYPOTHETICAL ]\n"
")\n"
"\n"
"<placeholder-32/>\n"
"\n"
"CREATE AGGREGATE <placeholder-33/> (\n"
"    BASETYPE = <placeholder-34/>,\n"
"    SFUNC = <placeholder-35/>,\n"
"    STYPE = <placeholder-36/>\n"
"    [ , SSPACE = <placeholder-37/> ]\n"
"    [ , FINALFUNC = <placeholder-38/> ]\n"
"    [ , FINALFUNC_EXTRA ]\n"
"    [ , COMBINEFUNC = <placeholder-39/> ]\n"
"    [ , SERIALFUNC = <placeholder-40/> ]\n"
"    [ , DESERIALFUNC = <placeholder-41/> ]\n"
"    [ , INITCOND = <placeholder-42/> ]\n"
"    [ , MSFUNC = <placeholder-43/> ]\n"
"    [ , MINVFUNC = <placeholder-44/> ]\n"
"    [ , MSTYPE = <placeholder-45/> ]\n"
"    [ , MSSPACE = <placeholder-46/> ]\n"
"    [ , MFINALFUNC = <placeholder-47/> ]\n"
"    [ , MFINALFUNC_EXTRA ]\n"
"    [ , MINITCOND = <placeholder-48/> ]\n"
"    [ , SORTOP = <placeholder-49/> ]\n"
")"

#: ref/create_aggregate.xml:82(title)
msgid "Description"
msgstr "Описание"

#: ref/create_aggregate.xml:84(para)
msgid ""
"<command>CREATE AGGREGATE</command> defines a new aggregate function. Some "
"basic and commonly-used aggregate functions are included with the "
"distribution; they are documented in <xref linkend=\"functions-aggregate\"/"
">. If one defines new types or needs an aggregate function not already "
"provided, then <command>CREATE AGGREGATE</command> can be used to provide "
"the desired features."
msgstr ""
"<command>CREATE AGGREGATE</command> создаёт новую агрегатную функцию. "
"Некоторое количество базовых и часто используемых агрегатных функций "
"включено в дистрибутив, они описаны в <xref remap=\"6\" linkend=\"functions-"
"aggregate\"/>. Но если нужно адаптировать их к новым типам или создать "
"недостающие агрегатные функции, это можно сделать с помощью команды "
"<command>CREATE AGGREGATE</command>."

#: ref/create_aggregate.xml:93(para)
msgid ""
"If a schema name is given (for example, <literal>CREATE AGGREGATE myschema."
"myagg ...</literal>) then the aggregate function is created in the specified "
"schema. Otherwise it is created in the current schema."
msgstr ""
"Если указывается имя схемы (например, <literal>CREATE AGGREGATE myschema."
"myagg ...</literal>), агрегатная функция создаётся в указанной схеме. В "
"противном случае она создаётся в текущей схеме."

#: ref/create_aggregate.xml:99(para)
msgid ""
"An aggregate function is identified by its name and input data type(s). Two "
"aggregates in the same schema can have the same name if they operate on "
"different input types. The name and input data type(s) of an aggregate must "
"also be distinct from the name and input data type(s) of every ordinary "
"function in the same schema. This behavior is identical to overloading of "
"ordinary function names (see <xref linkend=\"sql-createfunction\"/>)."
msgstr ""
"Агрегатная функция идентифицируется по имени и типам входных данных. Две "
"агрегатных функции в одной схеме могут иметь одно имя, только если они "
"работают с разными типами данных. Имя и тип(ы) входных данных агрегата не "
"могут совпадать с именем и типами данных любой другой обычной функции в той "
"же схеме. Это же правило действует при перегрузке имён обычных функций (см. "
"<xref remap=\"4\" linkend=\"sql-createfunction\"/>)."

#: ref/create_aggregate.xml:118(programlisting)
#, no-wrap
msgid ""
"<replaceable class=\"parameter\">sfunc</replaceable>( internal-state, next-data-values ) ---&gt; next-internal-state\n"
"<replaceable class=\"parameter\">ffunc</replaceable>( internal-state ) ---&gt; aggregate-value"
msgstr ""
"<replaceable class=\"parameter\">функция_состояния</replaceable>( внутреннее-состояние, следующие-значения-данных ) ---&gt; следующее-внутреннее-состояние\n"
"<replaceable class=\"parameter\">функция_завершения</replaceable>( внутреннее-состояние ) ---&gt; агрегатное_значение"

#: ref/create_aggregate.xml:110(para)
msgid ""
"A simple aggregate function is made from one or two ordinary functions: a "
"state transition function <replaceable class=\"parameter\">sfunc</"
"replaceable>, and an optional final calculation function <replaceable class="
"\"parameter\">ffunc</replaceable>. These are used as follows: <placeholder-1/"
">"
msgstr ""
"Простую агрегатную функцию образуют одна или две обычные функции: функция "
"перехода состояния <replaceable class=\"parameter\">функция_состояния</"
"replaceable> и необязательная функция окончательного вычисления <replaceable "
"class=\"parameter\">функция_завершения</replaceable>. Они используются "
"следующим образом: <placeholder-1/>"

#: ref/create_aggregate.xml:122(para)
msgid ""
"<productname>PostgreSQL</productname> creates a temporary variable of data "
"type <replaceable class=\"parameter\">stype</replaceable> to hold the "
"current internal state of the aggregate. At each input row, the aggregate "
"argument value(s) are calculated and the state transition function is "
"invoked with the current state value and the new argument value(s) to "
"calculate a new internal state value. After all the rows have been "
"processed, the final function is invoked once to calculate the aggregate's "
"return value. If there is no final function then the ending state value is "
"returned as-is."
msgstr ""
"<productname>PostgreSQL</productname> создаёт временную переменную типа "
"<replaceable class=\"parameter\">тип_данных_состояния</replaceable> для "
"хранения текущего внутреннего состояния агрегата. Затем для каждой "
"поступающей строки вычисляются значения аргументов агрегата и вызывается "
"функция перехода состояния с текущим значением состояния и полученными "
"аргументами; эта функция вычисляет следующее внутреннее состояние. Когда "
"таким образом будут обработаны все строки, вызывается завершающая функция, "
"которая должна вычислить возвращаемое значение агрегата. Если функция "
"завершения отсутствует, просто возвращается конечное значение состояния."

#: ref/create_aggregate.xml:135(para)
msgid ""
"An aggregate function can provide an initial condition, that is, an initial "
"value for the internal state value. This is specified and stored in the "
"database as a value of type <type>text</type>, but it must be a valid "
"external representation of a constant of the state value data type. If it is "
"not supplied then the state value starts out null."
msgstr ""
"Агрегатная функция может определить начальное условие, то есть начальное "
"значение для внутренней переменной состояния. Это значение задаётся и "
"сохраняется в базе данных в виде строки типа <type>text</type>, но оно "
"должно быть допустимым внешним представлением константы типа данных "
"переменной состояния. По умолчанию начальным значением состояния считается "
"NULL."

#: ref/create_aggregate.xml:144(para)
msgid ""
"If the state transition function is declared <quote>strict</quote>, then it "
"cannot be called with null inputs. With such a transition function, "
"aggregate execution behaves as follows. Rows with any null input values are "
"ignored (the function is not called and the previous state value is "
"retained). If the initial state value is null, then at the first row with "
"all-nonnull input values, the first argument value replaces the state value, "
"and the transition function is invoked at each subsequent row with all-"
"nonnull input values. This is handy for implementing aggregates like "
"<function>max</function>. Note that this behavior is only available when "
"<replaceable class=\"parameter\">state_data_type</replaceable> is the same "
"as the first <replaceable class=\"parameter\">arg_data_type</replaceable>. "
"When these types are different, you must supply a nonnull initial condition "
"or use a nonstrict transition function."
msgstr ""
"Если функция перехода состояния объявлена как <quote>strict</quote> "
"(строгая), её нельзя вызывать с входными значениями NULL. В этом случае "
"агрегатная функция выполняется следующим образом. Строки со значениями NULL "
"игнорируются (функция перехода не вызывается и предыдущее значение состояния "
"не меняется) и если начальное состояние равно NULL, то в первой же строке, в "
"которой все входные значения не NULL, первый аргумент заменяет значение "
"состояния, а функция перехода вызывается для каждой последующей строки, в "
"которой все входные значения не NULL. Это поведение удобно для реализации "
"таких агрегатных функций, как <function>max</function>. Заметьте, что такое "
"поведение возможно, только если <replaceable class=\"parameter"
"\">тип_данных_состояния</replaceable> совпадает с первым <replaceable class="
"\"parameter\">типом_данных_аргумента</replaceable>. Если же эти типы "
"различаются, необходимо задать начальное условие не NULL или использовать "
"нестрогую функцию перехода состояния."

#: ref/create_aggregate.xml:162(para)
msgid ""
"If the state transition function is not strict, then it will be called "
"unconditionally at each input row, and must deal with null inputs and null "
"state values for itself. This allows the aggregate author to have full "
"control over the aggregate's handling of null values."
msgstr ""
"Если функция перехода состояния не является строгой, она вызывается "
"безусловно для каждой поступающей строки и должна сама обрабатывать вводимые "
"значения и переменную состояния, равные NULL. Это позволяет разработчику "
"агрегатной функции полностью управлять тем, как она воспринимает значения "
"NULL."

#: ref/create_aggregate.xml:169(para)
msgid ""
"If the final function is declared <quote>strict</quote>, then it will not be "
"called when the ending state value is null; instead a null result will be "
"returned automatically. (Of course this is just the normal behavior of "
"strict functions.) In any case the final function has the option of "
"returning a null value. For example, the final function for <function>avg</"
"function> returns null when it sees there were zero input rows."
msgstr ""
"Если функция завершения объявлена как <quote>strict</quote> (строгая), она "
"не будет вызвана при конечном значении состояния, равном NULL; вместо этого "
"автоматически возвращается результат NULL. (Разумеется, это вполне "
"нормальное поведение для строгих функций.) Когда функция завершения "
"вызывается, она в любом случае может возвратить значение NULL. Например, "
"функция завершения для <function>avg</function> возвращает NULL, если "
"определяет, что было обработано ноль строк."

#: ref/create_aggregate.xml:179(para)
msgid ""
"Sometimes it is useful to declare the final function as taking not just the "
"state value, but extra parameters corresponding to the aggregate's input "
"values. The main reason for doing this is if the final function is "
"polymorphic and the state value's data type would be inadequate to pin down "
"the result type. These extra parameters are always passed as NULL (and so "
"the final function must not be strict when the <literal>FINALFUNC_EXTRA</"
"literal> option is used), but nonetheless they are valid parameters. The "
"final function could for example make use of <function>get_fn_expr_argtype</"
"function> to identify the actual argument type in the current call."
msgstr ""
"Иногда бывает полезно объявить функцию завершения как принимающую не только "
"состояние, но и дополнительные параметры, соответствующие входным данным "
"агрегата. В основном это имеет смысл для полиморфных функций завершения, "
"которым может быть недостаточно знать тип данных только переменной "
"состояния, чтобы вывести тип результата. Эти дополнительные параметры всегда "
"передаются как NULL (так что функция завершения не должна быть строгой, "
"когда применяется <literal>FINALFUNC_EXTRA</literal>), но в остальном это "
"обычные параметры. Функция завершения может выяснить фактические типы "
"аргументов в текущем вызове, воспользовавшись системным вызовом "
"<function>get_fn_expr_argtype</function>."

#: ref/create_aggregate.xml:192(para)
msgid ""
"An aggregate can optionally support <firstterm>moving-aggregate mode</"
"firstterm>, as described in <xref linkend=\"xaggr-moving-aggregates\"/>. "
"This requires specifying the <literal>MSFUNC</literal>, <literal>MINVFUNC</"
"literal>, and <literal>MSTYPE</literal> parameters, and optionally the "
"<literal>MSPACE</literal>, <literal>MFINALFUNC</literal>, "
"<literal>MFINALFUNC_EXTRA</literal>, and <literal>MINITCOND</literal> "
"parameters. Except for <literal>MINVFUNC</literal>, these parameters work "
"like the corresponding simple-aggregate parameters without <literal>M</"
"literal>; they define a separate implementation of the aggregate that "
"includes an inverse transition function."
msgstr ""
"Агрегатная функция может дополнительно поддерживать <firstterm>режим "
"движущегося агрегата</firstterm>, как описано в <xref remap=\"6\" linkend="
"\"xaggr-moving-aggregates\"/>. Для применения этого режима требуется указать "
"параметры <literal>MSFUNC</literal>, <literal>MINVFUNC</literal> и "
"<literal>MSTYPE</literal>, а также, возможно, параметры <literal>MSPACE</"
"literal>, <literal>MFINALFUNC</literal>, <literal>MFINALFUNC_EXTRA</literal> "
"и <literal>MINITCOND</literal>. За исключением <literal>MINVFUNC</literal>, "
"эти параметры работают как соответствующие параметры простого агрегата без "
"начальной буквы <literal>M</literal>; они определяют отдельную реализацию "
"агрегата, включающую функцию обратного перехода."

#: ref/create_aggregate.xml:204(para)
msgid ""
"The syntax with <literal>ORDER BY</literal> in the parameter list creates a "
"special type of aggregate called an <firstterm>ordered-set aggregate</"
"firstterm>; or if <literal>HYPOTHETICAL</literal> is specified, then a "
"<firstterm>hypothetical-set aggregate</firstterm> is created. These "
"aggregates operate over groups of sorted values in order-dependent ways, so "
"that specification of an input sort order is an essential part of a call. "
"Also, they can have <firstterm>direct</firstterm> arguments, which are "
"arguments that are evaluated only once per aggregation rather than once per "
"input row. Hypothetical-set aggregates are a subclass of ordered-set "
"aggregates in which some of the direct arguments are required to match, in "
"number and data types, the aggregated argument columns. This allows the "
"values of those direct arguments to be added to the collection of aggregate-"
"input rows as an additional <quote>hypothetical</quote> row."
msgstr ""
"Если в список параметров добавлено указание <literal>ORDER BY</literal>, "
"создаётся особый типа агрегата, называемый <firstterm>сортирующим агрегатом</"
"firstterm>; с указанием <literal>HYPOTHETICAL</literal> создаётся "
"<firstterm>гипотезирующий агрегат</firstterm>. Эти агрегаты работают с "
"группами отсортированных значений и зависят от порядка сортировки, поэтому "
"определение порядка сортировки входных данных является неотъемлемой частью "
"их вызова. Кроме того, они могут иметь <firstterm>непосредственные</"
"firstterm> аргументы, которые вычисляются единожды для всей процедуры "
"агрегирования, а не для каждой поступающей строки. Гипотезирующие агрегаты "
"представляют собой подкласс сортирующих агрегатов, в которых "
"непосредственные аргументы должны совпадать, по количеству и типам данных, с "
"агрегируемыми аргументами. Это позволяет добавить значения этих "
"непосредственных аргументов в набор агрегируемых строк в качестве "
"дополнительной <quote>гипотетической</quote> строки."

#: ref/create_aggregate.xml:220(para)
msgid ""
"An aggregate can optionally support <firstterm>partial aggregation</"
"firstterm>, as described in <xref linkend=\"xaggr-partial-aggregates\"/>. "
"This requires specifying the <literal>COMBINEFUNC</literal> parameter. If "
"the <replaceable class=\"parameter\">state_data_type</replaceable> is "
"<type>internal</type>, it's usually also appropriate to provide the "
"<literal>SERIALFUNC</literal> and <literal>DESERIALFUNC</literal> parameters "
"so that parallel aggregation is possible. Note that the aggregate must also "
"be marked <literal>PARALLEL SAFE</literal> to enable parallel aggregation."
msgstr ""
"Агрегатная функция может дополнительно поддерживать <firstterm>частичное "
"агрегирование</firstterm>, как описано в <xref remap=\"6\" linkend=\"xaggr-"
"partial-aggregates\"/>. Для этого требуется задать параметр "
"<literal>COMBINEFUNC</literal>. Если в качестве <replaceable class="
"\"parameter\">типа_данных_состояния</replaceable> выбран <type>internal</"
"type>, обычно уместно также задать <literal>SERIALFUNC</literal> и "
"<literal>DESERIALFUNC</literal>, чтобы было возможно параллельное "
"агрегирование. Заметьте, что для параллельного агрегирования агрегатная "
"функция также должна быть помечена как <literal>PARALLEL SAFE</literal> "
"(безопасная для распараллеливания)."

#: ref/create_aggregate.xml:238(programlisting)
#, no-wrap
msgid "SELECT agg(col) FROM tab;"
msgstr "SELECT agg(col) FROM tab;"

#: ref/create_aggregate.xml:240(programlisting)
#, no-wrap
msgid "SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;"
msgstr "SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;"

#: ref/create_aggregate.xml:231(para)
msgid ""
"Aggregates that behave like <function>MIN</function> or <function>MAX</"
"function> can sometimes be optimized by looking into an index instead of "
"scanning every input row. If this aggregate can be so optimized, indicate it "
"by specifying a <firstterm>sort operator</firstterm>. The basic requirement "
"is that the aggregate must yield the first element in the sort ordering "
"induced by the operator; in other words: <placeholder-1/> must be equivalent "
"to: <placeholder-2/> Further assumptions are that the aggregate ignores null "
"inputs, and that it delivers a null result if and only if there were no non-"
"null inputs. Ordinarily, a data type's <literal>&lt;</literal> operator is "
"the proper sort operator for <function>MIN</function>, and <literal>&gt;</"
"literal> is the proper sort operator for <function>MAX</function>. Note that "
"the optimization will never actually take effect unless the specified "
"operator is the <quote>less than</quote> or <quote>greater than</quote> "
"strategy member of a B-tree index operator class."
msgstr ""
"Агрегаты, работающие подобно <function>MIN</function> и <function>MAX</"
"function>, иногда можно соптимизировать, заменив сканирование всех строк "
"таблицы обращением к индексу. Если агрегат подлежит такой оптимизации, это "
"можно указать, определив <firstterm>оператор сортировки</firstterm>. "
"Основное требование при этом: агрегат должен выдавать в результате первый "
"элемент по порядку сортировки, задаваемому оператором; другими словами: "
"<placeholder-1/> должно быть равнозначно: <placeholder-2/> Дополнительно "
"предполагается, что агрегат игнорирует значения NULL и возвращает NULL, "
"только если строк со значениями не NULL не нашлось. Обычно оператор "
"<literal>&lt;</literal> является подходящим оператором сортировки для "
"<function>MIN</function>, а <literal>&gt;</literal> — для <function>MAX</"
"function>. Заметьте, что обращение к индексу может дать эффект, только если "
"заданный оператор реализует стратегию <quote>меньше</quote> или "
"<quote>больше</quote> в классе операторов индекса-B-дерева."

#: ref/create_aggregate.xml:251(para)
msgid ""
"To be able to create an aggregate function, you must have <literal>USAGE</"
"literal> privilege on the argument types, the state type(s), and the return "
"type, as well as <literal>EXECUTE</literal> privilege on the supporting "
"functions."
msgstr ""
"Чтобы создать агрегатную функцию, необходимо иметь право <literal>USAGE</"
"literal> для типов аргументов, типа(ов) состояния и типа результата, а также "
"право <literal>EXECUTE</literal> для опорных функций."

#: ref/create_aggregate.xml:260(title)
msgid "Parameters"
msgstr "Параметры"

#: ref/create_aggregate.xml:266(para)
msgid ""
"The name (optionally schema-qualified) of the aggregate function to create."
msgstr "Имя (возможно, дополненное схемой) создаваемой агрегатной функции."

#: ref/create_aggregate.xml:277(para)
msgid ""
"The mode of an argument: <literal>IN</literal> or <literal>VARIADIC</"
"literal>. (Aggregate functions do not support <literal>OUT</literal> "
"arguments.) If omitted, the default is <literal>IN</literal>. Only the last "
"argument can be marked <literal>VARIADIC</literal>."
msgstr ""
"Режим аргумента: <literal>IN</literal> или <literal>VARIADIC</literal>. "
"(Агрегатные функции не поддерживают выходные аргументы (<literal>OUT</"
"literal>).) По умолчанию подразумевается <literal>IN</literal>. Режим "
"<literal>VARIADIC</literal> может быть указан только последним."

#: ref/create_aggregate.xml:290(para)
msgid ""
"The name of an argument. This is currently only useful for documentation "
"purposes. If omitted, the argument has no name."
msgstr ""
"Имя аргумента. В настоящее время используется только в целях "
"документирования. Если опущено, соответствующий аргумент будет безымянным."

#: ref/create_aggregate.xml:300(para)
msgid ""
"An input data type on which this aggregate function operates. To create a "
"zero-argument aggregate function, write <literal>*</literal> in place of the "
"list of argument specifications. (An example of such an aggregate is "
"<function>count(*)</function>.)"
msgstr ""
"Тип входных данных, с которым работает эта агрегатная функция. Для создания "
"агрегатной функции без аргументов вставьте <literal>*</literal> вместо "
"списка с определениями аргументов. (Пример такой агрегатной функции: "
"<function>count(*)</function>.)"

#: ref/create_aggregate.xml:312(para)
msgid ""
"In the old syntax for <command>CREATE AGGREGATE</command>, the input data "
"type is specified by a <literal>basetype</literal> parameter rather than "
"being written next to the aggregate name. Note that this syntax allows only "
"one input parameter. To define a zero-argument aggregate function with this "
"syntax, specify the <literal>basetype</literal> as <literal>\"ANY\"</"
"literal> (not <literal>*</literal>). Ordered-set aggregates cannot be "
"defined with the old syntax."
msgstr ""
"В прежнем синтаксисе <command>CREATE AGGREGATE</command> тип входных данных "
"задавался параметром <literal>basetype</literal>, а не записывался после "
"имени агрегата. Это позволяло указать только один входной параметр. Чтобы "
"определить функцию без аргументов, используя этот синтаксис, в качестве "
"значения <literal>basetype</literal> нужно указать <literal>\"ANY\"</"
"literal> (не <literal>*</literal>). Создать сортирующий агрегат старый "
"синтаксис не позволял."

#: ref/create_aggregate.xml:327(para)
msgid ""
"The name of the state transition function to be called for each input row. "
"For a normal <replaceable class=\"parameter\">N</replaceable>-argument "
"aggregate function, the <replaceable class=\"parameter\">sfunc</replaceable> "
"must take <replaceable class=\"parameter\">N</replaceable>+1 arguments, the "
"first being of type <replaceable class=\"parameter\">state_data_type</"
"replaceable> and the rest matching the declared input data type(s) of the "
"aggregate. The function must return a value of type <replaceable class="
"\"parameter\">state_data_type</replaceable>. This function takes the current "
"state value and the current input data value(s), and returns the next state "
"value."
msgstr ""
"Имя функции перехода состояния, вызываемой для каждой входной строки. Для "
"обычных агрегатных функций с <replaceable class=\"parameter\">N</"
"replaceable> аргументами, <replaceable class=\"parameter"
"\">функция_состояния</replaceable> должна принимать <replaceable class="
"\"parameter\">N</replaceable>+1 аргумент, первый должен иметь тип "
"<replaceable class=\"parameter\">тип_данных_состояния</replaceable>, а "
"остальные — типы соответствующих входных данных. Возвращать она должна "
"значение типа <replaceable class=\"parameter\">тип_данных_состояния</"
"replaceable>. Эта функция принимает текущее значение состояния и текущие "
"значения входных данных, и возвращает следующее значение состояния."

#: ref/create_aggregate.xml:341(para)
msgid ""
"For ordered-set (including hypothetical-set) aggregates, the state "
"transition function receives only the current state value and the aggregated "
"arguments, not the direct arguments. Otherwise it is the same."
msgstr ""
"В сортирующих (и в том числе, гипотезирующих) агрегатах функция перехода "
"состояния получает только текущее значение состояния и агрегируемые "
"аргументы, без непосредственных аргументов. Других отличий у неё нет."

#: ref/create_aggregate.xml:353(para)
msgid "The data type for the aggregate's state value."
msgstr "Тип данных значения состояния для агрегатной функции."

#: ref/create_aggregate.xml:362(para)
msgid ""
"The approximate average size (in bytes) of the aggregate's state value. If "
"this parameter is omitted or is zero, a default estimate is used based on "
"the <replaceable>state_data_type</replaceable>. The planner uses this value "
"to estimate the memory required for a grouped aggregate query. The planner "
"will consider using hash aggregation for such a query only if the hash table "
"is estimated to fit in <xref linkend=\"guc-work-mem\"/>; therefore, large "
"values of this parameter discourage use of hash aggregation."
msgstr ""
"Средний размер значения состояния агрегата (в байтах). Если этот параметр "
"опущен или равен нулю, применяемая оценка по умолчанию определяется по типу "
"<replaceable>тип_данных_состояния</replaceable>. Планировщик использует это "
"значение для оценивания объёма памяти, требуемому для агрегатного запроса с "
"группировкой. Планировщик может применить агрегирование по хешу для такого "
"запроса, только если хеш-таблица, судя по оценке, поместится в <xref linkend="
"\"guc-work-mem\"/>; таким образом, при больших значениях этого параметра "
"агрегирование по хешу будет менее желательным."

#: ref/create_aggregate.xml:378(para)
msgid ""
"The name of the final function called to compute the aggregate's result "
"after all input rows have been traversed. For a normal aggregate, this "
"function must take a single argument of type <replaceable class=\"parameter"
"\">state_data_type</replaceable>. The return data type of the aggregate is "
"defined as the return type of this function. If <replaceable class="
"\"parameter\">ffunc</replaceable> is not specified, then the ending state "
"value is used as the aggregate's result, and the return type is <replaceable "
"class=\"parameter\">state_data_type</replaceable>."
msgstr ""
"Имя функции завершения, вызываемой для вычисления результата агрегатной "
"функции после обработки всех входных строк. Для обычного агрегата эта "
"функция должна принимать единственный аргумент типа <replaceable class="
"\"parameter\">тип_данных_состояния</replaceable>. Возвращаемым типом "
"агрегата будет тип, который возвращает эта функция. Если <replaceable class="
"\"parameter\">функция_завершения</replaceable> не указана, результатом "
"агрегата будет конечное значение состояния, а типом результата — "
"<replaceable class=\"parameter\">тип_данных_состояния</replaceable>."

#: ref/create_aggregate.xml:391(para)
msgid ""
"For ordered-set (including hypothetical-set) aggregates, the final function "
"receives not only the final state value, but also the values of all the "
"direct arguments."
msgstr ""
"В сортирующих (и в том числе, гипотезирующих) агрегатах функция завершения "
"получает не только конечное значение состояния, но и значения всех "
"непосредственных аргументов."

#: ref/create_aggregate.xml:397(para)
msgid ""
"If <literal>FINALFUNC_EXTRA</literal> is specified, then in addition to the "
"final state value and any direct arguments, the final function receives "
"extra NULL values corresponding to the aggregate's regular (aggregated) "
"arguments. This is mainly useful to allow correct resolution of the "
"aggregate result type when a polymorphic aggregate is being defined."
msgstr ""
"Если команда содержит указание <literal>FINALFUNC_EXTRA</literal>, то в "
"дополнение к конечному значению состояния и всем непосредственным аргументам "
"функция завершения получает добавочные значения NULL, соответствующие "
"обычным (агрегируемым) аргументам агрегата. Это в основном полезно для "
"правильного определения типа результата при создании полиморфной агрегатной "
"функции."

#: ref/create_aggregate.xml:411(para)
msgid ""
"The <replaceable class=\"parameter\">combinefunc</replaceable> function may "
"optionally be specified to allow the aggregate function to support partial "
"aggregation. If provided, the <replaceable class=\"parameter\">combinefunc</"
"replaceable> must combine two <replaceable class=\"parameter"
"\">state_data_type</replaceable> values, each containing the result of "
"aggregation over some subset of the input values, to produce a new "
"<replaceable class=\"parameter\">state_data_type</replaceable> that "
"represents the result of aggregating over both sets of inputs. This function "
"can be thought of as an <replaceable class=\"parameter\">sfunc</"
"replaceable>, where instead of acting upon an individual input row and "
"adding it to the running aggregate state, it adds another aggregate state to "
"the running state."
msgstr ""
"Дополнительно может быть указана <replaceable class=\"parameter"
"\">комбинирующая_функция</replaceable>, чтобы агрегатная функция "
"поддерживала частичное агрегирование. Если задаётся, <replaceable class="
"\"parameter\">комбинирующая_функция</replaceable> должна комбинировать два "
"значения <replaceable class=\"parameter\">типа_данных_состояния</"
"replaceable>, содержащих результат агрегирования по некоторому подмножеству "
"входных значений, и вычислять новое значение <replaceable class=\"parameter"
"\">типа_данных_состояния</replaceable>, представляющее результат "
"агрегирования по обоим множествам данных. Эту функцию можно считать своего "
"рода <replaceable class=\"parameter\">функцией_состояния</replaceable>, "
"которая вместо обработки отдельной входной строки и включения её данных в "
"текущее агрегируемое состояние включает некоторое агрегированное состояние в "
"текущее."

#: ref/create_aggregate.xml:427(para)
msgid ""
"The <replaceable class=\"parameter\">combinefunc</replaceable> must be "
"declared as taking two arguments of the <replaceable class=\"parameter"
"\">state_data_type</replaceable> and returning a value of the <replaceable "
"class=\"parameter\">state_data_type</replaceable>. Optionally this function "
"may be <quote>strict</quote>. In this case the function will not be called "
"when either of the input states are null; the other state will be taken as "
"the correct result."
msgstr ""
"Указанная <replaceable class=\"parameter\">комбинирующая_функция</"
"replaceable> должна быть объявлена как принимающая два аргумента "
"<replaceable class=\"parameter\">типа_данных_состояния</replaceable> и "
"возвращающая значение <replaceable class=\"parameter"
"\">типа_данных_состояния</replaceable>. Эта функция дополнительно может быть "
"объявлена <quote>строгой</quote>. В этом случае данная функция не будет "
"вызываться, когда одно из входных состояний — NULL; в качестве корректного "
"результата будет выдано другое состояние."

#: ref/create_aggregate.xml:438(para)
msgid ""
"For aggregate functions whose <replaceable class=\"parameter"
"\">state_data_type</replaceable> is <type>internal</type>, the <replaceable "
"class=\"parameter\">combinefunc</replaceable> must not be strict. In this "
"case the <replaceable class=\"parameter\">combinefunc</replaceable> must "
"ensure that null states are handled correctly and that the state being "
"returned is properly stored in the aggregate memory context."
msgstr ""
"Для агрегатных функций, у которых <replaceable class=\"parameter"
"\">тип_данных_состояния</replaceable> — <type>internal</type>, <replaceable "
"class=\"parameter\">комбинирующая_функция</replaceable> не должна быть "
"<quote>строгой</quote>. При этом <replaceable class=\"parameter"
"\">комбинирующая_функция</replaceable> должна позаботиться о том, чтобы "
"состояния NULL обрабатывались корректно и возвращаемое состояние "
"располагалось в контексте памяти агрегирования."

#: ref/create_aggregate.xml:454(para)
msgid ""
"An aggregate function whose <replaceable class=\"parameter"
"\">state_data_type</replaceable> is <type>internal</type> can participate in "
"parallel aggregation only if it has a <replaceable class=\"parameter"
"\">serialfunc</replaceable> function, which must serialize the aggregate "
"state into a <type>bytea</type> value for transmission to another process. "
"This function must take a single argument of type <type>internal</type> and "
"return type <type>bytea</type>. A corresponding <replaceable class="
"\"parameter\">deserialfunc</replaceable> is also required."
msgstr ""
"Агрегатная функция, у которой <replaceable class=\"parameter"
"\">тип_данных_состояния</replaceable> — <type>internal</type>, может "
"участвовать в параллельном агрегировании, только если для неё задана "
"<replaceable class=\"parameter\">функция_сериализации</replaceable>, которая "
"должна сериализовать агрегатное состояние в значение <type>bytea</type> для "
"передачи другому процессу. Эта функция должна принимать один аргумент типа "
"<type>internal</type> и возвращать тип <type>bytea</type>. Также при этом "
"нужно задать соответствующую <replaceable class=\"parameter"
"\">функцию_десериализации</replaceable>."

#: ref/create_aggregate.xml:471(para)
msgid ""
"Deserialize a previously serialized aggregate state back into <replaceable "
"class=\"parameter\">state_data_type</replaceable>. This function must take "
"two arguments of types <type>bytea</type> and <type>internal</type>, and "
"produce a result of type <type>internal</type>. (Note: the second, "
"<type>internal</type> argument is unused, but is required for type safety "
"reasons.)"
msgstr ""
"Десериализует ранее сериализованное агрегатное состояние обратно в "
"<replaceable class=\"parameter\">тип_данных_состояния</replaceable>. Эта "
"функция должна принимать два аргумента типов <type>bytea</type> и "
"<type>internal</type> и выдавать результат типа <type>internal</type>. "
"(Замечание: второй аргумент типа <type>internal</type> не используется, но "
"требуется из соображений типобезопасности.)"

#: ref/create_aggregate.xml:485(para)
msgid ""
"The initial setting for the state value. This must be a string constant in "
"the form accepted for the data type <replaceable class=\"parameter"
"\">state_data_type</replaceable>. If not specified, the state value starts "
"out null."
msgstr ""
"Начальное значение переменной состояния. Оно должно задаваться строковой "
"константой в форме, пригодной для ввода в <replaceable class=\"parameter"
"\">тип_данных_состояния</replaceable>. Если не указано, начальным значением "
"состояния будет NULL."

#: ref/create_aggregate.xml:497(para)
msgid ""
"The name of the forward state transition function to be called for each "
"input row in moving-aggregate mode. This is exactly like the regular "
"transition function, except that its first argument and result are of type "
"<replaceable>mstate_data_type</replaceable>, which might be different from "
"<replaceable>state_data_type</replaceable>."
msgstr ""
"Имя функции прямого перехода состояния, вызываемой для каждой входной строки "
"в режиме движущегося агрегата. Это точно такая же функция, как и обычная "
"функция перехода, но её первый аргумент и результат имеют тип "
"<replaceable>тип_данных_состояния_движ</replaceable>, который может "
"отличаться от типа <replaceable>тип_данных_состояния</replaceable>."

#: ref/create_aggregate.xml:510(para)
msgid ""
"The name of the inverse state transition function to be used in moving-"
"aggregate mode. This function has the same argument and result types as "
"<replaceable>msfunc</replaceable>, but it is used to remove a value from the "
"current aggregate state, rather than add a value to it. The inverse "
"transition function must have the same strictness attribute as the forward "
"state transition function."
msgstr ""
"Имя функции обратного перехода состояния, применяемой в режиме движущегося "
"агрегата. У этой функции те же типы аргумента и результатов, что и у "
"<replaceable>функции_состояния_движ</replaceable>, но она предназначена не "
"для добавления, а для удаления значения из текущего состояния агрегата. "
"Функция обратного перехода должна иметь ту же характеристику строгости, что "
"и функция прямого перехода."

#: ref/create_aggregate.xml:524(para)
msgid ""
"The data type for the aggregate's state value, when using moving-aggregate "
"mode."
msgstr ""
"Тип данных значения состояния для агрегатной функции в режиме движущегося "
"агрегата."

#: ref/create_aggregate.xml:534(para)
msgid ""
"The approximate average size (in bytes) of the aggregate's state value, when "
"using moving-aggregate mode. This works the same as "
"<replaceable>state_data_size</replaceable>."
msgstr ""
"Примерный размер значения состояния в режиме движущегося агрегата. Он имеет "
"то же значение, что и <replaceable>размер_данных_состояния</replaceable>."

#: ref/create_aggregate.xml:545(para)
msgid ""
"The name of the final function called to compute the aggregate's result "
"after all input rows have been traversed, when using moving-aggregate mode. "
"This works the same as <replaceable>ffunc</replaceable>, except that its "
"first argument's type is <replaceable>mstate_data_type</replaceable> and "
"extra dummy arguments are specified by writing <literal>MFINALFUNC_EXTRA</"
"literal>. The aggregate result type determined by <replaceable>mffunc</"
"replaceable> or <replaceable>mstate_data_type</replaceable> must match that "
"determined by the aggregate's regular implementation."
msgstr ""
"Имя функции завершения, вызываемой в режиме движущегося агрегата для "
"вычисления результата агрегатной функции после обработки всех входных строк. "
"Она работает так же, как <replaceable>функция_завершения</replaceable>, но "
"её первый аргумент имеет тип <replaceable>тип_данных_состояния_движ</"
"replaceable>, а дополнительными пустыми аргументами управляет параметр "
"<literal>MFINALFUNC_EXTRA</literal>. Тип результата, который определяет "
"<replaceable>функция_завершения_движ</replaceable>, или "
"<replaceable>тип_данных_состояния_движ</replaceable>, должен совпадать с "
"типом результата обычной реализации агрегата."

#: ref/create_aggregate.xml:562(para)
msgid ""
"The initial setting for the state value, when using moving-aggregate mode. "
"This works the same as <replaceable>initial_condition</replaceable>."
msgstr ""
"Начальное значение переменной состояния в режиме движущегося агрегата. Оно "
"применяется так же, как <replaceable>начальное_условие</replaceable>."

#: ref/create_aggregate.xml:572(para)
msgid ""
"The associated sort operator for a <function>MIN</function>- or "
"<function>MAX</function>-like aggregate. This is just an operator name "
"(possibly schema-qualified). The operator is assumed to have the same input "
"data types as the aggregate (which must be a single-argument normal "
"aggregate)."
msgstr ""
"Связанный оператор сортировки для реализации агрегатов, подобных "
"<function>MIN</function> или <function>MAX</function>. Здесь указывается "
"просто имя оператора (возможно, дополненное схемой). Предполагается, что "
"оператор поддерживает те же типы входных данных, что и агрегат (который "
"должен быть обычным и иметь один аргумент)."

#: ref/create_aggregate.xml:583(literal)
msgid "PARALLEL"
msgstr "PARALLEL"

#: ref/create_aggregate.xml:585(para)
msgid ""
"The meanings of <literal>PARALLEL SAFE</literal>, <literal>PARALLEL "
"RESTRICTED</literal>, and <literal>PARALLEL UNSAFE</literal> are the same as "
"for <xref linkend=\"sql-createfunction\"/>. An aggregate will not be "
"considered for parallelization if it is marked <literal>PARALLEL UNSAFE</"
"literal> (which is the default!) or <literal>PARALLEL RESTRICTED</literal>. "
"Note that the parallel-safety markings of the aggregate's support functions "
"are not consulted by the planner, only the marking of the aggregate itself."
msgstr ""
"Указания <literal>PARALLEL SAFE</literal>, <literal>PARALLEL RESTRICTED</"
"literal> и <literal>PARALLEL UNSAFE</literal> имеют те же значения, что и в "
"<xref linkend=\"sql-createfunction\"/>. Агрегатная функция не будет "
"считаться распараллеливаемой, если она имеет характеристику "
"<literal>PARALLEL UNSAFE</literal> (она подразумевается по умолчанию!) или "
"<literal>PARALLEL RESTRICTED</literal>. Заметьте, что планировщик не "
"обращает внимание на допустимость распараллеливания опорных функций "
"агрегата, а учитывает только характеристику самой агрегатной функции."

#: ref/create_aggregate.xml:599(literal)
msgid "HYPOTHETICAL"
msgstr "HYPOTHETICAL"

#: ref/create_aggregate.xml:601(para)
msgid ""
"For ordered-set aggregates only, this flag specifies that the aggregate "
"arguments are to be processed according to the requirements for hypothetical-"
"set aggregates: that is, the last few direct arguments must match the data "
"types of the aggregated (<literal>WITHIN GROUP</literal>) arguments. The "
"<literal>HYPOTHETICAL</literal> flag has no effect on run-time behavior, "
"only on parse-time resolution of the data types and collations of the "
"aggregate's arguments."
msgstr ""
"Этот признак, допустимый только для сортирующих агрегатов, указывает, что "
"агрегатные аргументы должны обрабатываться согласно требованиям "
"гипотезирующих агрегатов: то есть последние несколько прямых аргументов "
"должны соответствовать по типам агрегатным аргументам (<literal>WITHIN "
"GROUP</literal>). Признак <literal>HYPOTHETICAL</literal> не влияет на "
"поведение во время выполнения, он учитывается только при разрешении типов "
"данных и правил сортировки аргументов."

#: ref/create_aggregate.xml:614(para)
msgid ""
"The parameters of <command>CREATE AGGREGATE</command> can be written in any "
"order, not just the order illustrated above."
msgstr ""
"Параметры <command>CREATE AGGREGATE</command> могут записываться в любом "
"порядке, не обязательно так, как показано выше."

#: ref/create_aggregate.xml:621(title)
msgid "Notes"
msgstr "Замечания"

#: ref/create_aggregate.xml:623(para)
msgid ""
"In parameters that specify support function names, you can write a schema "
"name if needed, for example <literal>SFUNC = public.sum</literal>. Do not "
"write argument types there, however &mdash; the argument types of the "
"support functions are determined from other parameters."
msgstr ""
"В параметрах, определяющих имена вспомогательных функций, при необходимости "
"можно написать имя схемы, например: <literal>SFUNC = public.sum</literal>. "
"Однако типы аргументов там не указываются &mdash; типы аргументов "
"вспомогательных функций определяются другими параметрами."

#: ref/create_aggregate.xml:630(para)
msgid ""
"If an aggregate supports moving-aggregate mode, it will improve calculation "
"efficiency when the aggregate is used as a window function for a window with "
"moving frame start (that is, a frame start mode other than "
"<literal>UNBOUNDED PRECEDING</literal>). Conceptually, the forward "
"transition function adds input values to the aggregate's state when they "
"enter the window frame from the bottom, and the inverse transition function "
"removes them again when they leave the frame at the top. So, when values are "
"removed, they are always removed in the same order they were added. Whenever "
"the inverse transition function is invoked, it will thus receive the "
"earliest added but not yet removed argument value(s). The inverse transition "
"function can assume that at least one row will remain in the current state "
"after it removes the oldest row. (When this would not be the case, the "
"window function mechanism simply starts a fresh aggregation, rather than "
"using the inverse transition function.)"
msgstr ""
"Если агрегатная функция поддерживает режим движущегося агрегата, это "
"увеличивает эффективность вычислений, когда она применяется в качестве "
"оконной функции для окна с движущимся началом рамки (то есть, когда начало "
"определяется не как <literal>UNBOUNDED PRECEDING</literal>). По сути, "
"функция прямого перехода добавляет входные значения к состоянию агрегата, "
"когда они поступают в рамку окна снизу, а функция обратного перехода снова "
"вычитает их, когда они покидают рамку сверху. Поэтому вычитаются значения в "
"том же порядке, в каком добавлялись. Когда бы ни вызывалась функция "
"обратного перехода, она таким образом получит первое из добавленных, но ещё "
"не удалённых значений аргумента. Функция обратного перехода может "
"рассчитывать на то, что после того, как она удалит самые старые данные, в "
"текущем состоянии останется ещё как минимум одна строка. (Когда это правило "
"могло бы нарушиться, механизм оконных функций просто начинает агрегировать "
"данные заново, а не вызывает функцию обратного перехода.)"

#: ref/create_aggregate.xml:647(para)
msgid ""
"The forward transition function for moving-aggregate mode is not allowed to "
"return NULL as the new state value. If the inverse transition function "
"returns NULL, this is taken as an indication that the inverse function "
"cannot reverse the state calculation for this particular input, and so the "
"aggregate calculation will be redone from scratch for the current frame "
"starting position. This convention allows moving-aggregate mode to be used "
"in situations where there are some infrequent cases that are impractical to "
"reverse out of the running state value."
msgstr ""
"Функция прямого перехода для режима движущегося агрегата не может возвращать "
"NULL в качестве нового значения состояния. Если NULL возвращает функция "
"обратного перехода, это показывает, что она не может произвести обратное "
"вычисление для этих конкретных данных, и что вычисление агрегата следует "
"выполнить заново от начальной позиции текущей рамки. Благодаря этому "
"соглашению, режим движущегося агрегата можно использовать, даже если иногда "
"возникают ситуации, в которых обратный расчёт состояния производить "
"непрактично."

#: ref/create_aggregate.xml:659(para)
msgid ""
"If no moving-aggregate implementation is supplied, the aggregate can still "
"be used with moving frames, but <productname>PostgreSQL</productname> will "
"recompute the whole aggregation whenever the start of the frame moves. Note "
"that whether or not the aggregate supports moving-aggregate mode, "
"<productname>PostgreSQL</productname> can handle a moving frame end without "
"recalculation; this is done by continuing to add new values to the "
"aggregate's state. It is assumed that the final function does not damage the "
"aggregate's state value, so that the aggregation can be continued even after "
"an aggregate result value has been obtained for one set of frame boundaries."
msgstr ""
"Агрегатную функцию можно использовать с движущимися рамками и без реализации "
"движущегося агрегата, но при этом <productname>PostgreSQL</productname> "
"будет заново агрегировать все данные при каждом перемещении начала рамки. "
"Заметьте, что вне зависимости от того, поддерживает ли агрегатная функция "
"режим движущегося агрегата, <productname>PostgreSQL</productname> может "
"обойтись без повторных вычислений при сдвиге конца рамки; новые значения "
"просто продолжают добавляться в состояние агрегата. Предполагается, что "
"функция завершения не повреждает значение состояния агрегата, так что "
"вычисление агрегата можно продолжить даже после получения результата для "
"строк в определённой рамке."

#: ref/create_aggregate.xml:673(para)
msgid ""
"The syntax for ordered-set aggregates allows <literal>VARIADIC</literal> to "
"be specified for both the last direct parameter and the last aggregated "
"(<literal>WITHIN GROUP</literal>) parameter. However, the current "
"implementation restricts use of <literal>VARIADIC</literal> in two ways. "
"First, ordered-set aggregates can only use <literal>VARIADIC \"any\"</"
"literal>, not other variadic array types. Second, if the last direct "
"parameter is <literal>VARIADIC \"any\"</literal>, then there can be only one "
"aggregated parameter and it must also be <literal>VARIADIC \"any\"</"
"literal>. (In the representation used in the system catalogs, these two "
"parameters are merged into a single <literal>VARIADIC \"any\"</literal> "
"item, since <structname>pg_proc</structname> cannot represent functions with "
"more than one <literal>VARIADIC</literal> parameter.) If the aggregate is a "
"hypothetical-set aggregate, the direct arguments that match the "
"<literal>VARIADIC \"any\"</literal> parameter are the hypothetical ones; any "
"preceding parameters represent additional direct arguments that are not "
"constrained to match the aggregated arguments."
msgstr ""
"Синтаксис сортирующих агрегатных функций позволяет указать "
"<literal>VARIADIC</literal> и в последнем непосредственном параметре, и в "
"последнем агрегатном (<literal>WITHIN GROUP</literal>). Однако в текущей "
"реализации на применение <literal>VARIADIC</literal> накладываются два "
"ограничения. Во-первых, в сортирующих агрегатах можно использовать только "
"<literal>VARIADIC \"any\"</literal>, но не другие типы переменных массивов. "
"Во-вторых, если последним непосредственным аргументом является "
"<literal>VARIADIC \"any\"</literal>, то допускается только один агрегатный "
"аргумент и это тоже должен быть <literal>VARIADIC \"any\"</literal>. (В "
"представлении, используемом в системных каталогах, эти два параметра "
"объединяются в один элемент <literal>VARIADIC \"any\"</literal>, так как в "
"<structname>pg_proc</structname> нельзя представить функцию с несколькими "
"параметрами <literal>VARIADIC</literal>.) Если агрегатная функция является "
"гипотезирующей, непосредственные аргументы, соответствующие параметру "
"<literal>VARIADIC \"any\"</literal>, будут гипотетическими; любые "
"предшествующие параметры представляют дополнительные непосредственные "
"аргументы, которые могут не соответствовать агрегатным."

#: ref/create_aggregate.xml:692(para)
msgid ""
"Currently, ordered-set aggregates do not need to support moving-aggregate "
"mode, since they cannot be used as window functions."
msgstr ""
"В настоящее время сортирующие агрегатные функции не поддерживают режим "
"движущегося агрегата, так как их нельзя применять в качестве оконных функций."

#: ref/create_aggregate.xml:697(para)
msgid ""
"Partial (including parallel) aggregation is currently not supported for "
"ordered-set aggregates. Also, it will never be used for aggregate calls that "
"include <literal>DISTINCT</literal> or <literal>ORDER BY</literal> clauses, "
"since those semantics cannot be supported during partial aggregation."
msgstr ""
"Частичное (в том числе, параллельное) агрегирование в настоящее время не "
"поддерживается для сортирующих агрегатных функций. Также оно никогда не "
"будет применяться для агрегатных вызовов с предложениями <literal>DISTINCT</"
"literal> или <literal>ORDER BY</literal>, так как они по природе своей не "
"могут быть реализованы с частичным агрегированием."

#: ref/create_aggregate.xml:706(title)
msgid "Examples"
msgstr "Примеры"

#: ref/create_aggregate.xml:708(para)
msgid "See <xref linkend=\"xaggr\"/>."
msgstr "См. <xref remap=\"4\" linkend=\"xaggr\"/>."

#: ref/create_aggregate.xml:714(title)
msgid "Compatibility"
msgstr "Совместимость"

#: ref/create_aggregate.xml:716(para)
msgid ""
"<command>CREATE AGGREGATE</command> is a <productname>PostgreSQL</"
"productname> language extension. The SQL standard does not provide for user-"
"defined aggregate functions."
msgstr ""
"Оператор <command>CREATE AGGREGATE</command> является языковым расширением "
"<productname>PostgreSQL</productname>. В стандарте SQL не предусмотрено "
"создание пользовательских агрегатных функций."

#: ref/create_aggregate.xml:724(title)
msgid "See Also"
msgstr "См. также"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: ref/create_aggregate.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#~ msgid "serialtype"
#~ msgstr "сериализованный_тип"

#~ msgid ""
#~ "The <replaceable class=\"parameter\">combinefunc</replaceable> may "
#~ "optionally be specified in order to allow the aggregate function to "
#~ "support partial aggregation. This is a prerequisite to allow the "
#~ "aggregate to participate in certain optimizations such as parallel "
#~ "aggregation."
#~ msgstr ""
#~ "Дополнительно может быть указана <replaceable class=\"parameter"
#~ "\">комбинирующая_функция</replaceable>, чтобы агрегатная функция "
#~ "поддерживала частичное агрегирование. Это необходимо, чтобы эту "
#~ "агрегатную функцию можно было задействовать в определённых оптимизациях, "
#~ "например, в параллельном агрегировании."

#~ msgid ""
#~ "This function can be thought of as an <replaceable class=\"parameter\"> "
#~ "sfunc</replaceable>, where instead of acting upon individual input rows "
#~ "and adding these to the aggregate state, it adds other aggregate states "
#~ "to the aggregate state."
#~ msgstr ""
#~ "Эту функцию можно считать своего рода <replaceable class=\"parameter"
#~ "\">функцией_состояния</replaceable>, которая добавляет к агрегируемому "
#~ "состоянию не значения каждой отдельной строки, а другое агрегируемое "
#~ "состояние."

#~ msgid ""
#~ "The data type to into which an <literal>INTERNAL</literal> aggregate "
#~ "state should be serialized."
#~ msgstr ""
#~ "Тип данных, в который должно сериализовываться агрегатное состояние "
#~ "<literal>INTERNAL</literal>."

#~ msgid ""
#~ "The meaning of <literal>PARALLEL SAFE</literal>, <literal>PARALLEL "
#~ "RESTRICTED</literal>, and <literal>PARALLEL UNSAFE</literal> is the same "
#~ "as for <xref linkend=\"sql-createfunction\"/>."
#~ msgstr ""
#~ "Указания <literal>PARALLEL SAFE</literal>, <literal>PARALLEL RESTRICTED</"
#~ "literal> и <literal>PARALLEL UNSAFE</literal> имеют тот же смысл, что и в "
#~ "<xref linkend=\"sql-createfunction\"/>."
