# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-11 12:31+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: ddl.xml:5(title)
msgid "Data Definition"
msgstr "Определение данных"

#: ddl.xml:7(para)
msgid ""
"This chapter covers how one creates the database structures that will hold "
"one's data. In a relational database, the raw data is stored in tables, so "
"the majority of this chapter is devoted to explaining how tables are created "
"and modified and what features are available to control what data is stored "
"in the tables. Subsequently, we discuss how tables can be organized into "
"schemas, and how privileges can be assigned to tables. Finally, we will "
"briefly look at other features that affect the data storage, such as "
"inheritance, views, functions, and triggers."
msgstr ""
"Эта глава рассказывает, как создавать структуры базы данных, в которых будут "
"храниться данные. В реляционной базе данных данные хранятся в таблицах, так "
"что большая часть этой главы будет посвящена созданию и изменению таблиц, а "
"также средствам управления данными в них. Затем мы обсудим, как таблицы "
"можно объединять в схемы и как ограничивать доступ к ним. Наконец, мы кратко "
"рассмотрим другие возможности, связанные с хранением данных, в частности "
"наследование, представления, функции и триггеры."

#: ddl.xml:20(title)
msgid "Table Basics"
msgstr "Основы таблиц"

#: ddl.xml:22(indexterm)
msgid "<primary>table</primary>"
msgstr "<primary>таблица</primary>"

#: ddl.xml:26(indexterm)
msgid "<primary>row</primary>"
msgstr "<primary>строка</primary>"

#: ddl.xml:30(indexterm)
msgid "<primary>column</primary>"
msgstr "<primary>столбец</primary>"

#: ddl.xml:34(para)
msgid ""
"A table in a relational database is much like a table on paper: It consists "
"of rows and columns. The number and order of the columns is fixed, and each "
"column has a name. The number of rows is variable &mdash; it reflects how "
"much data is stored at a given moment. SQL does not make any guarantees "
"about the order of the rows in a table. When a table is read, the rows will "
"appear in an unspecified order, unless sorting is explicitly requested. This "
"is covered in <xref linkend=\"queries\"/>. Furthermore, SQL does not assign "
"unique identifiers to rows, so it is possible to have several completely "
"identical rows in a table. This is a consequence of the mathematical model "
"that underlies SQL but is usually not desirable. Later in this chapter we "
"will see how to deal with this issue."
msgstr ""
"Таблица в реляционной базе данных похожа на таблицу на бумаге: она так же "
"состоит из строк и столбцов. Число и порядок столбцов фиксированы, а каждый "
"столбец имеет имя. Число строк переменно &mdash; оно отражает текущее "
"количество находящихся в ней данных. SQL не даёт никаких гарантий "
"относительно порядка строк таблицы. При чтении таблицы строки выводятся в "
"произвольном порядке, если только явно не требуется сортировка. Подробнее "
"это рассматривается в <xref remap=\"6\" linkend=\"queries\"/>. Более того, "
"SQL не назначает строкам уникальные идентификаторы, так что можно иметь в "
"таблице несколько полностью идентичных строк. Это вытекает из математической "
"модели, которую реализует SQL, но обычно такое дублирование нежелательно. "
"Позже в этой главе мы увидим, как его избежать."

#: ddl.xml:49(para)
msgid ""
"Each column has a data type. The data type constrains the set of possible "
"values that can be assigned to a column and assigns semantics to the data "
"stored in the column so that it can be used for computations. For instance, "
"a column declared to be of a numerical type will not accept arbitrary text "
"strings, and the data stored in such a column can be used for mathematical "
"computations. By contrast, a column declared to be of a character string "
"type will accept almost any kind of data but it does not lend itself to "
"mathematical calculations, although other operations such as string "
"concatenation are available."
msgstr ""
"Каждому столбцу сопоставлен тип данных. Тип данных ограничивает набор "
"допустимых значений, которые можно присвоить столбцу, и определяет смысловое "
"значение данных для вычислений. Например, в столбец числового типа нельзя "
"записать обычные текстовые строки, но зато его данные можно использовать в "
"математических вычислениях. И наоборот, если столбец имеет тип текстовой "
"строки, для него допустимы практически любые данные, но он непригоден для "
"математических действий (хотя другие операции, например конкатенация строк, "
"возможны)."

#: ddl.xml:62(para)
msgid ""
"<productname>PostgreSQL</productname> includes a sizable set of built-in "
"data types that fit many applications. Users can also define their own data "
"types. Most built-in data types have obvious names and semantics, so we "
"defer a detailed explanation to <xref linkend=\"datatype\"/>. Some of the "
"frequently used data types are <type>integer</type> for whole numbers, "
"<type>numeric</type> for possibly fractional numbers, <type>text</type> for "
"character strings, <type>date</type> for dates, <type>time</type> for time-"
"of-day values, and <type>timestamp</type> for values containing both date "
"and time."
msgstr ""
"В <productname>PostgreSQL</productname> есть внушительный набор встроенных "
"типов данных, удовлетворяющий большинство приложений. Пользователи также "
"могут определять собственные типы данных. Большинство встроенных типов "
"данных имеют понятные имена и семантику, так что мы отложим их подробное "
"рассмотрение до <xref remap=\"2\" linkend=\"datatype\"/>. Наиболее часто "
"применяются следующие типы данных: <type>integer</type> для целых чисел, "
"<type>numeric</type> для чисел, которые могут быть дробными, <type>text</"
"type> для текстовых строк, <type>date</type> для дат, <type>time</type> для "
"времени и <type>timestamp</type> для значений, включающих дату и время."

#: ddl.xml:75(indexterm)
msgid "<primary>table</primary><secondary>creating</secondary>"
msgstr "<primary>таблица</primary><secondary>создание</secondary>"

#: ddl.xml:85(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE my_first_table (\n"
"    first_column text,\n"
"    second_column integer\n"
");"
msgstr ""
"CREATE TABLE my_first_table (\n"
"    first_column text,\n"
"    second_column integer\n"
");"

#: ddl.xml:79(para)
msgid ""
"To create a table, you use the aptly named <xref linkend=\"sql-createtable\"/"
"> command. In this command you specify at least a name for the new table, "
"the names of the columns and the data type of each column. For example: "
"<placeholder-1/> This creates a table named <literal>my_first_table</"
"literal> with two columns. The first column is named <literal>first_column</"
"literal> and has a data type of <type>text</type>; the second column has the "
"name <literal>second_column</literal> and the type <type>integer</type>. The "
"table and column names follow the identifier syntax explained in <xref "
"linkend=\"sql-syntax-identifiers\"/>. The type names are usually also "
"identifiers, but there are some exceptions. Note that the column list is "
"comma-separated and surrounded by parentheses."
msgstr ""
"Для создания таблицы используется команда <xref linkend=\"sql-createtable\"/"
">. В этой команде вы должны указать как минимум имя новой таблицы и имена и "
"типы данных каждого столбца. Например: <placeholder-1/> Так вы создадите "
"таблицу <literal>my_first_table</literal> с двумя столбцами. Первый столбец "
"называется <literal>first_column</literal> и имеет тип данных <type>text</"
"type>; второй столбец называется <literal>second_column</literal> и имеет "
"тип <type>integer</type>. Имена таблицы и столбцов соответствуют синтаксису "
"идентификаторов, описанному в <xref remap=\"6\" linkend=\"sql-syntax-"
"identifiers\"/>. Имена типов также являются идентификаторами, хотя есть "
"некоторые исключения. Заметьте, что список столбцов заключается в скобки, а "
"его элементы разделяются запятыми."

#: ddl.xml:105(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric\n"
");"

#: ddl.xml:100(para)
msgid ""
"Of course, the previous example was heavily contrived. Normally, you would "
"give names to your tables and columns that convey what kind of data they "
"store. So let's look at a more realistic example: <placeholder-1/> (The "
"<type>numeric</type> type can store fractional components, as would be "
"typical of monetary amounts.)"
msgstr ""
"Конечно, предыдущий пример ненатурален. Обычно в именах таблиц и столбцов "
"отражается, какие данные они будут содержать. Поэтому давайте взглянем на "
"более реалистичный пример: <placeholder-1/> (Тип <type>numeric</type> может "
"хранить дробные числа, в которых обычно выражаются денежные суммы.)"

#: ddl.xml:115(para)
msgid ""
"When you create many interrelated tables it is wise to choose a consistent "
"naming pattern for the tables and columns. For instance, there is a choice "
"of using singular or plural nouns for table names, both of which are favored "
"by some theorist or other."
msgstr ""
"Когда вы создаёте много взаимосвязанных таблиц, имеет смысл заранее выбрать "
"единый шаблон именования таблиц и столбцов. Например, решить, будут ли в "
"именах таблиц использоваться существительные во множественном или в "
"единственном числе (есть соображения в пользу каждого варианта)."

#: ddl.xml:123(para)
msgid ""
"There is a limit on how many columns a table can contain. Depending on the "
"column types, it is between 250 and 1600. However, defining a table with "
"anywhere near this many columns is highly unusual and often a questionable "
"design."
msgstr ""
"Число столбцов в таблице не может быть бесконечным. Это число ограничивается "
"максимумом в пределах от 250 до 1600, в зависимости от типов столбцов. "
"Однако создавать таблицы с таким большим числом столбцов обычно не "
"требуется, а если такая потребность возникает, это скорее признак "
"сомнительного дизайна."

#: ddl.xml:130(indexterm)
msgid "<primary>table</primary><secondary>removing</secondary>"
msgstr "<primary>таблица</primary><secondary>удаление</secondary>"

#: ddl.xml:138(programlisting)
#, no-wrap
msgid ""
"DROP TABLE my_first_table;\n"
"DROP TABLE products;"
msgstr ""
"DROP TABLE my_first_table;\n"
"DROP TABLE products;"

#: ddl.xml:134(para)
msgid ""
"If you no longer need a table, you can remove it using the <xref linkend="
"\"sql-droptable\"/> command. For example: <placeholder-1/> Attempting to "
"drop a table that does not exist is an error. Nevertheless, it is common in "
"SQL script files to unconditionally try to drop each table before creating "
"it, ignoring any error messages, so that the script works whether or not the "
"table exists. (If you like, you can use the <literal>DROP TABLE IF EXISTS</"
"literal> variant to avoid the error messages, but this is not standard SQL.)"
msgstr ""
"Если таблица вам больше не нужна, вы можете удалить её, выполнив команду "
"<xref linkend=\"sql-droptable\"/>. Например: <placeholder-1/> Попытка "
"удаления несуществующей таблицы считается ошибкой. Тем не менее в SQL-"
"скриптах часто применяют безусловное удаление таблиц перед созданием, "
"игнорируя все сообщения об ошибках, так что они выполняют свою задачу "
"независимо от того, существовали таблицы или нет. (Если вы хотите избежать "
"таких ошибок, можно использовать вариант <literal>DROP TABLE IF EXISTS</"
"literal>, но это не будет соответствовать стандарту SQL.)"

#: ddl.xml:148(para)
msgid ""
"If you need to modify a table that already exists, see <xref linkend=\"ddl-"
"alter\"/> later in this chapter."
msgstr ""
"Как изменить существующую таблицу, будет рассмотрено в этой главе позже, в "
"<xref remap=\"6\" linkend=\"ddl-alter\"/>."

#: ddl.xml:153(para)
msgid ""
"With the tools discussed so far you can create fully functional tables. The "
"remainder of this chapter is concerned with adding features to the table "
"definition to ensure data integrity, security, or convenience. If you are "
"eager to fill your tables with data now you can skip ahead to <xref linkend="
"\"dml\"/> and read the rest of this chapter later."
msgstr ""
"Имея средства, которые мы обсудили, вы уже можете создавать полностью "
"функциональные таблицы. В продолжении этой главы рассматриваются "
"дополнительные возможности, призванные обеспечить целостность данных, "
"безопасность и удобство. Если вам не терпится наполнить свои таблицы "
"данными, вы можете вернуться к этой главе позже, а сейчас перейти к <xref "
"remap=\"3\" linkend=\"dml\"/>."

#: ddl.xml:164(title)
msgid "Default Values"
msgstr "Значения по умолчанию"

#: ddl.xml:166(indexterm)
msgid "<primary>default value</primary>"
msgstr "<primary>значение по умолчанию</primary>"

#: ddl.xml:170(para)
msgid ""
"A column can be assigned a default value. When a new row is created and no "
"values are specified for some of the columns, those columns will be filled "
"with their respective default values. A data manipulation command can also "
"request explicitly that a column be set to its default value, without having "
"to know what that value is. (Details about data manipulation commands are in "
"<xref linkend=\"dml\"/>.)"
msgstr ""
"Столбцу можно назначить значение по умолчанию. Когда добавляется новая "
"строка и каким-то её столбцам не присваиваются значения, эти столбцы "
"принимают значения по умолчанию. Также команда управления данными может явно "
"указать, что столбцу должно быть присвоено значение по умолчанию, не зная "
"его. (Подробнее команды управления данными описаны в <xref remap=\"6\" "
"linkend=\"dml\"/>.)"

#: ddl.xml:180(indexterm)
msgid "<primary>null value</primary><secondary>default value</secondary>"
msgstr ""
"<primary>значение NULL</primary><secondary>значение по умолчанию</secondary>"

#: ddl.xml:179(para)
msgid ""
"<placeholder-1/> If no default value is declared explicitly, the default "
"value is the null value. This usually makes sense because a null value can "
"be considered to represent unknown data."
msgstr ""
"<placeholder-1/> Если значение по умолчанию не объявлено явно, им считается "
"значение NULL. Обычно это имеет смысл, так как можно считать, что NULL "
"представляет неизвестные данные."

#: ddl.xml:189(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric <emphasis>DEFAULT 9.99</emphasis>\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric <emphasis>DEFAULT 9.99</emphasis>\n"
");"

#: ddl.xml:186(para)
msgid ""
"In a table definition, default values are listed after the column data type. "
"For example: <placeholder-1/>"
msgstr ""
"В определении таблицы значения по умолчанию указываются после типа данных "
"столбца. Например: <placeholder-1/>"

#: ddl.xml:205(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,\n"
"    ...\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer <emphasis>DEFAULT nextval('products_product_no_seq')</emphasis>,\n"
"    ...\n"
");"

#: ddl.xml:213(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no <emphasis>SERIAL</emphasis>,\n"
"    ...\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no <emphasis>SERIAL</emphasis>,\n"
"    ...\n"
");"

#: ddl.xml:196(para)
msgid ""
"The default value can be an expression, which will be evaluated whenever the "
"default value is inserted (<emphasis>not</emphasis> when the table is "
"created). A common example is for a <type>timestamp</type> column to have a "
"default of <literal>CURRENT_TIMESTAMP</literal>, so that it gets set to the "
"time of row insertion. Another common example is generating a <quote>serial "
"number</quote> for each row. In <productname>PostgreSQL</productname> this "
"is typically done by something like: <placeholder-1/> where the "
"<literal>nextval()</literal> function supplies successive values from a "
"<firstterm>sequence object</firstterm> (see <xref linkend=\"functions-"
"sequence\"/>). This arrangement is sufficiently common that there's a "
"special shorthand for it: <placeholder-2/> The <literal>SERIAL</literal> "
"shorthand is discussed further in <xref linkend=\"datatype-serial\"/>."
msgstr ""
"Значение по умолчанию может быть выражением, которое в этом случае "
"вычисляется в момент присваивания значения по умолчанию (а <emphasis>не</"
"emphasis> когда создаётся таблица). Например, столбцу <type>timestamp</type> "
"в качестве значения по умолчания часто присваивается "
"<literal>CURRENT_TIMESTAMP</literal>, чтобы в момент добавления строки в нём "
"оказалось текущее время. Ещё один распространённый пример &mdash; генерация "
"<quote>последовательных номеров</quote> для всех строк. В "
"<productname>PostgreSQL</productname> это обычно делается примерно так: "
"<placeholder-1/> здесь функция <literal>nextval()</literal> выбирает "
"очередное значение из <firstterm>последовательности</firstterm> (см. <xref "
"remap=\"4\" linkend=\"functions-sequence\"/>). Это употребление настолько "
"распространено, что для него есть специальная короткая запись: "
"<placeholder-2/> <literal>SERIAL</literal> обсуждается позже в <xref remap="
"\"6\" linkend=\"datatype-serial\"/>."

#: ddl.xml:223(title)
msgid "Constraints"
msgstr "Ограничения"

#: ddl.xml:225(indexterm)
msgid "<primary>constraint</primary>"
msgstr "<primary>ограничение</primary>"

#: ddl.xml:229(para)
msgid ""
"Data types are a way to limit the kind of data that can be stored in a "
"table. For many applications, however, the constraint they provide is too "
"coarse. For example, a column containing a product price should probably "
"only accept positive values. But there is no standard data type that accepts "
"only positive numbers. Another issue is that you might want to constrain "
"column data with respect to other columns or rows. For example, in a table "
"containing product information, there should be only one row for each "
"product number."
msgstr ""
"Типы данных сами по себе ограничивают множество данных, которые можно "
"сохранить в таблице. Однако для многих приложений такие ограничения слишком "
"грубые. Например, столбец, содержащий цену продукта, должен, вероятно, "
"принимать только положительные значения. Но такого стандартного типа данных "
"нет. Возможно, вы также захотите ограничить данные столбца по отношению к "
"другим столбцам или строкам. Например, в таблице с информацией о товаре "
"должна быть только одна строка с определённым кодом товара."

#: ddl.xml:240(para)
msgid ""
"To that end, SQL allows you to define constraints on columns and tables. "
"Constraints give you as much control over the data in your tables as you "
"wish. If a user attempts to store data in a column that would violate a "
"constraint, an error is raised. This applies even if the value came from the "
"default value definition."
msgstr ""
"Для решения подобных задач SQL позволяет вам определять ограничения для "
"столбцов и таблиц. Ограничения дают вам возможность управлять данными в "
"таблицах так, как вы захотите. Если пользователь попытается сохранить в "
"столбце значение, нарушающее ограничения, возникнет ошибка. Ограничения "
"будут действовать, даже если это значение по умолчанию."

#: ddl.xml:249(title)
msgid "Check Constraints"
msgstr "Ограничения-проверки"

#: ddl.xml:251(indexterm)
msgid "<primary>check constraint</primary>"
msgstr "<primary>ограничение-проверка</primary>"

#: ddl.xml:255(indexterm)
msgid "<primary>constraint</primary><secondary>check</secondary>"
msgstr "<primary>ограничение</primary><secondary>проверка</secondary>"

#: ddl.xml:264(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric <emphasis>CHECK (price &gt; 0)</emphasis>\n"
");"

#: ddl.xml:259(para)
msgid ""
"A check constraint is the most generic constraint type. It allows you to "
"specify that the value in a certain column must satisfy a Boolean (truth-"
"value) expression. For instance, to require positive product prices, you "
"could use: <placeholder-1/>"
msgstr ""
"Ограничение-проверка &mdash; наиболее общий тип ограничений. В его "
"определении вы можете указать, что значение данного столбца должно "
"удовлетворять логическому выражению (проверке истинности). Например, цену "
"товара можно ограничить положительными значениями так: <placeholder-1/>"

#: ddl.xml:271(para)
msgid ""
"As you see, the constraint definition comes after the data type, just like "
"default value definitions. Default values and constraints can be listed in "
"any order. A check constraint consists of the key word <literal>CHECK</"
"literal> followed by an expression in parentheses. The check constraint "
"expression should involve the column thus constrained, otherwise the "
"constraint would not make too much sense."
msgstr ""
"Как вы видите, ограничение определяется после типа данных, как и значение по "
"умолчанию. Значения по умолчанию и ограничения могут указываться в любом "
"порядке. Ограничение-проверка состоит из ключевого слова <literal>CHECK</"
"literal>, за которым идёт выражение в скобках. Это выражение должно включать "
"столбец, для которого задаётся ограничение, иначе оно не имеет большого "
"смысла."

#: ddl.xml:281(indexterm)
msgid "<primary>constraint</primary><secondary>name</secondary>"
msgstr "<primary>ограничение</primary><secondary>имя</secondary>"

#: ddl.xml:289(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric <emphasis>CONSTRAINT positive_price</emphasis> CHECK (price &gt; 0)\n"
");"

#: ddl.xml:285(para)
msgid ""
"You can also give the constraint a separate name. This clarifies error "
"messages and allows you to refer to the constraint when you need to change "
"it. The syntax is: <placeholder-1/> So, to specify a named constraint, use "
"the key word <literal>CONSTRAINT</literal> followed by an identifier "
"followed by the constraint definition. (If you don't specify a constraint "
"name in this way, the system chooses a name for you.)"
msgstr ""
"Вы можете также присвоить ограничению отдельное имя. Это улучшит сообщения "
"об ошибках и позволит вам ссылаться на это ограничение, когда вам "
"понадобится изменить его. Сделать это можно так: <placeholder-1/> То есть, "
"чтобы создать именованное ограничение, напишите ключевое слово "
"<literal>CONSTRAINT</literal>, а за ним идентификатор и собственно "
"определение ограничения. (Если вы не определите имя ограничения таким "
"образом, система выберет для него имя за вас.)"

#: ddl.xml:304(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric CHECK (price &gt; 0),\n"
"    discounted_price numeric CHECK (discounted_price &gt; 0),\n"
"    <emphasis>CHECK (price &gt; discounted_price)</emphasis>\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric CHECK (price &gt; 0),\n"
"    discounted_price numeric CHECK (discounted_price &gt; 0),\n"
"    <emphasis>CHECK (price &gt; discounted_price)</emphasis>\n"
");"

#: ddl.xml:300(para)
msgid ""
"A check constraint can also refer to several columns. Say you store a "
"regular price and a discounted price, and you want to ensure that the "
"discounted price is lower than the regular price: <placeholder-1/>"
msgstr ""
"Ограничение-проверка может также ссылаться на несколько столбцов. Например, "
"если вы храните обычную цену и цену со скидкой, так вы можете гарантировать, "
"что цена со скидкой будет всегда меньше обычной: <placeholder-1/>"

#: ddl.xml:313(para)
msgid ""
"The first two constraints should look familiar. The third one uses a new "
"syntax. It is not attached to a particular column, instead it appears as a "
"separate item in the comma-separated column list. Column definitions and "
"these constraint definitions can be listed in mixed order."
msgstr ""
"Первые два ограничения определяются похожим образом, но для третьего "
"используется новый синтаксис. Оно не связано с определённым столбцом, а "
"представлено отдельным элементом в списке. Определения столбцов и такие "
"определения ограничений можно переставлять в произвольном порядке."

#: ddl.xml:331(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric,\n"
"    CHECK (price &gt; 0),\n"
"    discounted_price numeric,\n"
"    CHECK (discounted_price &gt; 0),\n"
"    CHECK (price &gt; discounted_price)\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric,\n"
"    CHECK (price &gt; 0),\n"
"    discounted_price numeric,\n"
"    CHECK (discounted_price &gt; 0),\n"
"    CHECK (price &gt; discounted_price)\n"
");"

#: ddl.xml:341(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric CHECK (price &gt; 0),\n"
"    discounted_price numeric,\n"
"    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric CHECK (price &gt; 0),\n"
"    discounted_price numeric,\n"
"    CHECK (discounted_price &gt; 0 AND price &gt; discounted_price)\n"
");"

#: ddl.xml:321(para)
msgid ""
"We say that the first two constraints are column constraints, whereas the "
"third one is a table constraint because it is written separately from any "
"one column definition. Column constraints can also be written as table "
"constraints, while the reverse is not necessarily possible, since a column "
"constraint is supposed to refer to only the column it is attached to. "
"(<productname>PostgreSQL</productname> doesn't enforce that rule, but you "
"should follow it if you want your table definitions to work with other "
"database systems.) The above example could also be written as: "
"<placeholder-1/> or even: <placeholder-2/> It's a matter of taste."
msgstr ""
"Про первые два ограничения можно сказать, что это ограничения столбцов, "
"тогда как третье является ограничением таблицы, так как оно написано "
"отдельно от определений столбцов. Ограничения столбцов также можно записать "
"в виде ограничений таблицы, тогда как обратное не всегда возможно, так как "
"подразумевается, что ограничение столбца ссылается только на связанный "
"столбец. (Хотя <productname>PostgreSQL</productname> этого не требует, но "
"для совместимости с другими СУБД лучше следовать это правилу.) Ранее "
"приведённый пример можно переписать и так: <placeholder-1/> Или даже так: "
"<placeholder-2/> Это дело вкуса."

#: ddl.xml:354(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric,\n"
"    CHECK (price &gt; 0),\n"
"    discounted_price numeric,\n"
"    CHECK (discounted_price &gt; 0),\n"
"    <emphasis>CONSTRAINT valid_discount</emphasis> CHECK (price &gt; discounted_price)\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric,\n"
"    CHECK (price &gt; 0),\n"
"    discounted_price numeric,\n"
"    CHECK (discounted_price &gt; 0),\n"
"    <emphasis>CONSTRAINT valid_discount</emphasis> CHECK (price &gt; discounted_price)\n"
");"

#: ddl.xml:351(para)
msgid ""
"Names can be assigned to table constraints in the same way as column "
"constraints: <placeholder-1/>"
msgstr ""
"Ограничениям таблицы можно присваивать имена так же, как и ограничениям "
"столбцов: <placeholder-1/>"

#: ddl.xml:365(indexterm)
msgid ""
"<primary>null value</primary><secondary sortas=\"check constraints\">with "
"check constraints</secondary>"
msgstr ""
"<primary>значение NULL</primary><secondary sortas=\"ограничение-проверка\">с "
"ограничениями-проверками</secondary>"

#: ddl.xml:369(para)
msgid ""
"It should be noted that a check constraint is satisfied if the check "
"expression evaluates to true or the null value. Since most expressions will "
"evaluate to the null value if any operand is null, they will not prevent "
"null values in the constrained columns. To ensure that a column does not "
"contain null values, the not-null constraint described in the next section "
"can be used."
msgstr ""
"Следует заметить, что ограничение-проверка удовлетворяется, если выражение "
"принимает значение true или NULL. Так как результатом многих выражений с "
"операндами NULL будет значение NULL, такие ограничения не будут "
"препятствовать записи NULL в связанные столбцы. Чтобы гарантировать, что "
"столбец не содержит значения NULL, можно использовать ограничение NOT NULL, "
"описанное в следующем разделе."

#: ddl.xml:380(title)
msgid "Not-Null Constraints"
msgstr "Ограничения NOT NULL"

#: ddl.xml:382(indexterm)
msgid "<primary>not-null constraint</primary>"
msgstr "<primary>ограничение NOT NULL</primary>"

#: ddl.xml:386(indexterm)
msgid "<primary>constraint</primary><secondary>NOT NULL</secondary>"
msgstr "<primary>ограничение</primary><secondary>NOT NULL</secondary>"

#: ddl.xml:393(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer <emphasis>NOT NULL</emphasis>,\n"
"    name text <emphasis>NOT NULL</emphasis>,\n"
"    price numeric\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer <emphasis>NOT NULL</emphasis>,\n"
"    name text <emphasis>NOT NULL</emphasis>,\n"
"    price numeric\n"
");"

#: ddl.xml:390(para)
msgid ""
"A not-null constraint simply specifies that a column must not assume the "
"null value. A syntax example: <placeholder-1/>"
msgstr ""
"Ограничение NOT NULL просто указывает, что столбцу нельзя присваивать "
"значение NULL. Пример синтаксиса: <placeholder-1/>"

#: ddl.xml:400(para)
msgid ""
"A not-null constraint is always written as a column constraint. A not-null "
"constraint is functionally equivalent to creating a check constraint "
"<literal>CHECK (<replaceable>column_name</replaceable> IS NOT NULL)</"
"literal>, but in <productname>PostgreSQL</productname> creating an explicit "
"not-null constraint is more efficient. The drawback is that you cannot give "
"explicit names to not-null constraints created this way."
msgstr ""
"Ограничение NOT NULL всегда записывается как ограничение столбца и "
"функционально эквивалентно ограничению <literal>CHECK "
"(<replaceable>имя_столбца</replaceable> IS NOT NULL)</literal>, но в "
"<productname>PostgreSQL</productname> явное ограничение NOT NULL работает "
"более эффективно. Хотя у такой записи есть недостаток &mdash; назначить имя "
"таким ограничениям нельзя."

#: ddl.xml:414(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer NOT NULL,\n"
"    name text NOT NULL,\n"
"    price numeric NOT NULL CHECK (price &gt; 0)\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer NOT NULL,\n"
"    name text NOT NULL,\n"
"    price numeric NOT NULL CHECK (price &gt; 0)\n"
");"

#: ddl.xml:411(para)
msgid ""
"Of course, a column can have more than one constraint. Just write the "
"constraints one after another: <placeholder-1/> The order doesn't matter. It "
"does not necessarily determine in which order the constraints are checked."
msgstr ""
"Естественно, для столбца можно определить больше одного ограничения. Для "
"этого их нужно просто указать одно за другим: <placeholder-1/> Порядок здесь "
"не имеет значения, он не обязательно соответствует порядку проверки "
"ограничений."

#: ddl.xml:434(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer NULL,\n"
"    name text NULL,\n"
"    price numeric NULL\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer NULL,\n"
"    name text NULL,\n"
"    price numeric NULL\n"
");"

#: ddl.xml:423(para)
msgid ""
"The <literal>NOT NULL</literal> constraint has an inverse: the "
"<literal>NULL</literal> constraint. This does not mean that the column must "
"be null, which would surely be useless. Instead, this simply selects the "
"default behavior that the column might be null. The <literal>NULL</literal> "
"constraint is not present in the SQL standard and should not be used in "
"portable applications. (It was only added to <productname>PostgreSQL</"
"productname> to be compatible with some other database systems.) Some users, "
"however, like it because it makes it easy to toggle the constraint in a "
"script file. For example, you could start with: <placeholder-1/> and then "
"insert the <literal>NOT</literal> key word where desired."
msgstr ""
"Для ограничения <literal>NOT NULL</literal> есть и обратное: ограничение "
"<literal>NULL</literal>. Оно не означает, что столбец должен иметь только "
"значение NULL, что конечно было бы бессмысленно. Суть же его в простом "
"указании, что столбец может иметь значение NULL (это поведение по "
"умолчанию). Ограничение <literal>NULL</literal> отсутствует в стандарте SQL "
"и использовать его в переносимых приложениях не следует. (Оно было добавлено "
"в <productname>PostgreSQL</productname> только для совместимости с "
"некоторыми другими СУБД.) Однако некоторые пользователи любят его "
"использовать, так как оно позволяет легко переключать ограничения в скрипте. "
"Например, вы можете начать с: <placeholder-1/> и затем вставить ключевое "
"слово <literal>NOT</literal>, где потребуется."

#: ddl.xml:443(para)
msgid ""
"In most database designs the majority of columns should be marked not null."
msgstr ""
"При проектировании баз данных чаще всего большинство столбцов должны быть "
"помечены как NOT NULL."

#: ddl.xml:451(title)
msgid "Unique Constraints"
msgstr "Ограничения уникальности"

#: ddl.xml:453(indexterm)
msgid "<primary>unique constraint</primary>"
msgstr "<primary>ограничение уникальности</primary>"

#: ddl.xml:457(indexterm)
msgid "<primary>constraint</primary><secondary>unique</secondary>"
msgstr "<primary>ограничение</primary><secondary>уникальности</secondary>"

#: ddl.xml:465(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer <emphasis>UNIQUE</emphasis>,\n"
"    name text,\n"
"    price numeric\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer <emphasis>UNIQUE</emphasis>,\n"
"    name text,\n"
"    price numeric\n"
");"

#: ddl.xml:471(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric,\n"
"    <emphasis>UNIQUE (product_no)</emphasis>\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer,\n"
"    name text,\n"
"    price numeric,\n"
"    <emphasis>UNIQUE (product_no)</emphasis>\n"
");"

#: ddl.xml:461(para)
msgid ""
"Unique constraints ensure that the data contained in a column, or a group of "
"columns, is unique among all the rows in the table. The syntax is: "
"<placeholder-1/> when written as a column constraint, and: <placeholder-2/> "
"when written as a table constraint."
msgstr ""
"Ограничения уникальности гарантируют, что данные в определённом столбце или "
"группе столбцов уникальны среди всех строк таблицы. Ограничение записывается "
"так: <placeholder-1/> в виде ограничения столбца и так: <placeholder-2/> в "
"виде ограничения таблицы."

#: ddl.xml:483(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE example (\n"
"    a integer,\n"
"    b integer,\n"
"    c integer,\n"
"    <emphasis>UNIQUE (a, c)</emphasis>\n"
");"
msgstr ""
"CREATE TABLE example (\n"
"    a integer,\n"
"    b integer,\n"
"    c integer,\n"
"    <emphasis>UNIQUE (a, c)</emphasis>\n"
");"

#: ddl.xml:480(para)
msgid ""
"To define a unique constraint for a group of columns, write it as a table "
"constraint with the column names separated by commas: <placeholder-1/> This "
"specifies that the combination of values in the indicated columns is unique "
"across the whole table, though any one of the columns need not be (and "
"ordinarily isn't) unique."
msgstr ""
"Чтобы определить ограничение уникальности для группы столбцов, запишите его "
"в виде ограничения таблицы, перечислив имена столбцов через запятую: "
"<placeholder-1/> Такое ограничение указывает, что сочетание значений "
"перечисленных столбцов должно быть уникально во всей таблице, тогда как "
"значения каждого столбца по отдельности не должны быть (и обычно не будут) "
"уникальными."

#: ddl.xml:496(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,\n"
"    name text,\n"
"    price numeric\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer <emphasis>CONSTRAINT must_be_different</emphasis> UNIQUE,\n"
"    name text,\n"
"    price numeric\n"
");"

#: ddl.xml:494(para)
msgid ""
"You can assign your own name for a unique constraint, in the usual way: "
"<placeholder-1/>"
msgstr ""
"Вы можете назначить уникальному ограничению имя обычным образом: "
"<placeholder-1/>"

#: ddl.xml:503(para)
msgid ""
"Adding a unique constraint will automatically create a unique B-tree index "
"on the column or group of columns listed in the constraint. A uniqueness "
"restriction covering only some rows cannot be written as a unique "
"constraint, but it is possible to enforce such a restriction by creating a "
"unique <link linkend=\"indexes-partial\">partial index</link>."
msgstr ""
"При добавлении ограничения уникальности будет автоматически создан "
"уникальный индекс-B-дерево для столбца или группы столбцов, перечисленных в "
"ограничении. Условие уникальности, распространяющееся только на некоторые "
"строки, нельзя записать в виде ограничения уникальности, однако такое "
"условие можно установить, создав уникальный <link linkend=\"indexes-partial"
"\">частичный индекс</link>."

#: ddl.xml:511(indexterm)
msgid ""
"<primary>null value</primary><secondary sortas=\"unique constraints\">with "
"unique constraints</secondary>"
msgstr ""
"<primary>значение NULL</primary><secondary sortas=\"unique constraints\">с "
"ограничениями уникальности</secondary>"

#: ddl.xml:515(para)
msgid ""
"In general, a unique constraint is violated if there is more than one row in "
"the table where the values of all of the columns included in the constraint "
"are equal. However, two null values are never considered equal in this "
"comparison. That means even in the presence of a unique constraint it is "
"possible to store duplicate rows that contain a null value in at least one "
"of the constrained columns. This behavior conforms to the SQL standard, but "
"we have heard that other SQL databases might not follow this rule. So be "
"careful when developing applications that are intended to be portable."
msgstr ""
"Вообще говоря, ограничение уникальности нарушается, если в таблице "
"оказывается несколько строк, у которых совпадают значения всех столбцов, "
"включённых в ограничение. Однако два значения NULL при сравнении никогда не "
"считаются равными. Это означает, что даже при наличии ограничения "
"уникальности в таблице можно сохранить строки с дублирующимися значениями, "
"если они содержат NULL в одном или нескольких столбцах ограничения. Это "
"поведение соответствует стандарту SQL, но мы слышали о СУБД, которые ведут "
"себя по-другому. Имейте в виду эту особенность, разрабатывая переносимые "
"приложения."

#: ddl.xml:531(title)
msgid "Primary Keys"
msgstr "Первичные ключи"

#: ddl.xml:533(indexterm)
msgid "<primary>primary key</primary>"
msgstr "<primary>первичный ключ</primary>"

#: ddl.xml:537(indexterm)
msgid "<primary>constraint</primary><secondary>primary key</secondary>"
msgstr "<primary>ограничение</primary><secondary>первичный ключ</secondary>"

#: ddl.xml:546(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer UNIQUE NOT NULL,\n"
"    name text,\n"
"    price numeric\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer UNIQUE NOT NULL,\n"
"    name text,\n"
"    price numeric\n"
");"

#: ddl.xml:552(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer <emphasis>PRIMARY KEY</emphasis>,\n"
"    name text,\n"
"    price numeric\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer <emphasis>PRIMARY KEY</emphasis>,\n"
"    name text,\n"
"    price numeric\n"
");"

#: ddl.xml:541(para)
msgid ""
"A primary key constraint indicates that a column, or group of columns, can "
"be used as a unique identifier for rows in the table. This requires that the "
"values be both unique and not null. So, the following two table definitions "
"accept the same data: <placeholder-1/>\n"
"\n"
"<placeholder-2/>"
msgstr ""
"Ограничение первичного ключа означает, что образующий его столбец или группа "
"столбцов может быть уникальным идентификатором строк в таблице. Для этого "
"требуется, чтобы значения были одновременно уникальными и отличными от NULL. "
"Таким образом, таблицы со следующими двумя определениями будут принимать "
"одинаковые данные: <placeholder-1/>\n"
"\n"
"<placeholder-2/>"

#: ddl.xml:562(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE example (\n"
"    a integer,\n"
"    b integer,\n"
"    c integer,\n"
"    <emphasis>PRIMARY KEY (a, c)</emphasis>\n"
");"
msgstr ""
"CREATE TABLE example (\n"
"    a integer,\n"
"    b integer,\n"
"    c integer,\n"
"    <emphasis>PRIMARY KEY (a, c)</emphasis>\n"
");"

#: ddl.xml:559(para)
msgid ""
"Primary keys can span more than one column; the syntax is similar to unique "
"constraints: <placeholder-1/>"
msgstr ""
"Первичные ключи могут включать несколько столбцов; синтаксис похож на запись "
"ограничений уникальности: <placeholder-1/>"

#: ddl.xml:570(para)
msgid ""
"Adding a primary key will automatically create a unique B-tree index on the "
"column or group of columns listed in the primary key, and will force the "
"column(s) to be marked <literal>NOT NULL</literal>."
msgstr ""
"При добавлении первичного ключа автоматически создаётся уникальный индекс-B-"
"дерево для столбца или группы столбцов, перечисленных в первичном ключе, и "
"данные столбцы помечаются как <literal>NOT NULL</literal>."

#: ddl.xml:576(para)
msgid ""
"A table can have at most one primary key. (There can be any number of unique "
"and not-null constraints, which are functionally almost the same thing, but "
"only one can be identified as the primary key.) Relational database theory "
"dictates that every table must have a primary key. This rule is not enforced "
"by <productname>PostgreSQL</productname>, but it is usually best to follow "
"it."
msgstr ""
"Таблица может иметь максимум один первичный ключ. (Ограничений уникальности "
"и ограничений NOT NULL, которые функционально почти равнозначны первичным "
"ключам, может быть сколько угодно, но назначить ограничением первичного "
"ключа можно только одно.) Теория реляционных баз данных говорит, что "
"первичный ключ должен быть в каждой таблице. В <productname>PostgreSQL</"
"productname> такого жёсткого требования нет, но обычно лучше ему следовать."

#: ddl.xml:586(para)
msgid ""
"Primary keys are useful both for documentation purposes and for client "
"applications. For example, a GUI application that allows modifying row "
"values probably needs to know the primary key of a table to be able to "
"identify rows uniquely. There are also various ways in which the database "
"system makes use of a primary key if one has been declared; for example, the "
"primary key defines the default target column(s) for foreign keys "
"referencing its table."
msgstr ""
"Первичные ключи полезны и для документирования, и для клиентских приложений. "
"Например, графическому приложению с возможностями редактирования содержимого "
"таблицы, вероятно, потребуется знать первичный ключ таблицы, чтобы "
"однозначно идентифицировать её строки. Первичные ключи находят и другое "
"применение в СУБД; в частности, первичный ключ в таблице определяет целевые "
"столбцы по умолчанию для сторонних ключей, ссылающихся на эту таблицу."

#: ddl.xml:599(title)
msgid "Foreign Keys"
msgstr "Внешние ключи"

#: ddl.xml:601(indexterm)
msgid "<primary>foreign key</primary>"
msgstr "<primary>внешний ключ</primary>"

#: ddl.xml:605(indexterm)
msgid "<primary>constraint</primary><secondary>foreign key</secondary>"
msgstr "<primary>ограничение</primary><secondary>внешний ключ</secondary>"

#: ddl.xml:609(indexterm)
msgid "<primary>referential integrity</primary>"
msgstr "<primary>ссылочная целостность</primary>"

#: ddl.xml:613(para)
msgid ""
"A foreign key constraint specifies that the values in a column (or a group "
"of columns) must match the values appearing in some row of another table. We "
"say this maintains the <firstterm>referential integrity</firstterm> between "
"two related tables."
msgstr ""
"Ограничение внешнего ключа указывает, что значения столбца (или группы "
"столбцов) должны соответствовать значениям в некоторой строке другой "
"таблицы. Это называется <firstterm>ссылочной целостностью</firstterm> двух "
"связанных таблиц."

#: ddl.xml:623(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer PRIMARY KEY,\n"
"    name text,\n"
"    price numeric\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer PRIMARY KEY,\n"
"    name text,\n"
"    price numeric\n"
");"

#: ddl.xml:633(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE orders (\n"
"    order_id integer PRIMARY KEY,\n"
"    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,\n"
"    quantity integer\n"
");"
msgstr ""
"CREATE TABLE orders (\n"
"    order_id integer PRIMARY KEY,\n"
"    product_no integer <emphasis>REFERENCES products (product_no)</emphasis>,\n"
"    quantity integer\n"
");"

#: ddl.xml:621(para)
msgid ""
"Say you have the product table that we have used several times already: "
"<placeholder-1/> Let's also assume you have a table storing orders of those "
"products. We want to ensure that the orders table only contains orders of "
"products that actually exist. So we define a foreign key constraint in the "
"orders table that references the products table: <placeholder-2/> Now it is "
"impossible to create orders with non-NULL <structfield>product_no</"
"structfield> entries that do not appear in the products table."
msgstr ""
"Пусть у вас уже есть таблица продуктов, которую мы неоднократно использовали "
"ранее: <placeholder-1/> Давайте предположим, что у вас есть таблица с "
"заказами этих продуктов. Мы хотим, чтобы в таблице заказов содержались "
"только заказы действительно существующих продуктов. Поэтому мы определим в "
"ней ограничение внешнего ключа, ссылающееся на таблицу продуктов: "
"<placeholder-2/> С таким ограничением создать заказ со значением "
"<structfield>product_no</structfield>, отсутствующим в таблице products (и "
"не равным NULL), будет невозможно."

#: ddl.xml:643(para)
msgid ""
"We say that in this situation the orders table is the "
"<firstterm>referencing</firstterm> table and the products table is the "
"<firstterm>referenced</firstterm> table. Similarly, there are referencing "
"and referenced columns."
msgstr ""
"В такой схеме таблицу orders называют <firstterm>подчинённой</firstterm> "
"таблицей, а products &mdash; <firstterm>главной</firstterm>. Соответственно, "
"столбцы называют так же подчинённым и главным (или ссылающимся и целевым)."

#: ddl.xml:652(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE orders (\n"
"    order_id integer PRIMARY KEY,\n"
"    product_no integer <emphasis>REFERENCES products</emphasis>,\n"
"    quantity integer\n"
");"
msgstr ""
"CREATE TABLE orders (\n"
"    order_id integer PRIMARY KEY,\n"
"    product_no integer <emphasis>REFERENCES products</emphasis>,\n"
"    quantity integer\n"
");"

#: ddl.xml:650(para)
msgid ""
"You can also shorten the above command to: <placeholder-1/> because in "
"absence of a column list the primary key of the referenced table is used as "
"the referenced column(s)."
msgstr ""
"Предыдущую команду можно сократить так: <placeholder-1/> то есть, если "
"опустить список столбцов, внешний ключ будет неявно связан с первичным "
"ключом главной таблицы."

#: ddl.xml:665(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE t1 (\n"
"  a integer PRIMARY KEY,\n"
"  b integer,\n"
"  c integer,\n"
"  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>\n"
");"
msgstr ""
"CREATE TABLE t1 (\n"
"  a integer PRIMARY KEY,\n"
"  b integer,\n"
"  c integer,\n"
"  <emphasis>FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)</emphasis>\n"
");"

#: ddl.xml:661(para)
msgid ""
"A foreign key can also constrain and reference a group of columns. As usual, "
"it then needs to be written in table constraint form. Here is a contrived "
"syntax example: <placeholder-1/> Of course, the number and type of the "
"constrained columns need to match the number and type of the referenced "
"columns."
msgstr ""
"Внешний ключ также может ссылаться на группу столбцов. В этом случае его "
"нужно записать в виде обычного ограничения таблицы. Например: <placeholder-1/"
"> Естественно, число и типы столбцов в ограничении должны соответствовать "
"числу и типам целевых столбцов."

#: ddl.xml:675(para)
msgid ""
"You can assign your own name for a foreign key constraint, in the usual way."
msgstr "Ограничению внешнего ключа можно назначить имя стандартным способом."

#: ddl.xml:686(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer PRIMARY KEY,\n"
"    name text,\n"
"    price numeric\n"
");\n"
"\n"
"CREATE TABLE orders (\n"
"    order_id integer PRIMARY KEY,\n"
"    shipping_address text,\n"
"    ...\n"
");\n"
"\n"
"CREATE TABLE order_items (\n"
"    product_no integer REFERENCES products,\n"
"    order_id integer REFERENCES orders,\n"
"    quantity integer,\n"
"    PRIMARY KEY (product_no, order_id)\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer PRIMARY KEY,\n"
"    name text,\n"
"    price numeric\n"
");\n"
"\n"
"CREATE TABLE orders (\n"
"    order_id integer PRIMARY KEY,\n"
"    shipping_address text,\n"
"    ...\n"
");\n"
"\n"
"CREATE TABLE order_items (\n"
"    product_no integer REFERENCES products,\n"
"    order_id integer REFERENCES orders,\n"
"    quantity integer,\n"
"    PRIMARY KEY (product_no, order_id)\n"
");"

#: ddl.xml:680(para)
msgid ""
"A table can have more than one foreign key constraint. This is used to "
"implement many-to-many relationships between tables. Say you have tables "
"about products and orders, but now you want to allow one order to contain "
"possibly many products (which the structure above did not allow). You could "
"use this table structure: <placeholder-1/> Notice that the primary key "
"overlaps with the foreign keys in the last table."
msgstr ""
"Таблица может содержать несколько ограничений внешнего ключа. Это полезно "
"для связи таблиц в отношении многие-ко-многим. Скажем, у вас есть таблицы "
"продуктов и заказов, но вы хотите, чтобы один заказ мог содержать несколько "
"продуктов (что невозможно в предыдущей схеме). Для этого вы можете "
"использовать такую схему: <placeholder-1/> Заметьте, что в последней таблице "
"первичный ключ покрывает внешние ключи."

#: ddl.xml:708(indexterm)
msgid "<primary>CASCADE</primary><secondary>foreign key action</secondary>"
msgstr ""
"<primary>CASCADE</primary><secondary>действие внешнего ключа</secondary>"

#: ddl.xml:712(indexterm)
msgid "<primary>RESTRICT</primary><secondary>foreign key action</secondary>"
msgstr ""
"<primary>RESTRICT</primary><secondary>действие внешнего ключа</secondary>"

#: ddl.xml:722(para)
msgid "Disallow deleting a referenced product"
msgstr "Запретить удаление продукта"

#: ddl.xml:723(para)
msgid "Delete the orders as well"
msgstr "Удалить также связанные заказы"

#: ddl.xml:724(para)
msgid "Something else?"
msgstr "Что-то ещё?"

#: ddl.xml:716(para)
msgid ""
"We know that the foreign keys disallow creation of orders that do not relate "
"to any products. But what if a product is removed after an order is created "
"that references it? SQL allows you to handle that as well. Intuitively, we "
"have a few options: <placeholder-1/>"
msgstr ""
"Мы знаем, что внешние ключи запрещают создание заказов, не относящихся ни к "
"одному продукту. Но что делать, если после создания заказов с определённым "
"продуктом мы захотим удалить его? SQL справится с этой ситуацией. Интуиция "
"подсказывает следующие варианты поведения: <placeholder-1/>"

#: ddl.xml:734(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE products (\n"
"    product_no integer PRIMARY KEY,\n"
"    name text,\n"
"    price numeric\n"
");\n"
"\n"
"CREATE TABLE orders (\n"
"    order_id integer PRIMARY KEY,\n"
"    shipping_address text,\n"
"    ...\n"
");\n"
"\n"
"CREATE TABLE order_items (\n"
"    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,\n"
"    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,\n"
"    quantity integer,\n"
"    PRIMARY KEY (product_no, order_id)\n"
");"
msgstr ""
"CREATE TABLE products (\n"
"    product_no integer PRIMARY KEY,\n"
"    name text,\n"
"    price numeric\n"
");\n"
"\n"
"CREATE TABLE orders (\n"
"    order_id integer PRIMARY KEY,\n"
"    shipping_address text,\n"
"    ...\n"
");\n"
"\n"
"CREATE TABLE order_items (\n"
"    product_no integer REFERENCES products <emphasis>ON DELETE RESTRICT</emphasis>,\n"
"    order_id integer REFERENCES orders <emphasis>ON DELETE CASCADE</emphasis>,\n"
"    quantity integer,\n"
"    PRIMARY KEY (product_no, order_id)\n"
");"

#: ddl.xml:728(para)
msgid ""
"To illustrate this, let's implement the following policy on the many-to-many "
"relationship example above: when someone wants to remove a product that is "
"still referenced by an order (via <literal>order_items</literal>), we "
"disallow it. If someone removes an order, the order items are removed as "
"well: <placeholder-1/>"
msgstr ""
"Для иллюстрации давайте реализуем следующее поведение в вышеприведённом "
"примере: при попытке удаления продукта, на который ссылаются заказы (через "
"таблицу <literal>order_items</literal>), мы запрещаем эту операцию. Если же "
"кто-то попытается удалить заказ, то удалится и его содержимое: "
"<placeholder-1/>"

#: ddl.xml:754(para)
msgid ""
"Restricting and cascading deletes are the two most common options. "
"<literal>RESTRICT</literal> prevents deletion of a referenced row. "
"<literal>NO ACTION</literal> means that if any referencing rows still exist "
"when the constraint is checked, an error is raised; this is the default "
"behavior if you do not specify anything. (The essential difference between "
"these two choices is that <literal>NO ACTION</literal> allows the check to "
"be deferred until later in the transaction, whereas <literal>RESTRICT</"
"literal> does not.) <literal>CASCADE</literal> specifies that when a "
"referenced row is deleted, row(s) referencing it should be automatically "
"deleted as well. There are two other options: <literal>SET NULL</literal> "
"and <literal>SET DEFAULT</literal>. These cause the referencing column(s) in "
"the referencing row(s) to be set to nulls or their default values, "
"respectively, when the referenced row is deleted. Note that these do not "
"excuse you from observing any constraints. For example, if an action "
"specifies <literal>SET DEFAULT</literal> but the default value would not "
"satisfy the foreign key constraint, the operation will fail."
msgstr ""
"Ограничивающие и каскадные удаления &mdash; два наиболее распространённых "
"варианта. <literal>RESTRICT</literal> предотвращает удаление связанной "
"строки. <literal>NO ACTION</literal> означает, что если зависимые строки "
"продолжают существовать при проверке ограничения, возникает ошибка (это "
"поведение по умолчанию). (Главным отличием этих двух вариантов является то, "
"что <literal>NO ACTION</literal> позволяет отложить проверку в процессе "
"транзакции, а <literal>RESTRICT</literal> &mdash; нет.) <literal>CASCADE</"
"literal> указывает, что при удалении связанных строк зависимые от них будут "
"так же автоматически удалены. Есть ещё два варианта: <literal>SET NULL</"
"literal> и <literal>SET DEFAULT</literal>. При удалении связанных строк они "
"назначают зависимым столбцам в подчинённой таблице значения NULL или "
"значения по умолчанию, соответственно. Заметьте, что это не будет основанием "
"для нарушения ограничений. Например, если в качестве действия задано "
"<literal>SET DEFAULT</literal>, но значение по умолчанию не удовлетворяет "
"ограничению внешнего ключа, операция закончится ошибкой."

#: ddl.xml:776(para)
msgid ""
"Analogous to <literal>ON DELETE</literal> there is also <literal>ON UPDATE</"
"literal> which is invoked when a referenced column is changed (updated). The "
"possible actions are the same. In this case, <literal>CASCADE</literal> "
"means that the updated values of the referenced column(s) should be copied "
"into the referencing row(s)."
msgstr ""
"Аналогично указанию <literal>ON DELETE</literal> существует <literal>ON "
"UPDATE</literal>, которое срабатывает при изменении заданного столбца. При "
"этом возможные действия те же, а <literal>CASCADE</literal> в данном случае "
"означает, что изменённые значения связанных столбцов будут скопированы в "
"зависимые строки."

#: ddl.xml:784(para)
msgid ""
"Normally, a referencing row need not satisfy the foreign key constraint if "
"any of its referencing columns are null. If <literal>MATCH FULL</literal> is "
"added to the foreign key declaration, a referencing row escapes satisfying "
"the constraint only if all its referencing columns are null (so a mix of "
"null and non-null values is guaranteed to fail a <literal>MATCH FULL</"
"literal> constraint). If you don't want referencing rows to be able to avoid "
"satisfying the foreign key constraint, declare the referencing column(s) as "
"<literal>NOT NULL</literal>."
msgstr ""
"Обычно зависимая строка не должна удовлетворять ограничению внешнего ключа, "
"если один из связанных столбцов содержит NULL. Если в объявление внешнего "
"ключа добавлено <literal>MATCH FULL</literal>, строка будет удовлетворять "
"ограничению, только если все связанные столбцы равны NULL (то есть при "
"разных значениях (NULL и не NULL) гарантируется невыполнение ограничения "
"<literal>MATCH FULL</literal>). Если вы хотите, чтобы зависимые строки не "
"могли избежать и этого ограничения, объявите связанные столбцы как "
"<literal>NOT NULL</literal>."

#: ddl.xml:795(para)
msgid ""
"A foreign key must reference columns that either are a primary key or form a "
"unique constraint. This means that the referenced columns always have an "
"index (the one underlying the primary key or unique constraint); so checks "
"on whether a referencing row has a match will be efficient. Since a "
"<command>DELETE</command> of a row from the referenced table or an "
"<command>UPDATE</command> of a referenced column will require a scan of the "
"referencing table for rows matching the old value, it is often a good idea "
"to index the referencing columns too. Because this is not always needed, and "
"there are many choices available on how to index, declaration of a foreign "
"key constraint does not automatically create an index on the referencing "
"columns."
msgstr ""
"Внешний ключ должен ссылаться на столбцы, образующие первичный ключ или "
"ограничение уникальности. Таким образом, для связанных столбцов всегда будет "
"существовать индекс (определённый соответствующим первичным ключом или "
"ограничением), а значит проверки соответствия связанной строки будут "
"выполняться эффективно. Так как команды <command>DELETE</command> для строк "
"главной таблицы или <command>UPDATE</command> для зависимых столбцов "
"потребуют просканировать подчинённую таблицу и найти строки, ссылающиеся на "
"старые значения, полезно будет иметь индекс и для подчинённых столбцов. Но "
"это нужно не всегда, и создать соответствующий индекс можно по-разному, "
"поэтому объявление внешнего ключа не создаёт автоматически индекс по "
"связанным столбцам."

#: ddl.xml:809(para)
msgid ""
"More information about updating and deleting data is in <xref linkend=\"dml"
"\"/>. Also see the description of foreign key constraint syntax in the "
"reference documentation for <xref linkend=\"sql-createtable\"/>."
msgstr ""
"Подробнее об изменении и удалении данных рассказывается в <xref remap=\"6\" "
"linkend=\"dml\"/>. Вы также можете подробнее узнать о синтаксисе ограничений "
"внешнего ключа в справке <xref linkend=\"sql-createtable\"/>."

#: ddl.xml:818(title)
msgid "Exclusion Constraints"
msgstr "Ограничения-исключения"

#: ddl.xml:820(indexterm)
msgid "<primary>exclusion constraint</primary>"
msgstr "<primary>ограничение-исключение</primary>"

#: ddl.xml:824(indexterm)
msgid "<primary>constraint</primary><secondary>exclusion</secondary>"
msgstr "<primary>ограничение</primary><secondary>исключение</secondary>"

#: ddl.xml:833(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE circles (\n"
"    c circle,\n"
"    EXCLUDE USING gist (c WITH &amp;&amp;)\n"
");"
msgstr ""
"CREATE TABLE circles (\n"
"    c circle,\n"
"    EXCLUDE USING gist (c WITH &amp;&amp;)\n"
");"

#: ddl.xml:828(para)
msgid ""
"Exclusion constraints ensure that if any two rows are compared on the "
"specified columns or expressions using the specified operators, at least one "
"of these operator comparisons will return false or null. The syntax is: "
"<placeholder-1/>"
msgstr ""
"Ограничения-исключения гарантируют, что при сравнении любых двух строк по "
"указанным столбцам или выражениям с помощью заданных операторов, минимум "
"одно из этих сравнений возвратит false или NULL. Записывается это так: "
"<placeholder-1/>"

#: ddl.xml:839(para)
msgid ""
"See also <link linkend=\"sql-createtable-exclude\"><command>CREATE TABLE ... "
"CONSTRAINT ... EXCLUDE</command></link> for details."
msgstr ""
"Подробнее об этом см. <link linkend=\"sql-createtable-exclude"
"\"><command>CREATE TABLE ... CONSTRAINT ... EXCLUDE</command></link>."

#: ddl.xml:844(para)
msgid ""
"Adding an exclusion constraint will automatically create an index of the "
"type specified in the constraint declaration."
msgstr ""
"При добавлении ограничения-исключения будет автоматически создан индекс того "
"типа, который указан в объявлении ограничения."

#: ddl.xml:852(title)
msgid "System Columns"
msgstr "Системные столбцы"

#: ddl.xml:854(para)
msgid ""
"Every table has several <firstterm>system columns</firstterm> that are "
"implicitly defined by the system. Therefore, these names cannot be used as "
"names of user-defined columns. (Note that these restrictions are separate "
"from whether the name is a key word or not; quoting a name will not allow "
"you to escape these restrictions.) You do not really need to be concerned "
"about these columns; just know they exist."
msgstr ""
"В каждой таблице есть несколько <firstterm>системных столбцов</firstterm>, "
"неявно определённых системой. Как следствие, их имена нельзя использовать в "
"качестве имён пользовательских столбцов. (Заметьте, что это не зависит от "
"того, является ли имя ключевым словом или нет; заключение имени в кавычки не "
"поможет избежать этого ограничения.) Эти столбцы не должны вас беспокоить, "
"вам лишь достаточно знать об их существовании."

#: ddl.xml:864(indexterm)
msgid "<primary>column</primary><secondary>system column</secondary>"
msgstr "<primary>столбец</primary><secondary>системный столбец</secondary>"

#: ddl.xml:870(structfield)
msgid "oid"
msgstr "oid"

#: ddl.xml:873(indexterm)
msgid "<primary>OID</primary><secondary>column</secondary>"
msgstr "<primary>OID</primary><secondary>столбец</secondary>"

#: ddl.xml:872(para)
msgid ""
"<placeholder-1/> The object identifier (object ID) of a row. This column is "
"only present if the table was created using <literal>WITH OIDS</literal>, or "
"if the <xref linkend=\"guc-default-with-oids\"/> configuration variable was "
"set at the time. This column is of type <type>oid</type> (same name as the "
"column); see <xref linkend=\"datatype-oid\"/> for more information about the "
"type."
msgstr ""
"<placeholder-1/> Идентификатор объекта (object ID) для строки. Этот столбец "
"присутствует, только если таблица была создана с указанием <literal>WITH "
"OIDS</literal>, или если в момент её создания была установлена переменная "
"конфигурации <xref linkend=\"guc-default-with-oids\"/>. Этот столбец имеет "
"тип <type>oid</type> (с тем же именем, что и сам столбец); подробнее об этом "
"типе см. <xref remap=\"4\" linkend=\"datatype-oid\"/>."

#: ddl.xml:887(structfield)
msgid "tableoid"
msgstr "tableoid"

#: ddl.xml:889(indexterm)
msgid "<primary>tableoid</primary>"
msgstr "<primary>tableoid</primary>"

#: ddl.xml:893(para)
msgid ""
"The OID of the table containing this row. This column is particularly handy "
"for queries that select from inheritance hierarchies (see <xref linkend="
"\"ddl-inherit\"/>), since without it, it's difficult to tell which "
"individual table a row came from. The <structfield>tableoid</structfield> "
"can be joined against the <structfield>oid</structfield> column of "
"<structname>pg_class</structname> to obtain the table name."
msgstr ""
"Идентификатор объекта для таблицы, содержащей строку. Этот столбец особенно "
"полезен для запросов, имеющих дело с иерархией наследования (см. <xref remap="
"\"4\" linkend=\"ddl-inherit\"/>), так как без него сложно определить, из "
"какой таблицы выбрана строка. Связав <structfield>tableoid</structfield> со "
"столбцом <structfield>oid</structfield> в таблице <structname>pg_class</"
"structname>, можно будет получить имя таблицы."

#: ddl.xml:906(structfield)
msgid "xmin"
msgstr "xmin"

#: ddl.xml:908(indexterm)
msgid "<primary>xmin</primary>"
msgstr "<primary>xmin</primary>"

#: ddl.xml:912(para)
msgid ""
"The identity (transaction ID) of the inserting transaction for this row "
"version. (A row version is an individual state of a row; each update of a "
"row creates a new row version for the same logical row.)"
msgstr ""
"Идентификатор (код) транзакции, добавившей строку этой версии. (Версия "
"строки &mdash; это её индивидуальное состояние; при каждом изменении "
"создаётся новая версия одной и той же логической строки.)"

#: ddl.xml:922(structfield)
msgid "cmin"
msgstr "cmin"

#: ddl.xml:924(indexterm)
msgid "<primary>cmin</primary>"
msgstr "<primary>cmin</primary>"

#: ddl.xml:928(para)
msgid ""
"The command identifier (starting at zero) within the inserting transaction."
msgstr "Номер команды (начиная с нуля) внутри транзакции, добавившей строку."

#: ddl.xml:936(structfield)
msgid "xmax"
msgstr "xmax"

#: ddl.xml:938(indexterm)
msgid "<primary>xmax</primary>"
msgstr "<primary>xmax</primary>"

#: ddl.xml:942(para)
msgid ""
"The identity (transaction ID) of the deleting transaction, or zero for an "
"undeleted row version. It is possible for this column to be nonzero in a "
"visible row version. That usually indicates that the deleting transaction "
"hasn't committed yet, or that an attempted deletion was rolled back."
msgstr ""
"Идентификатор транзакции, удалившей строку, или 0 для неудалённой версии "
"строки. Значение этого столбца может быть ненулевым и для видимой версии "
"строки. Это обычно означает, что удаляющая транзакция ещё не была "
"зафиксирована, или удаление было отменено."

#: ddl.xml:953(structfield)
msgid "cmax"
msgstr "cmax"

#: ddl.xml:955(indexterm)
msgid "<primary>cmax</primary>"
msgstr "<primary>cmax</primary>"

#: ddl.xml:959(para)
msgid "The command identifier within the deleting transaction, or zero."
msgstr "Номер команды в удаляющей транзакции или ноль."

#: ddl.xml:966(structfield)
msgid "ctid"
msgstr "ctid"

#: ddl.xml:968(indexterm)
msgid "<primary>ctid</primary>"
msgstr "<primary>ctid</primary>"

#: ddl.xml:972(para)
msgid ""
"The physical location of the row version within its table. Note that "
"although the <structfield>ctid</structfield> can be used to locate the row "
"version very quickly, a row's <structfield>ctid</structfield> will change if "
"it is updated or moved by <command>VACUUM FULL</command>. Therefore "
"<structfield>ctid</structfield> is useless as a long-term row identifier. "
"The OID, or even better a user-defined serial number, should be used to "
"identify logical rows."
msgstr ""
"Физическое расположение данной версии строки в таблице. Заметьте, что хотя "
"по <structfield>ctid</structfield> можно очень быстро найти версию строки, "
"значение <structfield>ctid</structfield> изменится при выполнении "
"<command>VACUUM FULL</command>. Таким образом, <structfield>ctid</"
"structfield> нельзя применять в качестве долгосрочного идентификатора "
"строки. Для идентификации логических строк лучше использовать OID или даже "
"дополнительный последовательный номер."

#: ddl.xml:998(para)
msgid ""
"A unique constraint should be created on the OID column of each table for "
"which the OID will be used to identify rows. When such a unique constraint "
"(or unique index) exists, the system takes care not to generate an OID "
"matching an already-existing row. (Of course, this is only possible if the "
"table contains fewer than 2<superscript>32</superscript> (4 billion) rows, "
"and in practice the table size had better be much less than that, or "
"performance might suffer.)"
msgstr ""
"Когда для идентификации строк таблиц применяется OID, в каждой такой таблице "
"должно создаваться ограничение уникальности для столбца OID. Когда такое "
"ограничение уникальности (или уникальный индекс) существует, система "
"позаботится о том, чтобы OID новой строки не совпал с уже существующими. "
"(Конечно, это возможно, только если в таблице меньше 2<superscript>32</"
"superscript> (4 миллиардов) строк, а на практике таблицы должны быть гораздо "
"меньше, иначе может пострадать производительность системы.)"

#: ddl.xml:1010(para)
msgid ""
"OIDs should never be assumed to be unique across tables; use the combination "
"of <structfield>tableoid</structfield> and row OID if you need a database-"
"wide identifier."
msgstr ""
"Никогда не следует рассчитывать, что OID будут уникальны среди всех таблиц; "
"в качестве глобального идентификатора в рамках базы данных используйте "
"комбинацию <structfield>tableoid</structfield> и OID строки."

#: ddl.xml:1017(para)
msgid ""
"Of course, the tables in question must be created <literal>WITH OIDS</"
"literal>. As of <productname>PostgreSQL</productname> 8.1, <literal>WITHOUT "
"OIDS</literal> is the default."
msgstr ""
"Конечно, все эти таблицы должны быть созданы с указанием <literal>WITH OIDS</"
"literal>. В <productname>PostgreSQL</productname> 8.1 и новее по умолчанию "
"подразумевается <literal>WITHOUT OIDS</literal>."

#: ddl.xml:986(para)
msgid ""
"OIDs are 32-bit quantities and are assigned from a single cluster-wide "
"counter. In a large or long-lived database, it is possible for the counter "
"to wrap around. Hence, it is bad practice to assume that OIDs are unique, "
"unless you take steps to ensure that this is the case. If you need to "
"identify the rows in a table, using a sequence generator is strongly "
"recommended. However, OIDs can be used as well, provided that a few "
"additional precautions are taken: <placeholder-1/>"
msgstr ""
"Коды OID представляют собой 32-битные значения и выбираются из единого для "
"всей СУБД счётчика. В больших или долгоживущих базах данных этот счётчик "
"может пойти по кругу. Таким образом, не рекомендуется рассчитывать на "
"уникальность OID, если только вы не обеспечите её дополнительно. Если вам "
"нужно идентифицировать строки таблицы, настоятельно рекомендуется "
"использовать последовательности. Однако можно использовать и коды OID, при "
"выполнении следующих условий: <placeholder-1/>"

#: ddl.xml:1026(para)
msgid ""
"Transaction identifiers are also 32-bit quantities. In a long-lived database "
"it is possible for transaction IDs to wrap around. This is not a fatal "
"problem given appropriate maintenance procedures; see <xref linkend="
"\"maintenance\"/> for details. It is unwise, however, to depend on the "
"uniqueness of transaction IDs over the long term (more than one billion "
"transactions)."
msgstr ""
"Идентификаторы транзакций также являются 32-битными. В долгоживущей базе "
"данных они могут пойти по кругу. Это не критично при правильном обслуживании "
"БД; подробнее об этом см. <xref remap=\"4\" linkend=\"maintenance\"/>. "
"Однако полагаться на уникальность кодов транзакций в течение длительного "
"времени (при более чем миллиарде транзакций) не следует."

#: ddl.xml:1035(para)
msgid ""
"Command identifiers are also 32-bit quantities. This creates a hard limit of "
"2<superscript>32</superscript> (4 billion) <acronym>SQL</acronym> commands "
"within a single transaction. In practice this limit is not a problem &mdash; "
"note that the limit is on the number of <acronym>SQL</acronym> commands, not "
"the number of rows processed. Also, only commands that actually modify the "
"database contents will consume a command identifier."
msgstr ""
"Идентификаторы команд также 32-битные. Это создаёт жёсткий лимит на "
"2<superscript>32</superscript> (4 миллиарда) команд <acronym>SQL</acronym> в "
"одной транзакции. На практике это не проблема &mdash; заметьте, что это "
"лимит числа команд <acronym>SQL</acronym>, а не количества обрабатываемых "
"строк. Кроме того, идентификатор получают только те команды, которые "
"фактически изменяют содержимое базы данных."

#: ddl.xml:1047(title)
msgid "Modifying Tables"
msgstr "Изменение таблиц"

#: ddl.xml:1049(indexterm)
msgid "<primary>table</primary><secondary>modifying</secondary>"
msgstr "<primary>таблица</primary><secondary>изменение</secondary>"

#: ddl.xml:1053(para)
msgid ""
"When you create a table and you realize that you made a mistake, or the "
"requirements of the application change, you can drop the table and create it "
"again. But this is not a convenient option if the table is already filled "
"with data, or if the table is referenced by other database objects (for "
"instance a foreign key constraint). Therefore <productname>PostgreSQL</"
"productname> provides a family of commands to make modifications to existing "
"tables. Note that this is conceptually distinct from altering the data "
"contained in the table: here we are interested in altering the definition, "
"or structure, of the table."
msgstr ""
"Если вы создали таблицы, а затем поняли, что допустили ошибку, или "
"изменились требования вашего приложения, вы можете удалить её и создать "
"заново. Но это будет неудобно, если таблица уже заполнена данными, или если "
"на неё ссылаются другие объекты базы данных (например, по внешнему ключу). "
"Поэтому <productname>PostgreSQL</productname> предоставляет набор команд для "
"модификации таблиц. Заметьте, что это по сути отличается от изменения "
"данных, содержащихся в таблице: здесь мы обсуждаем модификацию определения, "
"или структуры, таблицы."

#: ddl.xml:1070(para)
msgid "Add columns"
msgstr "Добавлять столбцы"

#: ddl.xml:1073(para)
msgid "Remove columns"
msgstr "Удалять столбцы"

#: ddl.xml:1076(para)
msgid "Add constraints"
msgstr "Добавлять ограничения"

#: ddl.xml:1079(para)
msgid "Remove constraints"
msgstr "Удалять ограничения"

#: ddl.xml:1082(para)
msgid "Change default values"
msgstr "Изменять значения по умолчанию"

#: ddl.xml:1085(para)
msgid "Change column data types"
msgstr "Изменять типы столбцов"

#: ddl.xml:1088(para)
msgid "Rename columns"
msgstr "Переименовывать столбцы"

#: ddl.xml:1091(para)
msgid "Rename tables"
msgstr "Переименовывать таблицы"

#: ddl.xml:1066(para)
msgid ""
"You can: <placeholder-1/> All these actions are performed using the <xref "
"linkend=\"sql-altertable\"/> command, whose reference page contains details "
"beyond those given here."
msgstr ""
"Вы можете: <placeholder-1/> Все эти действия выполняются с помощью команды "
"<xref linkend=\"sql-altertable\"/>; подробнее о ней вы можете узнать в её "
"справке."

#: ddl.xml:1102(title)
msgid "Adding a Column"
msgstr "Добавление столбца"

#: ddl.xml:1104(indexterm)
msgid "<primary>column</primary><secondary>adding</secondary>"
msgstr "<primary>столбец</primary><secondary>добавление</secondary>"

#: ddl.xml:1110(programlisting)
#, no-wrap
msgid "ALTER TABLE products ADD COLUMN description text;"
msgstr "ALTER TABLE products ADD COLUMN description text;"

#: ddl.xml:1108(para)
msgid ""
"To add a column, use a command like: <placeholder-1/> The new column is "
"initially filled with whatever default value is given (null if you don't "
"specify a <literal>DEFAULT</literal> clause)."
msgstr ""
"Добавить столбец вы можете так: <placeholder-1/> Новый столбец заполняется "
"заданным для него значением по умолчанию (или значением NULL, если вы не "
"добавите указание <literal>DEFAULT</literal>)."

#: ddl.xml:1118(programlisting)
#, no-wrap
msgid "ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');"
msgstr "ALTER TABLE products ADD COLUMN description text CHECK (description &lt;&gt; '');"

#: ddl.xml:1115(para)
msgid ""
"You can also define constraints on the column at the same time, using the "
"usual syntax: <placeholder-1/> In fact all the options that can be applied "
"to a column description in <command>CREATE TABLE</command> can be used here. "
"Keep in mind however that the default value must satisfy the given "
"constraints, or the <literal>ADD</literal> will fail. Alternatively, you can "
"add constraints later (see below) after you've filled in the new column "
"correctly."
msgstr ""
"При этом вы можете сразу определить ограничения столбца, используя обычный "
"синтаксис: <placeholder-1/> На самом деле здесь можно использовать все "
"конструкции, допустимые в определении столбца в команде <command>CREATE "
"TABLE</command>. Помните однако, что значение по умолчанию должно "
"удовлетворять данным ограничениям, чтобы операция <literal>ADD</literal> "
"выполнилась успешно. Вы также можете сначала заполнить столбец правильно, а "
"затем добавить ограничения (см. ниже)."

#: ddl.xml:1128(para)
msgid ""
"Adding a column with a default requires updating each row of the table (to "
"store the new column value). However, if no default is specified, "
"<productname>PostgreSQL</productname> is able to avoid the physical update. "
"So if you intend to fill the column with mostly nondefault values, it's best "
"to add the column with no default, insert the correct values using "
"<command>UPDATE</command>, and then add any desired default as described "
"below."
msgstr ""
"Добавление столбца со значением по умолчанию приводит к изменению всех строк "
"таблицы (в них будет сохранено новое значение). Однако, если значение по "
"умолчанию не указано, <productname>PostgreSQL</productname> может обойтись "
"без физического изменения. Поэтому, если вы планируете заполнить столбец в "
"основном не значениями по умолчанию, лучше будет добавить столбец без "
"значения по умолчанию, затем вставить требуемые значения с помощью "
"<command>UPDATE</command>, а потом определить значение по умолчанию, как "
"описано ниже."

#: ddl.xml:1141(title)
msgid "Removing a Column"
msgstr "Удаление столбца"

#: ddl.xml:1143(indexterm)
msgid "<primary>column</primary><secondary>removing</secondary>"
msgstr "<primary>столбец</primary><secondary>удаление</secondary>"

#: ddl.xml:1149(programlisting)
#, no-wrap
msgid "ALTER TABLE products DROP COLUMN description;"
msgstr "ALTER TABLE products DROP COLUMN description;"

#: ddl.xml:1156(programlisting)
#, no-wrap
msgid "ALTER TABLE products DROP COLUMN description CASCADE;"
msgstr "ALTER TABLE products DROP COLUMN description CASCADE;"

#: ddl.xml:1147(para)
msgid ""
"To remove a column, use a command like: <placeholder-1/> Whatever data was "
"in the column disappears. Table constraints involving the column are "
"dropped, too. However, if the column is referenced by a foreign key "
"constraint of another table, <productname>PostgreSQL</productname> will not "
"silently drop that constraint. You can authorize dropping everything that "
"depends on the column by adding <literal>CASCADE</literal>: <placeholder-2/> "
"See <xref linkend=\"ddl-depend\"/> for a description of the general "
"mechanism behind this."
msgstr ""
"Удалить столбец можно так: <placeholder-1/> Данные, которые были в этом "
"столбце, исчезают. Вместе со столбцом удаляются и включающие его ограничения "
"таблицы. Однако, если на столбец ссылается ограничение внешнего ключа другой "
"таблицы, <productname>PostgreSQL</productname> не удалит это ограничение "
"неявно. Разрешить удаление всех зависящих от этого столбца объектов можно, "
"добавив указание <literal>CASCADE</literal>: <placeholder-2/> Общий "
"механизм, стоящий за этим, описывается в <xref remap=\"6\" linkend=\"ddl-"
"depend\"/>."

#: ddl.xml:1163(title)
msgid "Adding a Constraint"
msgstr "Добавление ограничения"

#: ddl.xml:1165(indexterm)
msgid "<primary>constraint</primary><secondary>adding</secondary>"
msgstr "<primary>ограничение</primary><secondary>добавление</secondary>"

#: ddl.xml:1171(programlisting)
#, no-wrap
msgid ""
"ALTER TABLE products ADD CHECK (name &lt;&gt; '');\n"
"ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);\n"
"ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;"
msgstr ""
"ALTER TABLE products ADD CHECK (name &lt;&gt; '');\n"
"ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);\n"
"ALTER TABLE products ADD FOREIGN KEY (product_group_id)\n"
"  REFERENCES product_groups;"

#: ddl.xml:1176(programlisting)
#, no-wrap
msgid "ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;"
msgstr "ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;"

#: ddl.xml:1169(para)
msgid ""
"To add a constraint, the table constraint syntax is used. For example: "
"<placeholder-1/> To add a not-null constraint, which cannot be written as a "
"table constraint, use this syntax: <placeholder-2/>"
msgstr ""
"Для добавления ограничения используется синтаксис ограничения таблицы. "
"Например: <placeholder-1/> Чтобы добавить ограничение NOT NULL, которое "
"нельзя записать в виде ограничения таблицы, используйте такой синтаксис: "
"<placeholder-2/>"

#: ddl.xml:1179(para)
msgid ""
"The constraint will be checked immediately, so the table data must satisfy "
"the constraint before it can be added."
msgstr ""
"Ограничение проходит проверку автоматически и будет добавлено, только если "
"ему удовлетворяют данные таблицы."

#: ddl.xml:1186(title)
msgid "Removing a Constraint"
msgstr "Удаление ограничения"

#: ddl.xml:1188(indexterm)
msgid "<primary>constraint</primary><secondary>removing</secondary>"
msgstr "<primary>ограничение</primary><secondary>удаление</secondary>"

#: ddl.xml:1200(programlisting)
#, no-wrap
msgid "ALTER TABLE products DROP CONSTRAINT some_name;"
msgstr "ALTER TABLE products DROP CONSTRAINT some_name;"

#: ddl.xml:1192(para)
msgid ""
"To remove a constraint you need to know its name. If you gave it a name then "
"that's easy. Otherwise the system assigned a generated name, which you need "
"to find out. The <application>psql</application> command <literal>\\d "
"<replaceable>tablename</replaceable></literal> can be helpful here; other "
"interfaces might also provide a way to inspect table details. Then the "
"command is: <placeholder-1/> (If you are dealing with a generated constraint "
"name like <literal>$2</literal>, don't forget that you'll need to double-"
"quote it to make it a valid identifier.)"
msgstr ""
"Для удаления ограничения вы должны знать его имя. Если вы не присваивали ему "
"имя, это неявно сделала система, и вы должны выяснить его. Здесь может быть "
"полезна команда <application>psql</application> <literal>\\d "
"<replaceable>имя_таблицы</replaceable></literal> (или другие программы, "
"показывающие подробную информацию о таблицах). Зная имя, вы можете "
"использовать команду: <placeholder-1/> (Если вы имеете дело с именем "
"ограничения вида <literal>$2</literal>, не забудьте заключить его в кавычки, "
"чтобы это был допустимый идентификатор.)"

#: ddl.xml:1206(para)
msgid ""
"As with dropping a column, you need to add <literal>CASCADE</literal> if you "
"want to drop a constraint that something else depends on. An example is that "
"a foreign key constraint depends on a unique or primary key constraint on "
"the referenced column(s)."
msgstr ""
"Как и при удалении столбца, если вы хотите удалить ограничение с зависимыми "
"объектами, добавьте указание <literal>CASCADE</literal>. Примером такой "
"зависимости может быть ограничение внешнего ключа, связанное со столбцами "
"ограничения первичного ключа."

#: ddl.xml:1216(programlisting)
#, no-wrap
msgid "ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;"
msgstr "ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;"

#: ddl.xml:1213(para)
msgid ""
"This works the same for all constraint types except not-null constraints. To "
"drop a not null constraint use: <placeholder-1/> (Recall that not-null "
"constraints do not have names.)"
msgstr ""
"Так можно удалить ограничения любых типов, кроме NOT NULL. Чтобы удалить "
"ограничение NOT NULL, используйте команду: <placeholder-1/> (Вспомните, что "
"у ограничений NOT NULL нет имён.)"

#: ddl.xml:1222(title)
msgid "Changing a Column's Default Value"
msgstr "Изменение значения по умолчанию"

#: ddl.xml:1224(indexterm)
msgid "<primary>default value</primary><secondary>changing</secondary>"
msgstr ""
"<primary>значение по умолчанию</primary><secondary>изменение</secondary>"

#: ddl.xml:1230(programlisting)
#, no-wrap
msgid "ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;"
msgstr "ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;"

#: ddl.xml:1228(para)
msgid ""
"To set a new default for a column, use a command like: <placeholder-1/> Note "
"that this doesn't affect any existing rows in the table, it just changes the "
"default for future <command>INSERT</command> commands."
msgstr ""
"Назначить столбцу новое значение по умолчанию можно так: <placeholder-1/> "
"Заметьте, что это никак не влияет на существующие строки таблицы, а просто "
"задаёт значение по умолчанию для последующих команд <command>INSERT</"
"command>."

#: ddl.xml:1237(programlisting)
#, no-wrap
msgid "ALTER TABLE products ALTER COLUMN price DROP DEFAULT;"
msgstr "ALTER TABLE products ALTER COLUMN price DROP DEFAULT;"

#: ddl.xml:1235(para)
msgid ""
"To remove any default value, use: <placeholder-1/> This is effectively the "
"same as setting the default to null. As a consequence, it is not an error to "
"drop a default where one hadn't been defined, because the default is "
"implicitly the null value."
msgstr ""
"Чтобы удалить значение по умолчанию, выполните: <placeholder-1/> При этом по "
"сути значению по умолчанию просто присваивается NULL. Как следствие, ошибки "
"не будет, если вы попытаетесь удалить значение по умолчанию, не определённое "
"явно, так как неявно оно существует и равно NULL."

#: ddl.xml:1246(title)
msgid "Changing a Column's Data Type"
msgstr "Изменение типа данных столбца"

#: ddl.xml:1248(indexterm)
msgid "<primary>column data type</primary><secondary>changing</secondary>"
msgstr "<primary>тип данных столбца</primary><secondary>изменение</secondary>"

#: ddl.xml:1254(programlisting)
#, no-wrap
msgid "ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);"
msgstr "ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);"

#: ddl.xml:1252(para)
msgid ""
"To convert a column to a different data type, use a command like: "
"<placeholder-1/> This will succeed only if each existing entry in the column "
"can be converted to the new type by an implicit cast. If a more complex "
"conversion is needed, you can add a <literal>USING</literal> clause that "
"specifies how to compute the new values from the old."
msgstr ""
"Чтобы преобразовать столбец в другой тип данных, используйте команду: "
"<placeholder-1/> Она будет успешна, только если все существующие значения в "
"столбце могут быть неявно приведены к новому типу. Если требуется более "
"сложное преобразование, вы можете добавить указание <literal>USING</"
"literal>, определяющее, как получить новые значения из старых."

#: ddl.xml:1261(para)
msgid ""
"<productname>PostgreSQL</productname> will attempt to convert the column's "
"default value (if any) to the new type, as well as any constraints that "
"involve the column. But these conversions might fail, or might produce "
"surprising results. It's often best to drop any constraints on the column "
"before altering its type, and then add back suitably modified constraints "
"afterwards."
msgstr ""
"<productname>PostgreSQL</productname> попытается также преобразовать к "
"новому типу значение столбца по умолчанию (если оно определено) и все "
"связанные с этим столбцом ограничения. Но преобразование может оказаться "
"неправильным, и тогда вы получите неожиданные результаты. Поэтому обычно "
"лучше удалить все ограничения столбца, перед тем как менять его тип, а затем "
"воссоздать модифицированные должным образом ограничения."

#: ddl.xml:1272(title)
msgid "Renaming a Column"
msgstr "Переименование столбца"

#: ddl.xml:1274(indexterm)
msgid "<primary>column</primary><secondary>renaming</secondary>"
msgstr "<primary>столбец</primary><secondary>переименование</secondary>"

#: ddl.xml:1280(programlisting)
#, no-wrap
msgid "ALTER TABLE products RENAME COLUMN product_no TO product_number;"
msgstr "ALTER TABLE products RENAME COLUMN product_no TO product_number;"

#: ddl.xml:1278(para)
msgid "To rename a column: <placeholder-1/>"
msgstr "Чтобы переименовать столбец, выполните: <placeholder-1/>"

#: ddl.xml:1285(title)
msgid "Renaming a Table"
msgstr "Переименование таблицы"

#: ddl.xml:1287(indexterm)
msgid "<primary>table</primary><secondary>renaming</secondary>"
msgstr "<primary>таблица</primary><secondary>переименование</secondary>"

#: ddl.xml:1293(programlisting)
#, no-wrap
msgid "ALTER TABLE products RENAME TO items;"
msgstr "ALTER TABLE products RENAME TO items;"

#: ddl.xml:1291(para)
msgid "To rename a table: <placeholder-1/>"
msgstr "Таблицу можно переименовать так: <placeholder-1/>"

#: ddl.xml:1299(title)
msgid "Privileges"
msgstr "Права"

#: ddl.xml:1301(indexterm)
msgid "<primary>privilege</primary>"
msgstr "<primary>право</primary>"

#: ddl.xml:1305(indexterm)
msgid "<primary>permission</primary><see>privilege</see>"
msgstr "<primary>разрешение</primary><see>право</see>"

#: ddl.xml:1309(indexterm)
msgid "<primary>owner</primary>"
msgstr "<primary>владелец</primary>"

#: ddl.xml:1313(indexterm)
msgid "<primary>GRANT</primary>"
msgstr "<primary>GRANT</primary>"

#: ddl.xml:1317(indexterm)
msgid "<primary>REVOKE</primary>"
msgstr "<primary>REVOKE</primary>"

#: ddl.xml:1321(para)
msgid ""
"When an object is created, it is assigned an owner. The owner is normally "
"the role that executed the creation statement. For most kinds of objects, "
"the initial state is that only the owner (or a superuser) can do anything "
"with the object. To allow other roles to use it, <firstterm>privileges</"
"firstterm> must be granted."
msgstr ""
"Когда в базе данных создаётся объект, ему назначается владелец. Владельцем "
"обычно становится роль, с которой был выполнен оператор создания. Для "
"большинства типов объектов в исходном состоянии только владелец (или "
"суперпользователь) может делать с объектом всё, что угодно. Чтобы разрешить "
"использовать его другим ролям, нужно дать им <firstterm>права</firstterm>."

#: ddl.xml:1330(para)
msgid ""
"There are different kinds of privileges: <literal>SELECT</literal>, "
"<literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</"
"literal>, <literal>TRUNCATE</literal>, <literal>REFERENCES</literal>, "
"<literal>TRIGGER</literal>, <literal>CREATE</literal>, <literal>CONNECT</"
"literal>, <literal>TEMPORARY</literal>, <literal>EXECUTE</literal>, and "
"<literal>USAGE</literal>. The privileges applicable to a particular object "
"vary depending on the object's type (table, function, etc). For complete "
"information on the different types of privileges supported by "
"<productname>PostgreSQL</productname>, refer to the <xref linkend=\"sql-grant"
"\"/> reference page. The following sections and chapters will also show you "
"how those privileges are used."
msgstr ""
"Существует несколько типов прав: <literal>SELECT</literal>, <literal>INSERT</"
"literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>, "
"<literal>TRUNCATE</literal>, <literal>REFERENCES</literal>, "
"<literal>TRIGGER</literal>, <literal>CREATE</literal>, <literal>CONNECT</"
"literal>, <literal>TEMPORARY</literal>, <literal>EXECUTE</literal> и "
"<literal>USAGE</literal>. Набор прав, применимых к определённому объекту, "
"зависит от типа объекта (таблица, функция и т. д.) Полную информацию о "
"различных типах прав, поддерживаемых <productname>PostgreSQL</productname>, "
"вы найдете на странице справки <xref linkend=\"sql-grant\"/>. Вы также "
"увидите, как применяются эти права, в следующих разделах и главах."

#: ddl.xml:1345(para)
msgid ""
"The right to modify or destroy an object is always the privilege of the "
"owner only."
msgstr ""
"Неотъемлемое право изменять или удалять объект имеет только владелец объекта."

#: ddl.xml:1350(para)
msgid ""
"An object can be assigned to a new owner with an <command>ALTER</command> "
"command of the appropriate kind for the object, e.g. <xref linkend=\"sql-"
"altertable\"/>. Superusers can always do this; ordinary roles can only do it "
"if they are both the current owner of the object (or a member of the owning "
"role) and a member of the new owning role."
msgstr ""
"Объекту можно назначить нового владельца с помощью команды <command>ALTER</"
"command> для соответствующего типа объекта, например <xref linkend=\"sql-"
"altertable\"/>. Суперпользователь может делать это без ограничений, а "
"обычный пользователь, только если он является одновременно текущим "
"владельцем объекта (или членом роли владельца) и членом новой роли."

#: ddl.xml:1364(programlisting)
#, no-wrap
msgid "GRANT UPDATE ON accounts TO joe;"
msgstr "GRANT UPDATE ON accounts TO joe;"

#: ddl.xml:1359(para)
msgid ""
"To assign privileges, the <command>GRANT</command> command is used. For "
"example, if <literal>joe</literal> is an existing role, and "
"<literal>accounts</literal> is an existing table, the privilege to update "
"the table can be granted with: <placeholder-1/> Writing <literal>ALL</"
"literal> in place of a specific privilege grants all privileges that are "
"relevant for the object type."
msgstr ""
"Для назначения прав применяется команда <command>GRANT</command>. Например, "
"если в базе данных есть роль <literal>joe</literal> и таблица "
"<literal>accounts</literal>, право на изменение таблицы можно дать этой роли "
"так: <placeholder-1/> Если вместо конкретного права написать <literal>ALL</"
"literal>, роль получит все права, применимые для объекта этого типа."

#: ddl.xml:1369(para)
msgid ""
"The special <quote>role</quote> name <literal>PUBLIC</literal> can be used "
"to grant a privilege to every role on the system. Also, <quote>group</quote> "
"roles can be set up to help manage privileges when there are many users of a "
"database &mdash; for details see <xref linkend=\"user-manag\"/>."
msgstr ""
"Для назначения права всем ролям в системе можно использовать специальное имя "
"<quote>роли</quote>: <literal>PUBLIC</literal>. Также для упрощения "
"управления ролями, когда в базе данных есть множество пользователей, можно "
"настроить <quote>групповые</quote> роли; подробнее об этом см. <xref remap="
"\"4\" linkend=\"user-manag\"/>."

#: ddl.xml:1380(programlisting)
#, no-wrap
msgid "REVOKE ALL ON accounts FROM PUBLIC;"
msgstr "REVOKE ALL ON accounts FROM PUBLIC;"

#: ddl.xml:1377(para)
msgid ""
"To revoke a privilege, use the fittingly named <command>REVOKE</command> "
"command: <placeholder-1/> The special privileges of the object owner (i.e., "
"the right to do <command>DROP</command>, <command>GRANT</command>, "
"<command>REVOKE</command>, etc.) are always implicit in being the owner, and "
"cannot be granted or revoked. But the object owner can choose to revoke "
"their own ordinary privileges, for example to make a table read-only for "
"themselves as well as others."
msgstr ""
"Чтобы лишить пользователей прав, используйте команду <command>REVOKE</"
"command>: <placeholder-1/> Особые права владельца объекта (то есть права на "
"выполнение <command>DROP</command>, <command>GRANT</command>, "
"<command>REVOKE</command> и т. д.) всегда неявно закреплены за владельцем и "
"их нельзя назначить или отобрать. Но владелец объекта может лишить себя "
"обычных прав, например, разрешить всем, включая себя, только чтение таблицы."

#: ddl.xml:1389(para)
msgid ""
"Ordinarily, only the object's owner (or a superuser) can grant or revoke "
"privileges on an object. However, it is possible to grant a privilege "
"<quote>with grant option</quote>, which gives the recipient the right to "
"grant it in turn to others. If the grant option is subsequently revoked then "
"all who received the privilege from that recipient (directly or through a "
"chain of grants) will lose the privilege. For details see the <xref linkend="
"\"sql-grant\"/> and <xref linkend=\"sql-revoke\"/> reference pages."
msgstr ""
"Обычно распоряжаться правами может только владелец объекта (или "
"суперпользователь). Однако возможно дать право доступа к объекту <quote>с "
"правом передачи</quote>, что позволит получившему такое право назначать его "
"другим. Если такое право передачи впоследствии будет отозвано, то все, кто "
"получил данное право доступа (непосредственно или по цепочке передачи), "
"потеряют его. Подробнее об этом см. справку <xref linkend=\"sql-grant\"/> и "
"<xref linkend=\"sql-revoke\"/>."

#: ddl.xml:1402(title)
msgid "Row Security Policies"
msgstr "Политики защиты строк"

#: ddl.xml:1404(indexterm)
msgid "<primary>row-level security</primary>"
msgstr "<primary>защита на уровне строк</primary>"

#: ddl.xml:1408(indexterm)
msgid "<primary>policy</primary>"
msgstr "<primary>политика</primary>"

#: ddl.xml:1412(para)
msgid ""
"In addition to the SQL-standard <link linkend=\"ddl-priv\">privilege system</"
"link> available through <xref linkend=\"sql-grant\"/>, tables can have "
"<firstterm>row security policies</firstterm> that restrict, on a per-user "
"basis, which rows can be returned by normal queries or inserted, updated, or "
"deleted by data modification commands. This feature is also known as "
"<firstterm>Row-Level Security</firstterm>. By default, tables do not have "
"any policies, so that if a user has access privileges to a table according "
"to the SQL privilege system, all rows within it are equally available for "
"querying or updating."
msgstr ""
"В дополнение к стандартной <link linkend=\"ddl-priv\">системе прав</link> "
"SQL, управляемой командой <xref linkend=\"sql-grant\"/>, на уровне таблиц "
"можно определить <firstterm>политики защиты строк</firstterm>, "
"ограничивающие для пользователей наборы строк, которые могут быть возвращены "
"обычными запросами или добавлены, изменены и удалены командами, изменяющими "
"данные. Это называется также <firstterm>защитой на уровне строк</firstterm> "
"(RLS, Row-Level Security). По умолчанию таблицы не имеют политик, так что "
"если система прав SQL разрешает пользователю доступ к таблице, все строки в "
"ней одинаково доступны для чтения или изменения."

#: ddl.xml:1424(para)
msgid ""
"When row security is enabled on a table (with <link linkend=\"sql-altertable"
"\">ALTER TABLE ... ENABLE ROW LEVEL SECURITY</link>), all normal access to "
"the table for selecting rows or modifying rows must be allowed by a row "
"security policy. (However, the table's owner is typically not subject to row "
"security policies.) If no policy exists for the table, a default-deny policy "
"is used, meaning that no rows are visible or can be modified. Operations "
"that apply to the whole table, such as <command>TRUNCATE</command> and "
"<literal>REFERENCES</literal>, are not subject to row security."
msgstr ""
"Когда для таблицы включается защита строк (с помощью команды <link linkend="
"\"sql-altertable\">ALTER TABLE ... ENABLE ROW LEVEL SECURITY</link>), все "
"обычные запросы к таблице на выборку или модификацию строк должны "
"разрешаться политикой защиты строк. (Однако на владельца таблицы такие "
"политики обычно не действуют.) Если политика для таблицы не определена, "
"применяется политика запрета по умолчанию, так что никакие строки в этой "
"таблице нельзя увидеть или модифицировать. На операции с таблицей в целом, "
"такие как <command>TRUNCATE</command> и <literal>REFERENCES</literal>, "
"защита строк не распространяется."

#: ddl.xml:1436(para)
msgid ""
"Row security policies can be specific to commands, or to roles, or to both. "
"A policy can be specified to apply to <literal>ALL</literal> commands, or to "
"<literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</"
"literal>, or <literal>DELETE</literal>. Multiple roles can be assigned to a "
"given policy, and normal role membership and inheritance rules apply."
msgstr ""
"Политики защиты строк могут применяться к определённым командам и/или ролям. "
"Политику можно определить как применяемую к командам <literal>ALL</literal> "
"(всем), либо <literal>SELECT</literal>, <literal>INSERT</literal>, "
"<literal>UPDATE</literal> и <literal>DELETE</literal>. Кроме того, политику "
"можно связать с несколькими ролями, при этом действуют обычные правила "
"членства и наследования."

#: ddl.xml:1444(para)
msgid ""
"To specify which rows are visible or modifiable according to a policy, an "
"expression is required that returns a Boolean result. This expression will "
"be evaluated for each row prior to any conditions or functions coming from "
"the user's query. (The only exceptions to this rule are <literal>leakproof</"
"literal> functions, which are guaranteed to not leak information; the "
"optimizer may choose to apply such functions ahead of the row-security "
"check.) Rows for which the expression does not return <literal>true</"
"literal> will not be processed. Separate expressions may be specified to "
"provide independent control over the rows which are visible and the rows "
"which are allowed to be modified. Policy expressions are run as part of the "
"query and with the privileges of the user running the query, although "
"security-definer functions can be used to access data not available to the "
"calling user."
msgstr ""
"Чтобы определить, какие строки будут видимыми или могут изменяться в "
"таблице, для политики задаётся выражение, возвращающее логический результат. "
"Это выражение будет вычисляться для каждой строки перед другими условиями "
"или функциями, поступающими из запроса пользователя. (Единственным "
"исключением из этого правила являются <literal>герметичные</literal> "
"функции, которые гарантированно не допускают утечки информации; оптимизатор "
"может решить выполнить эти функции до проверок защиты строк.) Строки, для "
"которых это выражение возвращает не <literal>true</literal>, обрабатываться "
"не будут. Чтобы независимо управлять набором строк, которые можно видеть, и "
"набором строк, которые можно модифицировать, в политике можно задать "
"отдельные выражения. Выражения политик обрабатываются в составе запроса с "
"правами исполняющего его пользователя, но для обращения к данным, "
"недоступным этому пользователю, в этих выражениях могут применяться функции, "
"определяющие контекст безопасности."

#: ddl.xml:1460(para)
msgid ""
"Superusers and roles with the <literal>BYPASSRLS</literal> attribute always "
"bypass the row security system when accessing a table. Table owners normally "
"bypass row security as well, though a table owner can choose to be subject "
"to row security with <link linkend=\"sql-altertable\">ALTER TABLE ... FORCE "
"ROW LEVEL SECURITY</link>."
msgstr ""
"Суперпользователи и роли с атрибутом <literal>BYPASSRLS</literal> всегда "
"обращаются к таблице, минуя систему защиты строк. На владельца таблицы "
"защита строк тоже не действует, хотя он может включить её для себя "
"принудительно, выполнив команду <link linkend=\"sql-altertable\">ALTER "
"TABLE ... FORCE ROW LEVEL SECURITY</link>."

#: ddl.xml:1468(para)
msgid ""
"Enabling and disabling row security, as well as adding policies to a table, "
"is always the privilege of the table owner only."
msgstr ""
"Неотъемлемое право включать или отключать защиту строк, а также определять "
"политики для таблицы, имеет только её владелец."

#: ddl.xml:1473(para)
msgid ""
"Policies are created using the <xref linkend=\"sql-createpolicy\"/> command, "
"altered using the <xref linkend=\"sql-alterpolicy\"/> command, and dropped "
"using the <xref linkend=\"sql-droppolicy\"/> command. To enable and disable "
"row security for a given table, use the <xref linkend=\"sql-altertable\"/> "
"command."
msgstr ""
"Для создания политик предназначена команда <xref linkend=\"sql-createpolicy"
"\"/>, для изменения — <xref linkend=\"sql-alterpolicy\"/>, а для удаления — "
"<xref linkend=\"sql-droppolicy\"/>. Чтобы включить или отключить защиту "
"строк для определённой таблицы, воспользуйтесь командой <xref linkend=\"sql-"
"altertable\"/>."

#: ddl.xml:1481(para)
msgid ""
"Each policy has a name and multiple policies can be defined for a table. As "
"policies are table-specific, each policy for a table must have a unique "
"name. Different tables may have policies with the same name."
msgstr ""
"Каждой политике назначается имя, при этом для одной таблицы можно определить "
"несколько политик. Так как политики привязаны к таблицам, каждая политика "
"для таблицы должна иметь уникальное имя. В разных таблицах политики могут "
"иметь одинаковые имена."

#: ddl.xml:1488(para)
msgid ""
"When multiple policies apply to a given query, they are combined using "
"<literal>OR</literal>, so that a row is accessible if any policy allows it. "
"This is similar to the rule that a given role has the privileges of all "
"roles that they are a member of."
msgstr ""
"Когда к определённому запросу применяются несколько политик, они "
"объединяются логическим сложением, так что строка будет доступна, если это "
"разрешит какая-либо политика. Это подобно тому, как некоторая роль получает "
"права всех ролей, в которые она включена."

#: ddl.xml:1495(para)
msgid ""
"As a simple example, here is how to create a policy on the <literal>account</"
"literal> relation to allow only members of the <literal>managers</literal> "
"role to access rows, and only rows of their accounts:"
msgstr ""
"В качестве простого примера, создать политику для отношения "
"<literal>account</literal>, позволяющую только членам роли "
"<literal>managers</literal> обращаться к строкам отношения и при этом только "
"к своим, можно так:"

#: ddl.xml:1502(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE accounts (manager text, company text, contact_email text);\n"
"\n"
"ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;\n"
"\n"
"CREATE POLICY account_managers ON accounts TO managers\n"
"    USING (manager = current_user);"
msgstr ""
"CREATE TABLE accounts (manager text, company text, contact_email text);\n"
"\n"
"ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;\n"
"\n"
"CREATE POLICY account_managers ON accounts TO managers\n"
"    USING (manager = current_user);"

#: ddl.xml:1509(para)
msgid ""
"If no role is specified, or the special user name <literal>PUBLIC</literal> "
"is used, then the policy applies to all users on the system. To allow all "
"users to access their own row in a <literal>users</literal> table, a simple "
"policy can be used:"
msgstr ""
"Если роль не задана, либо задано специальное имя пользователя "
"<literal>PUBLIC</literal>, политика применяется ко всем пользователям в "
"данной системе. Чтобы все пользователи могли обратиться к собственной строке "
"в таблице <literal>users</literal>, можно применить простую политику:"

#: ddl.xml:1516(programlisting)
#, no-wrap
msgid ""
"CREATE POLICY user_policy ON users\n"
"    USING (user = current_user);"
msgstr ""
"CREATE POLICY user_policy ON users\n"
"    USING (user = current_user);"

#: ddl.xml:1519(para)
msgid ""
"To use a different policy for rows that are being added to the table "
"compared to those rows that are visible, the <literal>WITH CHECK</literal> "
"clause can be used. This policy would allow all users to view all rows in "
"the <literal>users</literal> table, but only modify their own:"
msgstr ""
"Чтобы определить для строк, добавляемых в таблицу, отдельную политику, "
"отличную от политики, ограничивающей видимые строки, можно применить "
"предложение <literal>WITH CHECK</literal>. Следующая политика позволит всем "
"пользователям видеть все строки в таблице <literal>users</literal>, но "
"изменять только свою собственную:"

#: ddl.xml:1526(programlisting)
#, no-wrap
msgid ""
"CREATE POLICY user_policy ON users\n"
"    USING (true)\n"
"    WITH CHECK (user = current_user);"
msgstr ""
"CREATE POLICY user_policy ON users\n"
"    USING (true)\n"
"    WITH CHECK (user = current_user);"

#: ddl.xml:1530(para)
msgid ""
"Row security can also be disabled with the <command>ALTER TABLE</command> "
"command. Disabling row security does not remove any policies that are "
"defined on the table; they are simply ignored. Then all rows in the table "
"are visible and modifiable, subject to the standard SQL privileges system."
msgstr ""
"Защиту строк можно отключить так же командой <command>ALTER TABLE</command>. "
"При отключении защиты, политики, определённые для таблицы, не удаляются, а "
"просто игнорируются. В результате в таблице будут видны и могут "
"модифицироваться все строки, с учётом ограничений стандартной системы прав "
"SQL."

#: ddl.xml:1538(para)
msgid ""
"Below is a larger example of how this feature can be used in production "
"environments. The table <literal>passwd</literal> emulates a Unix password "
"file:"
msgstr ""
"Ниже показан развёрнутый пример того, как этот механизм защиты можно "
"применять в производственной среде. Таблица <literal>passwd</literal> "
"имитирует файл паролей в Unix:"

#: ddl.xml:1544(programlisting)
#, no-wrap
msgid ""
"-- Simple passwd-file based example\n"
"CREATE TABLE passwd (\n"
"  username              text UNIQUE NOT NULL,\n"
"  pwhash                text,\n"
"  uid                   int  PRIMARY KEY,\n"
"  gid                   int  NOT NULL,\n"
"  real_name             text NOT NULL,\n"
"  home_phone            text,\n"
"  extra_info            text,\n"
"  home_dir              text NOT NULL,\n"
"  shell                 text NOT NULL\n"
");\n"
"\n"
"CREATE ROLE admin;  -- Administrator\n"
"CREATE ROLE bob;    -- Normal user\n"
"CREATE ROLE alice;  -- Normal user\n"
"\n"
"-- Populate the table\n"
"INSERT INTO passwd VALUES\n"
"  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');\n"
"INSERT INTO passwd VALUES\n"
"  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');\n"
"INSERT INTO passwd VALUES\n"
"  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');\n"
"\n"
"-- Be sure to enable row level security on the table\n"
"ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;\n"
"\n"
"-- Create policies\n"
"-- Administrator can see all rows and add any rows\n"
"CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);\n"
"-- Normal users can view all rows\n"
"CREATE POLICY all_view ON passwd FOR SELECT USING (true);\n"
"-- Normal users can update their own records, but\n"
"-- limit which shells a normal user is allowed to set\n"
"CREATE POLICY user_mod ON passwd FOR UPDATE\n"
"  USING (current_user = username)\n"
"  WITH CHECK (\n"
"    current_user = username AND\n"
"    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')\n"
"  );\n"
"\n"
"-- Allow admin all normal rights\n"
"GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;\n"
"-- Users only get select access on public columns\n"
"GRANT SELECT\n"
"  (username, uid, gid, real_name, home_phone, extra_info, home_dir, shell)\n"
"  ON passwd TO public;\n"
"-- Allow users to update certain columns\n"
"GRANT UPDATE\n"
"  (pwhash, real_name, home_phone, extra_info, shell)\n"
"  ON passwd TO public;"
msgstr ""
"-- Простой пример на базе файла passwd\n"
"CREATE TABLE passwd (\n"
"  username              text UNIQUE NOT NULL,\n"
"  pwhash                text,\n"
"  uid                   int  PRIMARY KEY,\n"
"  gid                   int  NOT NULL,\n"
"  real_name             text NOT NULL,\n"
"  home_phone            text,\n"
"  extra_info            text,\n"
"  home_dir              text NOT NULL,\n"
"  shell                 text NOT NULL\n"
");\n"
"\n"
"CREATE ROLE admin;  -- Администратор\n"
"CREATE ROLE bob;    -- Обычный пользователь\n"
"CREATE ROLE alice;  -- Обычный пользователь\n"
"\n"
"-- Наполнение таблицы\n"
"INSERT INTO passwd VALUES\n"
"  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');\n"
"INSERT INTO passwd VALUES\n"
"  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');\n"
"INSERT INTO passwd VALUES\n"
"  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');\n"
"\n"
"-- Необходимо включить для этой таблицы защиту на уровне строк\n"
"ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;\n"
"\n"
"-- Создание политик\n"
"-- Администратор может видеть и добавлять любые строки\n"
"CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);\n"
"-- Обычные пользователи могут видеть все строки\n"
"CREATE POLICY all_view ON passwd FOR SELECT USING (true);\n"
"-- Обычные пользователи могут изменять собственные данные, но\n"
"-- не могут задать произвольную оболочку входа\n"
"CREATE POLICY user_mod ON passwd FOR UPDATE\n"
"  USING (current_user = username)\n"
"  WITH CHECK (\n"
"    current_user = username AND\n"
"    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')\n"
"  );\n"
"\n"
"-- Администраторы получают все обычные права\n"
"GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;\n"
"-- Пользователям разрешается чтение только общедоступных столбцов\n"
"GRANT SELECT\n"
"  (username, uid, gid, real_name, home_phone, extra_info, home_dir, shell)\n"
"  ON passwd TO public;\n"
"-- Пользователям разрешается изменение определённых столбцов\n"
"GRANT UPDATE\n"
"  (pwhash, real_name, home_phone, extra_info, shell)\n"
"  ON passwd TO public;"

#: ddl.xml:1597(para)
msgid ""
"As with any security settings, it's important to test and ensure that the "
"system is behaving as expected. Using the example above, this demonstrates "
"that the permission system is working properly."
msgstr ""
"Как и любые средства защиты, важно проверить политики, и убедиться в том, "
"что они работают ожидаемым образом. Применительно к предыдущему примеру, эти "
"команды показывают, что система разрешений работает корректно."

#: ddl.xml:1603(programlisting)
#, no-wrap
msgid ""
"-- admin can view all rows and fields\n"
"postgres=&gt; set role admin;\n"
"SET\n"
"postgres=&gt; table passwd;\n"
" username | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell\n"
"----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------\n"
" admin    | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash\n"
" bob      | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh\n"
" alice    | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh\n"
"(3 rows)\n"
"\n"
"-- Test what Alice is able to do\n"
"postgres=&gt; set role alice;\n"
"SET\n"
"postgres=&gt; table passwd;\n"
"ERROR:  permission denied for relation passwd\n"
"postgres=&gt; select username,real_name,home_phone,extra_info,home_dir,shell from passwd;\n"
" username | real_name |  home_phone  | extra_info | home_dir    |   shell\n"
"----------+-----------+--------------+------------+-------------+-----------\n"
" admin    | Admin     | 111-222-3333 |            | /root       | /bin/dash\n"
" bob      | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh\n"
" alice    | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh\n"
"(3 rows)\n"
"\n"
"postgres=&gt; update passwd set username = 'joe';\n"
"ERROR:  permission denied for relation passwd\n"
"-- Alice is allowed to change her own real_name, but no others\n"
"postgres=&gt; update passwd set real_name = 'Alice Doe';\n"
"UPDATE 1\n"
"postgres=&gt; update passwd set real_name = 'John Doe' where username = 'admin';\n"
"UPDATE 0\n"
"postgres=&gt; update passwd set shell = '/bin/xx';\n"
"ERROR:  new row violates WITH CHECK OPTION for \"passwd\"\n"
"postgres=&gt; delete from passwd;\n"
"ERROR:  permission denied for relation passwd\n"
"postgres=&gt; insert into passwd (username) values ('xxx');\n"
"ERROR:  permission denied for relation passwd\n"
"-- Alice can change her own password; RLS silently prevents updating other rows\n"
"postgres=&gt; update passwd set pwhash = 'abc';\n"
"UPDATE 1"
msgstr ""
"-- Администратор может видеть все строки и поля\n"
"postgres=&gt; set role admin;\n"
"SET\n"
"postgres=&gt; table passwd;\n"
" username | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell\n"
"----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------\n"
" admin    | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash\n"
" bob      | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh\n"
" alice    | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh\n"
"(3 rows)\n"
"\n"
"-- Проверим, что может делать Алиса\n"
"postgres=&gt; set role alice;\n"
"SET\n"
"postgres=&gt; table passwd;\n"
"ERROR:  permission denied for relation passwd\n"
"postgres=&gt; select username,real_name,home_phone,extra_info,home_dir,shell from passwd;\n"
" username | real_name |  home_phone  | extra_info | home_dir    |   shell\n"
"----------+-----------+--------------+------------+-------------+-----------\n"
" admin    | Admin     | 111-222-3333 |            | /root       | /bin/dash\n"
" bob      | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh\n"
" alice    | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh\n"
"(3 rows)\n"
"\n"
"postgres=&gt; update passwd set username = 'joe';\n"
"ERROR:  permission denied for relation passwd\n"
"-- Алиса может изменить своё имя (поле real_name), но не имя кого-либо другого\n"
"postgres=&gt; update passwd set real_name = 'Alice Doe';\n"
"UPDATE 1\n"
"postgres=&gt; update passwd set real_name = 'John Doe' where username = 'admin';\n"
"UPDATE 0\n"
"postgres=&gt; update passwd set shell = '/bin/xx';\n"
"ERROR:  new row violates WITH CHECK OPTION for \"passwd\"\n"
"postgres=&gt; delete from passwd;\n"
"ERROR:  permission denied for relation passwd\n"
"postgres=&gt; insert into passwd (username) values ('xxx');\n"
"ERROR:  permission denied for relation passwd\n"
"-- Алиса может изменить собственный пароль; попытки поменять другие пароли RLS просто игнорирует\n"
"postgres=&gt; update passwd set pwhash = 'abc';\n"
"UPDATE 1"

#: ddl.xml:1644(para)
msgid ""
"Referential integrity checks, such as unique or primary key constraints and "
"foreign key references, always bypass row security to ensure that data "
"integrity is maintained. Care must be taken when developing schemas and row "
"level policies to avoid <quote>covert channel</quote> leaks of information "
"through such referential integrity checks."
msgstr ""
"На проверки ссылочной целостности, например, на ограничения уникальности и "
"внешние ключи, защита строк никогда не распространяется, чтобы не нарушалась "
"целостность данных. Поэтому организацию и политики защиты на уровне строк "
"необходимо тщательно прорабатывать, чтобы не возникли <quote>скрытые каналы</"
"quote> утечки информации через эти проверки."

#: ddl.xml:1652(para)
msgid ""
"In some contexts it is important to be sure that row security is not being "
"applied. For example, when taking a backup, it could be disastrous if row "
"security silently caused some rows to be omitted from the backup. In such a "
"situation, you can set the <xref linkend=\"guc-row-security\"/> "
"configuration parameter to <literal>off</literal>. This does not in itself "
"bypass row security; what it does is throw an error if any query's results "
"would get filtered by a policy. The reason for the error can then be "
"investigated and fixed."
msgstr ""
"В некоторых случаях важно, чтобы защита на уровне строк, наоборот, не "
"действовала. Например, резервное копирование может оказаться провальным, "
"если механизм защиты на уровне строк молча не даст скопировать какие-либо "
"строки. В таком случае вы можете установить для параметра конфигурации <xref "
"linkend=\"guc-row-security\"/> значение <literal>off</literal>. Это само по "
"себе не отключит защиту строк; при этом просто будет выдана ошибка, если "
"результаты запроса отфильтруются политикой, с тем чтобы можно было изучить "
"причину ошибки и устранить её."

#: ddl.xml:1664(para)
msgid ""
"In the examples above, the policy expressions consider only the current "
"values in the row to be accessed or updated. This is the simplest and best-"
"performing case; when possible, it's best to design row security "
"applications to work this way. If it is necessary to consult other rows or "
"other tables to make a policy decision, that can be accomplished using sub-"
"<command>SELECT</command>s, or functions that contain <command>SELECT</"
"command>s, in the policy expressions. Be aware however that such accesses "
"can create race conditions that could allow information leakage if care is "
"not taken. As an example, consider the following table design:"
msgstr ""
"В приведённых выше примерах выражения политики учитывали только текущие "
"значения в запрашиваемой или изменяемой строке. Это самый простой и наиболее "
"эффективный по скорости вариант; по возможности реализацию защиты строк "
"следует проектировать именно так. Если же для принятия решения о доступе "
"необходимо обращаться к другим строкам или другим таблицам, это можно "
"осуществить, применяя в выражениях политик вложенные <command>SELECT</"
"command> или функции, содержащие <command>SELECT</command>. Однако учтите, "
"что при такой реализации возможны условия гонки, что чревато утечкой "
"информации, если не принять меры предосторожности. Например, рассмотрим "
"следующую конструкцию таблиц:"

#: ddl.xml:1676(programlisting)
#, no-wrap
msgid ""
"-- definition of privilege groups\n"
"CREATE TABLE groups (group_id int PRIMARY KEY,\n"
"                     group_name text NOT NULL);\n"
"\n"
"INSERT INTO groups VALUES\n"
"  (1, 'low'),\n"
"  (2, 'medium'),\n"
"  (5, 'high');\n"
"\n"
"GRANT ALL ON groups TO alice;  -- alice is the administrator\n"
"GRANT SELECT ON groups TO public;\n"
"\n"
"-- definition of users' privilege levels\n"
"CREATE TABLE users (user_name text PRIMARY KEY,\n"
"                    group_id int NOT NULL REFERENCES groups);\n"
"\n"
"INSERT INTO users VALUES\n"
"  ('alice', 5),\n"
"  ('bob', 2),\n"
"  ('mallory', 2);\n"
"\n"
"GRANT ALL ON users TO alice;\n"
"GRANT SELECT ON users TO public;\n"
"\n"
"-- table holding the information to be protected\n"
"CREATE TABLE information (info text,\n"
"                          group_id int NOT NULL REFERENCES groups);\n"
"\n"
"INSERT INTO information VALUES\n"
"  ('barely secret', 1),\n"
"  ('slightly secret', 2),\n"
"  ('very secret', 5);\n"
"\n"
"ALTER TABLE information ENABLE ROW LEVEL SECURITY;\n"
"\n"
"-- a row should be visible to/updatable by users whose security group_id is\n"
"-- greater than or equal to the row's group_id\n"
"CREATE POLICY fp_s ON information FOR SELECT\n"
"  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));\n"
"CREATE POLICY fp_u ON information FOR UPDATE\n"
"  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));\n"
"\n"
"-- we rely only on RLS to protect the information table\n"
"GRANT ALL ON information TO public;"
msgstr ""
"-- определение групп привилегий\n"
"CREATE TABLE groups (group_id int PRIMARY KEY,\n"
"                     group_name text NOT NULL);\n"
"\n"
"INSERT INTO groups VALUES\n"
"  (1, 'low'),\n"
"  (2, 'medium'),\n"
"  (5, 'high');\n"
"\n"
"GRANT ALL ON groups TO alice;  -- alice является администратором\n"
"GRANT SELECT ON groups TO public;\n"
"\n"
"-- определение уровней привилегий для пользователей\n"
"CREATE TABLE users (user_name text PRIMARY KEY,\n"
"                    group_id int NOT NULL REFERENCES groups);\n"
"\n"
"INSERT INTO users VALUES\n"
"  ('alice', 5),\n"
"  ('bob', 2),\n"
"  ('mallory', 2);\n"
"\n"
"GRANT ALL ON users TO alice;\n"
"GRANT SELECT ON users TO public;\n"
"\n"
"-- таблица, содержащая защищаемую информацию\n"
"CREATE TABLE information (info text,\n"
"                          group_id int NOT NULL REFERENCES groups);\n"
"\n"
"INSERT INTO information VALUES\n"
"  ('barely secret', 1),\n"
"  ('slightly secret', 2),\n"
"  ('very secret', 5);\n"
"\n"
"ALTER TABLE information ENABLE ROW LEVEL SECURITY;\n"
"\n"
"-- строка должна быть доступна для чтения/изменения пользователям с group_id,\n"
"-- большим или равным group_id данной строки\n"
"CREATE POLICY fp_s ON information FOR SELECT\n"
"  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));\n"
"CREATE POLICY fp_u ON information FOR UPDATE\n"
"  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));\n"
"\n"
"-- мы защищаем таблицу с информацией, полагаясь только на RLS\n"
"GRANT ALL ON information TO public;"

#: ddl.xml:1721(para)
msgid ""
"Now suppose that <literal>alice</literal> wishes to change the "
"<quote>slightly secret</quote> information, but decides that "
"<literal>mallory</literal> should not be trusted with the new content of "
"that row, so she does:"
msgstr ""
"Теперь предположим, что Алиса (роль <literal>alice</literal>) желает "
"записать <quote>слегка секретную</quote> информацию, но при этом не хочет "
"давать <literal>mallory</literal> доступ к ней. Она делает следующее:"

#: ddl.xml:1727(programlisting)
#, no-wrap
msgid ""
"BEGIN;\n"
"UPDATE users SET group_id = 1 WHERE user_name = 'mallory';\n"
"UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;\n"
"COMMIT;"
msgstr ""
"BEGIN;\n"
"UPDATE users SET group_id = 1 WHERE user_name = 'mallory';\n"
"UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;\n"
"COMMIT;"

#: ddl.xml:1737(programlisting)
#, no-wrap
msgid "SELECT * FROM information WHERE group_id = 2 FOR UPDATE;"
msgstr "SELECT * FROM information WHERE group_id = 2 FOR UPDATE;"

#: ddl.xml:1732(para)
msgid ""
"That looks safe; there is no window wherein <literal>mallory</literal> "
"should be able to see the <quote>secret from mallory</quote> string. "
"However, there is a race condition here. If <literal>mallory</literal> is "
"concurrently doing, say, <placeholder-1/> and her transaction is in "
"<literal>READ COMMITTED</literal> mode, it is possible for her to see "
"<quote>secret from mallory</quote>. That happens if her transaction reaches "
"the <structname>information</structname> row just after <literal>alice</"
"literal>'s does. It blocks waiting for <literal>alice</literal>'s "
"transaction to commit, then fetches the updated row contents thanks to the "
"<literal>FOR UPDATE</literal> clause. However, it does <emphasis>not</"
"emphasis> fetch an updated row for the implicit <command>SELECT</command> "
"from <structname>users</structname>, because that sub-<command>SELECT</"
"command> did not have <literal>FOR UPDATE</literal>; instead the "
"<structname>users</structname> row is read with the snapshot taken at the "
"start of the query. Therefore, the policy expression tests the old value of "
"<literal>mallory</literal>'s privilege level and allows her to see the "
"updated row."
msgstr ""
"На первый взгляд всё нормально; <literal>mallory</literal> ни при каких "
"условиях не должна увидеть строку <quote>secret from mallory</quote>. Однако "
"здесь возможно условие гонки. Если Мэллори (роль <literal>mallory</literal>) "
"параллельно выполняет, скажем: <placeholder-1/> и её транзакция в режиме "
"<literal>READ COMMITTED</literal>, она сможет увидеть <quote>secret from "
"mallory</quote>. Это произойдёт, если её транзакция дойдёт до строки "
"<structname>information</structname> сразу после того, как эту строку "
"изменит Алиса (роль <literal>alice</literal>). Она заблокируется, ожидая "
"фиксирования транзакции Алисы, а затем прочитает изменённое содержимое "
"строки благодаря предложению <literal>FOR UPDATE</literal>. Однако при этом "
"изменённое содержимое <structname>users</structname> <emphasis>не</emphasis> "
"будет прочитано неявным запросом <command>SELECT</command>, так как этот "
"вложенный <command>SELECT</command> выполняется без указания <literal>FOR "
"UPDATE</literal>; вместо этого строка <structname>users</structname> "
"читается из снимка, полученного в начале запроса. Таким образом, выражение "
"политики проверяет старое значение уровня привилегий пользователя "
"<literal>mallory</literal> и позволяет ей видеть изменённую строку."

#: ddl.xml:1753(para)
msgid ""
"There are several ways around this problem. One simple answer is to use "
"<literal>SELECT ... FOR SHARE</literal> in sub-<command>SELECT</command>s in "
"row security policies. However, that requires granting <literal>UPDATE</"
"literal> privilege on the referenced table (here <structname>users</"
"structname>) to the affected users, which might be undesirable. (But another "
"row security policy could be applied to prevent them from actually "
"exercising that privilege; or the sub-<command>SELECT</command> could be "
"embedded into a security definer function.) Also, heavy concurrent use of "
"row share locks on the referenced table could pose a performance problem, "
"especially if updates of it are frequent. Another solution, practical if "
"updates of the referenced table are infrequent, is to take an exclusive lock "
"on the referenced table when updating it, so that no concurrent transactions "
"could be examining old row values. Or one could just wait for all concurrent "
"transactions to end after committing an update of the referenced table and "
"before making changes that rely on the new security situation."
msgstr ""
"Обойти эту проблему можно несколькими способами. Первое простое решение "
"заключается в использовании <literal>SELECT ... FOR SHARE</literal> во "
"вложенных запросах <command>SELECT</command> в политиках защиты строк. "
"Однако для этого потребуется давать затронутым пользователям право "
"<literal>UPDATE</literal> в целевой таблице (здесь <structname>users</"
"structname>), что может быть нежелательно. (Хотя можно применить ещё одну "
"политику защиты строк, чтобы они не могли практически воспользоваться этим "
"правилом; либо поместить вложенный <command>SELECT</command> в функцию, "
"определяющую контекст безопасности.) Кроме этого, активное использование "
"блокировок строк в целевой таблице может повлечь проблемы с "
"производительностью, особенно при частых изменениях. Другое решение, "
"практичное, если целевая таблица изменяется нечасто, заключается в "
"исключительной блокировке целевой таблицы при изменении, чтобы никакие "
"параллельные транзакции не видели старые значения строк. Либо можно просто "
"дождаться завершения всех параллельных транзакций после изменения в целевой "
"таблице, прежде чем вносить изменения, рассчитанные на новые условия "
"безопасности."

#: ddl.xml:1772(para)
msgid ""
"For additional details see <xref linkend=\"sql-createpolicy\"/> and <xref "
"linkend=\"sql-altertable\"/>."
msgstr ""
"За дополнительными подробностями обратитесь к <xref remap=\"3\" linkend="
"\"sql-createpolicy\"/> и <xref remap=\"3\" linkend=\"sql-altertable\"/>."

#: ddl.xml:1780(title)
msgid "Schemas"
msgstr "Схемы"

#: ddl.xml:1782(indexterm)
msgid "<primary>schema</primary>"
msgstr "<primary>схема</primary>"

#: ddl.xml:1786(para)
msgid ""
"A <productname>PostgreSQL</productname> database cluster contains one or "
"more named databases. Users and groups of users are shared across the entire "
"cluster, but no other data is shared across databases. Any given client "
"connection to the server can access only the data in a single database, the "
"one specified in the connection request."
msgstr ""
"Кластер баз данных <productname>PostgreSQL</productname> содержит один или "
"несколько именованных экземпляров баз. На уровне кластера создаются "
"пользователи и группы, но данные могут относиться только к базам данных. При "
"этом в рамках одного подключения к серверу можно обращаться к данным только "
"одной базы данных, указанной при установлении соединения."

#: ddl.xml:1796(para)
msgid ""
"Users of a cluster do not necessarily have the privilege to access every "
"database in the cluster. Sharing of user names means that there cannot be "
"different users named, say, <literal>joe</literal> in two databases in the "
"same cluster; but the system can be configured to allow <literal>joe</"
"literal> access to only some of the databases."
msgstr ""
"Пользователи кластера не обязательно будут иметь доступ ко всем базам данным "
"этого кластера. То, что пользователи создаются на уровне кластера, означает "
"только, что в нём не может быть двух пользователей <literal>joe</literal> в "
"разных базах данных, хотя система позволяет ограничить доступ <literal>joe</"
"literal> только некоторыми базами данных."

#: ddl.xml:1805(para)
msgid ""
"A database contains one or more named <firstterm>schemas</firstterm>, which "
"in turn contain tables. Schemas also contain other kinds of named objects, "
"including data types, functions, and operators. The same object name can be "
"used in different schemas without conflict; for example, both "
"<literal>schema1</literal> and <literal>myschema</literal> can contain "
"tables named <literal>mytable</literal>. Unlike databases, schemas are not "
"rigidly separated: a user can access objects in any of the schemas in the "
"database they are connected to, if they have privileges to do so."
msgstr ""
"База данных содержит одну или несколько именованных <firstterm>схем</"
"firstterm>, которые в свою очередь содержат таблицы. Схемы также содержат "
"именованные объекты других видов, включая типы данных, функции и операторы. "
"Одно и то же имя объекта можно свободно использовать в разных схемах, "
"например и <literal>schema1</literal>, и <literal>myschema</literal> могут "
"содержать таблицы с именем <literal>mytable</literal>. В отличие от баз "
"данных, схемы не ограничивают доступ к данным: пользователи могут обращаться "
"к объектам в любой схеме текущей базы данных, если им назначены "
"соответствующие права."

#: ddl.xml:1822(para)
msgid ""
"To allow many users to use one database without interfering with each other."
msgstr ""
"Чтобы одну базу данных могли использовать несколько пользователей, "
"независимо друг от друга."

#: ddl.xml:1829(para)
msgid ""
"To organize database objects into logical groups to make them more "
"manageable."
msgstr ""
"Чтобы объединить объекты базы данных в логические группы для облегчения "
"управления ими."

#: ddl.xml:1836(para)
msgid ""
"Third-party applications can be put into separate schemas so they do not "
"collide with the names of other objects."
msgstr ""
"Чтобы в одной базе сосуществовали разные приложения, и при этом не возникало "
"конфликтов имён."

#: ddl.xml:1817(para)
msgid ""
"There are several reasons why one might want to use schemas: <placeholder-1/"
"> Schemas are analogous to directories at the operating system level, except "
"that schemas cannot be nested."
msgstr ""
"Есть несколько возможных объяснений, для чего стоит применять схемы: "
"<placeholder-1/> Схемы в некоторым смысле подобны каталогам в операционной "
"системе, но они не могут быть вложенными."

#: ddl.xml:1848(title)
msgid "Creating a Schema"
msgstr "Создание схемы"

#: ddl.xml:1850(indexterm)
msgid "<primary>schema</primary><secondary>creating</secondary>"
msgstr "<primary>схема</primary><secondary>создание</secondary>"

#: ddl.xml:1858(programlisting)
#, no-wrap
msgid "CREATE SCHEMA myschema;"
msgstr "CREATE SCHEMA myschema;"

#: ddl.xml:1854(para)
msgid ""
"To create a schema, use the <xref linkend=\"sql-createschema\"/> command. "
"Give the schema a name of your choice. For example: <placeholder-1/>"
msgstr ""
"Для создания схемы используется команда <xref linkend=\"sql-createschema\"/"
">. При этом вы определяете имя схемы по своему выбору, например так: "
"<placeholder-1/>"

#: ddl.xml:1861(indexterm)
msgid "<primary>qualified name</primary>"
msgstr "<primary>полное имя</primary>"

#: ddl.xml:1865(indexterm)
msgid "<primary>name</primary><secondary>qualified</secondary>"
msgstr "<primary>имя</primary><secondary>полное</secondary>"

#: ddl.xml:1869(para)
msgid ""
"To create or access objects in a schema, write a <firstterm>qualified name</"
"firstterm> consisting of the schema name and table name separated by a dot: "
"<synopsis><replaceable>schema</replaceable><literal>.</"
"literal><replaceable>table</replaceable></synopsis> This works anywhere a "
"table name is expected, including the table modification commands and the "
"data access commands discussed in the following chapters. (For brevity we "
"will speak of tables only, but the same ideas apply to other kinds of named "
"objects, such as types and functions.)"
msgstr ""
"Чтобы создать объекты в схеме или обратиться к ним, указывайте "
"<firstterm>полное имя</firstterm>, состоящее из имён схемы и объекта, "
"разделённых точкой: <synopsis><replaceable>схема</replaceable><literal>.</"
"literal><replaceable>таблица</replaceable></synopsis> Этот синтаксис "
"работает везде, где ожидается имя таблицы, включая команды модификации "
"таблицы и команды обработки данных, обсуждаемые в следующих главах. (Для "
"краткости мы будем говорить только о таблицах, но всё это распространяется и "
"на другие типы именованных объектов, например, типы и функции.)"

#: ddl.xml:1881(para)
msgid ""
"Actually, the even more general syntax <synopsis><replaceable>database</"
"replaceable><literal>.</literal><replaceable>schema</replaceable><literal>.</"
"literal><replaceable>table</replaceable></synopsis> can be used too, but at "
"present this is just for <foreignphrase>pro forma</foreignphrase> compliance "
"with the SQL standard. If you write a database name, it must be the same as "
"the database you are connected to."
msgstr ""
"Есть ещё более общий синтаксис <synopsis><replaceable>база_данных</"
"replaceable><literal>.</literal><replaceable>схема</replaceable><literal>.</"
"literal><replaceable>таблица</replaceable></synopsis>но в настоящее время он "
"поддерживается только для формального соответствия стандарту SQL. Если вы "
"указываете базу данных, это может быть только база данных, к которой вы "
"подключены."

#: ddl.xml:1891(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE myschema.mytable (\n"
" ...\n"
");"
msgstr ""
"CREATE TABLE myschema.mytable (\n"
" ...\n"
");"

#: ddl.xml:1889(para)
msgid "So to create a table in the new schema, use: <placeholder-1/>"
msgstr ""
"Таким образом, создать таблицу в новой схеме можно так: <placeholder-1/>"

#: ddl.xml:1896(indexterm)
msgid "<primary>schema</primary><secondary>removing</secondary>"
msgstr "<primary>схема</primary><secondary>удаление</secondary>"

#: ddl.xml:1903(programlisting)
#, no-wrap
msgid "DROP SCHEMA myschema;"
msgstr "DROP SCHEMA myschema;"

#: ddl.xml:1905(programlisting)
#, no-wrap
msgid "DROP SCHEMA myschema CASCADE;"
msgstr "DROP SCHEMA myschema CASCADE;"

#: ddl.xml:1900(para)
msgid ""
"To drop a schema if it's empty (all objects in it have been dropped), use: "
"<placeholder-1/> To drop a schema including all contained objects, use: "
"<placeholder-2/> See <xref linkend=\"ddl-depend\"/> for a description of the "
"general mechanism behind this."
msgstr ""
"Чтобы удалить пустую схему (не содержащую объектов), выполните: "
"<placeholder-1/> Удалить схему со всеми содержащимися в ней объектами можно "
"так: <placeholder-2/> Стоящий за этим общий механизм описан в <xref remap="
"\"6\" linkend=\"ddl-depend\"/>."

#: ddl.xml:1914(programlisting)
#, no-wrap
msgid "CREATE SCHEMA <replaceable>schemaname</replaceable> AUTHORIZATION <replaceable>username</replaceable>;"
msgstr "CREATE SCHEMA <replaceable>имя_схемы</replaceable> AUTHORIZATION <replaceable>имя_пользователя</replaceable>;"

#: ddl.xml:1910(para)
msgid ""
"Often you will want to create a schema owned by someone else (since this is "
"one of the ways to restrict the activities of your users to well-defined "
"namespaces). The syntax for that is: <placeholder-1/> You can even omit the "
"schema name, in which case the schema name will be the same as the user "
"name. See <xref linkend=\"ddl-schemas-patterns\"/> for how this can be "
"useful."
msgstr ""
"Часто бывает нужно создать схему, владельцем которой будет другой "
"пользователь (это один из способов ограничения пользователей пространствами "
"имён). Сделать это можно так: <placeholder-1/> Вы даже можете опустить имя "
"схемы, в этом случае именем схемы станет имя пользователя. Как это можно "
"применять, описано в <xref remap=\"6\" linkend=\"ddl-schemas-patterns\"/>."

#: ddl.xml:1920(para)
msgid ""
"Schema names beginning with <literal>pg_</literal> are reserved for system "
"purposes and cannot be created by users."
msgstr ""
"Схемы с именами, начинающимися с <literal>pg_</literal>, являются "
"системными; пользователям не разрешено использовать такие имена."

#: ddl.xml:1927(title)
msgid "The Public Schema"
msgstr "Схема public"

#: ddl.xml:1929(indexterm)
msgid "<primary>schema</primary><secondary>public</secondary>"
msgstr "<primary>схема</primary><secondary>public</secondary>"

#: ddl.xml:1938(programlisting)
#, no-wrap
msgid "CREATE TABLE products ( ... );"
msgstr "CREATE TABLE products ( ... );"

#: ddl.xml:1940(programlisting)
#, no-wrap
msgid "CREATE TABLE public.products ( ... );"
msgstr "CREATE TABLE public.products ( ... );"

#: ddl.xml:1933(para)
msgid ""
"In the previous sections we created tables without specifying any schema "
"names. By default such tables (and other objects) are automatically put into "
"a schema named <quote>public</quote>. Every new database contains such a "
"schema. Thus, the following are equivalent: <placeholder-1/> and: "
"<placeholder-2/>"
msgstr ""
"До этого мы создавали таблицы, не указывая никакие имена схем. По умолчанию "
"такие таблицы (и другие объекты) автоматически помещаются в схему "
"<quote>public</quote>. Она содержится во всех создаваемых базах данных. "
"Таким образом, команда: <placeholder-1/> эквивалентна: <placeholder-2/>"

#: ddl.xml:1945(title)
msgid "The Schema Search Path"
msgstr "Путь поиска схемы"

#: ddl.xml:1947(indexterm)
msgid "<primary>search path</primary>"
msgstr "<primary>путь поиска</primary>"

#: ddl.xml:1951(indexterm)
msgid "<primary>unqualified name</primary>"
msgstr "<primary>неполное имя</primary>"

#: ddl.xml:1955(indexterm)
msgid "<primary>name</primary><secondary>unqualified</secondary>"
msgstr "<primary>имя</primary><secondary>неполное</secondary>"

#: ddl.xml:1959(para)
msgid ""
"Qualified names are tedious to write, and it's often best not to wire a "
"particular schema name into applications anyway. Therefore tables are often "
"referred to by <firstterm>unqualified names</firstterm>, which consist of "
"just the table name. The system determines which table is meant by following "
"a <firstterm>search path</firstterm>, which is a list of schemas to look in. "
"The first matching table in the search path is taken to be the one wanted. "
"If there is no match in the search path, an error is reported, even if "
"matching table names exist in other schemas in the database."
msgstr ""
"Везде писать полные имена утомительно, и часто всё равно лучше не "
"привязывать приложения к конкретной схеме. Поэтому к таблицам обычно "
"обращаются по <firstterm>неполному имени</firstterm>, состоящему просто из "
"имени таблицы. Система определяет, какая именно таблица подразумевается, "
"используя <firstterm>путь поиска</firstterm>, который представляет собой "
"список просматриваемых схем. Подразумеваемой таблицей считается первая "
"подходящая таблица, найденная в схемах пути. Если подходящая таблица не "
"найдена, возникает ошибка, даже если таблица с таким именем есть в других "
"схемах базы данных."

#: ddl.xml:1971(indexterm)
msgid "<primary>schema</primary><secondary>current</secondary>"
msgstr "<primary>схема</primary><secondary>текущая</secondary>"

#: ddl.xml:1975(para)
msgid ""
"The first schema named in the search path is called the current schema. "
"Aside from being the first schema searched, it is also the schema in which "
"new tables will be created if the <command>CREATE TABLE</command> command "
"does not specify a schema name."
msgstr ""
"Первая схема в пути поиска называется текущей. Эта схема будет "
"использоваться не только при поиске, но и при создании объектов &mdash; она "
"будет включать таблицы, созданные командой <command>CREATE TABLE</command> "
"без указания схемы."

#: ddl.xml:1982(indexterm)
msgid ""
"<primary><varname>search_path</varname> configuration parameter</primary>"
msgstr ""
"<primary>параметр конфигурации <varname>search_path</varname></primary>"

#: ddl.xml:1988(programlisting)
#, no-wrap
msgid "SHOW search_path;"
msgstr "SHOW search_path;"

#: ddl.xml:1986(para)
msgid ""
"To show the current search path, use the following command: <placeholder-1/> "
"In the default setup this returns: <screen> search_path\n"
"--------------\n"
" \"$user\", public</screen> The first element specifies that a schema with "
"the same name as the current user is to be searched. If no such schema "
"exists, the entry is ignored. The second element refers to the public schema "
"that we have seen already."
msgstr ""
"Чтобы узнать текущий тип поиска, выполните следующую команду: <placeholder-1/"
"> В конфигурации по умолчанию она возвращает: <screen> search_path\n"
"--------------\n"
" \"$user\", public</screen> Первый элемент ссылается на схему с именем "
"текущего пользователя. Если такой схемы не существует, ссылка на неё "
"игнорируется. Второй элемент ссылается на схему public, которую мы уже "
"видели."

#: ddl.xml:1999(para)
msgid ""
"The first schema in the search path that exists is the default location for "
"creating new objects. That is the reason that by default objects are created "
"in the public schema. When objects are referenced in any other context "
"without schema qualification (table modification, data modification, or "
"query commands) the search path is traversed until a matching object is "
"found. Therefore, in the default configuration, any unqualified access again "
"can only refer to the public schema."
msgstr ""
"Первая существующая схема в пути поиска также считается схемой по умолчанию "
"для новых объектов. Именно поэтому по умолчанию объекты создаются в схеме "
"public. При указании неполной ссылки на объект в любом контексте (при "
"модификации таблиц, изменении данных или в запросах) система просматривает "
"путь поиска, пока не найдёт соответствующий объект. Таким образом, в "
"конфигурации по умолчанию неполные имена могут относиться только к объектам "
"в схеме public."

#: ddl.xml:2012(programlisting)
#, no-wrap
msgid "SET search_path TO myschema,public;"
msgstr "SET search_path TO myschema,public;"

#: ddl.xml:2016(programlisting)
#, no-wrap
msgid "DROP TABLE mytable;"
msgstr "DROP TABLE mytable;"

#: ddl.xml:2010(para)
msgid ""
"To put our new schema in the path, we use: <placeholder-1/> (We omit the "
"<literal>$user</literal> here because we have no immediate need for it.) And "
"then we can access the table without schema qualification: <placeholder-2/> "
"Also, since <literal>myschema</literal> is the first element in the path, "
"new objects would by default be created in it."
msgstr ""
"Чтобы добавить в путь нашу новую схему, мы выполняем: <placeholder-1/> (Мы "
"опускаем компонент <literal>$user</literal>, так как здесь в нём нет "
"необходимости.) Теперь мы можем обращаться к таблице без указания схемы: "
"<placeholder-2/> И так как <literal>myschema</literal> &mdash; первый "
"элемент в пути, новые объекты будут по умолчанию создаваться в этой схеме."

#: ddl.xml:2023(programlisting)
#, no-wrap
msgid "SET search_path TO myschema;"
msgstr "SET search_path TO myschema;"

#: ddl.xml:2021(para)
msgid ""
"We could also have written: <placeholder-1/> Then we no longer have access "
"to the public schema without explicit qualification. There is nothing "
"special about the public schema except that it exists by default. It can be "
"dropped, too."
msgstr ""
"Мы можем также написать: <placeholder-1/> Тогда мы больше не сможем "
"обращаться к схеме public, не написав полное имя объекта. Единственное, что "
"отличает схему public от других, это то, что она существует по умолчанию, "
"хотя её так же можно удалить."

#: ddl.xml:2029(para)
msgid ""
"See also <xref linkend=\"functions-info\"/> for other ways to manipulate the "
"schema search path."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info\"/> вы узнаете, как ещё можно "
"манипулировать путём поиска схем."

#: ddl.xml:2042(programlisting)
#, no-wrap
msgid "SELECT 3 OPERATOR(pg_catalog.+) 4;"
msgstr "SELECT 3 OPERATOR(pg_catalog.+) 4;"

#: ddl.xml:2034(para)
msgid ""
"The search path works in the same way for data type names, function names, "
"and operator names as it does for table names. Data type and function names "
"can be qualified in exactly the same way as table names. If you need to "
"write a qualified operator name in an expression, there is a special "
"provision: you must write <synopsis><literal>OPERATOR(</"
"literal><replaceable>schema</replaceable><literal>.</"
"literal><replaceable>operator</replaceable><literal>)</literal></synopsis> "
"This is needed to avoid syntactic ambiguity. An example is: <placeholder-1/> "
"In practice one usually relies on the search path for operators, so as not "
"to have to write anything so ugly as that."
msgstr ""
"Как и для имён таблиц, путь поиска аналогично работает для имён типов "
"данных, имён функций и имён операторов. Имена типов данных и функций можно "
"записать в полном виде так же, как и имена таблиц. Если же вам нужно "
"использовать в выражении полное имя оператора, для этого есть специальный "
"способ &mdash; вы должны написать: <synopsis><literal>OPERATOR(</"
"literal><replaceable>схема</replaceable><literal>.</"
"literal><replaceable>оператор</replaceable><literal>)</literal></synopsis> "
"Такая запись необходима для избежания синтаксической неоднозначности. Пример "
"такого выражения: <placeholder-1/> На практике пользователи часто полагаются "
"на путь поиска, чтобы не приходилось писать такие замысловатые конструкции."

#: ddl.xml:2049(title)
msgid "Schemas and Privileges"
msgstr "Схемы и права"

#: ddl.xml:2051(indexterm)
msgid ""
"<primary>privilege</primary><secondary sortas=\"schemas\">for schemas</"
"secondary>"
msgstr ""
"<primary>права</primary><secondary sortas=\"схемы\">для схем</secondary>"

#: ddl.xml:2055(para)
msgid ""
"By default, users cannot access any objects in schemas they do not own. To "
"allow that, the owner of the schema must grant the <literal>USAGE</literal> "
"privilege on the schema. To allow users to make use of the objects in the "
"schema, additional privileges might need to be granted, as appropriate for "
"the object."
msgstr ""
"По умолчанию пользователь не может обращаться к объектам в чужих схемах. "
"Чтобы изменить это, владелец схемы должен дать пользователю право "
"<literal>USAGE</literal> для данной схемы. Чтобы пользователи могли "
"использовать объекты схемы, может понадобиться назначить дополнительные "
"права на уровне объектов."

#: ddl.xml:2073(programlisting)
#, no-wrap
msgid "REVOKE CREATE ON SCHEMA public FROM PUBLIC;"
msgstr "REVOKE CREATE ON SCHEMA public FROM PUBLIC;"

#: ddl.xml:2063(para)
msgid ""
"A user can also be allowed to create objects in someone else's schema. To "
"allow that, the <literal>CREATE</literal> privilege on the schema needs to "
"be granted. Note that by default, everyone has <literal>CREATE</literal> and "
"<literal>USAGE</literal> privileges on the schema <literal>public</literal>. "
"This allows all users that are able to connect to a given database to create "
"objects in its <literal>public</literal> schema. If you do not want to allow "
"that, you can revoke that privilege: <placeholder-1/> (The first "
"<quote>public</quote> is the schema, the second <quote>public</quote> means "
"<quote>every user</quote>. In the first sense it is an identifier, in the "
"second sense it is a key word, hence the different capitalization; recall "
"the guidelines from <xref linkend=\"sql-syntax-identifiers\"/>.)"
msgstr ""
"Пользователю также можно разрешить создавать объекты в не принадлежащей ему "
"схеме. Для этого ему нужно дать право <literal>CREATE</literal> в требуемой "
"схеме. Заметьте, что по умолчанию все имеют права <literal>CREATE</literal> "
"и <literal>USAGE</literal> в схеме <literal>public</literal>. Благодаря "
"этому все пользователи могут подключаться к заданной базе данных и создавать "
"объекты в её схеме <literal>public</literal>. Если вас это не устраивает, вы "
"можете отозвать это право: <placeholder-1/> (Первое слово <quote>public</"
"quote> обозначает схему, а второе <quote>public</quote> подразумевает "
"<quote>все пользователи</quote>. В первом случае это идентификатор, а во "
"втором &mdash; ключевое слово, поэтому оно написано в разном регистре; "
"вспомните рекомендации из <xref remap=\"2\" linkend=\"sql-syntax-identifiers"
"\"/>.)"

#: ddl.xml:2083(title)
msgid "The System Catalog Schema"
msgstr "Схема системного каталога"

#: ddl.xml:2085(indexterm)
msgid "<primary>system catalog</primary><secondary>schema</secondary>"
msgstr "<primary>системный каталог</primary><secondary>схема</secondary>"

#: ddl.xml:2089(para)
msgid ""
"In addition to <literal>public</literal> and user-created schemas, each "
"database contains a <literal>pg_catalog</literal> schema, which contains the "
"system tables and all the built-in data types, functions, and operators. "
"<literal>pg_catalog</literal> is always effectively part of the search path. "
"If it is not named explicitly in the path then it is implicitly searched "
"<emphasis>before</emphasis> searching the path's schemas. This ensures that "
"built-in names will always be findable. However, you can explicitly place "
"<literal>pg_catalog</literal> at the end of your search path if you prefer "
"to have user-defined names override built-in names."
msgstr ""
"В дополнение к схеме <literal>public</literal> и схемам, создаваемым "
"пользователями, любая база данных содержит схему <literal>pg_catalog</"
"literal>, в которой находятся системные таблицы и все встроенные типы "
"данных, функции и операторы. <literal>pg_catalog</literal> фактически всегда "
"является частью пути поиска. Если даже эта схема не добавлена в путь явно, "
"она неявно просматривается <emphasis>до</emphasis> всех схем, указанных в "
"пути. Так обеспечивается доступность встроенных имён при любых условиях. "
"Однако вы можете явным образом поместить <literal>pg_catalog</literal> в "
"конец пути поиска, если вам нужно, чтобы пользовательские имена "
"переопределяли встроенные."

#: ddl.xml:2102(para)
msgid ""
"Since system table names begin with <literal>pg_</literal>, it is best to "
"avoid such names to ensure that you won't suffer a conflict if some future "
"version defines a system table named the same as your table. (With the "
"default search path, an unqualified reference to your table name would then "
"be resolved as the system table instead.) System tables will continue to "
"follow the convention of having names beginning with <literal>pg_</literal>, "
"so that they will not conflict with unqualified user-table names so long as "
"users avoid the <literal>pg_</literal> prefix."
msgstr ""
"Так как имена системных таблиц начинаются с <literal>pg_</literal>, такие "
"имена лучше не использовать во избежание конфликта имён, возможного при "
"появлении в будущем системной таблицы с тем же именем, что и ваша. (С путём "
"поиска по умолчанию неполная ссылка будет воспринята как обращение к "
"системной таблице.) Системные таблицы будут и дальше содержать в имени "
"приставку <literal>pg_</literal>, так что они не будут конфликтовать с "
"неполными именами пользовательских таблиц, если пользователи со своей "
"стороны не будут использовать приставку <literal>pg_</literal>."

#: ddl.xml:2116(title)
msgid "Usage Patterns"
msgstr "Шаблоны использования"

#: ddl.xml:2124(para)
msgid ""
"If you do not create any schemas then all users access the public schema "
"implicitly. This simulates the situation where schemas are not available at "
"all. This setup is mainly recommended when there is only a single user or a "
"few cooperating users in a database. This setup also allows smooth "
"transition from the non-schema-aware world."
msgstr ""
"Если вы явно не создаёте какие-либо схемы, все пользователи будут неявно "
"обращаться к схеме public. Таким образом система ведёт себя так, как если бы "
"схем не было вообще. Эта конфигурация в основном рекомендуется, когда в базе "
"данных есть всего один или несколько сотрудничающих пользователей. Она также "
"позволяет легко мигрировать из среды, где схемы не поддерживаются."

#: ddl.xml:2135(para)
msgid ""
"You can create a schema for each user with the same name as that user. "
"Recall that the default search path starts with <literal>$user</literal>, "
"which resolves to the user name. Therefore, if each user has a separate "
"schema, they access their own schemas by default."
msgstr ""
"Вы можете создать отдельные схемы для каждого пользователя, назвав их "
"именами пользователей. Вспомните, путь поиска по умолчанию начинается с "
"<literal>$user</literal>, что интерпретируется как имя пользователя. Таким "
"образом, если у пользователя будет своя схема, по умолчанию он будет "
"обращаться к ней."

#: ddl.xml:2143(para)
msgid ""
"If you use this setup then you might also want to revoke access to the "
"public schema (or drop it altogether), so users are truly constrained to "
"their own schemas."
msgstr ""
"Если вы реализуете этот подход, вы, возможно, также захотите запретить "
"доступ к схеме public (или даже удалить её), чтобы пользователи не выходили "
"за рамки своих схем."

#: ddl.xml:2151(para)
msgid ""
"To install shared applications (tables to be used by everyone, additional "
"functions provided by third parties, etc.), put them into separate schemas. "
"Remember to grant appropriate privileges to allow the other users to access "
"them. Users can then refer to these additional objects by qualifying the "
"names with a schema name, or they can put the additional schemas into their "
"search path, as they choose."
msgstr ""
"В отдельные схемы также можно устанавливать совместно используемые "
"приложения (таблицы, которые нужны всем, дополнительные функции и т. д.). Не "
"забудьте дать другим пользователям права для доступа к этим схемам. Тогда "
"пользователи смогут обращаться к этим дополнительным объектам по полному "
"имени или при желании добавят эти схемы в свои пути поиска."

#: ddl.xml:2118(para)
msgid ""
"Schemas can be used to organize your data in many ways. There are a few "
"usage patterns that are recommended and are easily supported by the default "
"configuration: <placeholder-1/>"
msgstr ""
"Схемам можно найти множество применений. Вот лишь некоторые шаблоны их "
"использования, рекомендуемые и легко реализуемые в конфигурации по "
"умолчанию: <placeholder-1/>"

#: ddl.xml:2166(title)
msgid "Portability"
msgstr "Переносимость"

#: ddl.xml:2168(para)
msgid ""
"In the SQL standard, the notion of objects in the same schema being owned by "
"different users does not exist. Moreover, some implementations do not allow "
"you to create schemas that have a different name than their owner. In fact, "
"the concepts of schema and user are nearly equivalent in a database system "
"that implements only the basic schema support specified in the standard. "
"Therefore, many users consider qualified names to really consist of "
"<literal><replaceable>username</replaceable>.<replaceable>tablename</"
"replaceable></literal>. This is how <productname>PostgreSQL</productname> "
"will effectively behave if you create a per-user schema for every user."
msgstr ""
"Стандарт SQL не поддерживает обращение в одной схеме к разным объектам, "
"принадлежащим разным пользователям. Более того, в ряде реализаций СУБД "
"нельзя создавать схемы с именем, отличным от имени владельца. На практике, в "
"СУБД, реализующих только базовую поддержку схем согласно стандарту, "
"концепции пользователя и схемы очень близки. Таким образом, многие "
"пользователи полагают, что полное имя на самом деле образуется как "
"<literal><replaceable>имя_пользователя</replaceable>.<replaceable>таблица</"
"replaceable></literal>. И именно так будет вести себя "
"<productname>PostgreSQL</productname>, если вы создадите схемы для каждого "
"пользователя."

#: ddl.xml:2182(para)
msgid ""
"Also, there is no concept of a <literal>public</literal> schema in the SQL "
"standard. For maximum conformance to the standard, you should not use "
"(perhaps even remove) the <literal>public</literal> schema."
msgstr ""
"В стандарте SQL нет и понятия схемы <literal>public</literal>. Для "
"максимального соответствия стандарту использовать схему <literal>public</"
"literal> не следует (и возможно, лучше даже удалить её)."

#: ddl.xml:2188(para)
msgid ""
"Of course, some SQL database systems might not implement schemas at all, or "
"provide namespace support by allowing (possibly limited) cross-database "
"access. If you need to work with those systems, then maximum portability "
"would be achieved by not using schemas at all."
msgstr ""
"Конечно, есть СУБД, в которых вообще не реализованы схемы или пространства "
"имён поддерживают (возможно, с ограничениями) обращения к другим базам "
"данных. Если вам потребуется работать с этими системами, максимальной "
"переносимости вы достигнете, вообще не используя схемы."

#: ddl.xml:2199(title)
msgid "Inheritance"
msgstr "Наследование"

#: ddl.xml:2201(indexterm)
msgid "<primary>inheritance</primary>"
msgstr "<primary>наследование</primary>"

#: ddl.xml:2205(indexterm)
msgid "<primary>table</primary><secondary>inheritance</secondary>"
msgstr "<primary>таблица</primary><secondary>наследование</secondary>"

#: ddl.xml:2209(para)
msgid ""
"<productname>PostgreSQL</productname> implements table inheritance, which "
"can be a useful tool for database designers. (SQL:1999 and later define a "
"type inheritance feature, which differs in many respects from the features "
"described here.)"
msgstr ""
"<productname>PostgreSQL</productname> реализует наследование таблиц, что "
"может быть полезно для проектировщиков баз данных. (Стандарт SQL:1999 и "
"более поздние версии определяют возможность наследования типов, но это во "
"многом отличается от того, что описано здесь.)"

#: ddl.xml:2228(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE cities (\n"
"    name            text,\n"
"    population      float,\n"
"    altitude        int     -- in feet\n"
");\n"
"\n"
"CREATE TABLE capitals (\n"
"    state           char(2)\n"
") INHERITS (cities);"
msgstr ""
"CREATE TABLE cities (\n"
"    name            text,\n"
"    population      float,\n"
"    altitude        int     -- в футах\n"
");\n"
"\n"
"CREATE TABLE capitals (\n"
"    state           char(2)\n"
") INHERITS (cities);"

#: ddl.xml:2216(para)
msgid ""
"Let's start with an example: suppose we are trying to build a data model for "
"cities. Each state has many cities, but only one capital. We want to be able "
"to quickly retrieve the capital city for any particular state. This can be "
"done by creating two tables, one for state capitals and one for cities that "
"are not capitals. However, what happens when we want to ask for data about a "
"city, regardless of whether it is a capital or not? The inheritance feature "
"can help to resolve this problem. We define the <structname>capitals</"
"structname> table so that it inherits from <structname>cities</structname>: "
"<placeholder-1/> In this case, the <structname>capitals</structname> table "
"<firstterm>inherits</firstterm> all the columns of its parent table, "
"<structname>cities</structname>. State capitals also have an extra column, "
"<structfield>state</structfield>, that shows their state."
msgstr ""
"Давайте начнём со следующего примера: предположим, что мы создаём модель "
"данных для городов. В каждом штате есть множество городов, но лишь одна "
"столица. Мы хотим иметь возможность быстро получать город-столицу для любого "
"штата. Это можно сделать, создав две таблицы: одну для столиц штатов, а "
"другую для городов, не являющихся столицами. Однако, что делать, если нам "
"нужно получить информацию о любом городе, будь то столица штата или нет? В "
"решении этой проблемы может помочь наследование. Мы определим таблицу "
"<structname>capitals</structname> как наследника <structname>cities</"
"structname>: <placeholder-1/> В этом случае таблица <structname>capitals</"
"structname> <firstterm>наследует</firstterm> все столбцы своей родительской "
"таблицы, <structname>cities</structname>. Столицы штатов также имеют "
"дополнительный столбец <structfield>state</structfield>, в котором будет "
"указан штат."

#: ddl.xml:2253(programlisting)
#, no-wrap
msgid ""
"SELECT name, altitude\n"
"    FROM cities\n"
"    WHERE altitude &gt; 500;"
msgstr ""
"SELECT name, altitude\n"
"    FROM cities\n"
"    WHERE altitude &gt; 500;"

#: ddl.xml:2260(programlisting)
#, no-wrap
msgid ""
"   name    | altitude\n"
"-----------+----------\n"
" Las Vegas |     2174\n"
" Mariposa  |     1953\n"
" Madison   |      845"
msgstr ""
"   name    | altitude\n"
"-----------+----------\n"
" Las Vegas |     2174\n"
" Mariposa  |     1953\n"
" Madison   |      845"

#: ddl.xml:2244(para)
msgid ""
"In <productname>PostgreSQL</productname>, a table can inherit from zero or "
"more other tables, and a query can reference either all rows of a table or "
"all rows of a table plus all of its descendant tables. The latter behavior "
"is the default. For example, the following query finds the names of all "
"cities, including state capitals, that are located at an altitude over 500 "
"feet: <placeholder-1/> Given the sample data from the "
"<productname>PostgreSQL</productname> tutorial (see <xref linkend=\"tutorial-"
"sql-intro\"/>), this returns: <placeholder-2/>"
msgstr ""
"В <productname>PostgreSQL</productname> таблица может наследоваться от нуля "
"или нескольких других таблиц, а запросы могут выбирать все строки "
"родительской таблицы или все строки родительской и всех дочерних таблиц. По "
"умолчанию принят последний вариант. Например, следующий запрос найдёт "
"названия всех городов, включая столицы штатов, расположенных выше 500 футов: "
"<placeholder-1/> Для данных из введения (см. <xref remap=\"4\" linkend="
"\"tutorial-sql-intro\"/>) он выдаст: <placeholder-2/>"

#: ddl.xml:2271(programlisting)
#, no-wrap
msgid ""
"SELECT name, altitude\n"
"    FROM ONLY cities\n"
"    WHERE altitude &gt; 500;\n"
"\n"
"   name    | altitude\n"
"-----------+----------\n"
" Las Vegas |     2174\n"
" Mariposa  |     1953"
msgstr ""
"SELECT name, altitude\n"
"    FROM ONLY cities\n"
"    WHERE altitude &gt; 500;\n"
"\n"
"   name    | altitude\n"
"-----------+----------\n"
" Las Vegas |     2174\n"
" Mariposa  |     1953"

#: ddl.xml:2267(para)
msgid ""
"On the other hand, the following query finds all the cities that are not "
"state capitals and are situated at an altitude over 500 feet: <placeholder-1/"
">"
msgstr ""
"А следующий запрос находит все города, которые не являются столицами штатов, "
"но также находятся на высоте выше 500 футов: <placeholder-1/>"

#: ddl.xml:2281(para)
msgid ""
"Here the <literal>ONLY</literal> keyword indicates that the query should "
"apply only to <structname>cities</structname>, and not any tables below "
"<structname>cities</structname> in the inheritance hierarchy. Many of the "
"commands that we have already discussed &mdash;\n"
"   <command>SELECT</command>, <command>UPDATE</command> and <command>DELETE</"
"command> &mdash; support the <literal>ONLY</literal> keyword."
msgstr ""
"Здесь ключевое слово <literal>ONLY</literal> указывает, что запрос должен "
"применяться только к таблице <structname>cities</structname>, но не к "
"таблицам, расположенным ниже <structname>cities</structname> в иерархии "
"наследования. Многие операторы, которые мы уже обсудили, &mdash; "
"<command>SELECT</command>, <command>UPDATE</command> и <command>DELETE</"
"command> &mdash; поддерживают ключевое слово <literal>ONLY</literal>."

#: ddl.xml:2295(programlisting)
#, no-wrap
msgid ""
"SELECT name, altitude\n"
"    FROM cities*\n"
"    WHERE altitude &gt; 500;"
msgstr ""
"SELECT name, altitude\n"
"    FROM cities*\n"
"    WHERE altitude &gt; 500;"

#: ddl.xml:2291(para)
msgid ""
"You can also write the table name with a trailing <literal>*</literal> to "
"explicitly specify that descendant tables are included: <placeholder-1/> "
"Writing <literal>*</literal> is not necessary, since this behavior is the "
"default (unless you have changed the setting of the <xref linkend=\"guc-sql-"
"inheritance\"/> configuration option). However writing <literal>*</literal> "
"might be useful to emphasize that additional tables will be searched."
msgstr ""
"Вы также можете добавить после имени таблицы <literal>*</literal>, чтобы "
"обрабатывались и все дочерние таблицы: <placeholder-1/> Указывать "
"<literal>*</literal> не обязательно, так как теперь это поведение "
"подразумевается по умолчанию (если только вы не измените параметр "
"конфигурации <xref linkend=\"guc-sql-inheritance\"/>). Однако такая запись "
"может быть полезна тем, что подчеркнёт использование дополнительных таблиц."

#: ddl.xml:2312(programlisting)
#, no-wrap
msgid ""
"SELECT c.tableoid, c.name, c.altitude\n"
"FROM cities c\n"
"WHERE c.altitude &gt; 500;"
msgstr ""
"SELECT c.tableoid, c.name, c.altitude\n"
"FROM cities c\n"
"WHERE c.altitude &gt; 500;"

#: ddl.xml:2318(programlisting)
#, no-wrap
msgid ""
" tableoid |   name    | altitude\n"
"----------+-----------+----------\n"
"   139793 | Las Vegas |     2174\n"
"   139793 | Mariposa  |     1953\n"
"   139798 | Madison   |      845"
msgstr ""
" tableoid |   name    | altitude\n"
"----------+-----------+----------\n"
"   139793 | Las Vegas |     2174\n"
"   139793 | Mariposa  |     1953\n"
"   139798 | Madison   |      845"

#: ddl.xml:2328(programlisting)
#, no-wrap
msgid ""
"SELECT p.relname, c.name, c.altitude\n"
"FROM cities c, pg_class p\n"
"WHERE c.altitude &gt; 500 AND c.tableoid = p.oid;"
msgstr ""
"SELECT p.relname, c.name, c.altitude\n"
"FROM cities c, pg_class p\n"
"WHERE c.altitude &gt; 500 AND c.tableoid = p.oid;"

#: ddl.xml:2334(programlisting)
#, no-wrap
msgid ""
" relname  |   name    | altitude\n"
"----------+-----------+----------\n"
" cities   | Las Vegas |     2174\n"
" cities   | Mariposa  |     1953\n"
" capitals | Madison   |      845"
msgstr ""
" relname  |   name    | altitude\n"
"----------+-----------+----------\n"
" cities   | Las Vegas |     2174\n"
" cities   | Mariposa  |     1953\n"
" capitals | Madison   |      845"

#: ddl.xml:2306(para)
msgid ""
"In some cases you might wish to know which table a particular row originated "
"from. There is a system column called <structfield>tableoid</structfield> in "
"each table which can tell you the originating table: <placeholder-1/> which "
"returns: <placeholder-2/> (If you try to reproduce this example, you will "
"probably get different numeric OIDs.) By doing a join with "
"<structname>pg_class</structname> you can see the actual table names: "
"<placeholder-3/> which returns: <placeholder-4/>"
msgstr ""
"В некоторых ситуациях бывает необходимо узнать, из какой таблицы выбрана "
"конкретная строка. Для этого вы можете воспользоваться системным столбцом "
"<structfield>tableoid</structfield>, присутствующим в каждой таблице: "
"<placeholder-1/> этот запрос выдаст: <placeholder-2/> (Если вы попытаетесь "
"выполнить его у себя, скорее всего вы получите другие значения OID.) "
"Собственно имена таблиц вы можете получить, обратившись к "
"<structname>pg_class</structname>: <placeholder-3/> в результате вы "
"получите: <placeholder-4/>"

#: ddl.xml:2345(programlisting)
#, no-wrap
msgid ""
"SELECT c.tableoid::regclass, c.name, c.altitude\n"
"FROM cities c\n"
"WHERE c.altitude &gt; 500;"
msgstr ""
"SELECT c.tableoid::regclass, c.name, c.altitude\n"
"FROM cities c\n"
"WHERE c.altitude &gt; 500;"

#: ddl.xml:2341(para)
msgid ""
"Another way to get the same effect is to use the <type>regclass</type> "
"pseudo-type, which will print the table OID symbolically: <placeholder-1/>"
msgstr ""
"Тот же эффект можно получить другим способом, используя псевдотип "
"<type>regclass</type>; при этом OID таблицы выводится в символьном виде: "
"<placeholder-1/>"

#: ddl.xml:2355(programlisting)
#, no-wrap
msgid ""
"INSERT INTO cities (name, population, altitude, state)\n"
"VALUES ('Albany', NULL, NULL, 'NY');"
msgstr ""
"INSERT INTO cities (name, population, altitude, state)\n"
"VALUES ('Albany', NULL, NULL, 'NY');"

#: ddl.xml:2350(para)
msgid ""
"Inheritance does not automatically propagate data from <command>INSERT</"
"command> or <command>COPY</command> commands to other tables in the "
"inheritance hierarchy. In our example, the following <command>INSERT</"
"command> statement will fail: <placeholder-1/> We might hope that the data "
"would somehow be routed to the <structname>capitals</structname> table, but "
"this does not happen: <command>INSERT</command> always inserts into exactly "
"the table specified. In some cases it is possible to redirect the insertion "
"using a rule (see <xref linkend=\"rules\"/>). However that does not help for "
"the above case because the <structname>cities</structname> table does not "
"contain the column <structfield>state</structfield>, and so the command will "
"be rejected before the rule can be applied."
msgstr ""
"Механизм наследования не способен автоматически распределять данные команд "
"<command>INSERT</command> или <command>COPY</command> по таблицам в иерархии "
"наследования. Поэтому в нашем примере этот оператор <command>INSERT</"
"command> не выполнится: <placeholder-1/> Мы могли надеяться на то, что "
"данные каким-то образом попадут в таблицу <structname>capitals</structname>, "
"но этого не происходит: <command>INSERT</command> всегда вставляет данные "
"непосредственно в указанную таблицу. В некоторых случаях добавляемые данные "
"можно перенаправлять, используя правила (см. <xref remap=\"4\" linkend="
"\"rules\"/>). Однако в нашем случае это не поможет, так как таблица "
"<structname>cities</structname> не содержит столбца <structfield>state</"
"structfield> и команда будет отвергнута до применения правила."

#: ddl.xml:2367(para)
msgid ""
"All check constraints and not-null constraints on a parent table are "
"automatically inherited by its children. Other types of constraints (unique, "
"primary key, and foreign key constraints) are not inherited."
msgstr ""
"Дочерние таблицы автоматически наследуют от родительской таблицы ограничения-"
"проверки и ограничения NOT NULL. Все остальные ограничения (уникальности, "
"первичный ключ и внешние ключи) не наследуются."

#: ddl.xml:2373(para)
msgid ""
"A table can inherit from more than one parent table, in which case it has "
"the union of the columns defined by the parent tables. Any columns declared "
"in the child table's definition are added to these. If the same column name "
"appears in multiple parent tables, or in both a parent table and the child's "
"definition, then these columns are <quote>merged</quote> so that there is "
"only one such column in the child table. To be merged, columns must have the "
"same data types, else an error is raised. The merged column will have copies "
"of all the check constraints coming from any one of the column definitions "
"it came from, and will be marked not-null if any of them are."
msgstr ""
"Таблица может наследоваться от нескольких родительских таблиц, в этом случае "
"она будет объединять в себе все столбцы этих таблиц, а также столбцы, "
"описанные непосредственно в её определении. Если в определениях родительских "
"и дочерней таблиц встретятся столбцы с одним именем, эти столбцы будут "
"<quote>объединены</quote>, так что в дочерней таблице окажется только один "
"столбец. Чтобы такое объединение было возможно, столбцы должны иметь "
"одинаковый тип данных, в противном случае произойдёт ошибка. В определении "
"объединённого столбца будут собраны все ограничения-проверки объединяемых "
"столбцов, а также ограничение NOT NULL, если оно было задано для них."

#: ddl.xml:2386(para)
msgid ""
"Table inheritance is typically established when the child table is created, "
"using the <literal>INHERITS</literal> clause of the <xref linkend=\"sql-"
"createtable\"/> statement. Alternatively, a table which is already defined "
"in a compatible way can have a new parent relationship added, using the "
"<literal>INHERIT</literal> variant of <xref linkend=\"sql-altertable\"/>. To "
"do this the new child table must already include columns with the same names "
"and types as the columns of the parent. It must also include check "
"constraints with the same names and check expressions as those of the "
"parent. Similarly an inheritance link can be removed from a child using the "
"<literal>NO INHERIT</literal> variant of <command>ALTER TABLE</command>. "
"Dynamically adding and removing inheritance links like this can be useful "
"when the inheritance relationship is being used for table partitioning (see "
"<xref linkend=\"ddl-partitioning\"/>)."
msgstr ""
"Отношение наследования между таблицами обычно устанавливается при создании "
"дочерней таблицы с использованием предложения <literal>INHERITS</literal> "
"оператора <xref linkend=\"sql-createtable\"/>. Другой способ добавить такое "
"отношение для таблицы, определённой подходящим образом &mdash; использовать "
"<literal>INHERIT</literal> с оператором <xref linkend=\"sql-altertable\"/>. "
"Для этого будущая дочерняя таблица должна уже включать те же столбцы (с "
"совпадающими именами и типами), что и родительская таблица. Также она должна "
"включать аналогичные ограничения-проверки (с теми же именами и выражениями). "
"Удалить отношение наследования можно с помощью указания <literal>NO INHERIT</"
"literal> оператора <command>ALTER TABLE</command>. Динамическое добавление и "
"удаление отношений наследования может быть полезно при реализации "
"секционирования таблиц (см. <xref remap=\"4\" linkend=\"ddl-partitioning\"/"
">)."

#: ddl.xml:2404(para)
msgid ""
"One convenient way to create a compatible table that will later be made a "
"new child is to use the <literal>LIKE</literal> clause in <command>CREATE "
"TABLE</command>. This creates a new table with the same columns as the "
"source table. If there are any <literal>CHECK</literal> constraints defined "
"on the source table, the <literal>INCLUDING CONSTRAINTS</literal> option to "
"<literal>LIKE</literal> should be specified, as the new child must have "
"constraints matching the parent to be considered compatible."
msgstr ""
"Для создания таблицы, которая затем может стать наследником другой, удобно "
"воспользоваться предложением <literal>LIKE</literal> оператора "
"<command>CREATE TABLE</command>. Такая команда создаст новую таблицу с теми "
"же столбцами, что имеются в исходной. Если в исходной таблицы определены "
"ограничения <literal>CHECK</literal>, для создания полностью совместимой "
"таблицы их тоже нужно скопировать, и это можно сделать, добавив к "
"предложению <literal>LIKE</literal> параметр <literal>INCLUDING CONSTRAINTS</"
"literal>."

#: ddl.xml:2415(para)
msgid ""
"A parent table cannot be dropped while any of its children remain. Neither "
"can columns or check constraints of child tables be dropped or altered if "
"they are inherited from any parent tables. If you wish to remove a table and "
"all of its descendants, one easy way is to drop the parent table with the "
"<literal>CASCADE</literal> option."
msgstr ""
"Родительскую таблицу нельзя удалить, пока существуют унаследованные от неё. "
"Так же как в дочерних таблицах нельзя удалять или модифицировать столбцы или "
"ограничения-проверки, унаследованные от родительских таблиц. Если вы хотите "
"удалить таблицу вместе со всеми её потомками, это легко сделать, добавив в "
"команду удаления родительской таблицы параметр <literal>CASCADE</literal>."

#: ddl.xml:2424(para)
msgid ""
"<xref linkend=\"sql-altertable\"/> will propagate any changes in column data "
"definitions and check constraints down the inheritance hierarchy. Again, "
"dropping columns that are depended on by other tables is only possible when "
"using the <literal>CASCADE</literal> option. <command>ALTER TABLE</command> "
"follows the same rules for duplicate column merging and rejection that apply "
"during <command>CREATE TABLE</command>."
msgstr ""
"При изменениях определений и ограничений столбцов команда <xref linkend="
"\"sql-altertable\"/> распространяет эти изменения вниз в иерархии "
"наследования. Однако удалить столбцы, унаследованные дочерними таблицами, "
"можно только с помощью параметра <literal>CASCADE</literal>. При создании "
"отношений наследования команда <command>ALTER TABLE</command> следует тем же "
"правилам объединения дублирующихся столбцов, что и <command>CREATE TABLE</"
"command>."

#: ddl.xml:2434(para)
msgid ""
"Note how table access permissions are handled. Querying a parent table can "
"automatically access data in child tables without further access privilege "
"checking. This preserves the appearance that the data is (also) in the "
"parent table. Accessing the child tables directly is, however, not "
"automatically allowed and would require further privileges to be granted."
msgstr ""
"Обратите внимание на ситуацию с правами доступа. При запросе к родительской "
"таблице данные всех дочерних таблиц будут возвращены без дополнительной "
"проверки прав. Так создаётся представление, что эти данные (тоже) находятся "
"в родительской таблице. Однако права не распространяются автоматически на "
"все дочерние таблицы, и поэтому для обращения к ним права доступа должны "
"назначаться отдельно."

#: ddl.xml:2443(para)
msgid ""
"Foreign tables (see <xref linkend=\"ddl-foreign-data\"/>) can also be part "
"of inheritance hierarchies, either as parent or child tables, just as "
"regular tables can be. If a foreign table is part of an inheritance "
"hierarchy then any operations not supported by the foreign table are not "
"supported on the whole hierarchy either."
msgstr ""
"Сторонние таблицы (см. <xref remap=\"4\" linkend=\"ddl-foreign-data\"/>) "
"могут также входить в иерархию наследования как родительские или дочерние "
"таблицы, так же, как и обычные. Если в иерархию наследования входит "
"сторонняя таблица, все операции, не поддерживаемые ей, не будут "
"поддерживаться иерархией в целом."

#: ddl.xml:2452(title) ddl.xml:3118(title)
msgid "Caveats"
msgstr "Ограничения"

#: ddl.xml:2454(para)
msgid ""
"Note that not all SQL commands are able to work on inheritance hierarchies. "
"Commands that are used for data querying, data modification, or schema "
"modification (e.g., <literal>SELECT</literal>, <literal>UPDATE</literal>, "
"<literal>DELETE</literal>, most variants of <literal>ALTER TABLE</literal>, "
"but not <literal>INSERT</literal> or <literal>ALTER TABLE ... RENAME</"
"literal>) typically default to including child tables and support the "
"<literal>ONLY</literal> notation to exclude them. Commands that do database "
"maintenance and tuning (e.g., <literal>REINDEX</literal>, <literal>VACUUM</"
"literal>) typically only work on individual, physical tables and do not "
"support recursing over inheritance hierarchies. The respective behavior of "
"each individual command is documented in its reference page (<xref linkend="
"\"sql-commands\"/>)."
msgstr ""
"Заметьте, что не все SQL-команды могут работать с иерархиями наследования. "
"Команды, выполняющие выборку данных, изменение данных или модификацию схемы "
"(например <literal>SELECT</literal>, <literal>UPDATE</literal>, "
"<literal>DELETE</literal>, большинство вариантов <literal>ALTER TABLE</"
"literal>, но не <literal>INSERT</literal> и <literal>ALTER TABLE ... RENAME</"
"literal>), обычно по умолчанию обрабатывают данные дочерних таблиц и могут "
"исключать их, если поддерживают указание <literal>ONLY</literal>. Команды "
"для обслуживания и настройки базы данных (например <literal>REINDEX</"
"literal> и <literal>VACUUM</literal>) обычно работают только с отдельными "
"физическими таблицами и не поддерживают рекурсивную обработку отношений "
"наследования. Соответствующее поведение каждой команды описано в её справке "
"(<xref linkend=\"sql-commands\"/>)."

#: ddl.xml:2480(para)
msgid ""
"If we declared <structname>cities</structname>.<structfield>name</"
"structfield> to be <literal>UNIQUE</literal> or a <literal>PRIMARY KEY</"
"literal>, this would not stop the <structname>capitals</structname> table "
"from having rows with names duplicating rows in <structname>cities</"
"structname>. And those duplicate rows would by default show up in queries "
"from <structname>cities</structname>. In fact, by default "
"<structname>capitals</structname> would have no unique constraint at all, "
"and so could contain multiple rows with the same name. You could add a "
"unique constraint to <structname>capitals</structname>, but this would not "
"prevent duplication compared to <structname>cities</structname>."
msgstr ""
"Если мы объявим <structname>cities</structname>.<structfield>name</"
"structfield> с ограничением <literal>UNIQUE</literal> или <literal>PRIMARY "
"KEY</literal>, это не помешает добавить в таблицу <structname>capitals</"
"structname> строки с названиями городов, уже существующими в таблице "
"<structname>cities</structname>. И эти дублирующиеся строки по умолчанию "
"будут выводиться в результате запросов к <structname>cities</structname>. На "
"деле таблица <structname>capitals</structname> по умолчанию вообще не будет "
"содержать ограничение уникальности, так что в ней могут оказаться несколько "
"строк с одним названием. Хотя вы можете добавить в <structname>capitals</"
"structname> соответствующее ограничение, но это не предотвратит дублирование "
"при объединении с <structname>cities</structname>."

#: ddl.xml:2494(para)
msgid ""
"Similarly, if we were to specify that <structname>cities</structname>."
"<structfield>name</structfield> <literal>REFERENCES</literal> some other "
"table, this constraint would not automatically propagate to "
"<structname>capitals</structname>. In this case you could work around it by "
"manually adding the same <literal>REFERENCES</literal> constraint to "
"<structname>capitals</structname>."
msgstr ""
"Подобным образом, если мы укажем, что <structname>cities</structname>."
"<structfield>name</structfield> ссылается (<literal>REFERENCES</literal>) на "
"какую-то другую таблицу, это ограничение не будет автоматически "
"распространено на <structname>capitals</structname>. В этом случае решением "
"может стать явное добавление такого же ограничения <literal>REFERENCES</"
"literal> в таблицу <structname>capitals</structname>."

#: ddl.xml:2505(para)
msgid ""
"Specifying that another table's column <literal>REFERENCES cities(name)</"
"literal> would allow the other table to contain city names, but not capital "
"names. There is no good workaround for this case."
msgstr ""
"Если вы сделаете, чтобы столбец другой таблицы ссылался на "
"<literal>cities(name)</literal>, в этом столбце можно будет указывать только "
"названия городов, но не столиц. В этом случае хорошего решения нет."

#: ddl.xml:2471(para)
msgid ""
"A serious limitation of the inheritance feature is that indexes (including "
"unique constraints) and foreign key constraints only apply to single tables, "
"not to their inheritance children. This is true on both the referencing and "
"referenced sides of a foreign key constraint. Thus, in the terms of the "
"above example: <placeholder-1/> These deficiencies will probably be fixed in "
"some future release, but in the meantime considerable care is needed in "
"deciding whether inheritance is useful for your application."
msgstr ""
"Возможности наследования серьёзно ограничены тем, что индексы (включая "
"ограничения уникальности) и ограничения внешних ключей относятся только к "
"отдельным таблицам, но не к их потомкам. Это касается обеих сторон "
"ограничений внешних ключей. Таким образом, применительно к нашему примеру: "
"<placeholder-1/> Возможно, в будущем эти недостатки будут исправлены, но в "
"настоящее время вам следует тщательно взвесить все за и против, прежде чем "
"использовать наследование в своих приложениях."

#: ddl.xml:2522(title)
msgid "Partitioning"
msgstr "Секционирование"

#: ddl.xml:2524(indexterm)
msgid "<primary>partitioning</primary>"
msgstr "<primary>секционирование</primary>"

#: ddl.xml:2528(indexterm)
msgid "<primary>table</primary><secondary>partitioning</secondary>"
msgstr "<primary>таблица</primary><secondary>секционирование</secondary>"

#: ddl.xml:2532(para)
msgid ""
"<productname>PostgreSQL</productname> supports basic table partitioning. "
"This section describes why and how to implement partitioning as part of your "
"database design."
msgstr ""
"<productname>PostgreSQL</productname> поддерживает простое секционирование "
"таблиц. В этом разделе описывается, как и почему бывает полезно применять "
"секционирование при проектировании баз данных."

#: ddl.xml:2539(title)
msgid "Overview"
msgstr "Обзор"

#: ddl.xml:2547(para)
msgid ""
"Query performance can be improved dramatically in certain situations, "
"particularly when most of the heavily accessed rows of the table are in a "
"single partition or a small number of partitions. The partitioning "
"substitutes for leading columns of indexes, reducing index size and making "
"it more likely that the heavily-used parts of the indexes fit in memory."
msgstr ""
"В определённых ситуациях оно кардинально увеличивает быстродействие, "
"особенно когда большой процент часто запрашиваемых строк таблицы относится к "
"одному или небольшому числу секций. Секционирование может сыграть роль "
"ведущих столбцов в индексах, что позволит уменьшить размер индекса и "
"увеличит вероятность нахождения наиболее востребованных частей индексов в "
"памяти."

#: ddl.xml:2558(para)
msgid ""
"When queries or updates access a large percentage of a single partition, "
"performance can be improved by taking advantage of sequential scan of that "
"partition instead of using an index and random access reads scattered across "
"the whole table."
msgstr ""
"Когда в выборке или изменении данных задействована большая часть одной "
"секции, последовательное сканирование этой секции может выполняться гораздо "
"быстрее, чем случайный доступ по индексу к данным, разбросанным по всей "
"таблице."

#: ddl.xml:2567(para)
msgid ""
"Bulk loads and deletes can be accomplished by adding or removing partitions, "
"if that requirement is planned into the partitioning design. <command>ALTER "
"TABLE NO INHERIT</command> and <command>DROP TABLE</command> are both far "
"faster than a bulk operation. These commands also entirely avoid the "
"<command>VACUUM</command> overhead caused by a bulk <command>DELETE</"
"command>."
msgstr ""
"Массовую загрузку и удаление данных можно осуществлять, добавляя и удаляя "
"секции, если это было предусмотрено при проектировании секций. Команды "
"<command>ALTER TABLE NO INHERIT</command> и <command>DROP TABLE</command> "
"работают гораздо быстрее, чем массовая загрузка. Эти команды также полностью "
"исключают накладные расходы, связанные с выполнением операции "
"<command>VACUUM</command> после команды <command>DELETE</command>."

#: ddl.xml:2578(para)
msgid "Seldom-used data can be migrated to cheaper and slower storage media."
msgstr ""
"Редко используемые данные можно перенести на более дешёвые и медленные "
"носители."

#: ddl.xml:2541(para)
msgid ""
"Partitioning refers to splitting what is logically one large table into "
"smaller physical pieces. Partitioning can provide several benefits: "
"<placeholder-1/> The benefits will normally be worthwhile only when a table "
"would otherwise be very large. The exact point at which a table will benefit "
"from partitioning depends on the application, although a rule of thumb is "
"that the size of the table should exceed the physical memory of the database "
"server."
msgstr ""
"Секционированием данных называется разбиение одной большой логической "
"таблицы на несколько небольших физических секций. Секционирование может "
"принести следующую пользу: <placeholder-1/> Всё это обычно полезно только "
"для очень больших таблиц. Какие именно таблицы выиграют от секционирования, "
"зависит от конкретного приложения, хотя, как правило, это следует применять "
"для таблиц, размер которых превышает объём ОЗУ сервера."

#: ddl.xml:2591(para)
msgid ""
"Currently, <productname>PostgreSQL</productname> supports partitioning via "
"table inheritance. Each partition must be created as a child table of a "
"single parent table. The parent table itself is normally empty; it exists "
"just to represent the entire data set. You should be familiar with "
"inheritance (see <xref linkend=\"ddl-inherit\"/>) before attempting to set "
"up partitioning."
msgstr ""
"В настоящее время <productname>PostgreSQL</productname> реализует "
"секционирование таблиц через механизм наследования. Каждая секция одной "
"таблицы должна создаваться как её дочерняя таблица. Сама же родительская "
"таблица обычно остаётся пустой; она существует только для того, чтобы "
"представлять единый набор данных. Прежде чем приступить к изучению "
"секционирования, вам следует познакомиться с наследованием (см. <xref remap="
"\"4\" linkend=\"ddl-inherit\"/>)."

#: ddl.xml:2606(term)
msgid "Range Partitioning"
msgstr "Секционирование по диапазонам"

#: ddl.xml:2609(para)
msgid ""
"The table is partitioned into <quote>ranges</quote> defined by a key column "
"or set of columns, with no overlap between the ranges of values assigned to "
"different partitions. For example one might partition by date ranges, or by "
"ranges of identifiers for particular business objects."
msgstr ""
"Таблица секционируется по <quote>диапазонам</quote>, определённым по "
"ключевому столбцу или набору столбцов, и не пересекающимся друг с другом. "
"Например, можно секционировать данные по диапазонам дат или по диапазонам "
"идентификаторов определённых бизнес-объектов."

#: ddl.xml:2620(term)
msgid "List Partitioning"
msgstr "Секционирование по списку"

#: ddl.xml:2623(para)
msgid ""
"The table is partitioned by explicitly listing which key values appear in "
"each partition."
msgstr ""
"Таблица секционируется с помощью списка, явно указывающего, какие значения "
"ключа должны относиться к каждой секции."

#: ddl.xml:2600(para)
msgid ""
"The following forms of partitioning can be implemented in "
"<productname>PostgreSQL</productname>: <placeholder-1/>"
msgstr ""
"В <productname>PostgreSQL</productname> можно реализовать следующие типы "
"секционирования: <placeholder-1/>"

#: ddl.xml:2634(title)
msgid "Implementing Partitioning"
msgstr "Реализация секционирования"

#: ddl.xml:2640(para)
msgid ""
"Create the <quote>master</quote> table, from which all of the partitions "
"will inherit."
msgstr ""
"Создайте <quote>главную</quote> таблицу, от которой будут унаследованы все "
"секции."

#: ddl.xml:2644(para)
msgid ""
"This table will contain no data. Do not define any check constraints on this "
"table, unless you intend them to be applied equally to all partitions. There "
"is no point in defining any indexes or unique constraints on it, either."
msgstr ""
"Эта таблица не будет содержать данных. Не определяйте для неё никаких "
"ограничений, если только вы не намерены затем явно продублировать их во всех "
"секциях. Также не имеет смысла определять для неё какие-либо индексы или "
"ограничения уникальности."

#: ddl.xml:2653(para)
msgid ""
"Create several <quote>child</quote> tables that each inherit from the master "
"table. Normally, these tables will not add any columns to the set inherited "
"from the master."
msgstr ""
"Создайте несколько <quote>дочерних</quote> таблиц, унаследовав их все от "
"главной. Обычно в таких таблицах не будет никаких дополнительных столбцов, "
"кроме унаследованных."

#: ddl.xml:2659(para)
msgid ""
"We will refer to the child tables as partitions, though they are in every "
"way normal <productname>PostgreSQL</productname> tables (or, possibly, "
"foreign tables)."
msgstr ""
"Далее мы будем называть эти дочерние таблицы секциями, хотя по сути они "
"ничем не отличаются от обычных таблиц <productname>PostgreSQL</productname> "
"(и, возможно, сторонних таблиц)."

#: ddl.xml:2667(para)
msgid ""
"Add table constraints to the partition tables to define the allowed key "
"values in each partition."
msgstr ""
"Добавьте в таблицы-секции ограничения, определяющие допустимые значения "
"ключей для каждой секции."

#: ddl.xml:2674(programlisting)
#, no-wrap
msgid ""
"CHECK ( x = 1 )\n"
"CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))\n"
"CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )"
msgstr ""
"CHECK ( x = 1 )\n"
"CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))\n"
"CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )"

#: ddl.xml:2680(programlisting)
#, no-wrap
msgid ""
"CHECK ( outletID BETWEEN 100 AND 200 )\n"
"CHECK ( outletID BETWEEN 200 AND 300 )"
msgstr ""
"CHECK ( outletID BETWEEN 100 AND 200 )\n"
"CHECK ( outletID BETWEEN 200 AND 300 )"

#: ddl.xml:2672(para)
msgid ""
"Typical examples would be: <placeholder-1/> Ensure that the constraints "
"guarantee that there is no overlap between the key values permitted in "
"different partitions. A common mistake is to set up range constraints like: "
"<placeholder-2/> This is wrong since it is not clear which partition the key "
"value 200 belongs in."
msgstr ""
"Типичные примеры таких ограничений: <placeholder-1/> Убедитесь в том, что "
"ограничения не пересекаются, то есть никакие значения ключа не относятся "
"сразу к нескольким секциям. Например, часто допускают такую ошибку в "
"определении диапазонов: <placeholder-2/> Это не будет работать, так как "
"неясно, к какой секции должно относиться значение 200."

#: ddl.xml:2686(para)
msgid ""
"Note that there is no difference in syntax between range and list "
"partitioning; those terms are descriptive only."
msgstr ""
"Заметьте, что никаких синтаксических отличий между секционированием по "
"диапазонам и по списку значений нет; эти типы выделены только для понимания."

#: ddl.xml:2694(para)
msgid ""
"For each partition, create an index on the key column(s), as well as any "
"other indexes you might want. (The key index is not strictly necessary, but "
"in most scenarios it is helpful. If you intend the key values to be unique "
"then you should always create a unique or primary-key constraint for each "
"partition.)"
msgstr ""
"Для каждой секции создайте индекс по ключевому столбцу(ам), а также любые "
"другие индексы по своему усмотрению. (Индекс по ключу, строго говоря, не "
"необходим, но в большинстве случаев он будет полезен. Если вы хотите, чтобы "
"значения ключа были уникальны, вам следует также создать ограничения "
"уникальности или первичного ключа для каждой секции.)"

#: ddl.xml:2705(para)
msgid ""
"Optionally, define a trigger or rule to redirect data inserted into the "
"master table to the appropriate partition."
msgstr ""
"Дополнительно вы можете определить триггер или правило для перенаправления "
"данных, добавляемых в главную таблицу, в соответствующую секцию."

#: ddl.xml:2712(para)
msgid ""
"Ensure that the <xref linkend=\"guc-constraint-exclusion\"/> configuration "
"parameter is not disabled in <filename>postgresql.conf</filename>. If it is, "
"queries will not be optimized as desired."
msgstr ""
"Убедитесь в том, что параметр конфигурации <xref linkend=\"guc-constraint-"
"exclusion\"/> не выключен в <filename>postgresql.conf</filename>. Иначе "
"запросы не будут оптимизироваться должным образом."

#: ddl.xml:2636(para)
msgid "To set up a partitioned table, do the following: <placeholder-1/>"
msgstr ""
"Чтобы создать секционированную таблицу, выполните следующее: <placeholder-1/>"

#: ddl.xml:2729(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE measurement (\n"
"    city_id         int not null,\n"
"    logdate         date not null,\n"
"    peaktemp        int,\n"
"    unitsales       int\n"
");"
msgstr ""
"CREATE TABLE measurement (\n"
"    city_id         int not null,\n"
"    logdate         date not null,\n"
"    peaktemp        int,\n"
"    unitsales       int\n"
");"

#: ddl.xml:2723(para)
msgid ""
"For example, suppose we are constructing a database for a large ice cream "
"company. The company measures peak temperatures every day as well as ice "
"cream sales in each region. Conceptually, we want a table like: "
"<placeholder-1/> We know that most queries will access just the last week's, "
"month's or quarter's data, since the main use of this table will be to "
"prepare online reports for management. To reduce the amount of old data that "
"needs to be stored, we decide to only keep the most recent 3 years worth of "
"data. At the beginning of each month we will remove the oldest month's data."
msgstr ""
"Например, предположим, что мы создаём базу данных для большой компании, "
"торгующей мороженым. Компания учитывает максимальную температуру и продажи "
"мороженого каждый день в разрезе регионов. По сути нам нужна следующая "
"таблица: <placeholder-1/> Мы знаем, что большинство запросов будут работать "
"только с данными за последнюю неделю, месяц или квартал, так как в основном "
"эта таблица нужна для формирования текущих отчётов для руководства. Чтобы "
"сократить объём хранящихся старых данных, мы решили оставлять данные только "
"за 3 последних года. Ненужные данные мы будем удалять в начале каждого "
"месяца."

#: ddl.xml:2744(para)
msgid ""
"In this situation we can use partitioning to help us meet all of our "
"different requirements for the measurements table. Following the steps "
"outlined above, partitioning can be set up as follows:"
msgstr ""
"При таких условиях мы можем применить секционирование для удовлетворения "
"всех наших потребностей. Настроить секционирование согласно приведённой выше "
"последовательности действий можно следующим образом:"

#: ddl.xml:2753(para)
msgid ""
"The master table is the <structname>measurement</structname> table, declared "
"exactly as above."
msgstr ""
"Главная таблица, названная <structname>measurement</structname>, будет "
"объявлена в точности как показано выше."

#: ddl.xml:2763(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE measurement_y2006m02 ( ) INHERITS (measurement);\n"
"CREATE TABLE measurement_y2006m03 ( ) INHERITS (measurement);\n"
"...\n"
"CREATE TABLE measurement_y2007m11 ( ) INHERITS (measurement);\n"
"CREATE TABLE measurement_y2007m12 ( ) INHERITS (measurement);\n"
"CREATE TABLE measurement_y2008m01 ( ) INHERITS (measurement);"
msgstr ""
"CREATE TABLE measurement_y2006m02 ( ) INHERITS (measurement);\n"
"CREATE TABLE measurement_y2006m03 ( ) INHERITS (measurement);\n"
"...\n"
"CREATE TABLE measurement_y2007m11 ( ) INHERITS (measurement);\n"
"CREATE TABLE measurement_y2007m12 ( ) INHERITS (measurement);\n"
"CREATE TABLE measurement_y2008m01 ( ) INHERITS (measurement);"

#: ddl.xml:2760(para)
msgid ""
"Next we create one partition for each active month: <placeholder-1/> Each of "
"the partitions are complete tables in their own right, but they inherit "
"their definitions from the <structname>measurement</structname> table."
msgstr ""
"Затем мы создаём отдельные секции для каждого нужного нам месяца: "
"<placeholder-1/> Все эти секции являются полностью самостоятельными "
"таблицами, но они наследуют свои определения от таблицы "
"<structname>measurement</structname>."

#: ddl.xml:2775(para)
msgid ""
"This solves one of our problems: deleting old data. Each month, all we will "
"need to do is perform a <command>DROP TABLE</command> on the oldest child "
"table and create a new child table for the new month's data."
msgstr ""
"Это решает одну из наших проблем: удаление старых данных. Каждый месяц нам "
"нужно будет просто выполнять <command>DROP TABLE</command> для самой старой "
"дочерней таблицы и создавать новую дочернюю таблицу для данных нового месяца."

#: ddl.xml:2789(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE measurement_y2006m02 (\n"
"    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )\n"
") INHERITS (measurement);\n"
"CREATE TABLE measurement_y2006m03 (\n"
"    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )\n"
") INHERITS (measurement);\n"
"...\n"
"CREATE TABLE measurement_y2007m11 (\n"
"    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )\n"
") INHERITS (measurement);\n"
"CREATE TABLE measurement_y2007m12 (\n"
"    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )\n"
") INHERITS (measurement);\n"
"CREATE TABLE measurement_y2008m01 (\n"
"    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )\n"
") INHERITS (measurement);"
msgstr ""
"CREATE TABLE measurement_y2006m02 (\n"
"  CHECK (logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01')\n"
") INHERITS (measurement);\n"
"CREATE TABLE measurement_y2006m03 (\n"
"  CHECK (logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01')\n"
") INHERITS (measurement);\n"
"...\n"
"CREATE TABLE measurement_y2007m11 (\n"
"  CHECK (logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01')\n"
") INHERITS (measurement);\n"
"CREATE TABLE measurement_y2007m12 (\n"
"  CHECK (logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01')\n"
") INHERITS (measurement);\n"
"CREATE TABLE measurement_y2008m01 (\n"
"  CHECK (logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01')\n"
") INHERITS (measurement);"

#: ddl.xml:2784(para)
msgid ""
"We must provide non-overlapping table constraints. Rather than just creating "
"the partition tables as above, the table creation script should really be: "
"<placeholder-1/>"
msgstr ""
"Мы должны определить непересекающиеся ограничения таблиц. Таким образом, "
"скрипт создания таблиц должен не просто создавать секции, но ещё и задавать "
"ограничения: <placeholder-1/>"

#: ddl.xml:2812(programlisting)
#, no-wrap
msgid ""
"CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);\n"
"CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);\n"
"...\n"
"CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);\n"
"CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);\n"
"CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);"
msgstr ""
"CREATE INDEX measurement_y2006m02_logdate\n"
"  ON measurement_y2006m02 (logdate);\n"
"CREATE INDEX measurement_y2006m03_logdate\n"
"  ON measurement_y2006m03 (logdate);\n"
"...\n"
"CREATE INDEX measurement_y2007m11_logdate\n"
"  ON measurement_y2007m11 (logdate);\n"
"CREATE INDEX measurement_y2007m12_logdate\n"
"  ON measurement_y2007m12 (logdate);\n"
"CREATE INDEX measurement_y2008m01_logdate\n"
"  ON measurement_y2008m01 (logdate);"

#: ddl.xml:2809(para)
msgid ""
"We probably need indexes on the key columns too: <placeholder-1/> We choose "
"not to add further indexes at this time."
msgstr ""
"Мы, вероятно, также захотим добавить индексы по столбцам ключа: "
"<placeholder-1/> На этом с индексами мы пока остановимся."

#: ddl.xml:2832(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION measurement_insert_trigger()\n"
"RETURNS TRIGGER AS $$\n"
"BEGIN\n"
"    INSERT INTO measurement_y2008m01 VALUES (NEW.*);\n"
"    RETURN NULL;\n"
"END;\n"
"$$\n"
"LANGUAGE plpgsql;"
msgstr ""
"CREATE OR REPLACE FUNCTION measurement_insert_trigger()\n"
"RETURNS TRIGGER AS $$\n"
"BEGIN\n"
"    INSERT INTO measurement_y2008m01 VALUES (NEW.*);\n"
"    RETURN NULL;\n"
"END;\n"
"$$\n"
"LANGUAGE plpgsql;"

#: ddl.xml:2844(programlisting)
#, no-wrap
msgid ""
"CREATE TRIGGER insert_measurement_trigger\n"
"    BEFORE INSERT ON measurement\n"
"    FOR EACH ROW EXECUTE PROCEDURE measurement_insert_trigger();"
msgstr ""
"CREATE TRIGGER insert_measurement_trigger\n"
"    BEFORE INSERT ON measurement\n"
"    FOR EACH ROW EXECUTE PROCEDURE measurement_insert_trigger();"

#: ddl.xml:2824(para)
msgid ""
"We want our application to be able to say <literal>INSERT INTO "
"measurement ...</literal> and have the data be redirected into the "
"appropriate partition table. We can arrange that by attaching a suitable "
"trigger function to the master table. If data will be added only to the "
"latest partition, we can use a very simple trigger function: <placeholder-1/"
"> After creating the function, we create a trigger which calls the trigger "
"function: <placeholder-2/> We must redefine the trigger function each month "
"so that it always points to the current partition. The trigger definition "
"does not need to be updated, however."
msgstr ""
"Мы хотим, чтобы наше приложение могло сказать <literal>INSERT INTO "
"measurement ...</literal> и данные оказались в соответствующей секции. Мы "
"можем добиться этого, добавив подходящую триггерную функцию в главную "
"таблицу. Если данные всегда будут добавляться только в последнюю секцию, нам "
"будет достаточно очень простой функции: <placeholder-1/> Теперь мы создаём "
"триггер, вызывающий эту функцию: <placeholder-2/> Затем мы должны будем "
"каждый месяц переопределять триггерную функцию, чтобы она всегда указывала "
"на текущую секцию. Однако определение триггера обновлять не потребуется."

#: ddl.xml:2858(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION measurement_insert_trigger()\n"
"RETURNS TRIGGER AS $$\n"
"BEGIN\n"
"    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND\n"
"         NEW.logdate &lt; DATE '2006-03-01' ) THEN\n"
"        INSERT INTO measurement_y2006m02 VALUES (NEW.*);\n"
"    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND\n"
"            NEW.logdate &lt; DATE '2006-04-01' ) THEN\n"
"        INSERT INTO measurement_y2006m03 VALUES (NEW.*);\n"
"    ...\n"
"    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND\n"
"            NEW.logdate &lt; DATE '2008-02-01' ) THEN\n"
"        INSERT INTO measurement_y2008m01 VALUES (NEW.*);\n"
"    ELSE\n"
"        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';\n"
"    END IF;\n"
"    RETURN NULL;\n"
"END;\n"
"$$\n"
"LANGUAGE plpgsql;"
msgstr ""
"CREATE OR REPLACE FUNCTION measurement_insert_trigger()\n"
"RETURNS TRIGGER AS $$\n"
"BEGIN\n"
"    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND\n"
"         NEW.logdate &lt; DATE '2006-03-01' ) THEN\n"
"        INSERT INTO measurement_y2006m02 VALUES (NEW.*);\n"
"    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND\n"
"            NEW.logdate &lt; DATE '2006-04-01' ) THEN\n"
"        INSERT INTO measurement_y2006m03 VALUES (NEW.*);\n"
"    ...\n"
"    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND\n"
"            NEW.logdate &lt; DATE '2008-02-01' ) THEN\n"
"        INSERT INTO measurement_y2008m01 VALUES (NEW.*);\n"
"    ELSE\n"
"        RAISE EXCEPTION\n"
"  'Date out of range.  Fix the measurement_insert_trigger() function!';\n"
"    END IF;\n"
"    RETURN NULL;\n"
"END;\n"
"$$\n"
"LANGUAGE plpgsql;"

#: ddl.xml:2853(para)
msgid ""
"We might want to insert data and have the server automatically locate the "
"partition into which the row should be added. We could do this with a more "
"complex trigger function, for example: <placeholder-1/> The trigger "
"definition is the same as before. Note that each <literal>IF</literal> test "
"must exactly match the <literal>CHECK</literal> constraint for its partition."
msgstr ""
"Но мы можем также сделать, чтобы сервер автоматически находил секцию, в "
"которую нужно направить добавляемую строку. Для этого нам потребуется более "
"сложная триггерная функция: <placeholder-1/> Определение триггера остаётся "
"прежним. Заметьте, что все условия <literal>IF</literal> должны в точности "
"отражать ограничения <literal>CHECK</literal> соответствующих секций."

#: ddl.xml:2884(para)
msgid ""
"While this function is more complex than the single-month case, it doesn't "
"need to be updated as often, since branches can be added in advance of being "
"needed."
msgstr ""
"Хотя эта функция сложнее, чем вариант с одним текущим месяцем, её не "
"придётся так часто модифицировать, так как ветви условий можно добавить "
"заранее."

#: ddl.xml:2891(para)
msgid ""
"In practice it might be best to check the newest partition first, if most "
"inserts go into that partition. For simplicity we have shown the trigger's "
"tests in the same order as in other parts of this example."
msgstr ""
"На практике будет лучше сначала проверять условие для последней секции, если "
"строки чаще добавляются в эту секцию. Для простоты же мы расположили "
"проверки триггера в том же порядке, как и в других фрагментах кода для этого "
"примера."

#: ddl.xml:2902(para)
msgid ""
"As we can see, a complex partitioning scheme could require a substantial "
"amount of DDL. In the above example we would be creating a new partition "
"each month, so it might be wise to write a script that generates the "
"required DDL automatically."
msgstr ""
"Как уже можно понять, для реализации сложной схемы разбиения может "
"потребоваться DDL-код значительного объёма. В данном примере нам потребуется "
"создавать секцию каждый месяц, так что было бы разумно написать скрипт, "
"который бы формировал требуемый код DDL автоматически."

#: ddl.xml:2912(title)
msgid "Managing Partitions"
msgstr "Управление секциями"

#: ddl.xml:2914(para)
msgid ""
"Normally the set of partitions established when initially defining the table "
"are not intended to remain static. It is common to want to remove old "
"partitions of data and periodically add new partitions for new data. One of "
"the most important advantages of partitioning is precisely that it allows "
"this otherwise painful task to be executed nearly instantaneously by "
"manipulating the partition structure, rather than physically moving large "
"amounts of data around."
msgstr ""
"Обычно набор секций, образованный изначально при создании таблиц, не "
"предполагается сохранять неизменным. Чаще наоборот, планируется удалять "
"старые секции данных и периодически добавлять новые. Одно из наиболее важных "
"преимуществ секционирования состоит именно в том, что оно позволяет "
"практически моментально выполнять трудоёмкие операции, изменяя структуру "
"секций, а не физически перемещая большие объёмы данных."

#: ddl.xml:2928(programlisting)
#, no-wrap
msgid "DROP TABLE measurement_y2006m02;"
msgstr "DROP TABLE measurement_y2006m02;"

#: ddl.xml:2925(para)
msgid ""
"The simplest option for removing old data is simply to drop the partition "
"that is no longer necessary: <placeholder-1/> This can very quickly delete "
"millions of records because it doesn't have to individually delete every "
"record."
msgstr ""
"Самый лёгкий способ удалить старые данные &mdash; это просто удалить секцию, "
"ставшую ненужной: <placeholder-1/> Так можно удалить миллионы записей "
"гораздо быстрее, чем сервер будет удалять их по одной."

#: ddl.xml:2937(programlisting)
#, no-wrap
msgid "ALTER TABLE measurement_y2006m02 NO INHERIT measurement;"
msgstr "ALTER TABLE measurement_y2006m02 NO INHERIT measurement;"

#: ddl.xml:2933(para)
msgid ""
"Another option that is often preferable is to remove the partition from the "
"partitioned table but retain access to it as a table in its own right: "
"<placeholder-1/> This allows further operations to be performed on the data "
"before it is dropped. For example, this is often a useful time to back up "
"the data using <command>COPY</command>, <application>pg_dump</application>, "
"or similar tools. It might also be a useful time to aggregate data into "
"smaller formats, perform other data manipulations, or run reports."
msgstr ""
"Ещё один часто более предпочтительный вариант &mdash; убрать секцию из "
"главной таблицы, но сохранить возможность обращаться к ней как к "
"самостоятельной таблице: <placeholder-1/> При этом можно будет продолжать "
"работать с данными, пока таблица не будет удалена. Например, в этом "
"состоянии очень кстати будет сделать резервную копию данных, используя "
"<command>COPY</command>, <application>pg_dump</application> или подобные "
"средства. Возможно, эти данные также можно будет агрегировать, перевести в "
"компактный формат, выполнить другую обработку или построить отчёты."

#: ddl.xml:2951(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE measurement_y2008m02 (\n"
"    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )\n"
") INHERITS (measurement);"
msgstr ""
"CREATE TABLE measurement_y2008m02 (\n"
"    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )\n"
") INHERITS (measurement);"

#: ddl.xml:2960(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE measurement_y2008m02\n"
"  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);\n"
"ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02\n"
"   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );\n"
"\\copy measurement_y2008m02 from 'measurement_y2008m02'\n"
"-- possibly some other data preparation work\n"
"ALTER TABLE measurement_y2008m02 INHERIT measurement;"
msgstr ""
"CREATE TABLE measurement_y2008m02\n"
"  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);\n"
"ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02\n"
"   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );\n"
"\\copy measurement_y2008m02 from 'measurement_y2008m02'\n"
"-- возможно, дополнительная подготовка данных\n"
"ALTER TABLE measurement_y2008m02 INHERIT measurement;"

#: ddl.xml:2946(para)
msgid ""
"Similarly we can add a new partition to handle new data. We can create an "
"empty partition in the partitioned table just as the original partitions "
"were created above: <placeholder-1/> As an alternative, it is sometimes more "
"convenient to create the new table outside the partition structure, and make "
"it a proper partition later. This allows the data to be loaded, checked, and "
"transformed prior to it appearing in the partitioned table: <placeholder-2/>"
msgstr ""
"Аналогичным образом можно добавлять новую секцию с данными. Мы можем создать "
"пустую секцию в главной таблице так же, как мы создавали секции в исходном "
"состоянии до этого: <placeholder-1/> А иногда удобнее создать новую таблицу "
"вне структуры секций и сделать её полноценной секцией позже. При таком "
"подходе данные можно будет загрузить, проверить и преобразовать до того, как "
"они появятся в секционированной таблице: <placeholder-2/>"

#: ddl.xml:2971(title)
msgid "Partitioning and Constraint Exclusion"
msgstr "Секционирование и исключение по ограничению"

#: ddl.xml:2973(indexterm)
msgid "<primary>constraint exclusion</primary>"
msgstr "<primary>исключение по ограничению</primary>"

#: ddl.xml:2982(programlisting)
#, no-wrap
msgid ""
"SET constraint_exclusion = on;\n"
"SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';"
msgstr ""
"SET constraint_exclusion = on;\n"
"SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';"

#: ddl.xml:2977(para)
msgid ""
"<firstterm>Constraint exclusion</firstterm> is a query optimization "
"technique that improves performance for partitioned tables defined in the "
"fashion described above. As an example: <placeholder-1/> Without constraint "
"exclusion, the above query would scan each of the partitions of the "
"<structname>measurement</structname> table. With constraint exclusion "
"enabled, the planner will examine the constraints of each partition and try "
"to prove that the partition need not be scanned because it could not contain "
"any rows meeting the query's <literal>WHERE</literal> clause. When the "
"planner can prove this, it excludes the partition from the query plan."
msgstr ""
"<firstterm>Исключение по ограничению</firstterm> &mdash; это приём "
"оптимизации запросов, который ускоряет работу с секционированными таблицами, "
"определёнными по вышеописанной схеме. Например: <placeholder-1/> Без "
"исключения по ограничению для данного запроса пришлось бы просканировать все "
"секции таблицы <structname>measurement</structname>. Если же исключение по "
"ограничению включено, планировщик рассмотрит ограничение каждой секции с "
"целью определить, что данная секция не может содержать строки, "
"удовлетворяющие условию запроса <literal>WHERE</literal>. Если планировщик "
"придёт к такому выводу, он исключит эту секцию из плана запроса."

#: ddl.xml:2999(programlisting)
#, no-wrap
msgid ""
"SET constraint_exclusion = off;\n"
"EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';\n"
"\n"
"                                          QUERY PLAN\n"
"-----------------------------------------------------------------------------------------------\n"
" Aggregate  (cost=158.66..158.68 rows=1 width=0)\n"
"   -&gt;  Append  (cost=0.00..151.88 rows=2715 width=0)\n"
"         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)\n"
"         -&gt;  Seq Scan on measurement_y2006m02 measurement  (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)\n"
"         -&gt;  Seq Scan on measurement_y2006m03 measurement  (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)\n"
"...\n"
"         -&gt;  Seq Scan on measurement_y2007m12 measurement  (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)\n"
"         -&gt;  Seq Scan on measurement_y2008m01 measurement  (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)"
msgstr ""
"SET constraint_exclusion = off;\n"
"EXPLAIN SELECT count(*) FROM measurement\n"
"  WHERE logdate &gt;= DATE '2008-01-01';\n"
"\n"
"                              QUERY PLAN\n"
"---------------------------------------------------------------------------\n"
" Aggregate  (cost=158.66..158.68 rows=1 width=0)\n"
"   -&gt;  Append  (cost=0.00..151.88 rows=2715 width=0)\n"
"         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)\n"
"         -&gt;  Seq Scan on measurement_y2006m02 measurement\n"
"                      (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)\n"
"         -&gt;  Seq Scan on measurement_y2006m03 measurement\n"
"                      (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)\n"
"...\n"
"         -&gt;  Seq Scan on measurement_y2007m12 measurement\n"
"                      (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)\n"
"         -&gt;  Seq Scan on measurement_y2008m01 measurement\n"
"                      (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)"

#: ddl.xml:3024(programlisting)
#, no-wrap
msgid ""
"SET constraint_exclusion = on;\n"
"EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';\n"
"                                          QUERY PLAN\n"
"-----------------------------------------------------------------------------------------------\n"
" Aggregate  (cost=63.47..63.48 rows=1 width=0)\n"
"   -&gt;  Append  (cost=0.00..60.75 rows=1086 width=0)\n"
"         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)\n"
"         -&gt;  Seq Scan on measurement_y2008m01 measurement  (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)"
msgstr ""
"SET constraint_exclusion = on;\n"
"EXPLAIN SELECT count(*) FROM measurement\n"
"  WHERE logdate &gt;= DATE '2008-01-01';\n"
"\n"
"                              QUERY PLAN\n"
"--------------------------------------------------------------------------\n"
" Aggregate  (cost=63.47..63.48 rows=1 width=0)\n"
"   -&gt;  Append  (cost=0.00..60.75 rows=1086 width=0)\n"
"         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)\n"
"         -&gt;  Seq Scan on measurement_y2008m01 measurement\n"
"                      (cost=0.00..30.38 rows=543 width=0)\n"
"               Filter: (logdate &gt;= '2008-01-01'::date)"

#: ddl.xml:2994(para)
msgid ""
"You can use the <command>EXPLAIN</command> command to show the difference "
"between a plan with <varname>constraint_exclusion</varname> on and a plan "
"with it off. A typical unoptimized plan for this type of table setup is: "
"<placeholder-1/> Some or all of the partitions might use index scans instead "
"of full-table sequential scans, but the point here is that there is no need "
"to scan the older partitions at all to answer this query. When we enable "
"constraint exclusion, we get a significantly cheaper plan that will deliver "
"the same answer: <placeholder-2/>"
msgstr ""
"Чтобы увидеть, как меняется план при изменении параметра "
"<varname>constraint_exclusion</varname>, вы можете воспользоваться командой "
"<command>EXPLAIN</command>. Типичный неоптимизированный план для такой "
"конфигурации таблицы будет выглядеть так: <placeholder-1/> В некоторых или "
"всех секциях может применяться не полное последовательное сканирование, а "
"сканирование по индексу, но основная идея примера в том, что для "
"удовлетворения запроса не нужно сканировать старые секции. И когда мы "
"включаем исключение по ограничению, мы получаем значительно более "
"эффективный план, дающий тот же результат: <placeholder-2/>"

#: ddl.xml:3036(para)
msgid ""
"Note that constraint exclusion is driven only by <literal>CHECK</literal> "
"constraints, not by the presence of indexes. Therefore it isn't necessary to "
"define indexes on the key columns. Whether an index needs to be created for "
"a given partition depends on whether you expect that queries that scan the "
"partition will generally scan a large part of the partition or just a small "
"part. An index will be helpful in the latter case but not the former."
msgstr ""
"Заметьте, что механизм ограничения по исключению учитывает только "
"ограничения <literal>CHECK</literal>, но не наличие индексов. Поэтому "
"определять индексы для столбцов ключа не обязательно. Нужно ли создавать "
"индекс для данной секции, зависит от того, какая часть секции будет "
"обрабатываться при выполнении большинства запросов. Если это небольшая "
"часть, индекс может быть полезен, в противном случае он не нужен."

#: ddl.xml:3046(para)
msgid ""
"The default (and recommended) setting of <xref linkend=\"guc-constraint-"
"exclusion\"/> is actually neither <literal>on</literal> nor <literal>off</"
"literal>, but an intermediate setting called <literal>partition</literal>, "
"which causes the technique to be applied only to queries that are likely to "
"be working on partitioned tables. The <literal>on</literal> setting causes "
"the planner to examine <literal>CHECK</literal> constraints in all queries, "
"even simple ones that are unlikely to benefit."
msgstr ""
"По умолчанию параметр <xref linkend=\"guc-constraint-exclusion\"/> имеет "
"значение не <literal>on</literal> и не <literal>off</literal>, а "
"промежуточное (и рекомендуемое) значение <literal>partition</literal>, при "
"котором этот приём будет применяться только к запросам, где предположительно "
"будут задействованы секционированные таблицы. Значение <literal>on</literal> "
"обязывает планировщик просматривать ограничения <literal>CHECK</literal> во "
"всех запросах, даже в самых простых, где исключение по ограничению не будет "
"иметь смысла."

#: ddl.xml:3060(title)
msgid "Alternative Partitioning Methods"
msgstr "Альтернативные варианты секционирования"

#: ddl.xml:3067(programlisting)
#, no-wrap
msgid ""
"CREATE RULE measurement_insert_y2006m02 AS\n"
"ON INSERT TO measurement WHERE\n"
"    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )\n"
"DO INSTEAD\n"
"    INSERT INTO measurement_y2006m02 VALUES (NEW.*);\n"
"...\n"
"CREATE RULE measurement_insert_y2008m01 AS\n"
"ON INSERT TO measurement WHERE\n"
"    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )\n"
"DO INSTEAD\n"
"    INSERT INTO measurement_y2008m01 VALUES (NEW.*);"
msgstr ""
"CREATE RULE measurement_insert_y2006m02 AS\n"
"ON INSERT TO measurement WHERE\n"
"    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )\n"
"DO INSTEAD\n"
"    INSERT INTO measurement_y2006m02 VALUES (NEW.*);\n"
"...\n"
"CREATE RULE measurement_insert_y2008m01 AS\n"
"ON INSERT TO measurement WHERE\n"
"    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )\n"
"DO INSTEAD\n"
"    INSERT INTO measurement_y2008m01 VALUES (NEW.*);"

#: ddl.xml:3062(para)
msgid ""
"A different approach to redirecting inserts into the appropriate partition "
"table is to set up rules, instead of a trigger, on the master table. For "
"example: <placeholder-1/> A rule has significantly more overhead than a "
"trigger, but the overhead is paid once per query rather than once per row, "
"so this method might be advantageous for bulk-insert situations. In most "
"cases, however, the trigger method will offer better performance."
msgstr ""
"Другой способ перенаправления добавляемых строк в соответствующую секцию "
"можно реализовать, определив для главной таблицы не триггер, а правила. "
"Например: <placeholder-1/> С правилами связано гораздо больше накладных "
"расходов, чем с триггером, но они относятся к запросу в целом, а не к каждой "
"строке. Поэтому этот способ может быть более выигрышным при массовом "
"добавлении данных. Однако в большинстве случаев триггеры будут работать "
"быстрее."

#: ddl.xml:3085(para)
msgid ""
"Be aware that <command>COPY</command> ignores rules. If you want to use "
"<command>COPY</command> to insert data, you'll need to copy into the correct "
"partition table rather than into the master. <command>COPY</command> does "
"fire triggers, so you can use it normally if you use the trigger approach."
msgstr ""
"Учтите, что команда <command>COPY</command> игнорирует правила. Если вы "
"хотите вставить данные с помощью <command>COPY</command>, вам придётся "
"копировать их сразу в нужную секцию, а не в главную таблицу. С другой "
"стороны, <command>COPY</command> не отменяет триггеры, так что с триггерами "
"вы сможете использовать её обычным образом."

#: ddl.xml:3092(para)
msgid ""
"Another disadvantage of the rule approach is that there is no simple way to "
"force an error if the set of rules doesn't cover the insertion date; the "
"data will silently go into the master table instead."
msgstr ""
"Ещё один недостаток подхода с правилами связан с невозможностью выдать "
"ошибку, если добавляемая строка не подпадает ни под одно из правил; в этом "
"случае данные просто попадут в главную таблицу."

#: ddl.xml:3102(programlisting)
#, no-wrap
msgid ""
"CREATE VIEW measurement AS\n"
"          SELECT * FROM measurement_y2006m02\n"
"UNION ALL SELECT * FROM measurement_y2006m03\n"
"...\n"
"UNION ALL SELECT * FROM measurement_y2007m11\n"
"UNION ALL SELECT * FROM measurement_y2007m12\n"
"UNION ALL SELECT * FROM measurement_y2008m01;"
msgstr ""
"CREATE VIEW measurement AS\n"
"          SELECT * FROM measurement_y2006m02\n"
"UNION ALL SELECT * FROM measurement_y2006m03\n"
"...\n"
"UNION ALL SELECT * FROM measurement_y2007m11\n"
"UNION ALL SELECT * FROM measurement_y2007m12\n"
"UNION ALL SELECT * FROM measurement_y2008m01;"

#: ddl.xml:3098(para)
msgid ""
"Partitioning can also be arranged using a <literal>UNION ALL</literal> view, "
"instead of table inheritance. For example, <placeholder-1/> However, the "
"need to recreate the view adds an extra step to adding and dropping "
"individual partitions of the data set. In practice this method has little to "
"recommend it compared to using inheritance."
msgstr ""
"Секционирование можно также реализовать с помощью представления с "
"<literal>UNION ALL</literal> вместо наследования. Например:<placeholder-1/> "
"Однако для изменения набора секций в этом случае придётся не только "
"добавлять или удалять секции, но и пересоздавать представление. На практике "
"этот метод не имеет значительных преимуществ по сравнению с наследованием."

#: ddl.xml:3124(para)
msgid ""
"There is no automatic way to verify that all of the <literal>CHECK</literal> "
"constraints are mutually exclusive. It is safer to create code that "
"generates partitions and creates and/or modifies associated objects than to "
"write each by hand."
msgstr ""
"Система не может проверить автоматически, являются ли все ограничения "
"<literal>CHECK</literal> взаимно исключающими. Поэтому безопаснее будет "
"написать и отладить код для формирования секций и создания и/или изменения "
"связанных объектов, чем делать это вручную."

#: ddl.xml:3134(para)
msgid ""
"The schemes shown here assume that the partition key column(s) of a row "
"never change, or at least do not change enough to require it to move to "
"another partition. An <command>UPDATE</command> that attempts to do that "
"will fail because of the <literal>CHECK</literal> constraints. If you need "
"to handle such cases, you can put suitable update triggers on the partition "
"tables, but it makes management of the structure much more complicated."
msgstr ""
"Показанные здесь схемы подразумевают, что ключевой столбец(ы) секции в "
"строке никогда не меняется, или меняется не настолько, чтобы строку "
"потребовалось перенести в другую секцию. Если же попытаться выполнить такой "
"оператор <command>UPDATE</command>, произойдёт ошибка из-за нарушения "
"ограничения <literal>CHECK</literal>. Если вам нужно обработать и такие "
"случаи, вы можете установить подходящие триггеры на обновление в таблицы-"
"секции, но это ещё больше усложнит управление всей конструкцией."

#: ddl.xml:3150(programlisting)
#, no-wrap
msgid "ANALYZE measurement;"
msgstr "ANALYZE measurement;"

#: ddl.xml:3146(para)
msgid ""
"If you are using manual <command>VACUUM</command> or <command>ANALYZE</"
"command> commands, don't forget that you need to run them on each partition "
"individually. A command like: <placeholder-1/> will only process the master "
"table."
msgstr ""
"Если вы выполняете команды <command>VACUUM</command> или <command>ANALYZE</"
"command> вручную, не забывайте, что их нужно запускать для каждой секции в "
"отдельности. Команда <placeholder-1/> обработает только главную таблицу."

#: ddl.xml:3156(para)
msgid ""
"<command>INSERT</command> statements with <literal>ON CONFLICT</literal> "
"clauses are unlikely to work as expected, as the <literal>ON CONFLICT</"
"literal> action is only taken in case of unique violations on the specified "
"target relation, not its child relations."
msgstr ""
"Операторы <command>INSERT</command> с предложениями <literal>ON CONFLICT</"
"literal> скорее всего не будут работать ожидаемым образом, так как действие "
"<literal>ON CONFLICT</literal> предпринимается только в случае нарушений "
"уникальности в указанном целевом отношении, а не его дочерних отношениях."

#: ddl.xml:3120(para)
msgid "The following caveats apply to partitioned tables: <placeholder-1/>"
msgstr ""
"С секционированными таблицами связаны следующие ограничения: <placeholder-1/>"

#: ddl.xml:3172(para)
msgid ""
"Constraint exclusion only works when the query's <literal>WHERE</literal> "
"clause contains constants (or externally supplied parameters). For example, "
"a comparison against a non-immutable function such as "
"<function>CURRENT_TIMESTAMP</function> cannot be optimized, since the "
"planner cannot know which partition the function value might fall into at "
"run time."
msgstr ""
"Исключение по ограничению работает только когда предложение <literal>WHERE</"
"literal> в запросе содержит константы (или получаемые извне параметры). "
"Например, сравнение с функцией переменной природы, такой как "
"<function>CURRENT_TIMESTAMP</function>, нельзя оптимизировать, так как "
"планировщик не знает, в какую секцию попадёт значение функции во время "
"выполнения."

#: ddl.xml:3183(para)
msgid ""
"Keep the partitioning constraints simple, else the planner may not be able "
"to prove that partitions don't need to be visited. Use simple equality "
"conditions for list partitioning, or simple range tests for range "
"partitioning, as illustrated in the preceding examples. A good rule of thumb "
"is that partitioning constraints should contain only comparisons of the "
"partitioning column(s) to constants using B-tree-indexable operators."
msgstr ""
"Ограничения секций должны быть простыми, иначе планировщик не сможет "
"вычислить, какие секции не нужно обрабатывать. Для секционирования по списку "
"используйте простые условия на равенства, а для секционирования по "
"диапазонам — простые проверки диапазонов, подобные показанным в примерах. "
"Рекомендуется создавать ограничения секций, содержащие только такие "
"сравнения секционирующих столбцов с константами, в которых используются "
"операторы, поддерживающие B-деревья."

#: ddl.xml:3195(para)
msgid ""
"All constraints on all partitions of the master table are examined during "
"constraint exclusion, so large numbers of partitions are likely to increase "
"query planning time considerably. Partitioning using these techniques will "
"work well with up to perhaps a hundred partitions; don't try to use many "
"thousands of partitions."
msgstr ""
"При анализе для исключения по ограничению исследуются все ограничения всех "
"секций главной таблицы, поэтому при большом количестве секций время "
"планирования запросов может значительно увеличиться. Описанные выше подходы "
"работают хорошо, пока количество секций не превышает примерно ста, но не "
"пытайтесь применять их с тысячами секций."

#: ddl.xml:3167(para)
msgid "The following caveats apply to constraint exclusion: <placeholder-1/>"
msgstr ""
"Применяя исключения по ограничению, необходимо учитывать следующее: "
"<placeholder-1/>"

#: ddl.xml:3210(title)
msgid "Foreign Data"
msgstr "Сторонние данные"

#: ddl.xml:3212(indexterm)
msgid "<primary>foreign data</primary>"
msgstr "<primary>сторонние данные</primary>"

#: ddl.xml:3215(indexterm)
msgid "<primary>foreign table</primary>"
msgstr "<primary>сторонняя таблица</primary>"

#: ddl.xml:3218(indexterm)
msgid "<primary>user mapping</primary>"
msgstr "<primary>сопоставление пользователей</primary>"

#: ddl.xml:3222(para)
msgid ""
"<productname>PostgreSQL</productname> implements portions of the SQL/MED "
"specification, allowing you to access data that resides outside PostgreSQL "
"using regular SQL queries. Such data is referred to as <firstterm>foreign "
"data</firstterm>. (Note that this usage is not to be confused with foreign "
"keys, which are a type of constraint within the database.)"
msgstr ""
"<productname>PostgreSQL</productname> частично реализует спецификацию SQL/"
"MED, позволяя вам обращаться к данным, находящимся снаружи, используя "
"обычные SQL-запросы. Такие данные называются <firstterm>сторонними</"
"firstterm>."

#: ddl.xml:3230(para)
msgid ""
"Foreign data is accessed with help from a <firstterm>foreign data wrapper</"
"firstterm>. A foreign data wrapper is a library that can communicate with an "
"external data source, hiding the details of connecting to the data source "
"and obtaining data from it. There are some foreign data wrappers available "
"as <filename>contrib</filename> modules; see <xref linkend=\"contrib\"/>. "
"Other kinds of foreign data wrappers might be found as third party products. "
"If none of the existing foreign data wrappers suit your needs, you can write "
"your own; see <xref linkend=\"fdwhandler\"/>."
msgstr ""
"Сторонние данные доступны в <productname>PostgreSQL</productname> через "
"<firstterm>обёртку сторонних данных</firstterm>. Обёртка сторонних данных "
"&mdash; это библиотека, взаимодействующая с внешним источником данных и "
"скрывающая в себе внутренние особенности подключения и получения данных. "
"Несколько готовых обёрток предоставляются в виде модулей <filename>contrib</"
"filename> ; см. <xref remap=\"4\" linkend=\"contrib\"/>. Также вы можете "
"найти другие обёртки, выпускаемые как дополнительные продукты. Если ни одна "
"из существующих обёрток вас не устраивает, вы можете написать свою "
"собственную (см. <xref remap=\"4\" linkend=\"fdwhandler\"/>)."

#: ddl.xml:3242(para)
msgid ""
"To access foreign data, you need to create a <firstterm>foreign server</"
"firstterm> object, which defines how to connect to a particular external "
"data source according to the set of options used by its supporting foreign "
"data wrapper. Then you need to create one or more <firstterm>foreign tables</"
"firstterm>, which define the structure of the remote data. A foreign table "
"can be used in queries just like a normal table, but a foreign table has no "
"storage in the PostgreSQL server. Whenever it is used, "
"<productname>PostgreSQL</productname> asks the foreign data wrapper to fetch "
"data from the external source, or transmit data to the external source in "
"the case of update commands."
msgstr ""
"Чтобы обратиться к сторонним данным, вы должны создать объект "
"<firstterm>сторонний сервер</firstterm>, в котором настраивается подключение "
"к внешнему источнику данных, определяются параметры соответствующей обёртки "
"сторонних данных. Затем вы должны создать одну или несколько "
"<firstterm>сторонних таблиц</firstterm>, определив тем самым структуру "
"внешних данных. Сторонние таблицы можно использовать в запросах так же, как "
"и обычные, но их данные не хранятся на сервере PostgreSQL. При каждом "
"запросе <productname>PostgreSQL</productname> обращается к обёртке сторонних "
"данных, которая, в свою очередь, получает данные из внешнего источника или "
"передаёт их ему (в случае команд INSERT или UPDATE)."

#: ddl.xml:3255(para)
msgid ""
"Accessing remote data may require authenticating to the external data "
"source. This information can be provided by a <firstterm>user mapping</"
"firstterm>, which can provide additional data such as user names and "
"passwords based on the current <productname>PostgreSQL</productname> role."
msgstr ""
"При обращении к внешним данным удалённый источник может потребовать "
"аутентификации клиента. Соответствующие учётные данные можно предоставить с "
"помощью <firstterm>сопоставлений пользователей</firstterm>, позволяющих "
"определить в частности имена и пароли, в зависимости от текущей роли "
"пользователя <productname>PostgreSQL</productname>."

#: ddl.xml:3263(para)
msgid ""
"For additional information, see <xref linkend=\"sql-createforeigndatawrapper"
"\"/>, <xref linkend=\"sql-createserver\"/>, <xref linkend=\"sql-"
"createusermapping\"/>, <xref linkend=\"sql-createforeigntable\"/>, and <xref "
"linkend=\"sql-importforeignschema\"/>."
msgstr ""
"Дополнительную информацию вы найдёте в <xref remap=\"6\" linkend=\"sql-"
"createforeigndatawrapper\"/>, <xref remap=\"6\" linkend=\"sql-createserver\"/"
">, <xref remap=\"6\" linkend=\"sql-createusermapping\"/>, <xref remap=\"6\" "
"linkend=\"sql-createforeigntable\"/> и <xref remap=\"6\" linkend=\"sql-"
"importforeignschema\"/>."

#: ddl.xml:3274(title)
msgid "Other Database Objects"
msgstr "Другие объекты баз данных"

#: ddl.xml:3276(para)
msgid ""
"Tables are the central objects in a relational database structure, because "
"they hold your data. But they are not the only objects that exist in a "
"database. Many other kinds of objects can be created to make the use and "
"management of the data more efficient or convenient. They are not discussed "
"in this chapter, but we give you a list here so that you are aware of what "
"is possible:"
msgstr ""
"Таблицы &mdash; центральные объекты в структуре реляционной базы данных, так "
"как они содержат ваши данные. Но это не единственные объекты, которые могут "
"в ней существовать. Помимо них вы можете создавать и использовать объекты и "
"других типов, призванные сделать управление данными эффективнее и удобнее. "
"Они не обсуждаются в этой главе, но мы просто перечислим некоторые из них, "
"чтобы вы знали об их существовании:"

#: ddl.xml:3287(para)
msgid "Views"
msgstr "Представления"

#: ddl.xml:3293(para)
msgid "Functions and operators"
msgstr "Функции и операторы"

#: ddl.xml:3299(para)
msgid "Data types and domains"
msgstr "Типы данных и домены"

#: ddl.xml:3305(para)
msgid "Triggers and rewrite rules"
msgstr "Триггеры и правила перезаписи"

#: ddl.xml:3311(para)
msgid ""
"Detailed information on these topics appears in <xref linkend=\"server-"
"programming\"/>."
msgstr ""
"Подробнее соответствующие темы освещаются в <xref remap=\"6\" linkend="
"\"server-programming\"/>."

#: ddl.xml:3318(title)
msgid "Dependency Tracking"
msgstr "Отслеживание зависимостей"

#: ddl.xml:3320(indexterm)
msgid ""
"<primary>CASCADE</primary><secondary sortas=\"DROP\">with DROP</secondary>"
msgstr ""
"<primary>CASCADE</primary><secondary sortas=\"DROP\">с DROP</secondary>"

#: ddl.xml:3324(indexterm)
msgid ""
"<primary>RESTRICT</primary><secondary sortas=\"DROP\">with DROP</secondary>"
msgstr ""
"<primary>RESTRICT</primary><secondary sortas=\"DROP\">с DROP</secondary>"

#: ddl.xml:3328(para)
msgid ""
"When you create complex database structures involving many tables with "
"foreign key constraints, views, triggers, functions, etc. you implicitly "
"create a net of dependencies between the objects. For instance, a table with "
"a foreign key constraint depends on the table it references."
msgstr ""
"Когда вы создаёте сложные структуры баз данных, включающие множество таблиц "
"с внешними ключами, представлениями, триггерами, функциями и т. п., вы "
"неявно создаёте сеть зависимостей между объектами. Например, таблица с "
"ограничением внешнего ключа зависит от таблицы, на которую она ссылается."

#: ddl.xml:3336(para)
msgid ""
"To ensure the integrity of the entire database structure, "
"<productname>PostgreSQL</productname> makes sure that you cannot drop "
"objects that other objects still depend on. For example, attempting to drop "
"the products table we considered in <xref linkend=\"ddl-constraints-fk\"/>, "
"with the orders table depending on it, would result in an error message like "
"this: <screen>DROP TABLE products;\n"
"\n"
"ERROR:  cannot drop table products because other objects depend on it\n"
"DETAIL:  constraint orders_product_no_fkey on table orders depends on table "
"products\n"
"HINT:  Use DROP ... CASCADE to drop the dependent objects too.</screen> The "
"error message contains a useful hint: if you do not want to bother deleting "
"all the dependent objects individually, you can run: <screen>DROP TABLE "
"products CASCADE;</screen> and all the dependent objects will be removed. In "
"this case, it doesn't remove the orders table, it only removes the foreign "
"key constraint. (If you want to check what <command>DROP ... CASCADE</"
"command> will do, run <command>DROP</command> without <literal>CASCADE</"
"literal> and read the <literal>DETAIL</literal> output.)"
msgstr ""
"Для сохранения целостности структуры всей базы данных "
"<productname>PostgreSQL</productname> не позволяет удалять объекты, от "
"которых зависят другие. Например, попытка удалить таблицу products (мы "
"рассматривали её в <xref remap=\"6\" linkend=\"ddl-constraints-fk\"/>), от "
"которой зависит таблица orders, приведёт к ошибке примерно такого "
"содержания: <screen>DROP TABLE products;\n"
"\n"
"ОШИБКА:  удалить объект \"таблица products\" нельзя, так как от него зависят "
"другие\n"
"ПОДРОБНОСТИ:  ограничение orders_product_no_fkey в отношении \"таблица orders"
"\" зависит от объекта \"таблица products\"\n"
"ПОДСКАЗКА:  Для удаления зависимых объектов используйте DROP ... CASCADE.</"
"screen> Сообщение об ошибке даёт полезную подсказку: если вы не хотите "
"заниматься ликвидацией зависимостей по отдельности, можно выполнить: "
"<screen>DROP TABLE products CASCADE;</screen> и все зависимые объекты будут "
"удалены. В этом случае таблица orders останется, а удалено будет только её "
"ограничение внешнего ключа. (Если вы хотите проверить, что произойдёт при "
"выполнении <command>DROP ... CASCADE</command>, запустите <command>DROP</"
"command> без <literal>CASCADE</literal> и прочитайте <literal>ПОДРОБНОСТИ</"
"literal> (DETAIL).)"

#: ddl.xml:3358(para)
msgid ""
"All <command>DROP</command> commands in <productname>PostgreSQL</"
"productname> support specifying <literal>CASCADE</literal>. Of course, the "
"nature of the possible dependencies varies with the type of the object. You "
"can also write <literal>RESTRICT</literal> instead of <literal>CASCADE</"
"literal> to get the default behavior, which is to prevent the dropping of "
"objects that other objects depend on."
msgstr ""
"Все команды <command>DROP</command> в <productname>PostgreSQL</productname> "
"поддерживают указание <literal>CASCADE</literal>. Конечно, вид возможных "
"зависимостей зависит от типа объекта. Вы также можете написать "
"<literal>RESTRICT</literal> вместо <literal>CASCADE</literal>, чтобы "
"включить поведение по умолчанию, когда объект можно удалить, только если от "
"него не зависят никакие другие."

#: ddl.xml:3368(para)
msgid ""
"According to the SQL standard, specifying either <literal>RESTRICT</literal> "
"or <literal>CASCADE</literal> is required in a <command>DROP</command> "
"command. No database system actually enforces that rule, but whether the "
"default behavior is <literal>RESTRICT</literal> or <literal>CASCADE</"
"literal> varies across systems."
msgstr ""
"Стандарт SQL требует явного указания <literal>RESTRICT</literal> или "
"<literal>CASCADE</literal> в команде <command>DROP</command>. Но это "
"требование на самом деле не выполняется ни в одной СУБД, при этом одни "
"системы по умолчанию подразумевают <literal>RESTRICT</literal>, а другие — "
"<literal>CASCADE</literal>."

#: ddl.xml:3385(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',\n"
"                             'green', 'blue', 'purple');\n"
"\n"
"CREATE TABLE my_colors (color rainbow, note text);\n"
"\n"
"CREATE FUNCTION get_color_note (rainbow) RETURNS text AS\n"
"  'SELECT note FROM my_colors WHERE color = $1'\n"
"  LANGUAGE SQL;"
msgstr ""
"CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',\n"
"                             'green', 'blue', 'purple');\n"
"\n"
"CREATE TABLE my_colors (color rainbow, note text);\n"
"\n"
"CREATE FUNCTION get_color_note (rainbow) RETURNS text AS\n"
"  'SELECT note FROM my_colors WHERE color = $1'\n"
"  LANGUAGE SQL;"

#: ddl.xml:3378(para)
msgid ""
"For user-defined functions, <productname>PostgreSQL</productname> tracks "
"dependencies associated with a function's externally-visible properties, "
"such as its argument and result types, but <emphasis>not</emphasis> "
"dependencies that could only be known by examining the function body. As an "
"example, consider this situation: <placeholder-1/> (See <xref linkend="
"\"xfunc-sql\"/> for an explanation of SQL-language functions.) "
"<productname>PostgreSQL</productname> will be aware that the "
"<function>get_color_note</function> function depends on the <type>rainbow</"
"type> type: dropping the type would force dropping the function, because its "
"argument type would no longer be defined. But <productname>PostgreSQL</"
"productname> will not consider <function>get_color_note</function> to depend "
"on the <structname>my_colors</structname> table, and so will not drop the "
"function if the table is dropped. While there are disadvantages to this "
"approach, there are also benefits. The function is still valid in some sense "
"if the table is missing, though executing it would cause an error; creating "
"a new table of the same name would allow the function to work again."
msgstr ""
"Для пользовательских функций <productname>PostgreSQL</productname> "
"отслеживает зависимости, связанные с внешне видимыми свойствами функции, "
"такими как типы аргументов и результата, но <emphasis>не</emphasis> "
"зависимости, которые могут быть выявлены только при анализе тела функции. В "
"качестве примера рассмотрите следующий сценарий: <placeholder-1/> (Описание "
"функций языка SQL можно найти в <xref remap=\"6\" linkend=\"xfunc-sql\"/>.) "
"<productname>PostgreSQL</productname> будет понимать, что функция "
"<function>get_color_note</function> зависит от типа <type>rainbow</type>: "
"при удалении типа будет принудительно удалена функция, так как тип её "
"аргумента оказывается неопределённым. Но <productname>PostgreSQL</"
"productname> не будет учитывать зависимость <function>get_color_note</"
"function> от таблицы <structname>my_colors</structname> и не удалит функцию "
"при удалении таблицы. Но у этого подхода есть не только минус, но и плюс. В "
"случае отсутствия таблицы эта функция останется рабочей в некотором смысле: "
"хотя при попытке выполнить её возникнет ошибка, но при создании новой "
"таблицы с тем же именем функция снова будет работать."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: ddl.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#~ msgid ""
#~ "Foreign key constraint dependencies and serial column dependencies from "
#~ "<productname>PostgreSQL</productname> versions prior to 7.3 are "
#~ "<emphasis>not</emphasis> maintained or created during the upgrade "
#~ "process. All other dependency types will be properly created during an "
#~ "upgrade from a pre-7.3 database."
#~ msgstr ""
#~ "Зависимости внешнего ключа и столбцов последовательностей, созданные в "
#~ "версиях <productname>PostgreSQL</productname> до 7.3 <emphasis>не</"
#~ "emphasis> поддерживаются и не воссоздаются в процессе обновления. Все "
#~ "другие типы зависимостей будут созданы должным образом при обновлении "
#~ "таких старых версий."
