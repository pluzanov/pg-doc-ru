# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-09 11:02+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: plperl.xml:5(title)
msgid "PL/Perl - Perl Procedural Language"
msgstr "PL/Perl — процедурный язык Perl"

#: plperl.xml:7(indexterm)
msgid "<primary>PL/Perl</primary>"
msgstr "<primary>PL/Perl</primary>"

#: plperl.xml:11(indexterm)
msgid "<primary>Perl</primary>"
msgstr "<primary>Perl</primary>"

#: plperl.xml:15(para)
msgid ""
"PL/Perl is a loadable procedural language that enables you to write "
"<productname>PostgreSQL</productname> functions in the <ulink url=\"http://"
"www.perl.org\">Perl programming language</ulink>."
msgstr ""
"PL/Perl — это загружаемый процедурный язык, позволяющий реализовывать "
"функции <productname>PostgreSQL</productname> на <ulink url=\"http://www."
"perl.org\">языке программирования Perl</ulink>."

#: plperl.xml:21(para)
msgid ""
"The main advantage to using PL/Perl is that this allows use, within stored "
"functions, of the manyfold <quote>string munging</quote> operators and "
"functions available for Perl. Parsing complex strings might be easier using "
"Perl than it is with the string functions and control structures provided in "
"PL/pgSQL."
msgstr ""
"Основным преимуществом PL/Perl является то, что он позволяет применять в "
"сохранённых функциях множество функций и операторов <quote>перемалывания "
"строк</quote>, имеющихся в Perl. Разобрать сложные строки на языке Perl "
"может быть гораздо проще, чем используя строковые функции и управляющие "
"структуры в PL/pgSQL."

#: plperl.xml:29(para)
msgid ""
"To install PL/Perl in a particular database, use <literal>CREATE EXTENSION "
"plperl</literal>, or from the shell command line use <literal>createlang "
"plperl <replaceable>dbname</replaceable></literal>."
msgstr ""
"Чтобы установить PL/Perl в определённую базу данных, выполните команду "
"<literal>CREATE EXTENSION plperl</literal>, либо запустите в оболочке "
"системы <literal>createlang plperl <replaceable>имя_базы</replaceable></"
"literal>."

#: plperl.xml:36(para)
msgid ""
"If a language is installed into <literal>template1</literal>, all "
"subsequently created databases will have the language installed "
"automatically."
msgstr ""
"Если язык устанавливается в <literal>template1</literal>, он будет "
"автоматически установлен во все создаваемые впоследствии базы данных."

#: plperl.xml:43(para)
msgid ""
"Users of source packages must specially enable the build of PL/Perl during "
"the installation process. (Refer to <xref linkend=\"installation\"/> for "
"more information.) Users of binary packages might find PL/Perl in a separate "
"subpackage."
msgstr ""
"Пользователи, имеющие дело с исходным кодом, должны явно включить сборку PL/"
"Perl в процессе установки. (За дополнительными сведениями обратитесь к <xref "
"remap=\"3\" linkend=\"installation\"/>.) Пользователи двоичных пакетов могут "
"найти PL/Perl в отдельном модуле."

#: plperl.xml:52(title)
msgid "PL/Perl Functions and Arguments"
msgstr "Функции на PL/Perl и их аргументы"

#: plperl.xml:59(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>) RETURNS <replaceable>return-type</replaceable> AS $$\n"
"    # PL/Perl function body\n"
"$$ LANGUAGE plperl;"
msgstr ""
"CREATE FUNCTION <replaceable>имя_функции</replaceable> (<replaceable>типы-аргументов</replaceable>) RETURNS <replaceable>тип-результата</replaceable> AS $$\n"
"    # Тело функции на PL/Perl\n"
"$$ LANGUAGE plperl;"

#: plperl.xml:54(para)
msgid ""
"To create a function in the PL/Perl language, use the standard <xref linkend="
"\"sql-createfunction\"/> syntax: <placeholder-1/> The body of the function "
"is ordinary Perl code. In fact, the PL/Perl glue code wraps it inside a Perl "
"subroutine. A PL/Perl function is called in a scalar context, so it can't "
"return a list. You can return non-scalar values (arrays, records, and sets) "
"by returning a reference, as discussed below."
msgstr ""
"Чтобы создать функцию на языке PL/Perl, используйте стандартный синтаксис "
"<xref linkend=\"sql-createfunction\"/>: <placeholder-1/> Тело функции "
"содержит обычный код Perl. Фактически, код обвязки PL/Perl помещает этот код "
"в подпрограмму Perl. Функция PL/Perl вызывается в скалярном контексте, так "
"что она не может вернуть список. Не скалярные значения (массивы, записи и "
"множества) можно вернуть по ссылке, как описывается ниже."

#: plperl.xml:74(programlisting)
#, no-wrap
msgid ""
"DO $$\n"
"    # PL/Perl code\n"
"$$ LANGUAGE plperl;"
msgstr ""
"DO $$\n"
"    # Код PL/Perl\n"
"$$ LANGUAGE plperl;"

#: plperl.xml:70(para)
msgid ""
"PL/Perl also supports anonymous code blocks called with the <xref linkend="
"\"sql-do\"/> statement: <placeholder-1/> An anonymous code block receives no "
"arguments, and whatever value it might return is discarded. Otherwise it "
"behaves just like a function."
msgstr ""
"PL/Perl также поддерживает анонимные блоки кода, которые выполняются "
"оператором <xref linkend=\"sql-do\"/>: <placeholder-1/> Анонимный блок кода "
"не принимает аргументы, а любое значение, которое он мог бы вернуть, "
"отбрасывается. В остальном он работает подобно коду функции."

#: plperl.xml:83(para)
msgid ""
"The use of named nested subroutines is dangerous in Perl, especially if they "
"refer to lexical variables in the enclosing scope. Because a PL/Perl "
"function is wrapped in a subroutine, any named subroutine you place inside "
"one will be nested. In general, it is far safer to create anonymous "
"subroutines which you call via a coderef. For more information, see the "
"entries for <literal>Variable \"%s\" will not stay shared</literal> and "
"<literal>Variable \"%s\" is not available</literal> in the "
"<citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry> man "
"page, or search the Internet for <quote>perl nested named subroutine</quote>."
msgstr ""
"Использовать вложенные именованные подпрограммы в Perl опасно, особенно если "
"они обращаются к лексическим переменным в окружающей области. Так как "
"функция PL/Perl оборачивается в подпрограмму, любая именованная функция "
"внутри неё будет вложенной. Вообще гораздо безопаснее создавать анонимные "
"подпрограммы и вызывать их по ссылке на код. Дополнительную информацию вы "
"можете получить на странице руководства man "
"<citerefentry><refentrytitle>perldiag</refentrytitle></citerefentry>, в "
"описании ошибок <literal>Variable \"%s\" will not stay shared</literal> "
"(Переменная \"%s\" не останется разделяемой) и <literal>Variable \"%s\" is "
"not available</literal> (Переменная \"%s\" недоступна), либо найти в "
"Интернете по ключевым словам <quote>perl nested named subroutine</quote> "
"(perl вложенная именованная подпрограмма)."

#: plperl.xml:96(para)
msgid ""
"The syntax of the <command>CREATE FUNCTION</command> command requires the "
"function body to be written as a string constant. It is usually most "
"convenient to use dollar quoting (see <xref linkend=\"sql-syntax-dollar-"
"quoting\"/>) for the string constant. If you choose to use escape string "
"syntax <literal>E''</literal>, you must double any single quote marks "
"(<literal>'</literal>) and backslashes (<literal>\\</literal>) used in the "
"body of the function (see <xref linkend=\"sql-syntax-strings\"/>)."
msgstr ""
"Синтаксис команды <command>CREATE FUNCTION</command> требует, чтобы тело "
"функции было записано как строковая константа. Обычно для этого удобнее "
"всего заключать строковую константу в доллары (см. <xref remap=\"4\" linkend="
"\"sql-syntax-dollar-quoting\"/>). Если вы решите применять синтаксис "
"спецпоследовательностей <literal>E''</literal>, вам придётся дублировать "
"апострофы (<literal>'</literal>) и обратную косую черту (<literal>\\</"
"literal>) в теле функции (см. <xref remap=\"4\" linkend=\"sql-syntax-strings"
"\"/>)."

#: plperl.xml:107(para)
msgid ""
"Arguments and results are handled as in any other Perl subroutine: arguments "
"are passed in <varname>@_</varname>, and a result value is returned with "
"<literal>return</literal> or as the last expression evaluated in the "
"function."
msgstr ""
"Аргументы и результат обрабатываются как и в любой другой подпрограмме на "
"Perl: аргументы передаются в <varname>@_</varname>, а результирующим "
"значением будет указанное в <literal>return</literal> или полученное в "
"последнем выражении, вычисленном в функции."

#: plperl.xml:118(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$\n"
"    if ($_[0] &gt; $_[1]) { return $_[0]; }\n"
"    return $_[1];\n"
"$$ LANGUAGE plperl;"
msgstr ""
"CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$\n"
"    if ($_[0] &gt; $_[1]) { return $_[0]; }\n"
"    return $_[1];\n"
"$$ LANGUAGE plperl;"

#: plperl.xml:114(para)
msgid ""
"For example, a function returning the greater of two integer values could be "
"defined as: <placeholder-1/>"
msgstr ""
"Например, функцию, возвращающую большее из двух целых чисел, можно "
"определить так: <placeholder-1/>"

#: plperl.xml:125(para)
msgid ""
"Arguments will be converted from the database's encoding to UTF-8 for use "
"inside PL/Perl, and then converted from UTF-8 back to the database encoding "
"upon return."
msgstr ""
"Аргументы будут преобразованы из кодировки базы данных в UTF-8 для "
"использования в PL/Perl, а при выходе снова будут преобразованы из UTF-8 в "
"кодировку базы данных."

#: plperl.xml:133(indexterm)
msgid ""
"<primary>null value</primary><secondary sortas=\"PL/Perl\">in PL/Perl</"
"secondary>"
msgstr ""
"<primary>NULL-значение</primary><secondary sortas=\"PL/Perl\">в PL/Perl</"
"secondary>"

#: plperl.xml:147(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$\n"
"    my ($x, $y) = @_;\n"
"    if (not defined $x) {\n"
"        return undef if not defined $y;\n"
"        return $y;\n"
"    }\n"
"    return $x if not defined $y;\n"
"    return $x if $x &gt; $y;\n"
"    return $y;\n"
"$$ LANGUAGE plperl;"
msgstr ""
"CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$\n"
"    my ($x, $y) = @_;\n"
"    if (not defined $x) {\n"
"        return undef if not defined $y;\n"
"        return $y;\n"
"    }\n"
"    return $x if not defined $y;\n"
"    return $x if $x &gt; $y;\n"
"    return $y;\n"
"$$ LANGUAGE plperl;"

#: plperl.xml:132(para)
msgid ""
"If an SQL null value<placeholder-1/> is passed to a function, the argument "
"value will appear as <quote>undefined</quote> in Perl. The above function "
"definition will not behave very nicely with null inputs (in fact, it will "
"act as though they are zeroes). We could add <literal>STRICT</literal> to "
"the function definition to make <productname>PostgreSQL</productname> do "
"something more reasonable: if a null value is passed, the function will not "
"be called at all, but will just return a null result automatically. "
"Alternatively, we could check for undefined inputs in the function body. For "
"example, suppose that we wanted <function>perl_max</function> with one null "
"and one nonnull argument to return the nonnull argument, rather than a null "
"value: <placeholder-2/> As shown above, to return an SQL null value from a "
"PL/Perl function, return an undefined value. This can be done whether the "
"function is strict or not."
msgstr ""
"Если функции передаётся NULL-значение SQL<placeholder-1/>, значением "
"аргумента в Perl станет <quote>undefined</quote>. Показанное выше "
"определение функции будет не очень хорошо обрабатывать значения NULL (в "
"действительности они будут восприняты как нули). Мы могли бы добавить "
"указание <literal>STRICT</literal> в это определение, чтобы "
"<productname>PostgreSQL</productname> поступал немного разумнее: при "
"передаче значения NULL функция вовсе не будет вызываться, будет сразу "
"возвращён результат NULL. С другой стороны, мы могли бы проверить значения "
"undefined в теле функции. Например, предположим, что нам нужна функция "
"<function>perl_max</function>, которая с одним аргументом NULL и вторым "
"аргументом не NULL должна возвращать не NULL, а второй аргумент: "
"<placeholder-2/> Как показано выше, чтобы выдать значение SQL NULL, нужно "
"вернуть значение undefined. Это можно сделать и в строгой, и в нестрогой "
"функции."

#: plperl.xml:162(para)
msgid ""
"Anything in a function argument that is not a reference is a string, which "
"is in the standard <productname>PostgreSQL</productname> external text "
"representation for the relevant data type. In the case of ordinary numeric "
"or text types, Perl will just do the right thing and the programmer will "
"normally not have to worry about it. However, in other cases the argument "
"will need to be converted into a form that is more usable in Perl. For "
"example, the <function>decode_bytea</function> function can be used to "
"convert an argument of type <type>bytea</type> into unescaped binary."
msgstr ""
"Всё в аргументах функции, что не является ссылкой, является строкой, то есть "
"стандартным для <productname>PostgreSQL</productname> внешним текстовым "
"представлением соответствующего типа данных. В случае с обычными числовыми "
"или текстовыми типами, Perl просто воспринимает их должным образом, и "
"программист, как правило, может об этом не думать. Однако в более сложных "
"случаях может потребоваться преобразовать аргумент в форму, подходящую для "
"использования в Perl. Например, для преобразования типа <type>bytea</type> в "
"двоичное значение можно использовать функцию <function>decode_bytea</"
"function>."

#: plperl.xml:174(para)
msgid ""
"Similarly, values passed back to <productname>PostgreSQL</productname> must "
"be in the external text representation format. For example, the "
"<function>encode_bytea</function> function can be used to escape binary data "
"for a return value of type <type>bytea</type>."
msgstr ""
"Аналогично, значения, передаваемые в <productname>PostgreSQL</productname>, "
"должны быть в формате внешнего текстового представления. Например, для "
"подготовки двоичных данных к возврату в значении <type>bytea</type> можно "
"воспользоваться функцией <function>encode_bytea</function>."

#: plperl.xml:185(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE function returns_array()\n"
"RETURNS text[][] AS $$\n"
"    return [['a\"b','c,d'],['e\\\\f','g']];\n"
"$$ LANGUAGE plperl;\n"
"\n"
"select returns_array();"
msgstr ""
"CREATE OR REPLACE function returns_array()\n"
"RETURNS text[][] AS $$\n"
"    return [['a\"b','c,d'],['e\\\\f','g']];\n"
"$$ LANGUAGE plperl;\n"
"\n"
"select returns_array();"

#: plperl.xml:181(para)
msgid ""
"Perl can return <productname>PostgreSQL</productname> arrays as references "
"to Perl arrays. Here is an example: <placeholder-1/>"
msgstr ""
"Perl может возвращать массивы <productname>PostgreSQL</productname> как "
"ссылки на массивы Perl. Например, так: <placeholder-1/>"

#: plperl.xml:200(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$\n"
"    my $arg = shift;\n"
"    my $result = \"\";\n"
"    return undef if (!defined $arg);\n"
"\n"
"    # as an array reference\n"
"    for (@$arg) {\n"
"        $result .= $_;\n"
"    }\n"
"\n"
"    # also works as a string\n"
"    $result .= $arg;\n"
"\n"
"    return $result;\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT concat_array_elements(ARRAY['PL','/','Perl']);"
msgstr ""
"CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$\n"
"    my $arg = shift;\n"
"    my $result = \"\";\n"
"    return undef if (!defined $arg);\n"
"\n"
"    # в качестве ссылки на массив\n"
"    for (@$arg) {\n"
"        $result .= $_;\n"
"    }\n"
"\n"
"    # также работает со строкой\n"
"    $result .= $arg;\n"
"\n"
"    return $result;\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT concat_array_elements(ARRAY['PL','/','Perl']);"

#: plperl.xml:219(para)
msgid ""
"Multidimensional arrays are represented as references to lower-dimensional "
"arrays of references in a way common to every Perl programmer."
msgstr ""
"Многомерные массивы представляются как ссылки на массивы меньшей размерности "
"со ссылками — этот способ хорошо знаком каждому программисту на Perl."

#: plperl.xml:193(para)
msgid ""
"Perl passes <productname>PostgreSQL</productname> arrays as a blessed "
"<type>PostgreSQL::InServer::ARRAY</type> object. This object may be treated "
"as an array reference or a string, allowing for backward compatibility with "
"Perl code written for <productname>PostgreSQL</productname> versions below "
"9.1 to run. For example: <placeholder-1/>\n"
"\n"
"  <placeholder-2/>"
msgstr ""
"Perl передаёт массивы <productname>PostgreSQL</productname> как объект, "
"сопоставленный с <type>PostgreSQL::InServer::ARRAY</type>. С этим объектом "
"можно работать как со ссылкой на массив или строкой, что допускает обратную "
"совместимость с кодом Perl, написанным для <productname>PostgreSQL</"
"productname> версии до 9.1. Например: <placeholder-1/>\n"
"\n"
"  <placeholder-2/>"

#: plperl.xml:232(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE employee (\n"
"    name text,\n"
"    basesalary integer,\n"
"    bonus integer\n"
");\n"
"\n"
"CREATE FUNCTION empcomp(employee) RETURNS integer AS $$\n"
"    my ($emp) = @_;\n"
"    return $emp-&gt;{basesalary} + $emp-&gt;{bonus};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT name, empcomp(employee.*) FROM employee;"
msgstr ""
"CREATE TABLE employee (\n"
"    name text,\n"
"    basesalary integer,\n"
"    bonus integer\n"
");\n"
"\n"
"CREATE FUNCTION empcomp(employee) RETURNS integer AS $$\n"
"    my ($emp) = @_;\n"
"    return $emp-&gt;{basesalary} + $emp-&gt;{bonus};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT name, empcomp(employee.*) FROM employee;"

#: plperl.xml:227(para)
msgid ""
"Composite-type arguments are passed to the function as references to hashes. "
"The keys of the hash are the attribute names of the composite type. Here is "
"an example: <placeholder-1/>"
msgstr ""
"Аргументы составного типа передаются функции как ссылки на хеши. Ключами "
"хеша являются имена атрибутов составного типа. Например: <placeholder-1/>"

#: plperl.xml:251(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);\n"
"\n"
"CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS $$\n"
"    return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT * FROM perl_row();"
msgstr ""
"CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);\n"
"\n"
"CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS $$\n"
"    return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT * FROM perl_row();"

#: plperl.xml:246(para)
msgid ""
"A PL/Perl function can return a composite-type result using the same "
"approach: return a reference to a hash that has the required attributes. For "
"example: <placeholder-1/> Any columns in the declared result data type that "
"are not present in the hash will be returned as null values."
msgstr ""
"Функция на PL/Perl может вернуть результат составного типа, применяя тот же "
"подход: возвратить ссылку на хеш с требуемыми атрибутами. Например, так: "
"<placeholder-1/> Столбцы объявленного типа результата, отсутствующие в хеше, "
"будут возвращены как значения NULL."

#: plperl.xml:273(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION perl_set_int(int)\n"
"RETURNS SETOF INTEGER AS $$\n"
"    foreach (0..$_[0]) {\n"
"        return_next($_);\n"
"    }\n"
"    return undef;\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT * FROM perl_set_int(5);\n"
"\n"
"CREATE OR REPLACE FUNCTION perl_set()\n"
"RETURNS SETOF testrowperl AS $$\n"
"    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });\n"
"    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });\n"
"    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });\n"
"    return undef;\n"
"$$ LANGUAGE plperl;"
msgstr ""
"CREATE OR REPLACE FUNCTION perl_set_int(int)\n"
"RETURNS SETOF INTEGER AS $$\n"
"    foreach (0..$_[0]) {\n"
"        return_next($_);\n"
"    }\n"
"    return undef;\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT * FROM perl_set_int(5);\n"
"\n"
"CREATE OR REPLACE FUNCTION perl_set()\n"
"RETURNS SETOF testrowperl AS $$\n"
"    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });\n"
"    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });\n"
"    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });\n"
"    return undef;\n"
"$$ LANGUAGE plperl;"

#: plperl.xml:297(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$\n"
"    return [0..$_[0]];\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT * FROM perl_set_int(5);\n"
"\n"
"CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS $$\n"
"    return [\n"
"        { f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' },\n"
"        { f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' },\n"
"        { f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' }\n"
"    ];\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT * FROM perl_set();"
msgstr ""
"CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$\n"
"    return [0..$_[0]];\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT * FROM perl_set_int(5);\n"
"\n"
"CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS $$\n"
"    return [\n"
"        { f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' },\n"
"        { f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' },\n"
"        { f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' }\n"
"    ];\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT * FROM perl_set();"

#: plperl.xml:263(para)
msgid ""
"PL/Perl functions can also return sets of either scalar or composite types. "
"Usually you'll want to return rows one at a time, both to speed up startup "
"time and to keep from queuing up the entire result set in memory. You can do "
"this with <function>return_next</function> as illustrated below. Note that "
"after the last <function>return_next</function>, you must put either "
"<literal>return</literal> or (better) <literal>return undef</literal>. "
"<placeholder-1/> For small result sets, you can return a reference to an "
"array that contains either scalars, references to arrays, or references to "
"hashes for simple types, array types, and composite types, respectively. "
"Here are some simple examples of returning the entire result set as an array "
"reference: <placeholder-2/>"
msgstr ""
"Функции на PL/Perl могут также возвращать множества со скалярными или "
"составными типами. Обычно желательно возвращать результат по одной строке, "
"чтобы сократить время подготовки с одной стороны, и чтобы не потребовалось "
"накапливать весь набор данных в памяти, с другой. Это можно реализовать с "
"помощью функции <function>return_next</function>, как показано ниже. "
"Заметьте, что после последнего вызова <function>return_next</function>, "
"нужно поместить <literal>return</literal> или (что лучше) <literal>return "
"undef</literal>. <placeholder-1/> Для небольших наборов данных можно также "
"вернуть ссылку на массив, содержащий скаляры, ссылки на массивы, либо ссылки "
"на хеши для простых типов, типов массивов и составных типов, соответственно. "
"Ниже приведена пара простых примеров, показывающих, как возвратить весь "
"набор данных в виде ссылки на массив: <placeholder-2/>"

#: plperl.xml:314(para)
msgid ""
"If you wish to use the <literal>strict</literal> pragma with your code you "
"have a few options. For temporary global use you can <command>SET</command>\n"
"   <literal>plperl.use_strict</literal> to true. This will affect subsequent "
"compilations of <application>PL/Perl</application> functions, but not "
"functions already compiled in the current session. For permanent global use "
"you can set <literal>plperl.use_strict</literal> to true in the "
"<filename>postgresql.conf</filename> file."
msgstr ""
"Если вы хотите использовать в своём коде <literal>strict</literal>, у вас "
"есть несколько вариантов. Для временного глобального использования вы можете "
"задать для <literal>plperl.use_strict</literal> значение true командой "
"<command>SET</command>. Это повлияет на компилируемые впоследствии функции "
"<application>PL/Perl</application>, но не на функции, уже скомпилированные в "
"текущем сеансе. Для постоянного глобального использования вы можете "
"присвоить параметру <literal>plperl.use_strict</literal> значение true в "
"файле <filename>postgresql.conf</filename>."

#: plperl.xml:326(programlisting)
#, no-wrap
msgid "use strict;"
msgstr "use strict;"

#: plperl.xml:324(para)
msgid ""
"For permanent use in specific functions you can simply put: <placeholder-1/> "
"at the top of the function body."
msgstr ""
"Для постоянного использования strict в опредёлённых функциях вы можете "
"просто написать: <placeholder-1/> в начале тела этих функций."

#: plperl.xml:330(para)
msgid ""
"The <literal>feature</literal> pragma is also available to <function>use</"
"function> if your Perl is version 5.10.0 or higher."
msgstr ""
"Вы также можете использовать указания <literal>feature</literal> в "
"<function>use</function>, если используете Perl версии 5.10.0 или новее."

#: plperl.xml:337(title)
msgid "Data Values in PL/Perl"
msgstr "Значения в PL/Perl"

#: plperl.xml:339(para)
msgid ""
"The argument values supplied to a PL/Perl function's code are simply the "
"input arguments converted to text form (just as if they had been displayed "
"by a <command>SELECT</command> statement). Conversely, the <function>return</"
"function> and <function>return_next</function> commands will accept any "
"string that is acceptable input format for the function's declared return "
"type."
msgstr ""
"Значения аргументов, передаваемые в код функции PL/Perl, представляют собой "
"просто входные аргументы, преобразованные в текстовый вид (так же, как при "
"выводе оператором <command>SELECT</command>). И наоборот, команды "
"<function>return</function> и <function>return_next</function> могут принять "
"любую строку, соответствующую формату ввода для объявленного типа результата "
"функции."

#: plperl.xml:350(title)
msgid "Built-in Functions"
msgstr "Встроенные функции"

#: plperl.xml:353(title)
msgid "Database Access from PL/Perl"
msgstr "Обращение к базе данных из PL/Perl"

#: plperl.xml:355(para)
msgid ""
"Access to the database itself from your Perl function can be done via the "
"following functions:"
msgstr ""
"Обращаться к самой базе данных из кода Perl можно, используя следующие "
"функции:"

#: plperl.xml:363(function)
msgid "spi_exec_query"
msgstr "spi_exec_query"

#: plperl.xml:363(replaceable)
msgid "query"
msgstr "запрос"

#: plperl.xml:363(replaceable)
msgid "max-rows"
msgstr "макс-строк"

#: plperl.xml:363(literal)
msgid "<placeholder-1/>(<placeholder-2/> [, <placeholder-3/>])"
msgstr "<placeholder-1/>(<placeholder-2/> [, <placeholder-3/>])"

#: plperl.xml:364(indexterm)
msgid "<primary>spi_exec_query</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>spi_exec_query</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:377(programlisting)
#, no-wrap
msgid "$rv = spi_exec_query('SELECT * FROM my_table', 5);"
msgstr "$rv = spi_exec_query('SELECT * FROM my_table', 5);"

#: plperl.xml:382(programlisting)
#, no-wrap
msgid "$foo = $rv-&gt;{rows}[$i]-&gt;{my_column};"
msgstr "$foo = $rv-&gt;{rows}[$i]-&gt;{my_column};"

#: plperl.xml:385(programlisting)
#, no-wrap
msgid "$nrows = $rv-&gt;{processed}"
msgstr "$nrows = $rv-&gt;{processed}"

#: plperl.xml:369(para)
msgid ""
"<literal>spi_exec_query</literal> executes an SQL command and returns the "
"entire row set as a reference to an array of hash references. <emphasis>You "
"should only use this command when you know that the result set will be "
"relatively small.</emphasis> Here is an example of a query (<command>SELECT</"
"command> command) with the optional maximum number of rows: <placeholder-1/> "
"This returns up to 5 rows from the table <literal>my_table</literal>. If "
"<literal>my_table</literal> has a column <literal>my_column</literal>, you "
"can get that value from row <literal>$i</literal> of the result like this: "
"<placeholder-2/> The total number of rows returned from a <command>SELECT</"
"command> query can be accessed like this: <placeholder-3/>"
msgstr ""
"<literal>spi_exec_query</literal> выполняет команду SQL и возвращает весь "
"набор строк в виде ссылки на массив хешей. <emphasis>Эту функцию следует "
"использовать, только если вы знаете, что набор будет относительно небольшим."
"</emphasis> Так выглядит пример запроса (<command>SELECT</command>) с "
"дополнительно заданным максимальным числом строк: <placeholder-1/> Этот "
"запрос возвращает не больше 5 строк из таблицы <literal>my_table</literal>. "
"Если в <literal>my_table</literal> есть столбец <literal>my_column</"
"literal>, получить его значение из строки <literal>$i</literal> результата "
"можно следующим образом: <placeholder-2/> Общее число строк, возвращённых "
"запросом <command>SELECT</command>, можно получить так: <placeholder-3/>"

#: plperl.xml:390(programlisting)
#, no-wrap
msgid ""
"$query = \"INSERT INTO my_table VALUES (1, 'test')\";\n"
"$rv = spi_exec_query($query);"
msgstr ""
"$query = \"INSERT INTO my_table VALUES (1, 'test')\";\n"
"$rv = spi_exec_query($query);"

#: plperl.xml:394(programlisting)
#, no-wrap
msgid "$res = $rv-&gt;{status};"
msgstr "$res = $rv-&gt;{status};"

#: plperl.xml:396(programlisting)
#, no-wrap
msgid "$nrows = $rv-&gt;{processed};"
msgstr "$nrows = $rv-&gt;{processed};"

#: plperl.xml:388(para)
msgid ""
"Here is an example using a different command type: <placeholder-1/> You can "
"then access the command status (e.g., <literal>SPI_OK_INSERT</literal>) like "
"this: <placeholder-2/> To get the number of rows affected, do: "
"<placeholder-3/>"
msgstr ""
"Так можно выполнить команду другого типа: <placeholder-1/> Затем можно "
"получить статус команды (например, <literal>SPI_OK_INSERT</literal>) "
"следующим образом: <placeholder-2/> Чтобы получить число затронутых строк, "
"выполните: <placeholder-3/>"

#: plperl.xml:401(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test (\n"
"    i int,\n"
"    v varchar\n"
");\n"
"\n"
"INSERT INTO test (i, v) VALUES (1, 'first line');\n"
"INSERT INTO test (i, v) VALUES (2, 'second line');\n"
"INSERT INTO test (i, v) VALUES (3, 'third line');\n"
"INSERT INTO test (i, v) VALUES (4, 'immortal');\n"
"\n"
"CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$\n"
"    my $rv = spi_exec_query('select i, v from test;');\n"
"    my $status = $rv-&gt;{status};\n"
"    my $nrows = $rv-&gt;{processed};\n"
"    foreach my $rn (0 .. $nrows - 1) {\n"
"        my $row = $rv-&gt;{rows}[$rn];\n"
"        $row-&gt;{i} += 200 if defined($row-&gt;{i});\n"
"        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));\n"
"        return_next($row);\n"
"    }\n"
"    return undef;\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT * FROM test_munge();"
msgstr ""
"CREATE TABLE test (\n"
"    i int,\n"
"    v varchar\n"
");\n"
"\n"
"INSERT INTO test (i, v) VALUES (1, 'first line');\n"
"INSERT INTO test (i, v) VALUES (2, 'second line');\n"
"INSERT INTO test (i, v) VALUES (3, 'third line');\n"
"INSERT INTO test (i, v) VALUES (4, 'immortal');\n"
"\n"
"CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$\n"
"    my $rv = spi_exec_query('select i, v from test;');\n"
"    my $status = $rv-&gt;{status};\n"
"    my $nrows = $rv-&gt;{processed};\n"
"    foreach my $rn (0 .. $nrows - 1) {\n"
"        my $row = $rv-&gt;{rows}[$rn];\n"
"        $row-&gt;{i} += 200 if defined($row-&gt;{i});\n"
"        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));\n"
"        return_next($row);\n"
"    }\n"
"    return undef;\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT * FROM test_munge();"

#: plperl.xml:399(para)
msgid "Here is a complete example: <placeholder-1/>"
msgstr "Полный пример: <placeholder-1/>"

#: plperl.xml:431(replaceable) plperl.xml:502(replaceable)
msgid "command"
msgstr "команда"

#: plperl.xml:431(function)
msgid "spi_query(<placeholder-1/>)"
msgstr "spi_query(<placeholder-1/>)"

#: plperl.xml:432(indexterm)
msgid "<primary>spi_query</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>spi_query</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:437(replaceable) plperl.xml:443(replaceable)
msgid "cursor"
msgstr "cursor"

#: plperl.xml:437(function)
msgid "spi_fetchrow(<placeholder-1/>)"
msgstr "spi_fetchrow(<placeholder-1/>)"

#: plperl.xml:438(indexterm)
msgid "<primary>spi_fetchrow</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>spi_fetchrow</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:443(function)
msgid "spi_cursor_close(<placeholder-1/>)"
msgstr "spi_cursor_close(<placeholder-1/>)"

#: plperl.xml:444(indexterm)
msgid "<primary>spi_cursor_close</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>spi_cursor_close</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:458(programlisting)
#, no-wrap
msgid ""
"CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);\n"
"\n"
"CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$\n"
"    use Digest::MD5 qw(md5_hex);\n"
"    my $file = '/usr/share/dict/words';\n"
"    my $t = localtime;\n"
"    elog(NOTICE, \"opening file $file at $t\" );\n"
"    open my $fh, '&lt;', $file # ooh, it's a file access!\n"
"        or elog(ERROR, \"cannot open $file for reading: $!\");\n"
"    my @words = &lt;$fh&gt;;\n"
"    close $fh;\n"
"    $t = localtime;\n"
"    elog(NOTICE, \"closed file $file at $t\");\n"
"    chomp(@words);\n"
"    my $row;\n"
"    my $sth = spi_query(\"SELECT * FROM generate_series(1,$_[0]) AS b(a)\");\n"
"    while (defined ($row = spi_fetchrow($sth))) {\n"
"        return_next({\n"
"            the_num =&gt; $row-&gt;{a},\n"
"            the_text =&gt; md5_hex($words[rand @words])\n"
"        });\n"
"    }\n"
"    return;\n"
"$$ LANGUAGE plperlu;\n"
"\n"
"SELECT * from lotsa_md5(500);"
msgstr ""
"CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);\n"
"\n"
"CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$\n"
"    use Digest::MD5 qw(md5_hex);\n"
"    my $file = '/usr/share/dict/words';\n"
"    my $t = localtime;\n"
"    elog(NOTICE, \"opening file $file at $t\" );\n"
"    open my $fh, '&lt;', $file # здесь мы обращаемся к файлу!\n"
"        or elog(ERROR, \"cannot open $file for reading: $!\");\n"
"    my @words = &lt;$fh&gt;;\n"
"    close $fh;\n"
"    $t = localtime;\n"
"    elog(NOTICE, \"closed file $file at $t\");\n"
"    chomp(@words);\n"
"    my $row;\n"
"    my $sth = spi_query(\"SELECT * FROM generate_series(1,$_[0]) AS b(a)\");\n"
"    while (defined ($row = spi_fetchrow($sth))) {\n"
"        return_next({\n"
"            the_num =&gt; $row-&gt;{a},\n"
"            the_text =&gt; md5_hex($words[rand @words])\n"
"        });\n"
"    }\n"
"    return;\n"
"$$ LANGUAGE plperlu;\n"
"\n"
"SELECT * from lotsa_md5(500);"

#: plperl.xml:450(para)
msgid ""
"<literal>spi_query</literal> and <literal>spi_fetchrow</literal> work "
"together as a pair for row sets which might be large, or for cases where you "
"wish to return rows as they arrive. <literal>spi_fetchrow</literal> works "
"<emphasis>only</emphasis> with <literal>spi_query</literal>. The following "
"example illustrates how you use them together: <placeholder-1/>"
msgstr ""
"Функции <literal>spi_query</literal> и <literal>spi_fetchrow</literal> "
"применяются в паре, когда набор строк может быть очень большим или когда "
"нужно возвращать строки по мере их поступления. Функция "
"<literal>spi_fetchrow</literal> работает <emphasis>только</emphasis> с "
"<literal>spi_query</literal>. Следующий пример показывает, как использовать "
"их вместе: <placeholder-1/>"

#: plperl.xml:486(para)
msgid ""
"Normally, <function>spi_fetchrow</function> should be repeated until it "
"returns <literal>undef</literal>, indicating that there are no more rows to "
"read. The cursor returned by <literal>spi_query</literal> is automatically "
"freed when <function>spi_fetchrow</function> returns <literal>undef</"
"literal>. If you do not wish to read all the rows, instead call "
"<function>spi_cursor_close</function> to free the cursor. Failure to do so "
"will result in memory leaks."
msgstr ""
"Обычно вызов <function>spi_fetchrow</function> нужно повторять, пока не "
"будет получен результат <literal>undef</literal>, показывающий, что все "
"строки уже прочитаны. Курсор, возвращаемый функцией <literal>spi_query</"
"literal>, автоматически освобождается, когда <function>spi_fetchrow</"
"function> возвращает <literal>undef</literal>. Если вы не хотите читать все "
"строки, освободите курсор, выполнив <function>spi_cursor_close</function>, "
"чтобы не допустить утечки памяти."

#: plperl.xml:502(replaceable)
msgid "argument types"
msgstr "типы аргументов"

#: plperl.xml:502(function)
msgid "spi_prepare(<placeholder-1/>, <placeholder-2/>)"
msgstr "spi_prepare(<placeholder-1/>, <placeholder-2/>)"

#: plperl.xml:503(indexterm)
msgid "<primary>spi_prepare</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>spi_prepare</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:508(replaceable) plperl.xml:514(replaceable)
#: plperl.xml:520(replaceable)
msgid "plan"
msgstr "план"

#: plperl.xml:508(replaceable) plperl.xml:514(replaceable)
msgid "arguments"
msgstr "аргументы"

#: plperl.xml:508(function)
msgid "spi_query_prepared(<placeholder-1/>, <placeholder-2/>)"
msgstr "spi_query_prepared(<placeholder-1/>, <placeholder-2/>)"

#: plperl.xml:509(indexterm)
msgid "<primary>spi_query_prepared</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>spi_query_prepared</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:514(replaceable)
msgid "attributes"
msgstr "атрибуты"

#: plperl.xml:514(function)
msgid ""
"spi_exec_prepared(<placeholder-1/> [, <placeholder-2/>], <placeholder-3/>)"
msgstr ""
"spi_exec_prepared(<placeholder-1/> [, <placeholder-2/>], <placeholder-3/>)"

#: plperl.xml:515(indexterm)
msgid "<primary>spi_exec_prepared</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>spi_exec_prepared</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:520(function)
msgid "spi_freeplan(<placeholder-1/>)"
msgstr "spi_freeplan(<placeholder-1/>)"

#: plperl.xml:521(indexterm)
msgid "<primary>spi_freeplan</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>spi_freeplan</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:532(programlisting)
#, no-wrap
msgid ""
"$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2',\n"
"                                                     'INTEGER', 'TEXT');"
msgstr ""
"$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2',\n"
"                                                     'INTEGER', 'TEXT');"

#: plperl.xml:527(para)
msgid ""
"<literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>, "
"<literal>spi_exec_prepared</literal>, and <literal>spi_freeplan</literal> "
"implement the same functionality but for prepared queries. "
"<literal>spi_prepare</literal> accepts a query string with numbered argument "
"placeholders ($1, $2, etc) and a string list of argument types: "
"<placeholder-1/> Once a query plan is prepared by a call to "
"<literal>spi_prepare</literal>, the plan can be used instead of the string "
"query, either in <literal>spi_exec_prepared</literal>, where the result is "
"the same as returned by <literal>spi_exec_query</literal>, or in "
"<literal>spi_query_prepared</literal> which returns a cursor exactly as "
"<literal>spi_query</literal> does, which can be later passed to "
"<literal>spi_fetchrow</literal>. The optional second parameter to "
"<literal>spi_exec_prepared</literal> is a hash reference of attributes; the "
"only attribute currently supported is <literal>limit</literal>, which sets "
"the maximum number of rows returned by a query."
msgstr ""
"Функции <literal>spi_prepare</literal>, <literal>spi_query_prepared</"
"literal>, <literal>spi_exec_prepared</literal> и <literal>spi_freeplan</"
"literal> реализуют ту же функциональность, но для подготовленных запросов. "
"Функция <literal>spi_prepare</literal> принимает строку запроса с "
"нумерованными местозаполнителями аргументов ($1, $2 и т. д.) и список строк "
"с типами аргументов: <placeholder-1/> План запроса, подготовленный вызовом "
"<literal>spi_prepare</literal>, можно использовать вместо строки запроса "
"либо в <literal>spi_exec_prepared</literal>, возвращающей тот же результат, "
"что и <literal>spi_exec_query</literal>, либо в <literal>spi_query_prepared</"
"literal>, возвращающей курсор так же, как <literal>spi_query</literal>, "
"который затем можно передать в <literal>spi_fetchrow</literal>. В "
"необязательном втором параметре <literal>spi_exec_prepared</literal> можно "
"передать хеш с атрибутами; в настоящее время поддерживается только атрибут "
"<literal>limit</literal>, задающий максимальное число строк, которое может "
"вернуть запрос."

#: plperl.xml:546(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$\n"
"        $_SHARED{my_plan} = spi_prepare('SELECT (now() + $1)::date AS now',\n"
"                                        'INTERVAL');\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$\n"
"        return spi_exec_prepared(\n"
"                $_SHARED{my_plan},\n"
"                $_[0]\n"
"        )-&gt;{rows}-&gt;[0]-&gt;{now};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$\n"
"        spi_freeplan( $_SHARED{my_plan});\n"
"        undef $_SHARED{my_plan};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT init();\n"
"SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');\n"
"SELECT done();\n"
"\n"
"  add_time  |  add_time  |  add_time\n"
"------------+------------+------------\n"
" 2005-12-10 | 2005-12-11 | 2005-12-12"
msgstr ""
"CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$\n"
"        $_SHARED{my_plan} = spi_prepare('SELECT (now() + $1)::date AS now',\n"
"                                        'INTERVAL');\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$\n"
"        return spi_exec_prepared(\n"
"                $_SHARED{my_plan},\n"
"                $_[0]\n"
"        )-&gt;{rows}-&gt;[0]-&gt;{now};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$\n"
"        spi_freeplan( $_SHARED{my_plan});\n"
"        undef $_SHARED{my_plan};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT init();\n"
"SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');\n"
"SELECT done();\n"
"\n"
"  add_time  |  add_time  |  add_time\n"
"------------+------------+------------\n"
" 2005-12-10 | 2005-12-11 | 2005-12-12"

#: plperl.xml:542(para)
msgid ""
"The advantage of prepared queries is that is it possible to use one prepared "
"plan for more than one query execution. After the plan is not needed "
"anymore, it can be freed with <literal>spi_freeplan</literal>: "
"<placeholder-1/> Note that the parameter subscript in <literal>spi_prepare</"
"literal> is defined via $1, $2, $3, etc, so avoid declaring query strings in "
"double quotes that might easily lead to hard-to-catch bugs."
msgstr ""
"Подготовленные запросы хороши тем, что позволяют использовать единожды "
"подготовленный план для неоднократного выполнения запроса. Когда план "
"оказывается не нужен, его можно освободить, вызвав <literal>spi_freeplan</"
"literal>: <placeholder-1/> Заметьте, что параметры для <literal>spi_prepare</"
"literal> обозначаются как $1, $2, $3 и т. д., так что по возможности не "
"записывайте строки запросов в двойных кавычках, чтобы не спровоцировать "
"трудноуловимые ошибки."

#: plperl.xml:577(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address\n"
"                      FROM generate_series(1,3) AS id;\n"
"\n"
"CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$\n"
"        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts\n"
"                                      WHERE address &lt;&lt; $1', 'inet');\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$\n"
"        return spi_exec_prepared(\n"
"                $_SHARED{plan},\n"
"                {limit =&gt; 2},\n"
"                $_[0]\n"
"        )-&gt;{rows};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$\n"
"        spi_freeplan($_SHARED{plan});\n"
"        undef $_SHARED{plan};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT init_hosts_query();\n"
"SELECT query_hosts('192.168.1.0/30');\n"
"SELECT release_hosts_query();\n"
"\n"
"    query_hosts    \n"
"-----------------\n"
" (1,192.168.1.1)\n"
" (2,192.168.1.2)\n"
"(2 rows)"
msgstr ""
"CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address\n"
"                      FROM generate_series(1,3) AS id;\n"
"\n"
"CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$\n"
"        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts\n"
"                                      WHERE address &lt;&lt; $1', 'inet');\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$\n"
"        return spi_exec_prepared(\n"
"                $_SHARED{plan},\n"
"                {limit =&gt; 2},\n"
"                $_[0]\n"
"        )-&gt;{rows};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$\n"
"        spi_freeplan($_SHARED{plan});\n"
"        undef $_SHARED{plan};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT init_hosts_query();\n"
"SELECT query_hosts('192.168.1.0/30');\n"
"SELECT release_hosts_query();\n"
"\n"
"    query_hosts    \n"
"-----------------\n"
" (1,192.168.1.1)\n"
" (2,192.168.1.2)\n"
"(2 rows)"

#: plperl.xml:575(para)
msgid ""
"Another example illustrates usage of an optional parameter in "
"<literal>spi_exec_prepared</literal>: <placeholder-1/>"
msgstr ""
"Ещё один пример, иллюстрирующий использование необязательного параметра "
"<literal>spi_exec_prepared</literal>: <placeholder-1/>"

#: plperl.xml:614(title)
msgid "Utility Functions in PL/Perl"
msgstr "Вспомогательные функции в PL/Perl"

#: plperl.xml:619(replaceable)
msgid "level"
msgstr "уровень"

#: plperl.xml:619(replaceable)
msgid "msg"
msgstr "сообщение"

#: plperl.xml:619(function)
msgid "elog(<placeholder-1/>, <placeholder-2/>)"
msgstr "elog(<placeholder-1/>, <placeholder-2/>)"

#: plperl.xml:620(indexterm)
msgid "<primary>elog</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>elog</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:625(para)
msgid ""
"Emit a log or error message. Possible levels are <literal>DEBUG</literal>, "
"<literal>LOG</literal>, <literal>INFO</literal>, <literal>NOTICE</literal>, "
"<literal>WARNING</literal>, and <literal>ERROR</literal>. <literal>ERROR</"
"literal> raises an error condition; if this is not trapped by the "
"surrounding Perl code, the error propagates out to the calling query, "
"causing the current transaction or subtransaction to be aborted. This is "
"effectively the same as the Perl <literal>die</literal> command. The other "
"levels only generate messages of different priority levels. Whether messages "
"of a particular priority are reported to the client, written to the server "
"log, or both is controlled by the <xref linkend=\"guc-log-min-messages\"/> "
"and <xref linkend=\"guc-client-min-messages\"/> configuration variables. See "
"<xref linkend=\"runtime-config\"/> for more information."
msgstr ""
"Выдаёт служебное сообщение или сообщение об ошибке. Возможные уровни "
"сообщений: <literal>DEBUG</literal> (ОТЛАДКА), <literal>LOG</literal> "
"(СООБЩЕНИЕ), <literal>INFO</literal> (ИНФОРМАЦИЯ), <literal>NOTICE</literal> "
"(ЗАМЕЧАНИЕ), <literal>WARNING</literal> (ПРЕДУПРЕЖДЕНИЕ) и <literal>ERROR</"
"literal> (ОШИБКА). С уровнем <literal>ERROR</literal> выдаётся ошибка; если "
"она не перехватывается окружающим кодом Perl, она распространяется в "
"вызывающий запрос, что приводит к прерыванию текущей транзакции или "
"подтранзакции. По сути то же самое делает команда <literal>die</literal> "
"языка Perl. При использовании других уровней происходит просто вывод "
"сообщения с заданным уровнем важности. Будут ли сообщения определённого "
"уровня передаваться клиенту и/или записываться в журнал, определяется "
"конфигурационными параметрами <xref linkend=\"guc-log-min-messages\"/> и "
"<xref linkend=\"guc-client-min-messages\"/>. За дополнительными сведениями "
"обратитесь к <xref remap=\"3\" linkend=\"runtime-config\"/>."

#: plperl.xml:648(replaceable) plperl.xml:665(replaceable)
#: plperl.xml:681(replaceable) plperl.xml:698(replaceable)
#: plperl.xml:713(replaceable) plperl.xml:782(replaceable)
msgid "string"
msgstr "строка"

#: plperl.xml:648(function)
msgid "quote_literal(<placeholder-1/>)"
msgstr "quote_literal(<placeholder-1/>)"

#: plperl.xml:649(indexterm)
msgid "<primary>quote_literal</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>quote_literal</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:654(para)
msgid ""
"Return the given string suitably quoted to be used as a string literal in an "
"SQL statement string. Embedded single-quotes and backslashes are properly "
"doubled. Note that <function>quote_literal</function> returns undef on undef "
"input; if the argument might be undef, <function>quote_nullable</function> "
"is often more suitable."
msgstr ""
"Оформляет переданную строку для использования в качестве текстовой строки в "
"SQL-операторе. Включённые в неё апострофы и обратная косая черта при этом "
"дублируются. Заметьте, что <function>quote_literal</function> возвращает "
"undef, когда получает аргумент undef; если такие аргументы возможны, часто "
"лучше использовать <function>quote_nullable</function>."

#: plperl.xml:665(function)
msgid "quote_nullable(<placeholder-1/>)"
msgstr "quote_nullable(<placeholder-1/>)"

#: plperl.xml:666(indexterm)
msgid "<primary>quote_nullable</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>quote_nullable</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:671(para)
msgid ""
"Return the given string suitably quoted to be used as a string literal in an "
"SQL statement string; or, if the argument is undef, return the unquoted "
"string \"NULL\". Embedded single-quotes and backslashes are properly doubled."
msgstr ""
"Оформляет переданную строку для использования в качестве текстовой строки в "
"SQL-операторе; либо, если поступает аргумент undef, возвращает строку \"NULL"
"\" (без кавычек). Символы апостроф и обратная косая черта дублируются "
"должным образом."

#: plperl.xml:681(function)
msgid "quote_ident(<placeholder-1/>)"
msgstr "quote_ident(<placeholder-1/>)"

#: plperl.xml:682(indexterm)
msgid "<primary>quote_ident</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>quote_ident</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:687(para)
msgid ""
"Return the given string suitably quoted to be used as an identifier in an "
"SQL statement string. Quotes are added only if necessary (i.e., if the "
"string contains non-identifier characters or would be case-folded). Embedded "
"quotes are properly doubled."
msgstr ""
"Оформляет переданную строку для использования в качестве идентификатора в "
"SQL-операторе. При необходимости идентификатор заключается в кавычки "
"(например, если он содержит символы, недопустимые в открытом виде, или буквы "
"в разном регистре). Если переданная строка содержит кавычки, они дублируются."

#: plperl.xml:698(function)
msgid "decode_bytea(<placeholder-1/>)"
msgstr "decode_bytea(<placeholder-1/>)"

#: plperl.xml:699(indexterm)
msgid "<primary>decode_bytea</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>decode_bytea</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:704(para)
msgid ""
"Return the unescaped binary data represented by the contents of the given "
"string, which should be <type>bytea</type> encoded."
msgstr ""
"Возвращает неформатированные двоичные данные, представленные содержимым "
"заданной строки, которая должна быть закодирована как <type>bytea</type>."

#: plperl.xml:713(function)
msgid "encode_bytea(<placeholder-1/>)"
msgstr "encode_bytea(<placeholder-1/>)"

#: plperl.xml:714(indexterm)
msgid "<primary>encode_bytea</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>encode_bytea</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:719(para)
msgid ""
"Return the <type>bytea</type> encoded form of the binary data contents of "
"the given string."
msgstr ""
"Возвращает закодированные в виде <type>bytea</type> двоичные данные, "
"содержащиеся в переданной строке."

#: plperl.xml:727(replaceable) plperl.xml:733(replaceable)
#: plperl.xml:764(replaceable)
msgid "array"
msgstr "массив"

#: plperl.xml:727(function)
msgid "encode_array_literal(<placeholder-1/>)"
msgstr "encode_array_literal(<placeholder-1/>)"

#: plperl.xml:728(indexterm)
msgid ""
"<primary>encode_array_literal</primary><secondary>in PL/Perl</secondary>"
msgstr ""
"<primary>encode_array_literal</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:733(replaceable)
msgid "delimiter"
msgstr "разделитель"

#: plperl.xml:733(function)
msgid "encode_array_literal(<placeholder-1/>, <placeholder-2/>)"
msgstr "encode_array_literal(<placeholder-1/>, <placeholder-2/>)"

#: plperl.xml:736(para)
msgid ""
"Returns the contents of the referenced array as a string in array literal "
"format (see <xref linkend=\"arrays-input\"/>). Returns the argument value "
"unaltered if it's not a reference to an array. The delimiter used between "
"elements of the array literal defaults to \"<literal>, </literal>\" if a "
"delimiter is not specified or is undef."
msgstr ""
"Возвращает содержимое указанного массива в виде строки в формате массива "
"(см. <xref remap=\"4\" linkend=\"arrays-input\"/>). Возвращает значение "
"аргумента неизменённым, если это не ссылка не массив. Разделитель элементов "
"в строке массива по умолчанию — \"<literal>, </literal>\" (если разделитель "
"не определён или undef)."

#: plperl.xml:748(replaceable)
msgid "value"
msgstr "значение"

#: plperl.xml:748(replaceable)
msgid "typename"
msgstr "имя_типа"

#: plperl.xml:748(function)
msgid "encode_typed_literal(<placeholder-1/>, <placeholder-2/>)"
msgstr "encode_typed_literal(<placeholder-1/>, <placeholder-2/>)"

#: plperl.xml:749(indexterm)
msgid ""
"<primary>encode_typed_literal</primary><secondary>in PL/Perl</secondary>"
msgstr ""
"<primary>encode_typed_literal</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:754(para)
msgid ""
"Converts a Perl variable to the value of the data type passed as a second "
"argument and returns a string representation of this value. Correctly "
"handles nested arrays and values of composite types."
msgstr ""
"Преобразует переменную Perl в значение типа данных, указанного во втором "
"аргументе, и возвращает строковое представление этого значения. Корректно "
"обрабатывает вложенные массивы и значения составных типов."

#: plperl.xml:764(function)
msgid "encode_array_constructor(<placeholder-1/>)"
msgstr "encode_array_constructor(<placeholder-1/>)"

#: plperl.xml:765(indexterm)
msgid ""
"<primary>encode_array_constructor</primary><secondary>in PL/Perl</secondary>"
msgstr ""
"<primary>encode_array_constructor</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:770(para)
msgid ""
"Returns the contents of the referenced array as a string in array "
"constructor format (see <xref linkend=\"sql-syntax-array-constructors\"/>). "
"Individual values are quoted using <function>quote_nullable</function>. "
"Returns the argument value, quoted using <function>quote_nullable</"
"function>, if it's not a reference to an array."
msgstr ""
"Возвращает содержимое переданного массива в виде строки в формате "
"конструктора массива (см. <xref remap=\"4\" linkend=\"sql-syntax-array-"
"constructors\"/>). Отдельные значения заключаются в кавычки функцией "
"<function>quote_nullable</function>. Возвращает значение аргумента, "
"заключённое в кавычки функцией <function>quote_nullable</function>, если "
"аргумент — не ссылка на массив."

#: plperl.xml:782(function)
msgid "looks_like_number(<placeholder-1/>)"
msgstr "looks_like_number(<placeholder-1/>)"

#: plperl.xml:783(indexterm)
msgid "<primary>looks_like_number</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>looks_like_number</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:788(para)
msgid ""
"Returns a true value if the content of the given string looks like a number, "
"according to Perl, returns false otherwise. Returns undef if the argument is "
"undef. Leading and trailing space is ignored. <literal>Inf</literal> and "
"<literal>Infinity</literal> are regarded as numbers."
msgstr ""
"Возвращает значение true, если содержимое переданной строки похоже на число, "
"по правилам Perl, и false в обратном случае. Возвращает undef для аргумента "
"undef. Ведущие и замыкающие пробелы игнорируются. Строки <literal>Inf</"
"literal> и <literal>Infinity</literal> считаются представляющими число "
"(бесконечность)."

#: plperl.xml:799(replaceable)
msgid "argument"
msgstr "аргумент"

#: plperl.xml:799(function)
msgid "is_array_ref(<placeholder-1/>)"
msgstr "is_array_ref(<placeholder-1/>)"

#: plperl.xml:800(indexterm)
msgid "<primary>is_array_ref</primary><secondary>in PL/Perl</secondary>"
msgstr "<primary>is_array_ref</primary><secondary>в PL/Perl</secondary>"

#: plperl.xml:805(para)
msgid ""
"Returns a true value if the given argument may be treated as an array "
"reference, that is, if ref of the argument is <literal>ARRAY</literal> or "
"<literal>PostgreSQL::InServer::ARRAY</literal>. Returns false otherwise."
msgstr ""
"Возвращает значение true, если переданный аргумент можно воспринять как "
"ссылку на массив, то есть это ссылка на <literal>ARRAY</literal> или "
"<literal>PostgreSQL::InServer::ARRAY</literal>. В противном случае "
"возвращает false."

#: plperl.xml:818(title)
msgid "Global Values in PL/Perl"
msgstr "Глобальные значения в PL/Perl"

#: plperl.xml:820(para)
msgid ""
"You can use the global hash <varname>%_SHARED</varname> to store data, "
"including code references, between function calls for the lifetime of the "
"current session."
msgstr ""
"Вы можете использовать для хранения данных, включая ссылки на код, "
"глобальный хеш <varname>%_SHARED</varname>. Эти данные будут сохраняться "
"между вызовами функции на протяжении всего текущего сеанса."

#: plperl.xml:828(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$\n"
"    if ($_SHARED{$_[0]} = $_[1]) {\n"
"        return 'ok';\n"
"    } else {\n"
"        return \"cannot set shared variable $_[0] to $_[1]\";\n"
"    }\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$\n"
"    return $_SHARED{$_[0]};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT set_var('sample', 'Hello, PL/Perl!  How''s tricks?');\n"
"SELECT get_var('sample');"
msgstr ""
"CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$\n"
"    if ($_SHARED{$_[0]} = $_[1]) {\n"
"        return 'ok';\n"
"    } else {\n"
"        return \"cannot set shared variable $_[0] to $_[1]\";\n"
"    }\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$\n"
"    return $_SHARED{$_[0]};\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT set_var('sample', 'Hello, PL/Perl!  How''s tricks?');\n"
"SELECT get_var('sample');"

#: plperl.xml:826(para)
msgid "Here is a simple example for shared data: <placeholder-1/>"
msgstr "Простой пример работы с разделяемыми данными: <placeholder-1/>"

#: plperl.xml:847(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS $$\n"
"    $_SHARED{myquote} = sub {\n"
"        my $arg = shift;\n"
"        $arg =~ s/(['\\\\])/\\\\$1/g;\n"
"        return \"'$arg'\";\n"
"    };\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT myfuncs(); /* initializes the function */\n"
"\n"
"/* Set up a function that uses the quote function */\n"
"\n"
"CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS $$\n"
"    my $text_to_quote = shift;\n"
"    my $qfunc = $_SHARED{myquote};\n"
"    return &amp;$qfunc($text_to_quote);\n"
"$$ LANGUAGE plperl;"
msgstr ""
"CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS $$\n"
"    $_SHARED{myquote} = sub {\n"
"        my $arg = shift;\n"
"        $arg =~ s/(['\\\\])/\\\\$1/g;\n"
"        return \"'$arg'\";\n"
"    };\n"
"$$ LANGUAGE plperl;\n"
"\n"
"SELECT myfuncs(); /* инициализация функции */\n"
"\n"
"/* Определение функции, использующей функцию заключения в кавычки */\n"
"\n"
"CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS $$\n"
"    my $text_to_quote = shift;\n"
"    my $qfunc = $_SHARED{myquote};\n"
"    return &amp;$qfunc($text_to_quote);\n"
"$$ LANGUAGE plperl;"

#: plperl.xml:844(para)
msgid ""
"Here is a slightly more complicated example using a code reference: "
"<placeholder-1/> (You could have replaced the above with the one-liner "
"<literal>return $_SHARED{myquote}-&gt;($_[0]);</literal> at the expense of "
"readability.)"
msgstr ""
"Это чуть более сложный пример, в котором используется ссылка на код: "
"<placeholder-1/> (Код выше можно было бы упростить до однострочной команды "
"<literal>return $_SHARED{myquote}-&gt;($_[0]);</literal> в ущерб читаемости.)"

#: plperl.xml:870(para)
msgid ""
"For security reasons, PL/Perl executes functions called by any one SQL role "
"in a separate Perl interpreter for that role. This prevents accidental or "
"malicious interference by one user with the behavior of another user's PL/"
"Perl functions. Each such interpreter has its own value of the <varname>"
"%_SHARED</varname> variable and other global state. Thus, two PL/Perl "
"functions will share the same value of <varname>%_SHARED</varname> if and "
"only if they are executed by the same SQL role. In an application wherein a "
"single session executes code under multiple SQL roles (via <literal>SECURITY "
"DEFINER</literal> functions, use of <command>SET ROLE</command>, etc) you "
"may need to take explicit steps to ensure that PL/Perl functions can share "
"data via <varname>%_SHARED</varname>. To do that, make sure that functions "
"that should communicate are owned by the same user, and mark them "
"<literal>SECURITY DEFINER</literal>. You must of course take care that such "
"functions can't be used to do anything unintended."
msgstr ""
"По соображениям безопасности, PL/Perl выполняет функции, вызываемые "
"некоторой ролью SQL, в отдельном интерпретаторе Perl, выделенном для этой "
"роли. Это предотвращает случайное или злонамеренное влияние одного "
"пользователя на поведение функций PL/Perl другого пользователя. В каждом "
"интерпретаторе будет своё значение переменной <varname>%_SHARED</varname> и "
"собственное глобальное состояние. Таким образом, две функции PL/Perl будут "
"разделять одно значение <varname>%_SHARED</varname>, только если они "
"выполняются одной ролью SQL. В приложении, выполняющем код в одном сеансе с "
"разными ролями SQL (вызывающем функции <literal>SECURITY DEFINER</literal>, "
"использующем команду <command>SET ROLE</command> и т. д.) может понадобиться "
"явно предпринять дополнительные меры, чтобы функции на PL/Perl могли "
"разделять данные через <varname>%_SHARED</varname>. Для этого сначала "
"установите для функций, которые должны взаимодействовать, одного владельца, "
"а затем задайте для них свойство <literal>SECURITY DEFINER</literal>. "
"Разумеется, при этом нужно позаботиться о том, чтобы эти функции не могли "
"сделать ничего непредусмотренного."

#: plperl.xml:889(title)
msgid "Trusted and Untrusted PL/Perl"
msgstr "Доверенный и недоверенный PL/Perl"

#: plperl.xml:891(indexterm)
msgid "<primary>trusted</primary><secondary>PL/Perl</secondary>"
msgstr "<primary>доверенный</primary><secondary>PL/Perl</secondary>"

#: plperl.xml:895(para)
msgid ""
"Normally, PL/Perl is installed as a <quote>trusted</quote> programming "
"language named <literal>plperl</literal>. In this setup, certain Perl "
"operations are disabled to preserve security. In general, the operations "
"that are restricted are those that interact with the environment. This "
"includes file handle operations, <literal>require</literal>, and "
"<literal>use</literal> (for external modules). There is no way to access "
"internals of the database server process or to gain OS-level access with the "
"permissions of the server process, as a C function can do. Thus, any "
"unprivileged database user can be permitted to use this language."
msgstr ""
"Обычно PL/Perl устанавливается в базу данных как <quote>доверенный</quote> "
"язык программирования с именем <literal>plperl</literal>. При этом в целях "
"безопасности определённые операции в Perl запрещаются. Вообще говоря, "
"запрещаются все операции, взаимодействующие с окружением. В том числе, это "
"операции с файлами, <literal>require</literal> и <literal>use</literal> (для "
"внешних модулей). Поэтому функции на PL/Perl, в отличие от функций на C, "
"никаким образом не могут взаимодействовать с внутренними механизмами сервера "
"баз данных или обращаться к операционной системе с правами серверного "
"процесса. Вследствие этого, использовать этот язык можно разрешить любому "
"непривилегированному пользователю баз данных."

#: plperl.xml:912(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION badfunc() RETURNS integer AS $$\n"
"    my $tmpfile = \"/tmp/badfile\";\n"
"    open my $fh, '&gt;', $tmpfile\n"
"        or elog(ERROR, qq{could not open the file \"$tmpfile\": $!});\n"
"    print $fh \"Testing writing to a file\\n\";\n"
"    close $fh or elog(ERROR, qq{could not close the file \"$tmpfile\": $!});\n"
"    return 1;\n"
"$$ LANGUAGE plperl;"
msgstr ""
"CREATE FUNCTION badfunc() RETURNS integer AS $$\n"
"    my $tmpfile = \"/tmp/badfile\";\n"
"    open my $fh, '&gt;', $tmpfile\n"
"        or elog(ERROR, qq{could not open the file \"$tmpfile\": $!});\n"
"    print $fh \"Testing writing to a file\\n\";\n"
"    close $fh or elog(ERROR, qq{could not close the file \"$tmpfile\": $!});\n"
"    return 1;\n"
"$$ LANGUAGE plperl;"

#: plperl.xml:909(para)
msgid ""
"Here is an example of a function that will not work because file system "
"operations are not allowed for security reasons: <placeholder-1/> The "
"creation of this function will fail as its use of a forbidden operation will "
"be caught by the validator."
msgstr ""
"В следующем примере показана функция, которая не будет работать, потому что "
"операции с файловой системы запрещены по соображениям безопасности: "
"<placeholder-1/> Создать эту функцию не удастся, так как при проверке её "
"правильности будет обнаружено использование запрещённого оператора."

#: plperl.xml:929(indexterm)
msgid "<primary>PL/PerlU</primary>"
msgstr "<primary>PL/PerlU</primary>"

#: plperl.xml:924(para)
msgid ""
"Sometimes it is desirable to write Perl functions that are not restricted. "
"For example, one might want a Perl function that sends mail. To handle these "
"cases, PL/Perl can also be installed as an <quote>untrusted</quote> language "
"(usually called <application>PL/PerlU</application><placeholder-1/>). In "
"this case the full Perl language is available. When installing the language, "
"the language name <literal>plperlu</literal> will select the untrusted PL/"
"Perl variant."
msgstr ""
"Иногда возникает желание написать на Perl код, функциональность которого не "
"будет ограничиваться. Например, может потребоваться функция на Perl, которая "
"будет посылать почту. Для таких потребностей PL/Perl также можно установить "
"как <quote>недоверенный</quote> язык (обычно его называют <application>PL/"
"PerlU</application><placeholder-1/>). В этом случае будут доступны все "
"возможности языка Perl. Устанавливая язык, укажите имя <literal>plperlu</"
"literal>, чтобы выбрать недоверенную вариацию PL/Perl."

#: plperl.xml:935(para)
msgid ""
"The writer of a <application>PL/PerlU</application> function must take care "
"that the function cannot be used to do anything unwanted, since it will be "
"able to do anything that could be done by a user logged in as the database "
"administrator. Note that the database system allows only database superusers "
"to create functions in untrusted languages."
msgstr ""
"Автор функции на <application>PL/PerlU</application> должен позаботиться о "
"том, чтобы эту функцию нельзя было использовать не по назначению, так как "
"она может делать всё, что может пользователь с правами администратора баз "
"данных. Заметьте, что СУБД позволяет создавать функции на недоверенных "
"языках только суперпользователям базы данных."

#: plperl.xml:943(para)
msgid ""
"If the above function was created by a superuser using the language "
"<literal>plperlu</literal>, execution would succeed."
msgstr ""
"Если показанная выше функция будет создана суперпользователем, и при этом "
"будет выбран язык <literal>plperlu</literal>, она выполнится успешно."

#: plperl.xml:948(para)
msgid ""
"In the same way, anonymous code blocks written in Perl can use restricted "
"operations if the language is specified as <literal>plperlu</literal> rather "
"than <literal>plperl</literal>, but the caller must be a superuser."
msgstr ""
"Таким же образом, в анонимном блоке кода на Perl разрешены абсолютно любые "
"операции, если в качестве языка вместо <literal>plperl</literal> выбирается "
"<literal>plperlu</literal>, но выполнять этот код должен суперпользователь."

#: plperl.xml:956(para)
msgid ""
"While <application>PL/Perl</application> functions run in a separate Perl "
"interpreter for each SQL role, all <application>PL/PerlU</application> "
"functions executed in a given session run in a single Perl interpreter "
"(which is not any of the ones used for <application>PL/Perl</application> "
"functions). This allows <application>PL/PerlU</application> functions to "
"share data freely, but no communication can occur between <application>PL/"
"Perl</application> and <application>PL/PerlU</application> functions."
msgstr ""
"Тогда как функции на <application>PL/Perl</application> исполняются "
"отдельными интерпретаторами Perl для каждой роли SQL, все функции на "
"<application>PL/PerlU</application>, вызываемые в рамках сеанса, исполняются "
"в одном интерпретаторе Perl (отличном от тех, что исполняют функции "
"<application>PL/Perl</application>). Благодаря этому, функции "
"<application>PL/PerlU</application> могут свободно разделять общие данные, "
"но между функциями <application>PL/Perl</application> и <application>PL/"
"PerlU</application> взаимодействие невозможно."

#: plperl.xml:968(para)
msgid ""
"Perl cannot support multiple interpreters within one process unless it was "
"built with the appropriate flags, namely either <literal>usemultiplicity</"
"literal> or <literal>useithreads</literal>. (<literal>usemultiplicity</"
"literal> is preferred unless you actually need to use threads. For more "
"details, see the <citerefentry><refentrytitle>perlembed</refentrytitle></"
"citerefentry> man page.) If <application>PL/Perl</application> is used with "
"a copy of Perl that was not built this way, then it is only possible to have "
"one Perl interpreter per session, and so any one session can only execute "
"either <application>PL/PerlU</application> functions, or <application>PL/"
"Perl</application> functions that are all called by the same SQL role."
msgstr ""
"Perl поддерживает работу нескольких интерпретаторов в одном процессе, только "
"если он был собран с нужными флагами, а именно, с флагом "
"<literal>usemultiplicity</literal> или с флагом <literal>useithreads</"
"literal>. (В отсутствие веских причин использовать потоки предпочтительным "
"является вариант <literal>usemultiplicity</literal>. Дополнительную "
"информацию вы можете получить на странице man "
"<citerefentry><refentrytitle>perlembed</refentrytitle></citerefentry>.) При "
"использовании <application>PL/Perl</application> с версией Perl, собранной "
"без этих флагов, в рамках сеанса можно будет запустить только один "
"интерпретатор Perl, так что в сеансе будет возможно выполнять либо функции "
"<application>PL/PerlU</application>, либо функции <application>PL/Perl</"
"application> (и вызывать их должна одна роль SQL)."

#: plperl.xml:986(title)
msgid "PL/Perl Triggers"
msgstr "Триггеры на PL/Perl"

#: plperl.xml:997(literal)
msgid "$_TD-&gt;{new}{foo}"
msgstr "$_TD-&gt;{new}{foo}"

#: plperl.xml:999(para)
msgid "<literal>NEW</literal> value of column <literal>foo</literal>"
msgstr "Новое значение столбца <literal>foo</literal>"

#: plperl.xml:1006(literal)
msgid "$_TD-&gt;{old}{foo}"
msgstr "$_TD-&gt;{old}{foo}"

#: plperl.xml:1008(para)
msgid "<literal>OLD</literal> value of column <literal>foo</literal>"
msgstr "Старое значение столбца <literal>foo</literal>"

#: plperl.xml:1015(literal)
msgid "$_TD-&gt;{name}"
msgstr "$_TD-&gt;{name}"

#: plperl.xml:1017(para)
msgid "Name of the trigger being called"
msgstr "Имя вызываемого триггера"

#: plperl.xml:1024(literal) plperl.xml:1183(literal)
msgid "$_TD-&gt;{event}"
msgstr "$_TD-&gt;{event}"

#: plperl.xml:1026(para)
msgid ""
"Trigger event: <literal>INSERT</literal>, <literal>UPDATE</literal>, "
"<literal>DELETE</literal>, <literal>TRUNCATE</literal>, or <literal>UNKNOWN</"
"literal>"
msgstr ""
"Событие триггера: <literal>INSERT</literal>, <literal>UPDATE</literal>, "
"<literal>DELETE</literal>, <literal>TRUNCATE</literal> или <literal>UNKNOWN</"
"literal>"

#: plperl.xml:1034(literal)
msgid "$_TD-&gt;{when}"
msgstr "$_TD-&gt;{when}"

#: plperl.xml:1036(para)
msgid ""
"When the trigger was called: <literal>BEFORE</literal>, <literal>AFTER</"
"literal>, <literal>INSTEAD OF</literal>, or <literal>UNKNOWN</literal>"
msgstr ""
"Когда вызывается триггер: <literal>BEFORE</literal> (ДО), <literal>AFTER</"
"literal> (ПОСЛЕ), <literal>INSTEAD OF</literal> (ВМЕСТО) или "
"<literal>UNKNOWN</literal> (НЕИЗВЕСТНО)"

#: plperl.xml:1045(literal)
msgid "$_TD-&gt;{level}"
msgstr "$_TD-&gt;{level}"

#: plperl.xml:1047(para)
msgid ""
"The trigger level: <literal>ROW</literal>, <literal>STATEMENT</literal>, or "
"<literal>UNKNOWN</literal>"
msgstr ""
"Уровень триггера: <literal>ROW</literal> (СТРОКА), <literal>STATEMENT</"
"literal> (ОПЕРАТОР) или <literal>UNKNOWN</literal> (НЕИЗВЕСТНЫЙ)"

#: plperl.xml:1054(literal)
msgid "$_TD-&gt;{relid}"
msgstr "$_TD-&gt;{relid}"

#: plperl.xml:1056(para)
msgid "OID of the table on which the trigger fired"
msgstr "OID таблицы, для которой сработал триггер"

#: plperl.xml:1063(literal)
msgid "$_TD-&gt;{table_name}"
msgstr "$_TD-&gt;{table_name}"

#: plperl.xml:1065(para)
msgid "Name of the table on which the trigger fired"
msgstr "Имя таблицы, для которой сработал триггер"

#: plperl.xml:1072(literal)
msgid "$_TD-&gt;{relname}"
msgstr "$_TD-&gt;{relname}"

#: plperl.xml:1074(para)
msgid ""
"Name of the table on which the trigger fired. This has been deprecated, and "
"could be removed in a future release. Please use $_TD-&gt;{table_name} "
"instead."
msgstr ""
"Имя таблицы, для которой сработал триггер. Это обращение устарело и может "
"быть ликвидировано в будущем выпуске. Используйте вместо него $_TD-&gt;"
"{table_name}."

#: plperl.xml:1083(literal)
msgid "$_TD-&gt;{table_schema}"
msgstr "$_TD-&gt;{table_schema}"

#: plperl.xml:1085(para)
msgid "Name of the schema in which the table on which the trigger fired, is"
msgstr "Имя схемы, содержащей таблицу, для которой сработал триггер"

#: plperl.xml:1092(literal)
msgid "$_TD-&gt;{argc}"
msgstr "$_TD-&gt;{argc}"

#: plperl.xml:1094(para)
msgid "Number of arguments of the trigger function"
msgstr "Число аргументов в триггерной функции"

#: plperl.xml:1101(literal)
msgid "@{$_TD-&gt;{args}}"
msgstr "@{$_TD-&gt;{args}}"

#: plperl.xml:1103(para)
msgid ""
"Arguments of the trigger function. Does not exist if <literal>$_TD-&gt;{argc}"
"</literal> is 0."
msgstr ""
"Аргументы триггерной функции. Не определено, если <literal>$_TD-&gt;{argc}</"
"literal> равно 0."

#: plperl.xml:988(para)
msgid ""
"PL/Perl can be used to write trigger functions. In a trigger function, the "
"hash reference <varname>$_TD</varname> contains information about the "
"current trigger event. <varname>$_TD</varname> is a global variable, which "
"gets a separate local value for each invocation of the trigger. The fields "
"of the <varname>$_TD</varname> hash reference are: <placeholder-1/>"
msgstr ""
"PL/Perl можно использовать для написания триггерных функций. В триггерной "
"функции хеш-массив <varname>$_TD</varname> содержит информацию о "
"произошедшем событии триггера. <varname>$_TD</varname> — глобальная "
"переменная, которая получает нужное локальное значение при каждом вызове "
"триггера. Хеш-массив <varname>$_TD</varname> содержит следующие поля: "
"<placeholder-1/>"

#: plperl.xml:1117(literal)
msgid "return;"
msgstr "return;"

#: plperl.xml:1119(para)
msgid "Execute the operation"
msgstr "Выполнить операцию"

#: plperl.xml:1126(literal)
msgid "\"SKIP\""
msgstr "\"SKIP\""

#: plperl.xml:1128(para)
msgid "Don't execute the operation"
msgstr "Не выполнять операцию"

#: plperl.xml:1135(literal)
msgid "\"MODIFY\""
msgstr "\"MODIFY\""

#: plperl.xml:1137(para)
msgid ""
"Indicates that the <literal>NEW</literal> row was modified by the trigger "
"function"
msgstr ""
"Указывает, что строка <literal>NEW</literal> была изменена триггерной "
"функцией"

#: plperl.xml:1112(para)
msgid "Row-level triggers can return one of the following: <placeholder-1/>"
msgstr ""
"В триггерах уровня строки возможны следующие варианты возврата: "
"<placeholder-1/>"

#: plperl.xml:1149(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE test (\n"
"    i int,\n"
"    v varchar\n"
");\n"
"\n"
"CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$\n"
"    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {\n"
"        return \"SKIP\";    # skip INSERT/UPDATE command\n"
"    } elsif ($_TD-&gt;{new}{v} ne \"immortal\") {\n"
"        $_TD-&gt;{new}{v} .= \"(modified by trigger)\";\n"
"        return \"MODIFY\";  # modify row and execute INSERT/UPDATE command\n"
"    } else {\n"
"        return;           # execute INSERT/UPDATE command\n"
"    }\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE TRIGGER test_valid_id_trig\n"
"    BEFORE INSERT OR UPDATE ON test\n"
"    FOR EACH ROW EXECUTE PROCEDURE valid_id();"
msgstr ""
"CREATE TABLE test (\n"
"    i int,\n"
"    v varchar\n"
");\n"
"\n"
"CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$\n"
"    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {\n"
"        return \"SKIP\";    # пропустить команду INSERT/UPDATE\n"
"    } elsif ($_TD-&gt;{new}{v} ne \"immortal\") {\n"
"        $_TD-&gt;{new}{v} .= \"(modified by trigger)\";\n"
"        return \"MODIFY\";  # изменить строку и выполнить команду INSERT/UPDATE\n"
"    } else {\n"
"        return;           # выполнить команду INSERT/UPDATE\n"
"    }\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE TRIGGER test_valid_id_trig\n"
"    BEFORE INSERT OR UPDATE ON test\n"
"    FOR EACH ROW EXECUTE PROCEDURE valid_id();"

#: plperl.xml:1146(para)
msgid ""
"Here is an example of a trigger function, illustrating some of the above: "
"<placeholder-1/>"
msgstr ""
"Следующий пример триггерной функции иллюстрирует описанные выше варианты: "
"<placeholder-1/>"

#: plperl.xml:1172(title)
msgid "PL/Perl Event Triggers"
msgstr "Событийные триггеры на PL/Perl"

#: plperl.xml:1185(para)
msgid "The name of the event the trigger is fired for."
msgstr "Имя события, при котором срабатывает этот триггер."

#: plperl.xml:1192(literal)
msgid "$_TD-&gt;{tag}"
msgstr "$_TD-&gt;{tag}"

#: plperl.xml:1194(para)
msgid "The command tag for which the trigger is fired."
msgstr "Тег команды, для которой срабатывает этот триггер."

#: plperl.xml:1174(para)
msgid ""
"PL/Perl can be used to write event trigger functions. In an event trigger "
"function, the hash reference <varname>$_TD</varname> contains information "
"about the current trigger event. <varname>$_TD</varname> is a global "
"variable, which gets a separate local value for each invocation of the "
"trigger. The fields of the <varname>$_TD</varname> hash reference are: "
"<placeholder-1/>"
msgstr ""
"PL/Perl можно использовать для написания функций событийных триггеров. В "
"функции событийного триггера хеш-массив <varname>$_TD</varname> содержит "
"информацию о произошедшем событии триггера. <varname>$_TD</varname> — "
"глобальная переменная, которая получает нужное локальное значение при каждом "
"вызове триггера. Хеш-массив <varname>$_TD</varname> содержит следующие поля: "
"<placeholder-1/>"

#: plperl.xml:1202(para)
msgid "The return value of the trigger procedure is ignored."
msgstr "Возвращаемое значение триггерной процедуры игнорируется."

#: plperl.xml:1209(programlisting)
#, no-wrap
msgid ""
"CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS $$\n"
"  elog(NOTICE, \"perlsnitch: \" . $_TD-&gt;{event} . \" \" . $_TD-&gt;{tag} . \" \");\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE EVENT TRIGGER perl_a_snitch\n"
"    ON ddl_command_start\n"
"    EXECUTE PROCEDURE perlsnitch();"
msgstr ""
"CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS $$\n"
"  elog(NOTICE, \"perlsnitch: \" . $_TD-&gt;{event} . \" \" . $_TD-&gt;{tag} . \" \");\n"
"$$ LANGUAGE plperl;\n"
"\n"
"CREATE EVENT TRIGGER perl_a_snitch\n"
"    ON ddl_command_start\n"
"    EXECUTE PROCEDURE perlsnitch();"

#: plperl.xml:1206(para)
msgid ""
"Here is an example of an event trigger function, illustrating some of the "
"above: <placeholder-1/>"
msgstr ""
"Следующий пример функции событийного триггера иллюстрирует описанное выше: "
"<placeholder-1/>"

#: plperl.xml:1220(title)
msgid "PL/Perl Under the Hood"
msgstr "Внутренние особенности PL/Perl"

#: plperl.xml:1223(title)
msgid "Configuration"
msgstr "Конфигурирование"

#: plperl.xml:1225(para)
msgid ""
"This section lists configuration parameters that affect <application>PL/"
"Perl</application>."
msgstr ""
"В этом разделе описываются параметры конфигурации, влияющие на работу "
"<application>PL/Perl</application>."

#: plperl.xml:1234(indexterm)
msgid ""
"<primary><varname>plperl.on_init</varname> configuration parameter</primary>"
msgstr ""
"<primary>параметр конфигурации <varname>plperl.on_init</varname></primary>"

#: plperl.xml:1232(term)
msgid ""
"<varname>plperl.on_init</varname> (<type>string</type>) <placeholder-1/>"
msgstr ""
"<varname>plperl.on_init</varname> (<type>string</type>) <placeholder-1/>"

#: plperl.xml:1239(para)
msgid ""
"Specifies Perl code to be executed when a Perl interpreter is first "
"initialized, before it is specialized for use by <literal>plperl</literal> "
"or <literal>plperlu</literal>. The SPI functions are not available when this "
"code is executed. If the code fails with an error it will abort the "
"initialization of the interpreter and propagate out to the calling query, "
"causing the current transaction or subtransaction to be aborted."
msgstr ""
"Задаёт код Perl, который будет выполняться при первой инициализации "
"интерпретатора Perl, до того, как он получает специализацию <literal>plperl</"
"literal> или <literal>plperlu</literal>. Когда этот код выполняется, функции "
"SPI ещё не доступны. Если выполнение кода завершается ошибкой, инициализация "
"интерпретатора прерывается и ошибка распространяется в вызывающий запрос, в "
"результате чего текущая транзакция или подтранзакция прерывается."

#: plperl.xml:1252(programlisting)
#, no-wrap
msgid ""
"plperl.on_init = 'require \"plperlinit.pl\"'\n"
"plperl.on_init = 'use lib \"/my/app\"; use MyApp::PgInit;'"
msgstr ""
"plperl.on_init = 'require \"plperlinit.pl\"'\n"
"plperl.on_init = 'use lib \"/my/app\"; use MyApp::PgInit;'"

#: plperl.xml:1248(para)
msgid ""
"The Perl code is limited to a single string. Longer code can be placed into "
"a module and loaded by the <literal>on_init</literal> string. Examples: "
"<placeholder-1/>"
msgstr ""
"Размер этого кода ограничивается одной строкой. Более объёмный код можно "
"поместить в модуль и загрузить этот модуль в строке <literal>on_init</"
"literal>. Например: <placeholder-1/>"

#: plperl.xml:1259(programlisting)
#, no-wrap
msgid "DO 'elog(WARNING, join \", \", sort keys %INC)' LANGUAGE plperl;"
msgstr "DO 'elog(WARNING, join \", \", sort keys %INC)' LANGUAGE plperl;"

#: plperl.xml:1255(para)
msgid ""
"Any modules loaded by <literal>plperl.on_init</literal>, either directly or "
"indirectly, will be available for use by <literal>plperl</literal>. This may "
"create a security risk. To see what modules have been loaded you can use: "
"<placeholder-1/>"
msgstr ""
"Любые модули, загруженные в <literal>plperl.on_init</literal>, явно или "
"неявно, будут доступны для использования в коде на языке <literal>plperl</"
"literal>. Это может создать угрозу безопасности. Чтобы определить, какие "
"модули были загружены, можно выполнить: <placeholder-1/>"

#: plperl.xml:1261(para)
msgid ""
"Initialization will happen in the postmaster if the plperl library is "
"included in <xref linkend=\"guc-shared-preload-libraries\"/>, in which case "
"extra consideration should be given to the risk of destabilizing the "
"postmaster. The principal reason for making use of this feature is that Perl "
"modules loaded by <literal>plperl.on_init</literal> need be loaded only at "
"postmaster start, and will be instantly available without loading overhead "
"in individual database sessions. However, keep in mind that the overhead is "
"avoided only for the first Perl interpreter used by a database session "
"&mdash; either PL/PerlU, or PL/Perl for the first SQL role that calls a PL/"
"Perl function. Any additional Perl interpreters created in a database "
"session will have to execute <literal>plperl.on_init</literal> afresh. Also, "
"on Windows there will be no savings whatsoever from preloading, since the "
"Perl interpreter created in the postmaster process does not propagate to "
"child processes."
msgstr ""
"Если библиотека plperl включена в <xref linkend=\"guc-shared-preload-"
"libraries\"/>, инициализация произойдёт в главном процессе (postmaster) и в "
"этом случае необходимо очень серьёзно оценить риск нарушения "
"работоспособности этого процесса. Основной смысл использовать эту "
"возможность в том, чтобы модули Perl, подключаемые в <literal>plperl."
"on_init</literal>, загружались только при запуске главного процесса, и это "
"исключало бы издержки загрузки для отдельных сеансов. Однако, имейте в виду, "
"что эти издержки исключаются только при загрузке в сеансе первого "
"интерпретатора Perl &mdash; будь то PL/PerlU или PL/Perl для первой SQL-"
"роли, вызывающей функцию на PL/Perl. Любые дополнительные интерпретаторы "
"Perl, создаваемые в сеансе базы данных, должны будут выполнять "
"<literal>plperl.on_init</literal> заново. Также учтите, что в Windows "
"предварительная загрузка не даёт никакого выигрыша, так как интерпретатор "
"Perl, созданный в главном процессе, не передаётся дочерним процессам."

#: plperl.xml:1278(para)
msgid ""
"This parameter can only be set in the <filename>postgresql.conf</filename> "
"file or on the server command line."
msgstr ""
"Задать этот параметр можно только в <filename>postgresql.conf</filename> или "
"в командной строке при запуске сервера."

#: plperl.xml:1287(indexterm)
msgid ""
"<primary><varname>plperl.on_plperl_init</varname> configuration parameter</"
"primary>"
msgstr ""
"<primary>параметр конфигурации <varname>plperl.on_plperl_init</varname></"
"primary>"

#: plperl.xml:1285(term)
msgid ""
"<varname>plperl.on_plperl_init</varname> (<type>string</type>) "
"<placeholder-1/>"
msgstr ""
"<varname>plperl.on_plperl_init</varname> (<type>string</type>) "
"<placeholder-1/>"

#: plperl.xml:1293(indexterm)
msgid ""
"<primary><varname>plperl.on_plperlu_init</varname> configuration parameter</"
"primary>"
msgstr ""
"<primary>параметр конфигурации <varname>plperl.on_plperlu_init</varname></"
"primary>"

#: plperl.xml:1291(term)
msgid ""
"<varname>plperl.on_plperlu_init</varname> (<type>string</type>) "
"<placeholder-1/>"
msgstr ""
"<varname>plperl.on_plperlu_init</varname> (<type>string</type>) "
"<placeholder-1/>"

#: plperl.xml:1298(para)
msgid ""
"These parameters specify Perl code to be executed when a Perl interpreter is "
"specialized for <literal>plperl</literal> or <literal>plperlu</literal> "
"respectively. This will happen when a PL/Perl or PL/PerlU function is first "
"executed in a database session, or when an additional interpreter has to be "
"created because the other language is called or a PL/Perl function is called "
"by a new SQL role. This follows any initialization done by <literal>plperl."
"on_init</literal>. The SPI functions are not available when this code is "
"executed. The Perl code in <literal>plperl.on_plperl_init</literal> is "
"executed after <quote>locking down</quote> the interpreter, and thus it can "
"only perform trusted operations."
msgstr ""
"В этих параметрах задаётся код Perl, который будет выполняться в момент, "
"когда интерпретатор Perl получает специализацию <literal>plperl</literal> "
"или <literal>plperlu</literal>, соответственно. Это произойдёт, когда в "
"рамках сеанса будет первый раз вызвана функция на PL/Perl или PL/PerlU, либо "
"когда потребуется дополнительный интерпретатор при использовании другого "
"языка или при вызове функции PL/Perl новой SQL-ролью. Этот код выполняется "
"после инициализации, произведённой в <literal>plperl.on_init</literal>. "
"Однако функции SPI в момент исполнения этого кода ещё не доступны. Код в "
"<literal>plperl.on_plperl_init</literal> запускается после того, как "
"интерпретатор <quote>помещается под замок</quote>, так что в нём разрешаются "
"только доверенные операции."

#: plperl.xml:1311(para)
msgid ""
"If the code fails with an error it will abort the initialization and "
"propagate out to the calling query, causing the current transaction or "
"subtransaction to be aborted. Any actions already done within Perl won't be "
"undone; however, that interpreter won't be used again. If the language is "
"used again the initialization will be attempted again within a fresh Perl "
"interpreter."
msgstr ""
"Если этот код завершается ошибкой, инициализация прерывается и ошибка "
"распространяется в вызывающий запрос, что приводит к прерыванию текущей "
"транзакции или подтранзакции. При этом любые действия, уже произведённые в "
"Perl, не будут отменены; однако использоваться этот интерпретатор больше не "
"будет. При следующей попытке использовать этот язык система попытается "
"заново инициализировать свежий интерпретатор Perl."

#: plperl.xml:1319(para)
msgid ""
"Only superusers can change these settings. Although these settings can be "
"changed within a session, such changes will not affect Perl interpreters "
"that have already been used to execute functions."
msgstr ""
"Изменять эти параметры разрешено только суперпользователям. Хотя изменить их "
"можно в рамках сеанса, такие изменения не повлияют на работу интерпретаторов "
"Perl, задействованных для выполнения функций ранее."

#: plperl.xml:1330(indexterm)
msgid ""
"<primary><varname>plperl.use_strict</varname> configuration parameter</"
"primary>"
msgstr ""
"<primary>параметр конфигурации <varname>plperl.use_strict</varname></primary>"

#: plperl.xml:1328(term)
msgid ""
"<varname>plperl.use_strict</varname> (<type>boolean</type>) <placeholder-1/>"
msgstr ""
"<varname>plperl.use_strict</varname> (<type>boolean</type>) <placeholder-1/>"

#: plperl.xml:1335(para)
msgid ""
"When set true subsequent compilations of PL/Perl functions will have the "
"<literal>strict</literal> pragma enabled. This parameter does not affect "
"functions already compiled in the current session."
msgstr ""
"При значении, равном true, последующая компиляция функций PL/Perl будет "
"выполняться с включённым указанием <literal>strict</literal>. Этот параметр "
"не влияет на функции, уже скомпилированные в текущем сеансе."

#: plperl.xml:1347(title)
msgid "Limitations and Missing Features"
msgstr "Ограничения и недостающие возможности"

#: plperl.xml:1355(para)
msgid "PL/Perl functions cannot call each other directly."
msgstr "Функции на PL/Perl не могут напрямую вызывать друг друга."

#: plperl.xml:1361(para)
msgid "SPI is not yet fully implemented."
msgstr "SPI ещё не полностью реализован."

#: plperl.xml:1367(para)
msgid ""
"If you are fetching very large data sets using <literal>spi_exec_query</"
"literal>, you should be aware that these will all go into memory. You can "
"avoid this by using <literal>spi_query</literal>/<literal>spi_fetchrow</"
"literal> as illustrated earlier."
msgstr ""
"Если вы выбираете очень большие наборы данных, используя "
"<literal>spi_exec_query</literal>, вы должны понимать, что все эти данные "
"загружаются в память. Вы можете избежать этого, используя пару функций "
"<literal>spi_query</literal>/<literal>spi_fetchrow</literal>, как показано "
"ранее."

#: plperl.xml:1374(para)
msgid ""
"A similar problem occurs if a set-returning function passes a large set of "
"rows back to PostgreSQL via <literal>return</literal>. You can avoid this "
"problem too by instead using <literal>return_next</literal> for each row "
"returned, as shown previously."
msgstr ""
"Похожая проблема возникает, если функция, возвращающая множество, передаёт в "
"PostgreSQL большое число строк, выполняя <literal>return</literal>. Этой "
"проблемы так же можно избежать, выполняя для каждой возвращаемой строки "
"<literal>return_next</literal>, как показано ранее."

#: plperl.xml:1384(para)
msgid ""
"When a session ends normally, not due to a fatal error, any <literal>END</"
"literal> blocks that have been defined are executed. Currently no other "
"actions are performed. Specifically, file handles are not automatically "
"flushed and objects are not automatically destroyed."
msgstr ""
"Когда сеанс завершается штатно, не по причине критической ошибки, в Perl "
"выполняются все блоки <literal>END</literal>, которые были определены. "
"Никакие другие действия в настоящее время не выполняются. В частности, "
"буферы файлов автоматически не сбрасываются и объекты автоматически не "
"уничтожаются."

#: plperl.xml:1349(para)
msgid ""
"The following features are currently missing from PL/Perl, but they would "
"make welcome contributions. <placeholder-1/>"
msgstr ""
"Следующие возможности в настоящее время в PL/Perl отсутствуют, но их "
"реализация будет желанной доработкой. <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: plperl.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
