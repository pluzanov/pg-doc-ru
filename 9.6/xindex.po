# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-11 12:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: xindex.xml:5(title)
msgid "Interfacing Extensions To Indexes"
msgstr "Интерфейсы расширений для индексов"

#: xindex.xml:7(indexterm)
msgid ""
"<primary>index</primary><secondary>for user-defined data type</secondary>"
msgstr ""
"<primary>индекс</primary><secondary>для пользовательского типа данных</"
"secondary>"

#: xindex.xml:11(para)
msgid ""
"The procedures described thus far let you define new types, new functions, "
"and new operators. However, we cannot yet define an index on a column of a "
"new data type. To do this, we must define an <firstterm>operator class</"
"firstterm> for the new data type. Later in this section, we will illustrate "
"this concept in an example: a new operator class for the B-tree index method "
"that stores and sorts complex numbers in ascending absolute value order."
msgstr ""
"Описанные до этого процедуры позволяли определять новые типы, функции и "
"операторы. Однако, мы ещё не можем определить индекс по столбцу нового типа "
"данных. Для этого нам потребуется создать <firstterm>класс операторов</"
"firstterm> для нового типа данных. Далее в этом разделе мы продемонстрируем "
"эту концепцию на примере: мы создадим новый класс операторов для метода "
"индекса-B-дерева, в котором будут храниться комплексные числа и "
"сортироваться по возрастанию абсолютного значения."

#: xindex.xml:21(para)
msgid ""
"Operator classes can be grouped into <firstterm>operator families</"
"firstterm> to show the relationships between semantically compatible "
"classes. When only a single data type is involved, an operator class is "
"sufficient, so we'll focus on that case first and then return to operator "
"families."
msgstr ""
"Классы операторов могут объединяться в <firstterm>семейства операторов</"
"firstterm>, выражающие зависимости между семантически совместимыми классами. "
"Когда вводится один тип данных, достаточно класса операторов, так что мы "
"начнём с него, а к семействам операторов вернёмся позже."

#: xindex.xml:29(title)
msgid "Index Methods and Operator Classes"
msgstr "Методы индексов и классы операторов"

#: xindex.xml:31(para)
msgid ""
"The <classname>pg_am</classname> table contains one row for every index "
"method (internally known as access method). Support for regular access to "
"tables is built into <productname>PostgreSQL</productname>, but all index "
"methods are described in <classname>pg_am</classname>. It is possible to add "
"a new index access method by writing the necessary code and then creating a "
"row in <classname>pg_am</classname> &mdash; but that is beyond the scope of "
"this chapter (see <xref linkend=\"indexam\"/>)."
msgstr ""
"В системном каталоге есть таблица <classname>pg_am</classname>, содержащая "
"записи для каждого метода индекса (внутри называемого методом доступа). "
"Поддержка обычного доступа к таблицам встроена в <productname>PostgreSQL</"
"productname>, но все методы доступа описываются в <classname>pg_am</"
"classname>. Система позволяет добавлять новые методы доступа — для этого "
"нужно написать необходимый код, а затем добавить запись в <classname>pg_am</"
"classname>, но это выходит за рамки данной главы (см. <xref remap=\"4\" "
"linkend=\"indexam\"/>)."

#: xindex.xml:46(indexterm)
msgid "<primary>operator class</primary>"
msgstr "<primary>класс операторов</primary>"

#: xindex.xml:42(para)
msgid ""
"The routines for an index method do not directly know anything about the "
"data types that the index method will operate on. Instead, an "
"<firstterm>operator class</firstterm><placeholder-1/> identifies the set of "
"operations that the index method needs to use to work with a particular data "
"type. Operator classes are so called because one thing they specify is the "
"set of <literal>WHERE</literal>-clause operators that can be used with an "
"index (i.e., can be converted into an index-scan qualification). An operator "
"class can also specify some <firstterm>support procedures</firstterm> that "
"are needed by the internal operations of the index method, but do not "
"directly correspond to any <literal>WHERE</literal>-clause operator that can "
"be used with the index."
msgstr ""
"Процедуры метода индекса непосредственно ничего не знают о типах данных, с "
"которыми будет применяться этот метод. Вместо этого, набор операций, которые "
"нужны методу индекса для работы с конкретным типом данных, определяется "
"<firstterm>классом операторов</firstterm><placeholder-1/>. Классы операторов "
"называются так потому, что они определяют множество операторов в предложении "
"<literal>WHERE</literal>, которые могут использоваться с индексом (т. е. "
"могут быть сведены к сканированию индекса). В классе операторов могут также "
"определяться некоторые <firstterm>опорные процедуры</firstterm>, которые "
"нужны для внутренних операций метода индекса, но они не соответствуют "
"напрямую каким-либо операторам предложения <literal>WHERE</literal>, которые "
"могут обрабатываться с индексом."

#: xindex.xml:58(para)
msgid ""
"It is possible to define multiple operator classes for the same data type "
"and index method. By doing this, multiple sets of indexing semantics can be "
"defined for a single data type. For example, a B-tree index requires a sort "
"ordering to be defined for each data type it works on. It might be useful "
"for a complex-number data type to have one B-tree operator class that sorts "
"the data by complex absolute value, another that sorts by real part, and so "
"on. Typically, one of the operator classes will be deemed most commonly "
"useful and will be marked as the default operator class for that data type "
"and index method."
msgstr ""
"Для одного типа данных и метода индекса можно определить несколько классов "
"операторов. Благодаря этому, для одного типа данных можно использовать "
"несколько семантически разных вариантов индексирования. Например, индекс-B-"
"дерево требует, чтобы для каждого типа данных, с которым он работает, "
"определялся порядок сортировки. Для типа комплексных чисел может быть "
"полезен класс операторов B-дерева, сортирующий данные по модулю комплексного "
"числа, и ещё один, сортирующий по вещественной части, и т. п. Обычно "
"предполагается, что один из классов операторов будет применяться чаще "
"других, и тогда он помечается как класс по умолчанию для данного типа и "
"метода индекса."

#: xindex.xml:72(para)
msgid ""
"The same operator class name can be used for several different index methods "
"(for example, both B-tree and hash index methods have operator classes named "
"<literal>int4_ops</literal>), but each such class is an independent entity "
"and must be defined separately."
msgstr ""
"Одно и то же имя класса операторов может использоваться для разных методов "
"индекса (например, для методов индекса-B-дерева или хеш-индекса применяются "
"классы операторов <literal>int4_ops</literal>), но все такие классы являются "
"независимыми и должны определяться отдельно."

#: xindex.xml:82(title)
msgid "Index Method Strategies"
msgstr "Стратегии методов индексов"

#: xindex.xml:84(para)
msgid ""
"The operators associated with an operator class are identified by "
"<quote>strategy numbers</quote>, which serve to identify the semantics of "
"each operator within the context of its operator class. For example, B-trees "
"impose a strict ordering on keys, lesser to greater, and so operators like "
"<quote>less than</quote> and <quote>greater than or equal to</quote> are "
"interesting with respect to a B-tree. Because <productname>PostgreSQL</"
"productname> allows the user to define operators, <productname>PostgreSQL</"
"productname> cannot look at the name of an operator (e.g., <literal>&lt;</"
"literal> or <literal>&gt;=</literal>) and tell what kind of comparison it "
"is. Instead, the index method defines a set of <quote>strategies</quote>, "
"which can be thought of as generalized operators. Each operator class "
"specifies which actual operator corresponds to each strategy for a "
"particular data type and interpretation of the index semantics."
msgstr ""
"Операторам, которые связываются с классом операторов, назначаются "
"<quote>номера стратегий</quote>, определяющие роль каждого оператора в "
"контексте его класса. Например, в B-дереве должен быть строгий порядок "
"ключей с отношениями меньше/больше, так что в данном контексте представляют "
"интерес операторы <quote>меньше</quote> и <quote>больше или равно</quote>. "
"Так как <productname>PostgreSQL</productname> позволяет пользователям "
"определять операторы произвольным образом, <productname>PostgreSQL</"
"productname> не может просто посмотреть на имя оператора (<literal>&lt;</"
"literal> или <literal>&gt;=</literal>) и сказать, какое сравнение он "
"выполняет. Вместо этого для метода индекса определяется набор "
"<quote>стратегий</quote>, которые можно считать обобщёнными операторами. "
"Каждый класс операторов устанавливает, какие фактические операторы "
"соответствуют стратегиям для определённого типа данных и интерпретации "
"семантики индекса."

#: xindex.xml:102(para)
msgid ""
"The B-tree index method defines five strategies, shown in <xref linkend="
"\"xindex-btree-strat-table\"/>."
msgstr ""
"Для метода индекса-B-дерева определены пять стратегий, описанных в <xref "
"remap=\"6\" linkend=\"xindex-btree-strat-table\"/>."

#: xindex.xml:108(title)
msgid "B-tree Strategies"
msgstr "Стратегии B-дерева"

#: xindex.xml:112(entry) xindex.xml:151(entry) xindex.xml:182(entry)
#: xindex.xml:253(entry) xindex.xml:300(entry) xindex.xml:339(entry)
msgid "Operation"
msgstr "Операция"

#: xindex.xml:113(entry) xindex.xml:152(entry) xindex.xml:183(entry)
#: xindex.xml:254(entry) xindex.xml:301(entry) xindex.xml:340(entry)
msgid "Strategy Number"
msgstr "Номер стратегии"

#: xindex.xml:118(entry) xindex.xml:345(entry)
msgid "less than"
msgstr "меньше"

#: xindex.xml:119(entry) xindex.xml:158(entry) xindex.xml:189(entry)
#: xindex.xml:260(entry) xindex.xml:307(entry) xindex.xml:346(entry)
#: xindex.xml:425(entry) xindex.xml:455(entry) xindex.xml:482(entry)
#: xindex.xml:553(entry) xindex.xml:605(entry) xindex.xml:671(entry)
msgid "1"
msgstr "1"

#: xindex.xml:122(entry) xindex.xml:349(entry)
msgid "less than or equal"
msgstr "меньше или равно"

#: xindex.xml:123(entry) xindex.xml:193(entry) xindex.xml:311(entry)
#: xindex.xml:350(entry) xindex.xml:432(entry) xindex.xml:487(entry)
#: xindex.xml:558(entry) xindex.xml:610(entry) xindex.xml:676(entry)
msgid "2"
msgstr "2"

#: xindex.xml:126(entry) xindex.xml:157(entry) xindex.xml:318(entry)
#: xindex.xml:353(entry)
msgctxt "entry"
msgid "equal"
msgstr "равно"

#: xindex.xml:127(entry) xindex.xml:197(entry) xindex.xml:315(entry)
#: xindex.xml:354(entry) xindex.xml:493(entry) xindex.xml:563(entry)
#: xindex.xml:615(entry) xindex.xml:681(entry)
msgid "3"
msgstr "3"

#: xindex.xml:130(entry) xindex.xml:357(entry)
msgid "greater than or equal"
msgstr "больше или равно"

#: xindex.xml:131(entry) xindex.xml:201(entry) xindex.xml:319(entry)
#: xindex.xml:358(entry) xindex.xml:499(entry) xindex.xml:569(entry)
#: xindex.xml:623(entry) xindex.xml:688(entry)
msgid "4"
msgstr "4"

#: xindex.xml:134(entry) xindex.xml:361(entry)
msgid "greater than"
msgstr "больше"

#: xindex.xml:135(entry) xindex.xml:205(entry) xindex.xml:264(entry)
#: xindex.xml:362(entry) xindex.xml:505(entry) xindex.xml:575(entry)
#: xindex.xml:633(entry)
msgid "5"
msgstr "5"

#: xindex.xml:141(para)
msgid ""
"Hash indexes support only equality comparisons, and so they use only one "
"strategy, shown in <xref linkend=\"xindex-hash-strat-table\"/>."
msgstr ""
"Индексы по хешу поддерживают только сравнение на равенство, так что они "
"используют только одну стратегию, показанную в <xref remap=\"6\" linkend="
"\"xindex-hash-strat-table\"/>."

#: xindex.xml:147(title)
msgid "Hash Strategies"
msgstr "Стратегии хеша"

#: xindex.xml:164(para)
msgid ""
"GiST indexes are more flexible: they do not have a fixed set of strategies "
"at all. Instead, the <quote>consistency</quote> support routine of each "
"particular GiST operator class interprets the strategy numbers however it "
"likes. As an example, several of the built-in GiST index operator classes "
"index two-dimensional geometric objects, providing the <quote>R-tree</quote> "
"strategies shown in <xref linkend=\"xindex-rtree-strat-table\"/>. Four of "
"these are true two-dimensional tests (overlaps, same, contains, contained "
"by); four of them consider only the X direction; and the other four provide "
"the same tests in the Y direction."
msgstr ""
"Индексы GiST более гибкие: для них вообще нет фиксированного набора "
"стратегий. Вместо этого опорная процедура <quote>согласованности</quote> "
"каждого конкретного класса операторов GiST интерпретирует номера стратегий "
"как ей угодно. Например, некоторые из встроенных классов операторов для "
"индексов GiST индексируют двумерные геометрические объекты, и реализуют "
"стратегии <quote>R-дерева</quote>, показанные в <xref remap=\"6\" linkend="
"\"xindex-rtree-strat-table\"/>. Четыре из них являются истинно двумерными "
"проверками (overlaps, same, contains, contained by); другие четыре учитывают "
"только ординаты, а ещё четыре проводят же проверки только с абсциссами."

#: xindex.xml:178(title)
msgid "GiST Two-Dimensional <quote>R-tree</quote> Strategies"
msgstr "Стратегии двумерного <quote>R-дерева</quote> индекса GiST"

#: xindex.xml:188(entry) xindex.xml:259(entry)
msgid "strictly left of"
msgstr "строго слева от"

#: xindex.xml:192(entry)
msgid "does not extend to right of"
msgstr "не простирается правее"

#: xindex.xml:196(entry)
msgid "overlaps"
msgstr "пересекается с"

#: xindex.xml:200(entry)
msgid "does not extend to left of"
msgstr "не простирается левее"

#: xindex.xml:204(entry) xindex.xml:263(entry)
msgid "strictly right of"
msgstr "строго справа от"

#: xindex.xml:208(entry) xindex.xml:267(entry)
msgid "same"
msgstr "одинаковы"

#: xindex.xml:209(entry) xindex.xml:268(entry) xindex.xml:511(entry)
#: xindex.xml:641(entry)
msgid "6"
msgstr "6"

#: xindex.xml:212(entry) xindex.xml:310(entry)
msgid "contains"
msgstr "содержит"

#: xindex.xml:213(entry) xindex.xml:516(entry)
msgid "7"
msgstr "7"

#: xindex.xml:216(entry) xindex.xml:271(entry)
msgid "contained by"
msgstr "содержится в"

#: xindex.xml:217(entry) xindex.xml:272(entry) xindex.xml:521(entry)
msgid "8"
msgstr "8"

#: xindex.xml:220(entry)
msgid "does not extend above"
msgstr "не простирается выше"

#: xindex.xml:221(entry) xindex.xml:527(entry)
msgid "9"
msgstr "9"

#: xindex.xml:224(entry) xindex.xml:275(entry)
msgid "strictly below"
msgstr "строго ниже"

#: xindex.xml:225(entry) xindex.xml:276(entry)
msgid "10"
msgstr "10"

#: xindex.xml:228(entry) xindex.xml:279(entry)
msgid "strictly above"
msgstr "строго выше"

#: xindex.xml:229(entry) xindex.xml:280(entry)
msgid "11"
msgstr "11"

#: xindex.xml:232(entry)
msgid "does not extend below"
msgstr "не простирается ниже"

#: xindex.xml:233(entry)
msgid "12"
msgstr "12"

#: xindex.xml:239(para)
msgid ""
"SP-GiST indexes are similar to GiST indexes in flexibility: they don't have "
"a fixed set of strategies. Instead the support routines of each operator "
"class interpret the strategy numbers according to the operator class's "
"definition. As an example, the strategy numbers used by the built-in "
"operator classes for points are shown in <xref linkend=\"xindex-spgist-point-"
"strat-table\"/>."
msgstr ""
"Индексы SP-GiST такие же гибкие, как и индексы GiST: для них не задаётся "
"фиксированный набор стратегий. Вместо этого опорные процедуры каждого класса "
"операторов интерпретируют номера стратегий в соответствии с определением "
"класса операторов. В качестве примера, в <xref remap=\"6\" linkend=\"xindex-"
"spgist-point-strat-table\"/> приведены номера стратегий, установленные для "
"встроенных классов операторов для точек."

#: xindex.xml:249(title)
msgid "SP-GiST Point Strategies"
msgstr "Стратегии SP-GiST для точек"

#: xindex.xml:286(para)
msgid ""
"GIN indexes are similar to GiST and SP-GiST indexes, in that they don't have "
"a fixed set of strategies either. Instead the support routines of each "
"operator class interpret the strategy numbers according to the operator "
"class's definition. As an example, the strategy numbers used by the built-in "
"operator classes for arrays are shown in <xref linkend=\"xindex-gin-array-"
"strat-table\"/>."
msgstr ""
"Индексы GIN такие же гибкие, как и индексы GiST и SP-GiST: для них не "
"задаётся фиксированный набор стратегий. Вместо этого опорные процедуры "
"каждого класса операторов интерпретируют номера стратегий в соответствии с "
"определением класса операторов. В качестве примера, в <xref remap=\"6\" "
"linkend=\"xindex-gin-array-strat-table\"/> приведены номера стратегий, "
"установленные для встроенных классов операторов для массивов."

#: xindex.xml:296(title)
msgid "GIN Array Strategies"
msgstr "Стратегии GIN для массивов"

#: xindex.xml:306(entry)
msgid "overlap"
msgstr "пересекается с"

#: xindex.xml:314(entry)
msgid "is contained by"
msgstr "содержится в"

#: xindex.xml:325(para)
msgid ""
"BRIN indexes are similar to GiST, SP-GiST and GIN indexes in that they don't "
"have a fixed set of strategies either. Instead the support routines of each "
"operator class interpret the strategy numbers according to the operator "
"class's definition. As an example, the strategy numbers used by the built-in "
"<literal>Minmax</literal> operator classes are shown in <xref linkend="
"\"xindex-brin-minmax-strat-table\"/>."
msgstr ""
"Индексы BRIN такие же гибкие, как и индексы GiST, SP-GiST и GIN: для них не "
"задаётся фиксированный набор стратегий. Вместо этого опорные процедуры "
"каждого класса операторов интерпретируют номера стратегий в соответствии с "
"определением класса операторов. В качестве примера, в <xref remap=\"6\" "
"linkend=\"xindex-brin-minmax-strat-table\"/> приведены номера стратегий, "
"используемые встроенными классами операторов <literal>Minmax</literal>."

#: xindex.xml:335(title)
msgid "BRIN Minmax Strategies"
msgstr "Стратегии BRIN Minmax"

#: xindex.xml:368(para)
msgid ""
"Notice that all the operators listed above return Boolean values. In "
"practice, all operators defined as index method search operators must return "
"type <type>boolean</type>, since they must appear at the top level of a "
"<literal>WHERE</literal> clause to be used with an index. (Some index access "
"methods also support <firstterm>ordering operators</firstterm>, which "
"typically don't return Boolean values; that feature is discussed in <xref "
"linkend=\"xindex-ordering-ops\"/>.)"
msgstr ""
"Заметьте, что все вышеперечисленные операторы возвращают булевы значения. На "
"практике все операторы, определённые как операторы поиска для метода "
"индекса, должны возвращать тип <type>boolean</type>, так как они должны "
"находиться на верхнем уровне предложения <literal>WHERE</literal>, чтобы для "
"них применялся индекс. (Некоторые методы доступа по индексу также "
"поддерживают <firstterm>операторы упорядочивания</firstterm>, которые обычно "
"не возвращают булевы значения; это обсуждается в <xref remap=\"6\" linkend="
"\"xindex-ordering-ops\"/>.)"

#: xindex.xml:380(title)
msgid "Index Method Support Routines"
msgstr "Опорные процедуры метода индекса"

#: xindex.xml:382(para)
msgid ""
"Strategies aren't usually enough information for the system to figure out "
"how to use an index. In practice, the index methods require additional "
"support routines in order to work. For example, the B-tree index method must "
"be able to compare two keys and determine whether one is greater than, equal "
"to, or less than the other. Similarly, the hash index method must be able to "
"compute hash codes for key values. These operations do not correspond to "
"operators used in qualifications in SQL commands; they are administrative "
"routines used by the index methods, internally."
msgstr ""
"Стратегии обычно не дают системе достаточно информации, чтобы понять, как "
"использовать индекс. На практике, чтобы методы индекса работали, необходимы "
"дополнительные опорные процедуры. Например, метод индекса-B-дерева должен "
"уметь сравнивать два ключа и определять, больше, равен или меньше ли первый "
"второго. Аналогично, метод индекса по хешу должен уметь сравнивать хеш-коды "
"значений ключа. Эти операции не соответствуют операторам, которые "
"применяются в условиях в командах SQL; это внутрисистемные подпрограммы, "
"используемые методами индекса."

#: xindex.xml:394(para)
msgid ""
"Just as with strategies, the operator class identifies which specific "
"functions should play each of these roles for a given data type and semantic "
"interpretation. The index method defines the set of functions it needs, and "
"the operator class identifies the correct functions to use by assigning them "
"to the <quote>support function numbers</quote> specified by the index method."
msgstr ""
"Так же, как и со стратегиями, класс операторов определяет, какие конкретные "
"функции должны играть каждую из ролей для определённого типа данных и "
"интерпретации семантики индекса. Для метода индекса определяется набор "
"нужных ему функций, а класс оператора выбирает нужные функции для "
"применения, назначая им <quote>номера опорных функций</quote>, определяемые "
"методом индекса."

#: xindex.xml:403(para)
msgid ""
"B-trees require a single support function, and allow a second one to be "
"supplied at the operator class author's option, as shown in <xref linkend="
"\"xindex-btree-support-table\"/>."
msgstr ""
"Для B-деревьев требуется одна опорная функция, а вторая задаётся по выбору "
"автора класса операторов, как показано в <xref remap=\"6\" linkend=\"xindex-"
"btree-support-table\"/>."

#: xindex.xml:410(title)
msgid "B-tree Support Functions"
msgstr "Опорные функции B-деревьев"

#: xindex.xml:414(entry) xindex.xml:448(entry) xindex.xml:472(entry)
#: xindex.xml:544(entry) xindex.xml:592(entry) xindex.xml:659(entry)
msgid "Function"
msgstr "Функция"

#: xindex.xml:415(entry) xindex.xml:449(entry) xindex.xml:474(entry)
#: xindex.xml:546(entry) xindex.xml:594(entry) xindex.xml:661(entry)
msgid "Support Number"
msgstr "Номер опорной функции"

#: xindex.xml:420(entry)
msgid ""
"Compare two keys and return an integer less than zero, zero, or greater than "
"zero, indicating whether the first key is less than, equal to, or greater "
"than the second"
msgstr ""
"Сравнивает два ключа и возвращает целое меньше нуля, ноль или целое больше "
"нуля, показывающее, что первый ключ меньше, равен или больше второго"

#: xindex.xml:428(entry)
msgid ""
"Return the addresses of C-callable sort support function(s), as documented "
"in <filename>utils/sortsupport.h</filename> (optional)"
msgstr ""
"Возвращает адрес вызываемой из C функции(й), поддерживающей сортировку, как "
"описано в <filename>utils/sortsupport.h</filename> (необязательно)"

#: xindex.xml:438(para)
msgid ""
"Hash indexes require one support function, shown in <xref linkend=\"xindex-"
"hash-support-table\"/>."
msgstr ""
"Для хеш-индексов требуется одна опорная функция, указанная в <xref remap="
"\"6\" linkend=\"xindex-hash-support-table\"/>."

#: xindex.xml:444(title)
msgid "Hash Support Functions"
msgstr "Опорные функции хеша"

#: xindex.xml:454(entry)
msgid "Compute the hash value for a key"
msgstr "Вычисляет значение хеша для ключа"

#: xindex.xml:461(para)
msgid ""
"GiST indexes have nine support functions, two of which are optional, as "
"shown in <xref linkend=\"xindex-gist-support-table\"/>. (For more "
"information see <xref linkend=\"gist\"/>.)"
msgstr ""
"Для индексов GiST требуются девять опорных функций, две из которых "
"необязательны; они описаны в <xref remap=\"6\" linkend=\"xindex-gist-support-"
"table\"/>. (За дополнительными сведениями обратитесь к <xref remap=\"3\" "
"linkend=\"gist\"/>.)"

#: xindex.xml:468(title)
msgid "GiST Support Functions"
msgstr "Опорные функции GiST"

#: xindex.xml:473(entry) xindex.xml:545(entry) xindex.xml:593(entry)
#: xindex.xml:660(entry)
msgid "Description"
msgstr "Описание"

#: xindex.xml:479(function) xindex.xml:618(function) xindex.xml:679(function)
msgid "consistent"
msgstr "consistent"

#: xindex.xml:480(entry) xindex.xml:573(entry)
msgid "determine whether key satisfies the query qualifier"
msgstr "определяет, удовлетворяет ли ключ условию запроса"

#: xindex.xml:485(function) xindex.xml:684(function)
msgid "union"
msgstr "union"

#: xindex.xml:486(entry)
msgid "compute union of a set of keys"
msgstr "вычисляет объединение набора ключей"

#: xindex.xml:490(function)
msgid "compress"
msgstr "compress"

#: xindex.xml:491(entry)
msgid "compute a compressed representation of a key or value to be indexed"
msgstr "вычисляет сжатое представление ключа или индексируемого значения"

#: xindex.xml:496(function)
msgid "decompress"
msgstr "decompress"

#: xindex.xml:497(entry)
msgid "compute a decompressed representation of a compressed key"
msgstr "вычисляет развёрнутое представление сжатого ключа"

#: xindex.xml:502(function)
msgid "penalty"
msgstr "penalty"

#: xindex.xml:503(entry)
msgid ""
"compute penalty for inserting new key into subtree with given subtree's key"
msgstr ""
"вычисляет стоимость добавления нового ключа в поддерево с заданным ключом"

#: xindex.xml:508(function) xindex.xml:561(function)
msgid "picksplit"
msgstr "picksplit"

#: xindex.xml:509(entry)
msgid ""
"determine which entries of a page are to be moved to the new page and "
"compute the union keys for resulting pages"
msgstr ""
"определяет, какие записи страницы должны быть перемещены в новую страницу, и "
"вычисляет ключи объединения для результирующих страниц"

#: xindex.xml:514(function)
msgctxt "function"
msgid "equal"
msgstr "equal"

#: xindex.xml:515(entry)
msgid "compare two keys and return true if they are equal"
msgstr "сравнивает два ключа и возвращает true, если они равны"

#: xindex.xml:519(function)
msgid "distance"
msgstr "distance"

#: xindex.xml:520(entry)
msgid "determine distance from key to query value (optional)"
msgstr "определяет дистанцию от ключа до искомого значения (необязательно)"

#: xindex.xml:524(function)
msgid "fetch"
msgstr "fetch"

#: xindex.xml:525(entry)
msgid ""
"compute original representation of a compressed key for index-only scans "
"(optional)"
msgstr ""
"вычисляет исходное представление сжатого ключа для сканирования только по "
"индексу (необязательно)"

#: xindex.xml:533(para)
msgid ""
"SP-GiST indexes require five support functions, as shown in <xref linkend="
"\"xindex-spgist-support-table\"/>. (For more information see <xref linkend="
"\"spgist\"/>.)"
msgstr ""
"Для индексов SP-GiST требуются пять опорных функций, описанных в <xref remap="
"\"6\" linkend=\"xindex-spgist-support-table\"/>. (За дополнительными "
"сведениями обратитесь к <xref remap=\"3\" linkend=\"spgist\"/>.)"

#: xindex.xml:540(title)
msgid "SP-GiST Support Functions"
msgstr "Опорные функции SP-GiST"

#: xindex.xml:551(function)
msgid "config"
msgstr "config"

#: xindex.xml:552(entry)
msgid "provide basic information about the operator class"
msgstr "предоставляет основную информацию о классе операторов"

#: xindex.xml:556(function)
msgid "choose"
msgstr "choose"

#: xindex.xml:557(entry)
msgid "determine how to insert a new value into an inner tuple"
msgstr "определяет, как вставить новое значение во внутренний элемент"

#: xindex.xml:562(entry)
msgid "determine how to partition a set of values"
msgstr "определяет, как разделить множество значений"

#: xindex.xml:566(function)
msgid "inner_consistent"
msgstr "inner_consistent"

#: xindex.xml:567(entry)
msgid "determine which sub-partitions need to be searched for a query"
msgstr "определяет, в каких внутренних ветвях нужно искать заданное значение"

#: xindex.xml:572(function)
msgid "leaf_consistent"
msgstr "leaf_consistent"

#: xindex.xml:581(para)
msgid ""
"GIN indexes have six support functions, three of which are optional, as "
"shown in <xref linkend=\"xindex-gin-support-table\"/>. (For more information "
"see <xref linkend=\"gin\"/>.)"
msgstr ""
"Для индексов GIN требуются шесть опорных функций, три из которых "
"необязательны; они описаны в <xref remap=\"6\" linkend=\"xindex-gin-support-"
"table\"/>. (За дополнительными сведениями обратитесь к <xref remap=\"3\" "
"linkend=\"gin\"/>.)"

#: xindex.xml:588(title)
msgid "GIN Support Functions"
msgstr "Опорные функции GIN"

#: xindex.xml:599(function)
msgid "compare"
msgstr "compare"

#: xindex.xml:600(entry)
msgid ""
"compare two keys and return an integer less than zero, zero, or greater than "
"zero, indicating whether the first key is less than, equal to, or greater "
"than the second"
msgstr ""
"сравнивает два ключа и возвращает целое меньше нуля, ноль или целое больше "
"нуля, показывающее, что первый ключ меньше, равен или больше второго"

#: xindex.xml:608(function)
msgid "extractValue"
msgstr "extractValue"

#: xindex.xml:609(entry)
msgid "extract keys from a value to be indexed"
msgstr "извлекает ключи из индексируемого значения"

#: xindex.xml:613(function)
msgid "extractQuery"
msgstr "extractQuery"

#: xindex.xml:614(entry)
msgid "extract keys from a query condition"
msgstr "извлекает ключи из условия запроса"

#: xindex.xml:619(entry)
msgid ""
"determine whether value matches query condition (Boolean variant) (optional "
"if support function 6 is present)"
msgstr ""
"определяет, соответствует ли значение условию запроса (булевская вариация) "
"(не требуется, если присутствует опорная функция 6)"

#: xindex.xml:626(function)
msgid "comparePartial"
msgstr "comparePartial"

#: xindex.xml:627(entry)
msgid ""
"compare partial key from query and key from index, and return an integer "
"less than zero, zero, or greater than zero, indicating whether GIN should "
"ignore this index entry, treat the entry as a match, or stop the index scan "
"(optional)"
msgstr ""
"сравнивает частичный ключ из запроса с ключом из индекса и возвращает целое "
"число меньше нуля, ноль или больше нуля, показывающее, что GIN должен "
"игнорировать эту запись индекса, принять её как соответствующую или "
"прекратить сканирование индекса (необязательно)"

#: xindex.xml:636(function)
msgid "triConsistent"
msgstr "triConsistent"

#: xindex.xml:637(entry)
msgid ""
"determine whether value matches query condition (ternary variant) (optional "
"if support function 4 is present)"
msgstr ""
"определяет, соответствует ли значение условию запроса (троичная вариация) "
"(не требуется, если присутствует опорная функция 4)"

#: xindex.xml:647(para)
msgid ""
"BRIN indexes have four basic support functions, as shown in <xref linkend="
"\"xindex-brin-support-table\"/>; those basic functions may require "
"additional support functions to be provided. (For more information see <xref "
"linkend=\"brin-extensibility\"/>.)"
msgstr ""
"Для индексов BRIN требуются четыре базовые опорные функции, перечисленные в "
"<xref remap=\"6\" linkend=\"xindex-brin-support-table\"/>; для этих базовых "
"функций может потребоваться предоставить дополнительные опорные функции. (За "
"дополнительными сведениями обратитесь к <xref remap=\"3\" linkend=\"brin-"
"extensibility\"/>.)"

#: xindex.xml:655(title)
msgid "BRIN Support Functions"
msgstr "Опорные функции BRIN"

#: xindex.xml:666(function)
msgid "opcInfo"
msgstr "opcInfo"

#: xindex.xml:667(entry)
msgid ""
"return internal information describing the indexed columns' summary data"
msgstr ""
"возвращает внутреннюю информацию, описывающую сводные данные по "
"индексированным столбцам"

#: xindex.xml:674(function)
msgid "add_value"
msgstr "add_value"

#: xindex.xml:675(entry)
msgid "add a new value to an existing summary index tuple"
msgstr "добавляет новое значение в существующий сводный кортеж индекса"

#: xindex.xml:680(entry)
msgid "determine whether value matches query condition"
msgstr "определяет, удовлетворяет ли значение условию запроса"

#: xindex.xml:685(entry)
msgid "compute union of two summary tuples"
msgstr "вычисляет объединение двух обобщающих кортежей"

#: xindex.xml:694(para)
msgid ""
"Unlike search operators, support functions return whichever data type the "
"particular index method expects; for example in the case of the comparison "
"function for B-trees, a signed integer. The number and types of the "
"arguments to each support function are likewise dependent on the index "
"method. For B-tree and hash the comparison and hashing support functions "
"take the same input data types as do the operators included in the operator "
"class, but this is not the case for most GiST, SP-GiST, GIN, and BRIN "
"support functions."
msgstr ""
"В отличие от операторов поиска, опорные функции возвращают тот тип данных, "
"который ожидает конкретный метод индекса; например, функция сравнения для B-"
"деревьев возвращает знаковое целое. Количество и типы аргументов для каждой "
"опорной функции так же зависят от метода индекса. Для методов B-дерева и "
"хеша функции сравнения и хеширования принимают те же типы данных, что и "
"операторы, включённые в класс операторов, но для большинства опорных функций "
"GiST, SP-GiST, GIN и BRIN это не так."

#: xindex.xml:707(title)
msgid "An Example"
msgstr "Пример"

#: xindex.xml:724(simpara)
msgid "absolute-value less-than (strategy 1)"
msgstr "абсолютное-значение меньше (стратегия 1)"

#: xindex.xml:725(simpara)
msgid "absolute-value less-than-or-equal (strategy 2)"
msgstr "абсолютное-значение меньше-или-равно (стратегия 2)"

#: xindex.xml:726(simpara)
msgid "absolute-value equal (strategy 3)"
msgstr "абсолютное-значение равно (стратегия 3)"

#: xindex.xml:727(simpara)
msgid "absolute-value greater-than-or-equal (strategy 4)"
msgstr "абсолютное-значение больше-или-равно (стратегия 4)"

#: xindex.xml:728(simpara)
msgid "absolute-value greater-than (strategy 5)"
msgstr "абсолютное-значение больше (стратегия 5)"

#: xindex.xml:709(para)
msgid ""
"Now that we have seen the ideas, here is the promised example of creating a "
"new operator class. (You can find a working copy of this example in "
"<filename>src/tutorial/complex.c</filename> and <filename>src/tutorial/"
"complex.sql</filename> in the source distribution.) The operator class "
"encapsulates operators that sort complex numbers in absolute value order, so "
"we choose the name <literal>complex_abs_ops</literal>. First, we need a set "
"of operators. The procedure for defining operators was discussed in <xref "
"linkend=\"xoper\"/>. For an operator class on B-trees, the operators we "
"require are: <placeholder-1/>"
msgstr ""
"Теперь, когда мы познакомились с основными идеями, мы можем перейти к "
"обещанному примеру создания нового класса операторов. (Рабочую копию этого "
"примера можно найти в <filename>src/tutorial/complex.c</filename> и "
"<filename>src/tutorial/complex.sql</filename> в пакете исходного кода.) "
"Класс операторов включает операторы, сортирующие комплексные числа по "
"порядку абсолютных значений, поэтому мы выбрали для него имя "
"<literal>complex_abs_ops</literal>. Во-первых, нам понадобится набор "
"операторов. Процедура определения операторов была рассмотрена в <xref remap="
"\"6\" linkend=\"xoper\"/>. Для класса операторов B-деревьев нам понадобятся "
"операторы: <placeholder-1/>"

#: xindex.xml:732(para)
msgid ""
"The least error-prone way to define a related set of comparison operators is "
"to write the B-tree comparison support function first, and then write the "
"other functions as one-line wrappers around the support function. This "
"reduces the odds of getting inconsistent results for corner cases. Following "
"this approach, we first write: <placeholder-1/> Now the less-than function "
"looks like: <placeholder-2/> The other four functions differ only in how "
"they compare the internal function's result to zero."
msgstr ""
"Чтобы не провоцировать ошибки при определении связанного набора операторов "
"сравнения, лучше всего сначала написать вспомогательную функцию сравнения "
"для B-дерева, а затем написать другие функции как однострочные оболочки этой "
"вспомогательной функции. Это уменьшит вероятность получения несогласованных "
"результатов в исключительных случаях. Следуя этому подходу, мы сначала "
"напишем: <placeholder-1/> Теперь функция &laquo;меньше&raquo; будет "
"выглядеть так: <placeholder-2/> Остальные четыре функции отличаются от неё "
"только тем, как сравнивают результат внутренней функции с нулём."

#: xindex.xml:781(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool\n"
"    AS '<replaceable>filename</replaceable>', 'complex_abs_lt'\n"
"    LANGUAGE C IMMUTABLE STRICT;\n"
"\n"
"CREATE OPERATOR &lt; (\n"
"   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,\n"
"   commutator = &gt; , negator = &gt;= ,\n"
"   restrict = scalarltsel, join = scalarltjoinsel\n"
");"
msgstr ""
"CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool\n"
"    AS '<replaceable>имя_файла</replaceable>', 'complex_abs_lt'\n"
"    LANGUAGE C IMMUTABLE STRICT;\n"
"\n"
"CREATE OPERATOR &lt; (\n"
"   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,\n"
"   commutator = &gt; , negator = &gt;= ,\n"
"   restrict = scalarltsel, join = scalarltjoinsel\n"
");"

#: xindex.xml:777(para)
msgid ""
"Next we declare the functions and the operators based on the functions to "
"SQL: <placeholder-1/> It is important to specify the correct commutator and "
"negator operators, as well as suitable restriction and join selectivity "
"functions, otherwise the optimizer will be unable to make effective use of "
"the index. Note that the less-than, equal, and greater-than cases should use "
"different selectivity functions."
msgstr ""
"Затем мы объявим в SQL функции и операторы на основе этих функций: "
"<placeholder-1/> Важно правильно определить обратные и коммутирующие "
"операторы, а также подходящие функции избирательности ограничения и "
"соединения; иначе оптимизатор не сможет использовать наш индекс эффективно. "
"Заметьте, что для случаев меньше, равно и больше следует использовать другие "
"функции оценки избирательности."

#: xindex.xml:804(para)
msgid ""
"There can only be one operator named, say, <literal>=</literal> and taking "
"type <type>complex</type> for both operands. In this case we don't have any "
"other operator <literal>=</literal> for <type>complex</type>, but if we were "
"building a practical data type we'd probably want <literal>=</literal> to be "
"the ordinary equality operation for complex numbers (and not the equality of "
"the absolute values). In that case, we'd need to use some other operator "
"name for <function>complex_abs_eq</function>."
msgstr ""
"Учтите, что может быть только один оператор с именем, например, <literal>=</"
"literal>, который будет принимать тип <type>complex</type> с двух сторон. В "
"этом случае у нас не будет другого оператора <literal>=</literal> для "
"<type>complex</type>, но если мы создаём практически полезный тип данных, "
"вероятно, мы захотим, чтобы оператор <literal>=</literal> проверял обычное "
"равенство двух комплексных чисел (а не равенство их абсолютных значений). В "
"этом случае, для <function>complex_abs_eq</function> нужно выбрать какое-то "
"другое имя оператора."

#: xindex.xml:817(para)
msgid ""
"Although <productname>PostgreSQL</productname> can cope with functions "
"having the same SQL name as long as they have different argument data types, "
"C can only cope with one global function having a given name. So we "
"shouldn't name the C function something simple like <filename>abs_eq</"
"filename>. Usually it's a good practice to include the data type name in the "
"C function name, so as not to conflict with functions for other data types."
msgstr ""
"Хотя в <productname>PostgreSQL</productname> разные функции могут иметь "
"одинаковые имена SQL, если у них различные типы аргументов, в C только одна "
"глобальная функция может иметь заданное имя. Поэтому не следует давать "
"функции на C имя вроде <filename>abs_eq</filename>. Во избежание конфликтов "
"с функциями для других типов данных, в имя функции на C обычно включается "
"имя конкретного типа данных."

#: xindex.xml:829(para)
msgid ""
"We could have made the SQL name of the function <filename>abs_eq</filename>, "
"relying on <productname>PostgreSQL</productname> to distinguish it by "
"argument data types from any other SQL function of the same name. To keep "
"the example simple, we make the function have the same names at the C level "
"and SQL level."
msgstr ""
"Мы могли быть дать нашей функции имя <filename>abs_eq</filename> в SQL, "
"рассчитывая на то, что <productname>PostgreSQL</productname> отличит её от "
"любых других одноимённых функций SQL по типам аргументов. Но в данном случае "
"для упрощения примера мы дали ей одинаковые имена на уровне C и уровне SQL."

#: xindex.xml:799(para)
msgid "Other things worth noting are happening here: <placeholder-1/>"
msgstr "Здесь также стоит обратить внимание на следующее: <placeholder-1/>"

#: xindex.xml:847(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION complex_abs_cmp(complex, complex)\n"
"    RETURNS integer\n"
"    AS '<replaceable>filename</replaceable>'\n"
"    LANGUAGE C IMMUTABLE STRICT;"
msgstr ""
"CREATE FUNCTION complex_abs_cmp(complex, complex)\n"
"    RETURNS integer\n"
"    AS '<replaceable>имя_файла</replaceable>'\n"
"    LANGUAGE C IMMUTABLE STRICT;"

#: xindex.xml:841(para)
msgid ""
"The next step is the registration of the support routine required by B-"
"trees. The example C code that implements this is in the same file that "
"contains the operator functions. This is how we declare the function: "
"<placeholder-1/>"
msgstr ""
"На следующем этапе регистрируется опорная процедура, необходимая для B-"
"деревьев. В нашем примере код C, реализующий её, находится в том же файле, "
"что и функции операторов. Мы объявляем эту процедуру так: <placeholder-1/>"

#: xindex.xml:855(para)
msgid ""
"Now that we have the required operators and support routine, we can finally "
"create the operator class: <placeholder-1/>"
msgstr ""
"Теперь, когда мы объявили требуемые операторы и опорную функцию, мы наконец "
"можем создать класс операторов: <placeholder-1/>"

#: xindex.xml:872(para)
msgid ""
"And we're done! It should now be possible to create and use B-tree indexes "
"on <type>complex</type> columns."
msgstr ""
"Вот и всё! Теперь должно быть возможно создавать и использовать индексы-B-"
"деревья по столбцам <type>complex</type>."

#: xindex.xml:879(programlisting)
#, no-wrap
msgid "        OPERATOR        1       &lt; (complex, complex) ,"
msgstr "        OPERATOR        1       &lt; (complex, complex) ,"

#: xindex.xml:877(para)
msgid ""
"We could have written the operator entries more verbosely, as in: "
"<placeholder-1/> but there is no need to do so when the operators take the "
"same data type we are defining the operator class for."
msgstr ""
"Операторы можно было записать более многословно, например, так: "
"<placeholder-1/> но в этом необходимости, так как эти операторы принимают "
"тот же тип данных, для которого определяется класс операторов."

#: xindex.xml:886(para)
msgid ""
"The above example assumes that you want to make this new operator class the "
"default B-tree operator class for the <type>complex</type> data type. If you "
"don't, just leave out the word <literal>DEFAULT</literal>."
msgstr ""
"В приведённом примере предполагается, что этот класс операторов будет "
"классом операторов B-дерева по умолчанию для типа <type>complex</type>. Если "
"вам это не нужно, просто опустите слово <literal>DEFAULT</literal>."

#: xindex.xml:894(title)
msgid "Operator Classes and Operator Families"
msgstr "Семейства и классы операторов"

#: xindex.xml:896(para)
msgid ""
"So far we have implicitly assumed that an operator class deals with only one "
"data type. While there certainly can be only one data type in a particular "
"index column, it is often useful to index operations that compare an indexed "
"column to a value of a different data type. Also, if there is use for a "
"cross-data-type operator in connection with an operator class, it is often "
"the case that the other data type has a related operator class of its own. "
"It is helpful to make the connections between related classes explicit, "
"because this can aid the planner in optimizing SQL queries (particularly for "
"B-tree operator classes, since the planner contains a great deal of "
"knowledge about how to work with them)."
msgstr ""
"До этого мы неявно полагали, что класс операторов работает только с одним "
"типом данных. Хотя в конкретном индексируемом столбце, определённо, может "
"быть только один тип данных, часто бывает полезно индексировать операции, "
"сравнивающие значение столбца со значением другого типа. Также, если в "
"сочетании с классом операторов возможно применение оператора, работающего с "
"двумя типами, для другого типа данных обычно тоже создаётся собственный "
"класс. В таких случаях полезно установить явную связь между связанными "
"классами, так как это поможет планировщику оптимизировать SQL-запросы "
"(особенно для классов операторов B-дерева, потому что планировщик хорошо "
"знает, как работать с ними)."

#: xindex.xml:912(indexterm)
msgid "<primary>operator family</primary>"
msgstr "<primary>семейство операторов</primary>"

#: xindex.xml:909(para)
msgid ""
"To handle these needs, <productname>PostgreSQL</productname> uses the "
"concept of an <firstterm>operator family</firstterm><placeholder-1/>. An "
"operator family contains one or more operator classes, and can also contain "
"indexable operators and corresponding support functions that belong to the "
"family as a whole but not to any single class within the family. We say that "
"such operators and functions are <quote>loose</quote> within the family, as "
"opposed to being bound into a specific class. Typically each operator class "
"contains single-data-type operators while cross-data-type operators are "
"loose in the family."
msgstr ""
"Для удовлетворения этих потребностей в <productname>PostgreSQL</productname> "
"введена концепция <firstterm>семейства операторов</firstterm><placeholder-1/"
">. Семейство операторов содержит один или несколько классов операторов и "
"может также содержать индексируемые операторы и соответствующие опорные "
"функции, принадлежащие к семейству в целом, но не к какому-то одному классу "
"в нём. Мы называем такую связь операторов и функций с семейством "
"<quote>слабой</quote>, в отличие от обычной связи с определённым классом. "
"Как правило, классы содержат операторы с операндами одного типа, тогда как "
"межтиповые операторы слабо связываются с семейством."

#: xindex.xml:922(para)
msgid ""
"All the operators and functions in an operator family must have compatible "
"semantics, where the compatibility requirements are set by the index method. "
"You might therefore wonder why bother to single out particular subsets of "
"the family as operator classes; and indeed for many purposes the class "
"divisions are irrelevant and the family is the only interesting grouping. "
"The reason for defining operator classes is that they specify how much of "
"the family is needed to support any particular index. If there is an index "
"using an operator class, then that operator class cannot be dropped without "
"dropping the index &mdash; but other parts of the operator family, namely "
"other operator classes and loose operators, could be dropped. Thus, an "
"operator class should be specified to contain the minimum set of operators "
"and functions that are reasonably needed to work with an index on a specific "
"data type, and then related but non-essential operators can be added as "
"loose members of the operator family."
msgstr ""
"Все операторы и функции в семействе операторов должны иметь совместимую "
"семантику; требования к совместимости устанавливаются методом индекса. Вы "
"можете спросить, зачем в таком случае вообще выделять конкретные "
"подмножества семейства в виде классов операторов; и на самом деле во многих "
"случаях деление на классы не имеет значения, важно только связывание с "
"семейством. Смысл классов операторов в том, что они определяют, какая часть "
"семейства необходима для поддержки некоторого индекса. Если существует "
"индекс, использующий класс операторов, этот класс нельзя будет удалить, не "
"удалив индекс &mdash; но другие части семейства, а именно, другие классы "
"операторов и слабосвязанные операторы, удалить можно. Таким образом, класс "
"операторов должен определяться так, чтобы он содержал минимальный набор "
"операторов и функций, обоснованно требующихся для работы с индексом по "
"определённому типу данных, а связанные, но не существенные операторы могут "
"добавляться в качестве слабосвязанных членов в семейство операторов."

#: xindex.xml:940(para)
msgid ""
"As an example, <productname>PostgreSQL</productname> has a built-in B-tree "
"operator family <literal>integer_ops</literal>, which includes operator "
"classes <literal>int8_ops</literal>, <literal>int4_ops</literal>, and "
"<literal>int2_ops</literal> for indexes on <type>bigint</type> (<type>int8</"
"type>), <type>integer</type> (<type>int4</type>), and <type>smallint</type> "
"(<type>int2</type>) columns respectively. The family also contains cross-"
"data-type comparison operators allowing any two of these types to be "
"compared, so that an index on one of these types can be searched using a "
"comparison value of another type. The family could be duplicated by these "
"definitions: <placeholder-1/> Notice that this definition <quote>overloads</"
"quote> the operator strategy and support function numbers: each number "
"occurs multiple times within the family. This is allowed so long as each "
"instance of a particular number has distinct input data types. The instances "
"that have both input types equal to an operator class's input type are the "
"primary operators and support functions for that operator class, and in most "
"cases should be declared as part of the operator class rather than as loose "
"members of the family."
msgstr ""
"В качестве примера, в <productname>PostgreSQL</productname> есть встроенное "
"семейство операторов B-дерева <literal>integer_ops</literal>, включающее "
"классы операторов <literal>int8_ops</literal>, <literal>int4_ops</literal> и "
"<literal>int2_ops</literal> для индексов по столбцам <type>bigint</type> "
"(<type>int8</type>), <type>integer</type> (<type>int4</type>) и "
"<type>smallint</type> (<type>int2</type>), соответственно. В этом семействе "
"также содержатся операторы межтипового сравнения, позволяющие сравнивать "
"значения любых двух этих типов, так что индексом по любому из этих типов "
"можно пользоваться, выполняя сравнение с другим типом. Это семейство можно "
"представить такими определениями: <placeholder-1/> Заметьте, что в "
"определении семейства <quote>перегружаются</quote> номера стратегий "
"операторов и опорных функций: каждый номер фигурирует в семействе "
"неоднократно. Это допускается, если для каждого экземпляра определённого "
"номера задаются свои типы данных. Экземпляры, у которых оба входных типа "
"совпадают с входным типом класса операторов, являются первичными операторами "
"и опорными функциями для этого класса, и в большинстве случаев они должны "
"объявляться в составе класса операторов, а не быть слабосвязанными членами "
"семейства."

#: xindex.xml:1048(para)
msgid ""
"In a B-tree operator family, all the operators in the family must sort "
"compatibly, meaning that the transitive laws hold across all the data types "
"supported by the family: <quote>if A = B and B = C, then A = C</quote>, and "
"<quote>if A &lt; B and B &lt; C, then A &lt; C</quote>. Moreover, implicit "
"or binary coercion casts between types represented in the operator family "
"must not change the associated sort ordering. For each operator in the "
"family there must be a support function having the same two input data types "
"as the operator. It is recommended that a family be complete, i.e., for each "
"combination of data types, all operators are included. Each operator class "
"should include just the non-cross-type operators and support function for "
"its data type."
msgstr ""
"В семействе операторов B-дерева все операторы должны быть совместимыми в "
"контексте сортировки, то есть для всех типов данных, поддерживаемых "
"семейством, должны действовать транзитивные законы: <quote>если A = B и B = "
"C, то A = C</quote>, и <quote>если A &lt; B и B &lt; C, то A &lt; C</quote>. "
"Более того, неявное или двоичное приведение типов, представленных в "
"семействе операторов, не должно влиять на порядок сортировки. Для каждого "
"оператора в семействе должна существовать опорная функция, принимающая на "
"вход те же два типа, что и оператор. Семейство рекомендуется делать полным, "
"то есть включить в него все операторы для каждого сочетания типов данных. В "
"классы операторов следует включать только однотиповые операторы и опорные "
"функции для определённого типа данных."

#: xindex.xml:1062(para)
msgid ""
"To build a multiple-data-type hash operator family, compatible hash support "
"functions must be created for each data type supported by the family. Here "
"compatibility means that the functions are guaranteed to return the same "
"hash code for any two values that are considered equal by the family's "
"equality operators, even when the values are of different types. This is "
"usually difficult to accomplish when the types have different physical "
"representations, but it can be done in some cases. Furthermore, casting a "
"value from one data type represented in the operator family to another data "
"type also represented in the operator family via an implicit or binary "
"coercion cast must not change the computed hash value. Notice that there is "
"only one support function per data type, not one per equality operator. It "
"is recommended that a family be complete, i.e., provide an equality operator "
"for each combination of data types. Each operator class should include just "
"the non-cross-type equality operator and the support function for its data "
"type."
msgstr ""
"Чтобы создать семейство операторов хеширования для нескольких типов данных, "
"необходимо создать совместимые функции поддержки хеша для каждого типа "
"данных, который будет поддерживать семейство. Здесь под совместимостью "
"понимается гарантия получения одного хеш-кода для любых двух значений, "
"которые операторы сравнения в этом семействе считают равными, даже если они "
"имеют разные типы. Обычно это сложно осуществить, когда типы имеют разное "
"физическое представление, но в некоторых случаях всё же возможно. Более "
"того, преобразование значения одного типа данных, представленного в "
"семействе операторов, к другому типу, также представленному в этом "
"семействе, путём неявного или двоичного сведения не должно менять значение "
"вычисляемого хеша. Заметьте, что единственная опорная функция задаётся для "
"типа данных, а не для оператора равенства. Семейство рекомендуется делать "
"полным, то есть включить в него оператор равенства для всех сочетаний типов "
"данных. В классы операторов следует включать только однотиповый оператор "
"равенства и опорную функция для определённого типа данных."

#: xindex.xml:1080(para)
msgid ""
"GiST, SP-GiST, and GIN indexes do not have any explicit notion of cross-data-"
"type operations. The set of operators supported is just whatever the primary "
"support functions for a given operator class can handle."
msgstr ""
"В индексах GiST, SP-GiST и GIN межтиповые операции явно не выражены. "
"Множество поддерживаемых операторов определяется только теми операциями, "
"которые могут выполнять основные опорные функции заданного класса операторов."

#: xindex.xml:1087(para)
msgid ""
"In BRIN, the requirements depends on the framework that provides the "
"operator classes. For operator classes based on <literal>minmax</literal>, "
"the behavior required is the same as for B-tree operator families: all the "
"operators in the family must sort compatibly, and casts must not change the "
"associated sort ordering."
msgstr ""
"В BRIN требования зависят от инфраструктуры, предоставляющей классы "
"операторов. Для классов операторов, построенных на инфраструктуре "
"<literal>minmax</literal>, требуется то же поведение, что и для семейств "
"операторов B-дерева: все операторы в семействе должны поддерживать "
"совместимый порядок, а приведения не должны влиять на установленный порядок "
"сортировки."

#: xindex.xml:1096(para)
msgid ""
"Prior to <productname>PostgreSQL</productname> 8.3, there was no concept of "
"operator families, and so any cross-data-type operators intended to be used "
"with an index had to be bound directly into the index's operator class. "
"While this approach still works, it is deprecated because it makes an "
"index's dependencies too broad, and because the planner can handle cross-"
"data-type comparisons more effectively when both data types have operators "
"in the same operator family."
msgstr ""
"До версии 8.3 в <productname>PostgreSQL</productname> не было понятия "
"семейства операторов, поэтому любые межтиповые операторы, предназначенные "
"для применения с индексом, должны были привязываться непосредственно к "
"классу оператора индекса. Хотя этот подход по-прежнему работает, он "
"считается устаревшим, потому что он создаёт слишком много зависимостей для "
"индекса, а также потому, что планировщик может выполнять межтиповые "
"сравнения более эффективно, когда для обоих типов данных определены "
"операторы в одном семействе."

#: xindex.xml:1109(title)
msgid "System Dependencies on Operator Classes"
msgstr "Системные зависимости от классов операторов"

#: xindex.xml:1111(indexterm)
msgid "<primary>ordering operator</primary>"
msgstr "<primary>оператор упорядочивания</primary>"

#: xindex.xml:1115(para)
msgid ""
"<productname>PostgreSQL</productname> uses operator classes to infer the "
"properties of operators in more ways than just whether they can be used with "
"indexes. Therefore, you might want to create operator classes even if you "
"have no intention of indexing any columns of your data type."
msgstr ""
"<productname>PostgreSQL</productname> использует классы операторов для "
"наделения операторов такими свойствами, которые могут быть полезны не только "
"для индексов. Поэтому классы операторов могут быть полезны, даже если вы не "
"намерены индексировать столбцы со значениями определённого вами типа."

#: xindex.xml:1122(para)
msgid ""
"In particular, there are SQL features such as <literal>ORDER BY</literal> "
"and <literal>DISTINCT</literal> that require comparison and sorting of "
"values. To implement these features on a user-defined data type, "
"<productname>PostgreSQL</productname> looks for the default B-tree operator "
"class for the data type. The <quote>equals</quote> member of this operator "
"class defines the system's notion of equality of values for <literal>GROUP "
"BY</literal> and <literal>DISTINCT</literal>, and the sort ordering imposed "
"by the operator class defines the default <literal>ORDER BY</literal> "
"ordering."
msgstr ""
"В частности, это касается SQL-конструкций <literal>ORDER BY</literal> и "
"<literal>DISTINCT</literal>, для которых требуется сравнивать и "
"упорядочивать значения. Чтобы эти конструкции работали с определённым "
"пользователем типом данных, <productname>PostgreSQL</productname> "
"задействует класс операторов B-дерева по умолчанию для этого типа. Член "
"<quote>равно</quote> этого класса определяет, как система будет понимать "
"равенство значений для <literal>GROUP BY</literal> и <literal>DISTINCT</"
"literal>, а порядок сортировки, задаваемый классом операторов, определяет "
"порядок <literal>ORDER BY</literal> по умолчанию."

#: xindex.xml:1134(para)
msgid ""
"Comparison of arrays of user-defined types also relies on the semantics "
"defined by the default B-tree operator class."
msgstr ""
"Сравнение массивов пользовательских типов также зависит от семантики, "
"определённой классом операторов B-дерева по умолчанию."

#: xindex.xml:1139(para)
msgid ""
"If there is no default B-tree operator class for a data type, the system "
"will look for a default hash operator class. But since that kind of operator "
"class only provides equality, in practice it is only enough to support array "
"equality."
msgstr ""
"Если класс операторов B-дерева по умолчанию для типа данных не определён, "
"система будет искать класс операторов хеша по умолчанию. Но так как этот вид "
"класса поддерживает только равенство, на практике его достаточно только для "
"проверки равенства массивов."

#: xindex.xml:1146(para)
msgid ""
"When there is no default operator class for a data type, you will get errors "
"like <quote>could not identify an ordering operator</quote> if you try to "
"use these SQL features with the data type."
msgstr ""
"Если для типа не определён класс операторов по умолчанию, попытавшись "
"использовать эти конструкции SQL с данным типом, вы получите ошибку вида "
"<quote>не удалось найти оператор сортировки</quote>."

#: xindex.xml:1153(para)
msgid ""
"In <productname>PostgreSQL</productname> versions before 7.4, sorting and "
"grouping operations would implicitly use operators named <literal>=</"
"literal>, <literal>&lt;</literal>, and <literal>&gt;</literal>. The new "
"behavior of relying on default operator classes avoids having to make any "
"assumption about the behavior of operators with particular names."
msgstr ""
"До версии <productname>PostgreSQL</productname> 7.4, в операциях сортировки "
"и группировки неявно использовались операторы с именами <literal>=</"
"literal>, <literal>&lt;</literal> и <literal>&gt;</literal>. С новым "
"подходом, опирающимся на классы операторов по умолчанию, система не делает "
"никаких предположений о поведении операторов по их именам."

#: xindex.xml:1162(para)
msgid ""
"Another important point is that an operator that appears in a hash operator "
"family is a candidate for hash joins, hash aggregation, and related "
"optimizations. The hash operator family is essential here since it "
"identifies the hash function(s) to use."
msgstr ""
"Также важно отметить, что оператор, указанный в семействе операторов "
"хеширования, является кандидатом для применения при слиянии и агрегации по "
"хешу, а также связанной оптимизации. В данном случае от семейства операторов "
"зависит, какую функцию хеширования использовать."

#: xindex.xml:1171(title)
msgid "Ordering Operators"
msgstr "Операторы упорядочивания"

#: xindex.xml:1173(para)
msgid ""
"Some index access methods (currently, only GiST) support the concept of "
"<firstterm>ordering operators</firstterm>. What we have been discussing so "
"far are <firstterm>search operators</firstterm>. A search operator is one "
"for which the index can be searched to find all rows satisfying "
"<literal>WHERE</literal>\n"
"   <replaceable>indexed_column</replaceable>\n"
"   <replaceable>operator</replaceable>\n"
"   <replaceable>constant</replaceable>. Note that nothing is promised about "
"the order in which the matching rows will be returned. In contrast, an "
"ordering operator does not restrict the set of rows that can be returned, "
"but instead determines their order. An ordering operator is one for which "
"the index can be scanned to return rows in the order represented by "
"<literal>ORDER BY</literal>\n"
"   <replaceable>indexed_column</replaceable>\n"
"   <replaceable>operator</replaceable>\n"
"   <replaceable>constant</replaceable>. The reason for defining ordering "
"operators that way is that it supports nearest-neighbor searches, if the "
"operator is one that measures distance. For example, a query like "
"<placeholder-1/> finds the ten places closest to a given target point. A "
"GiST index on the location column can do this efficiently because "
"<literal>&lt;-&gt;</literal> is an ordering operator."
msgstr ""
"Некоторые методы доступа индексов (в настоящее время только GiST) "
"поддерживают концепцию <firstterm>операторов упорядочивания</firstterm>. "
"Операторы, которые мы обсуждали до этого, были <firstterm>операторами "
"поиска</firstterm>. Оператором поиска называется такой оператор, для "
"которого можно выполнить поиск по индексу и найти все строки, "
"удовлетворяющие условию <literal>WHERE</literal>\n"
"   <replaceable>индексированный_столбец</replaceable>\n"
"   <replaceable>оператор</replaceable>\n"
"   <replaceable>константа</replaceable>. Заметьте, что при этом ничего не "
"говорится о порядке, в котором будут возвращены подходящие строки. Оператор "
"упорядочивания, напротив, не ограничивает набор возвращаемых строк, но "
"определяет их порядок. С таким оператором, просканировав индекс, можно "
"получить строки в порядке, заданным указанием <literal>ORDER BY</literal>\n"
"   <replaceable>индексированный_столбец</replaceable>\n"
"   <replaceable>оператор</replaceable>\n"
"   <replaceable>константа</replaceable>. Такое определение объясняется тем, "
"что оно поддерживает поиск ближайшего соседа, если этот оператор вычисляет "
"расстояние. Например, запрос <placeholder-1/> находит десять ближайших к "
"заданной точке мест. Индекс GiST по столбцу location может сделать это "
"эффективно, так как <literal>&lt;-&gt;</literal> — это оператор "
"упорядочивания."

#: xindex.xml:1203(para)
msgid ""
"While search operators have to return Boolean results, ordering operators "
"usually return some other type, such as float or numeric for distances. This "
"type is normally not the same as the data type being indexed. To avoid hard-"
"wiring assumptions about the behavior of different data types, the "
"definition of an ordering operator is required to name a B-tree operator "
"family that specifies the sort ordering of the result data type. As was "
"stated in the previous section, B-tree operator families define "
"<productname>PostgreSQL</productname>'s notion of ordering, so this is a "
"natural representation. Since the point <literal>&lt;-&gt;</literal> "
"operator returns <type>float8</type>, it could be specified in an operator "
"class creation command like this: <placeholder-1/> where <literal>float_ops</"
"literal> is the built-in operator family that includes operations on "
"<type>float8</type>. This declaration states that the index is able to "
"return rows in order of increasing values of the <literal>&lt;-&gt;</"
"literal> operator."
msgstr ""
"Тогда как операторы поиска должны возвращать булевские результаты, операторы "
"упорядочивания обычно возвращают другой тип, например, float или numeric для "
"расстояний. Этот тип, как правило, отличается от типа индексируемых данных. "
"Чтобы избежать жёстко запрограммированных предположений о поведении "
"различных типов данных, при объявлении оператора упорядочивания должно "
"указываться семейство операторов B-дерева, определяющее порядок сортировки "
"результирующего типа данных. Как было отмечено в предыдущем разделе, "
"семейства операторов B-дерева определяют понятие упорядочивания для "
"<productname>PostgreSQL</productname>, так что такое объявление оказывается "
"естественным. Так как оператор <literal>&lt;-&gt;</literal> для точек "
"возвращает <type>float8</type>, его можно включить в команду создания класса "
"операторов так: <placeholder-1/> где <literal>float_ops</literal> — "
"встроенное семейство операторов, включающее операции с <type>float8</type>. "
"Это объявление означает, что индекс может возвращать строки в порядке "
"увеличения значений оператора <literal>&lt;-&gt;</literal>."

#: xindex.xml:1227(title)
msgid "Special Features of Operator Classes"
msgstr "Особенности классов операторов"

#: xindex.xml:1229(para)
msgid ""
"There are two special features of operator classes that we have not "
"discussed yet, mainly because they are not useful with the most commonly "
"used index methods."
msgstr ""
"Есть ещё две особенности классов операторов, которые мы до этого не "
"обсуждали, в первую очередь потому, что они не востребованы для наиболее "
"часто применяемых методов индексов."

#: xindex.xml:1239(programlisting)
#, no-wrap
msgid "SELECT * FROM table WHERE integer_column &lt; 4;"
msgstr "SELECT * FROM table WHERE integer_column &lt; 4;"

#: xindex.xml:1235(para)
msgid ""
"Normally, declaring an operator as a member of an operator class (or family) "
"means that the index method can retrieve exactly the set of rows that "
"satisfy a <literal>WHERE</literal> condition using the operator. For "
"example: <placeholder-1/> can be satisfied exactly by a B-tree index on the "
"integer column. But there are cases where an index is useful as an inexact "
"guide to the matching rows. For example, if a GiST index stores only "
"bounding boxes for geometric objects, then it cannot exactly satisfy a "
"<literal>WHERE</literal> condition that tests overlap between nonrectangular "
"objects such as polygons. Yet we could use the index to find objects whose "
"bounding box overlaps the bounding box of the target object, and then do the "
"exact overlap test only on the objects found by the index. If this scenario "
"applies, the index is said to be <quote>lossy</quote> for the operator. "
"Lossy index searches are implemented by having the index method return a "
"<firstterm>recheck</firstterm> flag when a row might or might not really "
"satisfy the query condition. The core system will then test the original "
"query condition on the retrieved row to see whether it should be returned as "
"a valid match. This approach works if the index is guaranteed to return all "
"the required rows, plus perhaps some additional rows, which can be "
"eliminated by performing the original operator invocation. The index methods "
"that support lossy searches (currently, GiST, SP-GiST and GIN) allow the "
"support functions of individual operator classes to set the recheck flag, "
"and so this is essentially an operator-class feature."
msgstr ""
"Обычно объявление оператора в качестве члена класса операторов (или "
"семейства) означает, что метод индекса может получить точно набор строк, "
"который удовлетворяет условию <literal>WHERE</literal> с этим оператором. "
"Например, запрос: <placeholder-1/> может быть удовлетворён в точности "
"индексом-B-деревом по целочисленному столбцу. Но бывают случаи, когда индекс "
"полезен как приблизительный указатель на соответствующие строки. Например, "
"если индекс GiST хранит только прямоугольники, описанные вокруг "
"геометрических объектов, он не может точно удовлетворить условие "
"<literal>WHERE</literal>, которое проверяет пересечение не прямоугольных "
"объектов, а например, многоугольников. Однако этот индекс можно применить, "
"чтобы найти объекты, для которых описанные вокруг прямоугольники "
"пересекаются с прямоугольником, описанным вокруг целевого объекта, а затем "
"провести точную проверку пересечения только для найденных по индексу "
"объектов. Если это имеет место, такой индекс называется <quote>неточным</"
"quote> для оператора. Для реализации поиска по неточному индексу метод "
"индекса возвращает флаг <firstterm>recheck</firstterm> (перепроверить), "
"когда строка может действительно удовлетворять, а может не удовлетворять "
"условию запроса. Затем исполнитель запроса перепроверяет полученную строку "
"по исходному условию запроса и определяет, должна ли она выдаваться как "
"действительно соответствующая ему. Этот подход работает, если индекс "
"гарантированно выдаёт все требуемые строки плюс, возможно, дополнительные "
"строки, которые можно исключить, вызвав первоначальный оператор. Методы "
"индексов, поддерживающие неточный поиск (в настоящее время, GiST, SP-GiST и "
"GIN), позволяют устанавливать флаг recheck опорным функциям отдельных "
"классов операторов, так что по сути это особенность класса операторов."

#: xindex.xml:1272(programlisting)
#, no-wrap
msgid ""
"CREATE OPERATOR CLASS polygon_ops\n"
"    DEFAULT FOR TYPE polygon USING gist AS\n"
"        ...\n"
"        STORAGE box;"
msgstr ""
"CREATE OPERATOR CLASS polygon_ops\n"
"    DEFAULT FOR TYPE polygon USING gist AS\n"
"        ...\n"
"        STORAGE box;"

#: xindex.xml:1264(para)
msgid ""
"Consider again the situation where we are storing in the index only the "
"bounding box of a complex object such as a polygon. In this case there's not "
"much value in storing the whole polygon in the index entry &mdash; we might "
"as well store just a simpler object of type <type>box</type>. This situation "
"is expressed by the <literal>STORAGE</literal> option in <command>CREATE "
"OPERATOR CLASS</command>: we'd write something like: <placeholder-1/> At "
"present, only the GiST, GIN and BRIN index methods support a "
"<literal>STORAGE</literal> type that's different from the column data type. "
"The GiST <function>compress</function> and <function>decompress</function> "
"support routines must deal with data-type conversion when <literal>STORAGE</"
"literal> is used. In GIN, the <literal>STORAGE</literal> type identifies the "
"type of the <quote>key</quote> values, which normally is different from the "
"type of the indexed column &mdash; for example, an operator class for "
"integer-array columns might have keys that are just integers. The GIN "
"<function>extractValue</function> and <function>extractQuery</function> "
"support routines are responsible for extracting keys from indexed values. "
"BRIN is similar to GIN: the <literal>STORAGE</literal> type identifies the "
"type of the stored summary values, and operator classes' support procedures "
"are responsible for interpreting the summary values correctly."
msgstr ""
"Вернёмся к ситуации, когда мы храним в индексе только прямоугольник, "
"описанный вокруг сложного объекта, такого как многоугольник. В этом случае "
"нет большого смысла хранить в элементе индекса весь многоугольник &mdash; мы "
"можем с тем же успехом хранить более простой объект типа <type>box</type>. "
"Это отклонение выражается указанием <literal>STORAGE</literal> в команде "
"<command>CREATE OPERATOR CLASS</command>, которое записывается примерно так: "
"<placeholder-1/> В настоящее время, только методы индексов GiST, GIN и BRIN "
"позволяют задать в <literal>STORAGE</literal> тип, отличный от типа данных "
"столбца. В GiST преобразованием данных, связанным с использованием "
"<literal>STORAGE</literal>, должны заниматься опорные процедуры "
"<function>compress</function> и <function>decompress</function>. В GIN тип "
"<literal>STORAGE</literal> определяет тип значений <quote>ключа</quote>, "
"который обычно отличается от типа индексируемого столбца &mdash; например, в "
"классе операторов для столбцов с целочисленным массивом ключами могут быть "
"просто целые числа. За извлечение ключей из индексированных значений в GIN "
"отвечают опорные функции <function>extractValue</function> и "
"<function>extractQuery</function>. BRIN похож на GIN: в нём тип "
"<literal>STORAGE</literal> определяет тип хранимых обобщённых значений, а "
"опорные процедуры классов операторов отвечают за правильное прочтение этих "
"значений."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: xindex.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
