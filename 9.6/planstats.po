# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-11 12:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: planstats.xml:5(title)
msgid "How the Planner Uses Statistics"
msgstr "Как планировщик использует статистику"

#: planstats.xml:7(para)
msgid ""
"This chapter builds on the material covered in <xref linkend=\"using-explain"
"\"/> and <xref linkend=\"planner-stats\"/> to show some additional details "
"about how the planner uses the system statistics to estimate the number of "
"rows each part of a query might return. This is a significant part of the "
"planning process, providing much of the raw material for cost calculation."
msgstr ""
"Данная глава основана на материалах, рассмотренных ранее (см. <xref remap="
"\"4\" linkend=\"using-explain\"/> и <xref remap=\"4\" linkend=\"planner-stats"
"\"/>), и подробнее рассказывает о том, как планировщик использует статистику "
"для определения количества строк, которое может вернуть каждая часть "
"запроса. Это важная составляющая процесса создания плана запроса, "
"предоставляющая большую часть исходного материала для расчёта стоимости."

#: planstats.xml:16(para)
msgid ""
"The intent of this chapter is not to document the code in detail, but to "
"present an overview of how it works. This will perhaps ease the learning "
"curve for someone who subsequently wishes to read the code."
msgstr ""
"Целью данной главы является не подробное документирование кода, а общее "
"описание его работы. Возможно, это поможет тем, кто пожелает в дальнейшем "
"ознакомиться с кодом."

#: planstats.xml:24(title)
msgid "Row Estimation Examples"
msgstr "Примеры оценки количества строк"

#: planstats.xml:26(indexterm)
msgid "<primary>row estimation</primary><secondary>planner</secondary>"
msgstr ""
"<primary>Оценка количества строк</primary><secondary> планировщик</secondary>"

#: planstats.xml:30(para)
msgid ""
"The examples shown below use tables in the <productname>PostgreSQL</"
"productname> regression test database. The outputs shown are taken from "
"version 8.3. The behavior of earlier (or later) versions might vary. Note "
"also that since <command>ANALYZE</command> uses random sampling while "
"producing statistics, the results will change slightly after any new "
"<command>ANALYZE</command>."
msgstr ""
"В приведённых ниже примерах используются таблицы базы данных регрессионного "
"тестирования <productname>PostgreSQL</productname>. Приведённые листинги "
"получены в версии 8.3. Поведение более ранних (или поздних) версий может "
"отличаться. Заметьте также, что поскольку команда <command>ANALYZE</command> "
"использует случайную выборку при формировании статистики, после любого "
"нового выполнения команды <command>ANALYZE</command> результаты "
"незначительно изменятся."

#: planstats.xml:43(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1;\n"
"\n"
"                         QUERY PLAN\n"
"-------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1;\n"
"\n"
"                         QUERY PLAN\n"
"-------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..458.00 rows=10000 width=244)"

#: planstats.xml:56(programlisting)
#, no-wrap
msgid ""
"SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';\n"
"\n"
" relpages | reltuples\n"
"----------+-----------\n"
"      358 |     10000"
msgstr ""
"SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';\n"
"\n"
" relpages | reltuples\n"
"----------+-----------\n"
"      358 |     10000"

#: planstats.xml:40(para)
msgid ""
"Let's start with a very simple query: <placeholder-1/> How the planner "
"determines the cardinality of <structname>tenk1</structname> is covered in "
"<xref linkend=\"planner-stats\"/>, but is repeated here for completeness. "
"The number of pages and rows is looked up in <structname>pg_class</"
"structname>: <placeholder-2/> These numbers are current as of the last "
"<command>VACUUM</command> or <command>ANALYZE</command> on the table. The "
"planner then fetches the actual current number of pages in the table (this "
"is a cheap operation, not requiring a table scan). If that is different from "
"<structfield>relpages</structfield> then <structfield>reltuples</"
"structfield> is scaled accordingly to arrive at a current number-of-rows "
"estimate. In the example above, the value of <structfield>relpages</"
"structfield> is up-to-date so the rows estimate is the same as "
"<structfield>reltuples</structfield>."
msgstr ""
"Давайте начнём с очень простого запроса: <placeholder-1/> Как планировщик "
"определяет мощность <structname>tenk1</structname>, рассматривается выше "
"(см. <xref remap=\"4\" linkend=\"planner-stats\"/>), но для полноты здесь "
"говорится об этом ещё раз. Количество страниц и строк берётся в "
"<structname>pg_class</structname>: <placeholder-2/>Это текущие цифры, "
"полученные при последнем выполнении команд <command>VACUUM</command> или "
"<command>ANALYZE</command>, применённых к этой таблице. Затем планировщик "
"выполняет выборку фактического текущего числа страниц в таблице (это "
"недорогая операция, для которой не требуется сканирование таблицы). Если оно "
"отличается от <structfield>relpages</structfield>, то "
"<structfield>reltuples</structfield> изменяется для того, чтобы привести это "
"значение к текущей оценке количества строк. В показанном выше примере "
"значение <structfield>relpages</structfield> является актуальным, поэтому "
"количество строк берётся равным <structfield>reltuples</structfield>."

#: planstats.xml:79(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;\n"
"\n"
"                                   QUERY PLAN\n"
"--------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=24.06..394.64 rows=1007 width=244)\n"
"   Recheck Cond: (unique1 &lt; 1000)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)\n"
"         Index Cond: (unique1 &lt; 1000)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000;\n"
"\n"
"                                   QUERY PLAN\n"
"--------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=24.06..394.64 rows=1007 width=244)\n"
"   Recheck Cond: (unique1 &lt; 1000)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)\n"
"         Index Cond: (unique1 &lt; 1000)"

#: planstats.xml:101(programlisting)
#, no-wrap
msgid ""
"SELECT histogram_bounds FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='unique1';\n"
"\n"
"                   histogram_bounds\n"
"------------------------------------------------------\n"
" {0,993,1997,3050,4040,5036,5957,7057,8029,9016,9995}"
msgstr ""
"SELECT histogram_bounds FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='unique1';\n"
"\n"
"                   histogram_bounds\n"
"------------------------------------------------------\n"
" {0,993,1997,3050,4040,5036,5957,7057,8029,9016,9995}"

#: planstats.xml:118(programlisting)
#, no-wrap
msgid ""
"selectivity = (1 + (1000 - bucket[2].min)/(bucket[2].max - bucket[2].min))/num_buckets\n"
"            = (1 + (1000 - 993)/(1997 - 993))/10\n"
"            = 0.100697"
msgstr ""
"selectivity = (1 + (1000 - bucket[2].min)/(bucket[2].max - bucket[2].min))/num_buckets\n"
"            = (1 + (1000 - 993)/(1997 - 993))/10\n"
"            = 0.100697"

#: planstats.xml:129(programlisting)
#, no-wrap
msgid ""
"rows = rel_cardinality * selectivity\n"
"     = 10000 * 0.100697\n"
"     = 1007  (rounding off)"
msgstr ""
"rows = rel_cardinality * selectivity\n"
"     = 10000 * 0.100697\n"
"     = 1007  (округлённо)"

#: planstats.xml:75(para)
msgid ""
"Let's move on to an example with a range condition in its <literal>WHERE</"
"literal> clause: <placeholder-1/> The planner examines the <literal>WHERE</"
"literal> clause condition and looks up the selectivity function for the "
"operator <literal>&lt;</literal> in <structname>pg_operator</structname>. "
"This is held in the column <structfield>oprrest</structfield>, and the entry "
"in this case is <function>scalarltsel</function>. The <function>scalarltsel</"
"function> function retrieves the histogram for <structfield>unique1</"
"structfield> from <structname>pg_statistics</structname>. For manual queries "
"it is more convenient to look in the simpler <structname>pg_stats</"
"structname> view: <placeholder-2/> Next the fraction of the histogram "
"occupied by <quote>&lt; 1000</quote> is worked out. This is the selectivity. "
"The histogram divides the range into equal frequency buckets, so all we have "
"to do is locate the bucket that our value is in and count <emphasis>part</"
"emphasis> of it and <emphasis>all</emphasis> of the ones before. The value "
"1000 is clearly in the second bucket (993-1997). Assuming a linear "
"distribution of values inside each bucket, we can calculate the selectivity "
"as: <placeholder-3/> that is, one whole bucket plus a linear fraction of the "
"second, divided by the number of buckets. The estimated number of rows can "
"now be calculated as the product of the selectivity and the cardinality of "
"<structname>tenk1</structname>: <placeholder-4/>"
msgstr ""
"Давайте обратимся к примеру с диапазонным условием в предложении "
"<literal>WHERE</literal>: <placeholder-1/> Планировщик рассматривает условие "
"предложения <literal>WHERE</literal> и находит в справочнике функцию "
"избирательности для оператора <literal>&lt;</literal> в "
"<structname>pg_operator</structname>. Это значение содержится в столбце "
"<structfield>oprrest</structfield>, и в данном случае значением является "
"<function>scalarltsel</function>. Функция <function>scalarltsel</function> "
"извлекает гистограмму для <structfield>unique1</structfield> из "
"<structname>pg_statistics</structname>. Для вводимых вручную запросов "
"удобнее просматривать более простое представление <structname>pg_stats</"
"structname>: <placeholder-2/> Затем обрабатывается часть гистограммы, "
"которая соответствует условию <quote>&lt; 1000</quote>. Таким образом и "
"определяется избирательность. Гистограмма делит диапазон на равные частотные "
"группы, поэтому нужно лишь определить группу, содержащую наше значение, и "
"подсчитать её <emphasis> долю </emphasis> и <emphasis> долю групп</"
"emphasis>, предшествующих данной. Очевидно, что значение 1000 находится во "
"второй группе (993-1997). Если предположить, что внутри каждой группы "
"распределение значений линейное, мы можем вычислить избирательность "
"следующим образом: <placeholder-3/> т. е. сумма элементов одной целой группы "
"и пропорциональной части элементов второй, делённая на число групп. Теперь "
"примерное число строк может быть рассчитано как произведение избирательности "
"и мощности <structname>tenk1</structname>: <placeholder-4/>"

#: planstats.xml:140(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'CRAAAA';\n"
"\n"
"                        QUERY PLAN\n"
"----------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=30 width=244)\n"
"   Filter: (stringu1 = 'CRAAAA'::name)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'CRAAAA';\n"
"\n"
"                        QUERY PLAN\n"
"----------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=30 width=244)\n"
"   Filter: (stringu1 = 'CRAAAA'::name)"

#: planstats.xml:157(programlisting)
#, no-wrap
msgid ""
"SELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='stringu1';\n"
"\n"
"null_frac         | 0\n"
"n_distinct        | 676\n"
"most_common_vals  | {EJAAAA,BBAAAA,CRAAAA,FCAAAA,FEAAAA,GSAAAA,JOAAAA,MCAAAA,NAAAAA,WGAAAA}\n"
"most_common_freqs | {0.00333333,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003}"
msgstr ""
"SELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='stringu1';\n"
"\n"
"null_frac         | 0\n"
"n_distinct        | 676\n"
"most_common_vals  | {EJAAAA,BBAAAA,CRAAAA,FCAAAA,FEAAAA,GSAAAA,JOAAAA,MCAAAA,NAAAAA,WGAAAA}\n"
"most_common_freqs | {0.00333333,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003,0.003}"

#: planstats.xml:172(programlisting)
#, no-wrap
msgid ""
"selectivity = mcf[3]\n"
"            = 0.003"
msgstr ""
"selectivity = mcf[3]\n"
"            = 0.003"

#: planstats.xml:180(programlisting)
#, no-wrap
msgid ""
"rows = 10000 * 0.003\n"
"     = 30"
msgstr ""
"rows = 10000 * 0.003\n"
"     = 30"

#: planstats.xml:136(para)
msgid ""
"Next let's consider an example with an equality condition in its "
"<literal>WHERE</literal> clause: <placeholder-1/> Again the planner examines "
"the <literal>WHERE</literal> clause condition and looks up the selectivity "
"function for <literal>=</literal>, which is <function>eqsel</function>. For "
"equality estimation the histogram is not useful; instead the list of "
"<firstterm>most common values</firstterm> (<acronym>MCV</acronym>s) is used "
"to determine the selectivity. Let's have a look at the MCVs, with some "
"additional columns that will be useful later: <placeholder-2/> Since "
"<literal>CRAAAA</literal> appears in the list of MCVs, the selectivity is "
"merely the corresponding entry in the list of most common frequencies "
"(<acronym>MCF</acronym>s): <placeholder-3/> As before, the estimated number "
"of rows is just the product of this with the cardinality of "
"<structname>tenk1</structname>: <placeholder-4/>"
msgstr ""
"Далее, давайте рассмотрим пример с условием на равенство в предложении "
"<literal>WHERE</literal>: <placeholder-1/> Планировщик вновь проверяет "
"условие в предложении <literal>WHERE</literal> и определяет функцию "
"избирательности для <literal>=</literal>, и этой функцией является "
"<function>eqsel</function>. Для оценки равенства гистограмма бесполезна, "
"вместо неё для оценки избирательности используется список "
"<firstterm>наиболее распространённых значений</firstterm> (Most Commom "
"Values, <acronym>MCV</acronym>). Давайте рассмотрим MCV и соответствующие "
"дополнительные столбцы, которые пригодятся позже: <placeholder-2/> Так как "
"значение <literal>CRAAAA</literal> оказалось в списке MCV, избирательность "
"будет определяться просто соответствующим элементом в списке частот наиболее "
"распространённых значений (Most Common Frequencies, MCF): <placeholder-3/> "
"Как и в предыдущем примере, оценка числа строк берётся как произведение "
"мощности и избирательности <structname>tenk1</structname>: <placeholder-4/>"

#: planstats.xml:190(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'xxx';\n"
"\n"
"                        QUERY PLAN\n"
"----------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=15 width=244)\n"
"   Filter: (stringu1 = 'xxx'::name)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'xxx';\n"
"\n"
"                        QUERY PLAN\n"
"----------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=15 width=244)\n"
"   Filter: (stringu1 = 'xxx'::name)"

#: planstats.xml:205(programlisting)
#, no-wrap
msgid ""
"selectivity = (1 - sum(mvf))/(num_distinct - num_mcv)\n"
"            = (1 - (0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003 +\n"
"                    0.003 + 0.003 + 0.003 + 0.003))/(676 - 10)\n"
"            = 0.0014559"
msgstr ""
"selectivity = (1 - sum(mvf))/(num_distinct - num_mcv)\n"
"            = (1 - (0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003 +\n"
"                    0.003 + 0.003 + 0.003 + 0.003))/(676 - 10)\n"
"            = 0.0014559"

#: planstats.xml:221(programlisting)
#, no-wrap
msgid ""
"rows = 10000 * 0.0014559\n"
"     = 15  (rounding off)"
msgstr ""
"rows = 10000 * 0.0014559\n"
"     = 15  (округлённо)"

#: planstats.xml:186(para)
msgid ""
"Now consider the same query, but with a constant that is not in the "
"<acronym>MCV</acronym> list: <placeholder-1/> This is quite a different "
"problem: how to estimate the selectivity when the value is <emphasis>not</"
"emphasis> in the <acronym>MCV</acronym> list. The approach is to use the "
"fact that the value is not in the list, combined with the knowledge of the "
"frequencies for all of the <acronym>MCV</acronym>s: <placeholder-2/> That "
"is, add up all the frequencies for the <acronym>MCV</acronym>s and subtract "
"them from one, then divide by the number of <emphasis>other</emphasis> "
"distinct values. This amounts to assuming that the fraction of the column "
"that is not any of the MCVs is evenly distributed among all the other "
"distinct values. Notice that there are no null values so we don't have to "
"worry about those (otherwise we'd subtract the null fraction from the "
"numerator as well). The estimated number of rows is then calculated as "
"usual: <placeholder-3/>"
msgstr ""
"Теперь рассмотрим тот же самый запрос, но с константой, которой нет в списке "
"<acronym>MCV</acronym>: <placeholder-1/> Это совершенно другая задача — как "
"оценить избирательность значения, которого <emphasis>нет</emphasis> в списке "
"<acronym>MCV</acronym>. При её решении используется факт отсутствия данного "
"значения в списке в сочетании с частотой для каждого значения из списка "
"<acronym>MCV</acronym>. <placeholder-2/> Т. е. нужно сложить частоты "
"значений из списка <acronym>MCV</acronym>, отнять полученное число от "
"единицы, и полученное значение разделить на количество <emphasis>остальных</"
"emphasis> уникальных значений. Эти вычисления основаны на предположении, что "
"значения, которые не входят в список MCV, имеют равномерное распределение. "
"Заметьте, что в данном примере нет неопределённых значений, поэтому о них "
"беспокоиться не нужно (иначе их долю также пришлось бы вычитать из "
"числителя). Оценка числа строк затем производится как обычно: <placeholder-3/"
">"

#: planstats.xml:247(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 &lt; 'IAAAAA';\n"
"\n"
"                         QUERY PLAN\n"
"------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=3077 width=244)\n"
"   Filter: (stringu1 &lt; 'IAAAAA'::name)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 WHERE stringu1 &lt; 'IAAAAA';\n"
"\n"
"                         QUERY PLAN\n"
"------------------------------------------------------------\n"
" Seq Scan on tenk1  (cost=0.00..483.00 rows=3077 width=244)\n"
"   Filter: (stringu1 &lt; 'IAAAAA'::name)"

#: planstats.xml:259(programlisting)
#, no-wrap
msgid ""
"SELECT histogram_bounds FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='stringu1';\n"
"\n"
"                                histogram_bounds\n"
"--------------------------------------------------------------------------------\n"
" {AAAAAA,CQAAAA,FRAAAA,IBAAAA,KRAAAA,NFAAAA,PSAAAA,SGAAAA,VAAAAA,XLAAAA,ZZAAAA}"
msgstr ""
"SELECT histogram_bounds FROM pg_stats\n"
"WHERE tablename='tenk1' AND attname='stringu1';\n"
"\n"
"                                histogram_bounds\n"
"--------------------------------------------------------------------------------\n"
" {AAAAAA,CQAAAA,FRAAAA,IBAAAA,KRAAAA,NFAAAA,PSAAAA,SGAAAA,VAAAAA,XLAAAA,ZZAAAA}"

#: planstats.xml:272(programlisting)
#, no-wrap
msgid ""
"selectivity = sum(relevant mvfs)\n"
"            = 0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003\n"
"            = 0.01833333"
msgstr ""
"selectivity = sum(relevant mvfs)\n"
"            = 0.00333333 + 0.003 + 0.003 + 0.003 + 0.003 + 0.003\n"
"            = 0.01833333"

#: planstats.xml:289(programlisting)
#, no-wrap
msgid ""
"selectivity = mcv_selectivity + histogram_selectivity * histogram_fraction\n"
"            = 0.01833333 + 0.298387 * 0.96966667\n"
"            = 0.307669\n"
"\n"
"rows        = 10000 * 0.307669\n"
"            = 3077  (rounding off)"
msgstr ""
"selectivity = mcv_selectivity + histogram_selectivity * histogram_fraction\n"
"            = 0.01833333 + 0.298387 * 0.96966667\n"
"            = 0.307669\n"
"\n"
"rows        = 10000 * 0.307669\n"
"            = 3077  (округлённо)"

#: planstats.xml:227(para)
msgid ""
"The previous example with <literal>unique1 &lt; 1000</literal> was an "
"oversimplification of what <function>scalarltsel</function> really does; now "
"that we have seen an example of the use of MCVs, we can fill in some more "
"detail. The example was correct as far as it went, because since "
"<structfield>unique1</structfield> is a unique column it has no MCVs "
"(obviously, no value is any more common than any other value). For a non-"
"unique column, there will normally be both a histogram and an MCV list, and "
"<emphasis>the histogram does not include the portion of the column "
"population represented by the MCVs</emphasis>. We do things this way because "
"it allows more precise estimation. In this situation <function>scalarltsel</"
"function> directly applies the condition (e.g., <quote>&lt; 1000</quote>) to "
"each value of the MCV list, and adds up the frequencies of the MCVs for "
"which the condition is true. This gives an exact estimate of the selectivity "
"within the portion of the table that is MCVs. The histogram is then used in "
"the same way as above to estimate the selectivity in the portion of the "
"table that is not MCVs, and then the two numbers are combined to estimate "
"the overall selectivity. For example, consider <placeholder-1/> We already "
"saw the MCV information for <structfield>stringu1</structfield>, and here is "
"its histogram: <placeholder-2/> Checking the MCV list, we find that the "
"condition <literal>stringu1 &lt; 'IAAAAA'</literal> is satisfied by the "
"first six entries and not the last four, so the selectivity within the MCV "
"part of the population is <placeholder-3/> Summing all the MCFs also tells "
"us that the total fraction of the population represented by MCVs is "
"0.03033333, and therefore the fraction represented by the histogram is "
"0.96966667 (again, there are no nulls, else we'd have to exclude them here). "
"We can see that the value <literal>IAAAAA</literal> falls nearly at the end "
"of the third histogram bucket. Using some rather cheesy assumptions about "
"the frequency of different characters, the planner arrives at the estimate "
"0.298387 for the portion of the histogram population that is less than "
"<literal>IAAAAA</literal>. We then combine the estimates for the MCV and non-"
"MCV populations: <placeholder-4/> In this particular example, the correction "
"from the MCV list is fairly small, because the column distribution is "
"actually quite flat (the statistics showing these particular values as being "
"more common than others are mostly due to sampling error). In a more typical "
"case where some values are significantly more common than others, this "
"complicated process gives a useful improvement in accuracy because the "
"selectivity for the most common values is found exactly."
msgstr ""
"Предыдущий пример с <literal>unique1 &lt; 1000</literal> был большим "
"упрощением того, что в действительности делает <function>scalarltsel</"
"function>. Но после того, как мы увидели пример использования списка MCV, мы "
"можем внести некоторые дополнения. Что касается самого примера, в нём все "
"было правильно, поскольку <structfield>unique1</structfield> это уникальный "
"столбец, у него нет значений в списке MCV (очевидно, в данном случае нет "
"значения, которое является более распространённым, чем любое другое). Для "
"неуникального столбца обычно создаётся как гистограмма, так и список MCV, "
"при этом <emphasis>гистограмма не включает значения, представленные в списке "
"MCV</emphasis>. Данный способ позволяет выполнить более точный подсчёт. В "
"этой ситуации <function>scalarltsel</function> напрямую применяет условие "
"<quote>&lt; 1000</quote> к каждому значению списка MCV и суммирует частоты "
"значений MCV, для которых условие является верным. Это даёт точную оценку "
"избирательности для той части таблицы, которая содержит значения из списка "
"MCV. Подобным же образом используется гистограмма для оценки избирательности "
"для той части таблицы, которая не содержит значения из списка MCV, а затем "
"эти две цифры складываются для оценки общей избирательности. Например, "
"рассмотрим <placeholder-1/> Мы уже видели данные списка MCV для "
"<structfield>stringu1</structfield>, а это его гистограмма: <placeholder-2/> "
"Проверяя список MCV, находим, что условие <literal>stringu1 &lt; 'IAAAAA'</"
"literal> соответствует первым шести записям, но не соответствует последним "
"четырём, поэтому избирательность для значений, соответствующих значениям в "
"списке MCV, такова: <placeholder-3/> Сумма всех частот из списка MCF также "
"сообщает нам, что общая часть представленной списком MCV совокупности "
"записей равняется 0.03033333, и поэтому представленная гистограммой часть "
"равняется 0.96966667 (в этом случае тоже нет неопределённых значений, иначе "
"их пришлось бы также исключить). Видно, что значение <literal>IAAAAA</"
"literal> попадает почти в конец третьего столбца гистограммы. Основываясь на "
"простых предположениях относительно частоты различных символов, планировщик "
"получает число 0.298387 для части значений, представленных в гистограмме, "
"которые меньше чем <literal>IAAAAA</literal>. Затем объединяем оценки части "
"значений из списка MCV и значений, не содержащихся в нём: <placeholder-4/> В "
"этом конкретном примере, корректировка со стороны списка MCV достаточно "
"мала, потому что распределение значений столбца довольно плоское "
"(статистика, показывающая конкретные значения как более распространённые, "
"чаще всего получается вследствие статистической погрешности). В более "
"типичном случае, когда некоторые значения являются значительно более "
"распространёнными по сравнению с другими, этот более сложный метод повышает "
"точность вследствие точного определения избирательности наиболее "
"распространённых значений."

#: planstats.xml:311(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000 AND stringu1 = 'xxx';\n"
"\n"
"                                   QUERY PLAN\n"
"--------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=23.80..396.91 rows=1 width=244)\n"
"   Recheck Cond: (unique1 &lt; 1000)\n"
"   Filter: (stringu1 = 'xxx'::name)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)\n"
"         Index Cond: (unique1 &lt; 1000)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 1000 AND stringu1 = 'xxx';\n"
"\n"
"                                   QUERY PLAN\n"
"--------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tenk1  (cost=23.80..396.91 rows=1 width=244)\n"
"   Recheck Cond: (unique1 &lt; 1000)\n"
"   Filter: (stringu1 = 'xxx'::name)\n"
"   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..23.80 rows=1007 width=0)\n"
"         Index Cond: (unique1 &lt; 1000)"

#: planstats.xml:326(programlisting)
#, no-wrap
msgid ""
"selectivity = selectivity(unique1 &lt; 1000) * selectivity(stringu1 = 'xxx')\n"
"            = 0.100697 * 0.0014559\n"
"            = 0.0001466\n"
"\n"
"rows        = 10000 * 0.0001466\n"
"            = 1  (rounding off)"
msgstr ""
"selectivity = selectivity(unique1 &lt; 1000) * selectivity(stringu1 = 'xxx')\n"
"            = 0.100697 * 0.0014559\n"
"            = 0.0001466\n"
"\n"
"rows        = 10000 * 0.0001466\n"
"            = 1  (округлённо)"

#: planstats.xml:307(para)
msgid ""
"Now let's consider a case with more than one condition in the "
"<literal>WHERE</literal> clause: <placeholder-1/> The planner assumes that "
"the two conditions are independent, so that the individual selectivities of "
"the clauses can be multiplied together: <placeholder-2/> Notice that the "
"number of rows estimated to be returned from the bitmap index scan reflects "
"only the condition used with the index; this is important since it affects "
"the cost estimate for the subsequent heap fetches."
msgstr ""
"Теперь давайте рассмотрим случай с более чем одним условием в предложении "
"<literal>WHERE</literal>: <placeholder-1/> Планировщик исходит из того, что "
"два условия независимы, таким образом, отдельные значения избирательности "
"можно перемножить: <placeholder-2/> Заметьте, что число строк, которые "
"предполагается вернуть через сканирование битового индекса, соответствует "
"условию, используемому при работе индекса; это важно, так как влияет на "
"оценку стоимости для последующих выборок из таблицы."

#: planstats.xml:344(programlisting)
#, no-wrap
msgid ""
"EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                      QUERY PLAN\n"
"--------------------------------------------------------------------------------------\n"
" Nested Loop  (cost=4.64..456.23 rows=50 width=488)\n"
"   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.64..142.17 rows=50 width=244)\n"
"         Recheck Cond: (unique1 &lt; 50)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.63 rows=50 width=0)\n"
"               Index Cond: (unique1 &lt; 50)\n"
"   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..6.27 rows=1 width=244)\n"
"         Index Cond: (unique2 = t1.unique2)"
msgstr ""
"EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2\n"
"WHERE t1.unique1 &lt; 50 AND t1.unique2 = t2.unique2;\n"
"\n"
"                                      QUERY PLAN\n"
"--------------------------------------------------------------------------------------\n"
" Nested Loop  (cost=4.64..456.23 rows=50 width=488)\n"
"   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.64..142.17 rows=50 width=244)\n"
"         Recheck Cond: (unique1 &lt; 50)\n"
"         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.63 rows=50 width=0)\n"
"               Index Cond: (unique1 &lt; 50)\n"
"   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.00..6.27 rows=1 width=244)\n"
"         Index Cond: (unique2 = t1.unique2)"

#: planstats.xml:366(programlisting)
#, no-wrap
msgid ""
"selectivity = (0 + (50 - bucket[1].min)/(bucket[1].max - bucket[1].min))/num_buckets\n"
"            = (0 + (50 - 0)/(993 - 0))/10\n"
"            = 0.005035\n"
"\n"
"rows        = 10000 * 0.005035\n"
"            = 50  (rounding off)"
msgstr ""
"selectivity = (0 + (50 - bucket[1].min)/(bucket[1].max - bucket[1].min))/num_buckets\n"
"            = (0 + (50 - 0)/(993 - 0))/10\n"
"            = 0.005035\n"
"\n"
"rows        = 10000 * 0.005035\n"
"            = 50  (округлённо)"

#: planstats.xml:383(programlisting)
#, no-wrap
msgid ""
"SELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats\n"
"WHERE tablename IN ('tenk1', 'tenk2') AND attname='unique2';\n"
"\n"
"tablename  | null_frac | n_distinct | most_common_vals\n"
"-----------+-----------+------------+------------------\n"
" tenk1     |         0 |         -1 |\n"
" tenk2     |         0 |         -1 |"
msgstr ""
"SELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats\n"
"WHERE tablename IN ('tenk1', 'tenk2') AND attname='unique2';\n"
"\n"
"tablename  | null_frac | n_distinct | most_common_vals\n"
"-----------+-----------+------------+------------------\n"
" tenk1     |         0 |         -1 |\n"
" tenk2     |         0 |         -1 |"

#: planstats.xml:398(programlisting)
#, no-wrap
msgid ""
"selectivity = (1 - null_frac1) * (1 - null_frac2) * min(1/num_distinct1, 1/num_distinct2)\n"
"            = (1 - 0) * (1 - 0) / max(10000, 10000)\n"
"            = 0.0001"
msgstr ""
"selectivity = (1 - null_frac1) * (1 - null_frac2) * min(1/num_distinct1, 1/num_distinct2)\n"
"            = (1 - 0) * (1 - 0) / max(10000, 10000)\n"
"            = 0.0001"

#: planstats.xml:411(programlisting)
#, no-wrap
msgid ""
"rows = (outer_cardinality * inner_cardinality) * selectivity\n"
"     = (50 * 10000) * 0.0001\n"
"     = 50"
msgstr ""
"rows = (outer_cardinality * inner_cardinality) * selectivity\n"
"     = (50 * 10000) * 0.0001\n"
"     = 50"

#: planstats.xml:341(para)
msgid ""
"Finally we will examine a query that involves a join: <placeholder-1/> The "
"restriction on <structname>tenk1</structname>, <literal>unique1 &lt; 50</"
"literal>, is evaluated before the nested-loop join. This is handled "
"analogously to the previous range example. This time the value 50 falls into "
"the first bucket of the <structfield>unique1</structfield> histogram: "
"<placeholder-2/> The restriction for the join is <literal>t2.unique2 = t1."
"unique2</literal>. The operator is just our familiar <literal>=</literal>, "
"however the selectivity function is obtained from the <structfield>oprjoin</"
"structfield> column of <structname>pg_operator</structname>, and is "
"<function>eqjoinsel</function>. <function>eqjoinsel</function> looks up the "
"statistical information for both <structname>tenk2</structname> and "
"<structname>tenk1</structname>: <placeholder-3/> In this case there is no "
"<acronym>MCV</acronym> information for <structfield>unique2</structfield> "
"because all the values appear to be unique, so we use an algorithm that "
"relies only on the number of distinct values for both relations together "
"with their null fractions: <placeholder-4/> This is, subtract the null "
"fraction from one for each of the relations, and divide by the maximum of "
"the numbers of distinct values. The number of rows that the join is likely "
"to emit is calculated as the cardinality of the Cartesian product of the two "
"inputs, multiplied by the selectivity: <placeholder-5/>"
msgstr ""
"В заключение исследуем запрос, выполняющий соединение: <placeholder-1/> "
"Ограничение, накладываемое на <structname>tenk1</structname>, "
"<literal>unique1 &lt; 50</literal>, производится до соединения вложенным "
"циклом. Это обрабатывается аналогично предыдущему примеру с диапазонным "
"условием. На этот раз значение 50 попадает в первый столбец гистограммы "
"<structfield>unique1</structfield>: <placeholder-2/> Ограничение для "
"соединения следующее <literal>t2.unique2 = t1.unique2</literal>. Здесь "
"используется уже известный нам оператор <literal>=</literal>, однако функцию "
"избирательности получаем из столбца <structfield>oprjoin</structfield> "
"представления <structname>pg_operator</structname>, и эта функция — "
"<function>eqjoinsel</function>. Функция <function>eqjoinsel</function> "
"находит статистические данные как для <structname>tenk2</structname>, так и "
"для <structname>tenk1</structname>: <placeholder-3/> В этом случае нет "
"данных <acronym>MCV</acronym> для <structfield>unique2</structfield>, потому "
"что все значения будут уникальными. Таким образом, используется алгоритм, "
"зависящий только от числа различающихся значений для обеих таблиц и от "
"данных с неопределёнными значениями: <placeholder-4/> Т. е., вычитаем долю "
"неопределённых значений из единицы для каждой таблицы и делим на "
"максимальное из чисел различающихся значений. Количество строк, которое "
"соединение, вероятно, сгенерирует, вычисляется как мощность декартова "
"произведения двух входных значений, умноженная на избирательность: "
"<placeholder-5/>"

#: planstats.xml:418(para)
msgid ""
"Had there been MCV lists for the two columns, <function>eqjoinsel</function> "
"would have used direct comparison of the MCV lists to determine the join "
"selectivity within the part of the column populations represented by the "
"MCVs. The estimate for the remainder of the populations follows the same "
"approach shown here."
msgstr ""
"Если бы имелись списки MCV для двух столбцов, функцией <function>eqjoinsel</"
"function> использовалось бы прямое сравнение со списками MCV для определения "
"общей избирательности той части данных, которая содержит значения списка "
"MCV. Оценка остальной части данных при этом выполнялась бы представленным "
"выше способом."

#: planstats.xml:426(para)
msgid ""
"Notice that we showed <literal>inner_cardinality</literal> as 10000, that "
"is, the unmodified size of <structname>tenk2</structname>. It might appear "
"from inspection of the <command>EXPLAIN</command> output that the estimate "
"of join rows comes from 50 * 1, that is, the number of outer rows times the "
"estimated number of rows obtained by each inner index scan on "
"<structname>tenk2</structname>. But this is not the case: the join relation "
"size is estimated before any particular join plan has been considered. If "
"everything is working well then the two ways of estimating the join size "
"will produce about the same answer, but due to round-off error and other "
"factors they sometimes diverge significantly."
msgstr ""
"Заметьте, что здесь выводится для <literal>inner_cardinality</literal> "
"значение 10000, то есть исходный размер <structname>tenk2</structname>. Если "
"изучить вывод <command>EXPLAIN</command>, может показаться, что оценка "
"количества строк вычисляется как 50 * 1, то есть число внешних строк "
"умножается на ориентировочное число строк, получаемых при каждом внутреннем "
"сканировании индекса в <structname>tenk2</structname>. Но это не так, ведь "
"размер результата соединения оценивается до того, как выбирается конкретный "
"план соединения. Если всё работает корректно, оба варианта вычисления этого "
"размера должны давать один и тот же ответ, но из-за ошибок округления и "
"других факторов иногда они значительно различаются."

#: planstats.xml:439(para)
msgid ""
"For those interested in further details, estimation of the size of a table "
"(before any <literal>WHERE</literal> clauses) is done in <filename>src/"
"backend/optimizer/util/plancat.c</filename>. The generic logic for clause "
"selectivities is in <filename>src/backend/optimizer/path/clausesel.c</"
"filename>. The operator-specific selectivity functions are mostly found in "
"<filename>src/backend/utils/adt/selfuncs.c</filename>."
msgstr ""
"Для интересующихся более подробной информацией: оценка размера таблицы (до "
"выполнения условий в предложении <literal>WHERE</literal>) реализована в "
"файле <filename>src/backend/optimizer/util/plancat.c</filename>. Основная "
"логика для вычисления избирательности предложений находится в <filename>src/"
"backend/optimizer/path/clausesel.c</filename>. Специфичные для отдельных "
"операторов функции избирательности, в основном, расположены в <filename>src/"
"backend/utils/adt/selfuncs.c</filename>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: planstats.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
